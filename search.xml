<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Wget 使用技巧</title>
      <link href="/wget-tips/"/>
      <url>/wget-tips/</url>
      
        <content type="html"><![CDATA[<p><code>wget</code> 是一个命令行的下载工具，对于经常使用<code>Linux</code>的用户来说，真是再熟悉不过了。下面总结了一些实用的<code>wget</code>使用技巧，可能会让你更加高效地使用 <code>wget</code>。</p><a id="more"></a><h3 id="重命名"><a href="#重命名" class="headerlink" title="重命名"></a>重命名</h3><p>最常见的使用方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget http:&#x2F;&#x2F;example.com&#x2F;filename.txt</span><br></pre></td></tr></table></figure><p>wget默认会以最后一个符合 <code>/</code> 的后面的字符来对下载文件命名，对于动态链接的下载通常文件名会不正确。</p><p>如果希望对这个下载的文件进行重命名，我们可以使用参数 <code>-O</code> 来指定一个文件名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -O file.zip http:&#x2F;&#x2F;example.com&#x2F;filename.txt</span><br></pre></td></tr></table></figure><h3 id="后台下载"><a href="#后台下载" class="headerlink" title="后台下载"></a>后台下载</h3><p>当需要下载比较大的文件时，使用参数 <code>-b</code> 可以隐藏在后台进行下载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -b http:&#x2F;&#x2F;wppkg.baidupcs.com&#x2F;issue&#x2F;netdisk&#x2F;MACguanjia&#x2F;BaiduNetdisk_mac_3.2.0.9.dmg</span><br></pre></td></tr></table></figure><p>然后可以使用以下命令查看当前的进度：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tail -f wget-log</span><br></pre></td></tr></table></figure><h3 id="下载目录"><a href="#下载目录" class="headerlink" title="下载目录"></a>下载目录</h3><p>这条命令可以下载 <a href="http://example.com" target="_blank" rel="noopener">http://example.com</a> 网站上 packages 目录中的所有文件。</p><p>参数说明：</p><ul><li><code>-r</code>：下载目录</li><li><code>-np</code>：不遍历父目录</li><li><code>-nd</code>：不在本机重新创建目录结构</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -r -np -nd http:&#x2F;&#x2F;example.com&#x2F;packages&#x2F;</span><br></pre></td></tr></table></figure><p>与上一条命令相似，但多加了一个 <code>--accept=iso</code> 选项，这指示 wget 仅下载 i386 目录中所有扩展名为 iso 的文件。你也可以指定多个扩展名，只需用逗号分隔即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -r -np -nd --accept&#x3D;iso http:&#x2F;&#x2F;example.com&#x2F;centos-5&#x2F;i386&#x2F;</span><br></pre></td></tr></table></figure><h3 id="批量下载"><a href="#批量下载" class="headerlink" title="批量下载"></a>批量下载</h3><p>此命令常用于批量下载的情形，把所有需要下载文件的地址放到 filename.txt 中，然后 wget 就会自动为你下载所有文件了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -i filename.txt</span><br></pre></td></tr></table></figure><h3 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h3><p>通常我们在下载大文件时，为了防止中途因为网络不稳定等因素所引起的下载失败，可以使用 <code>-c</code> 参数，作为断点续传。</p><p>好处是：如果当时下载失败了，之后再次下载该文件时，会继续上一次的下载，而不用重头下载了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -c http:&#x2F;&#x2F;example.com&#x2F;really-big-file.iso</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>该命令可用来镜像一个网站，wget 将对链接进行转换。如果网站中的图像是放在另外的站点，那么可以使用 -H 选项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -m -k (-H) http:&#x2F;&#x2F;www.example.com&#x2F;</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://linuxtoy.org/archives/wget-tips.html" target="_blank" rel="noopener">wget 使用技巧</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 命令整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些实用的 Linux 命令</title>
      <link href="/some-practical-linux-commands/"/>
      <url>/some-practical-linux-commands/</url>
      
        <content type="html"><![CDATA[<p>这篇笔记的目的是用来整理那些不常用但又很实用的Linux 命令。</p><a id="more"></a><h3 id="sudo"><a href="#sudo" class="headerlink" title="sudo!!"></a>sudo!!</h3><p>有时候我们好不容易输完一长串命令，却被提示”权限不足”，如果这个时候有一个命令记住上一次的输入内容那该多好。</p><p>还真有，<code>!!</code>命令可以获取最后一次输入的命令，所以我们直接输入下面这个命令就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo!!</span><br></pre></td></tr></table></figure><h3 id="nl"><a href="#nl" class="headerlink" title="nl"></a>nl</h3><p><code>nl</code> 命令类似<code>cat</code>命令，都是查看文件内容，但不同之处在于：<code>nl</code>命令会在文本内容的每一行前面，添加行号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat test.txt</span><br><span class="line">boo</span><br><span class="line">mac</span><br><span class="line">$ nl test.txt</span><br><span class="line">1. boo</span><br><span class="line">2. mac</span><br></pre></td></tr></table></figure><h3 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h3><p>以树状的形式返回当前目录的文件夹结构，这个命令很好用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ tree </span><br><span class="line">.</span><br><span class="line">└── test.txt</span><br><span class="line"></span><br><span class="line">0 directories, 1 file</span><br></pre></td></tr></table></figure><h3 id="pstree"><a href="#pstree" class="headerlink" title="pstree"></a>pstree</h3><p>和<code>tree</code>类似，不过它是返回当前运行的所有进程及其相关的子进程的树状结构。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ pstree | grep php</span><br><span class="line">|-+&#x3D; 01365 boo nginx: master process &#x2F;usr&#x2F;local&#x2F;opt&#x2F;nginx&#x2F;bin&#x2F;nginx -g daemon off;</span><br><span class="line"> | \--- 01410 boo nginx: worker process</span><br><span class="line"> | |     \--- 73098 boo grep --color&#x3D;auto nginx</span><br></pre></td></tr></table></figure><h3 id="lt-空格-gt-命令"><a href="#lt-空格-gt-命令" class="headerlink" title="&lt;空格&gt; 命令"></a>&lt;空格&gt; 命令</h3><p>这是一个有趣的命令，总所周知，用户在终端上键入的每一个命令都会被记录到<code>history</code>中，那么有没有一个命令可以骗过<code>history</code>，而不被记入呢？答案是有的。</p><p>在终端，只需要在键入命令之前输入一个或多个空格，这样你的命令就不会被记录了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ hisotry</span><br><span class="line">8874  pstree | grep nginx</span><br><span class="line">$  date</span><br><span class="line">2020年 5月18日 星期一 21时09分03秒 CST</span><br><span class="line">$ history</span><br><span class="line">8874  pstree | grep nginx</span><br></pre></td></tr></table></figure><h3 id="一些其他命令"><a href="#一些其他命令" class="headerlink" title="一些其他命令"></a>一些其他命令</h3><p>查看系统信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ uname -a</span><br></pre></td></tr></table></figure><p>查看当前日期</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ date</span><br></pre></td></tr></table></figure><p>立即关机</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ shutdown -h now</span><br></pre></td></tr></table></figure><p>重新启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ reboot</span><br></pre></td></tr></table></figure><p>输出文件类型信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ file test.txt</span><br><span class="line">test.txt: ASCII text</span><br></pre></td></tr></table></figure><p>在终端中进行简单的算数运算</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ expr 1 + 3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>重命名文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mv fileA.txt fileB.txt</span><br><span class="line">$ ls</span><br><span class="line">fileB.txt</span><br></pre></td></tr></table></figure><p>nohup 是一个 <code>POSIX</code> 命令，用于忽略 <code>SIGHUP</code> 。 SIGHUP信号是終端注销时所发送至程序的一个信号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohub php script.php</span><br></pre></td></tr></table></figure><p>type 命令用来显示指定命令的类型，判断给出的指令是内部指令还是外部指令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type -a php</span><br><span class="line">php is &#x2F;usr&#x2F;local&#x2F;bin&#x2F;php</span><br><span class="line">php is &#x2F;usr&#x2F;bin&#x2F;php</span><br></pre></td></tr></table></figure><p>命令类型：</p><ul><li>alias：别名。</li><li>keyword：关键字，Shell保留字。</li><li>function：函数，Shell函数。</li><li>builtin：内建命令，Shell内建命令。</li><li>file：文件，磁盘文件，外部命令。</li><li>unfound：没有找到。</li></ul><p>查找进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | grep php</span><br></pre></td></tr></table></figure><p>注意：每个操作系统的ps版本略有不同，Ubuntu 和Mac 上可以直接使用<code>-aux</code>参数，但可能其他系统不能加破折号。<br>参考链接：<a href="https://www.computerhope.com/unix/ups.htm" target="_blank" rel="noopener">Linux ps command help and example</a></p><p>杀死进程</p><ol><li>根据 <code>pid</code>（会杀死指定pid 的进程）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 [pid]</span><br></pre></td></tr></table></figure><ol start="2"><li>根据进程名称（会杀死一组同名进程）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall php</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://blog.csdn.net/zhu_xun/article/details/17018799" target="_blank" rel="noopener">鲜为人知而又实用的 Linux 命令</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 命令整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 添加用户以及权限分配</title>
      <link href="/linux-add-users-and-assign-permissions/"/>
      <url>/linux-add-users-and-assign-permissions/</url>
      
        <content type="html"><![CDATA[<p>写这篇笔记的目的是：在 Linux 下经常为用户的权限问题而头疼，要么是权限不足，要么是权限太大，导致结果往往不是自己想要的。</p><p>另外还有一个促使我写这篇笔记的原因就是：之前在 本地的 Ubuntu 上，竟然把用户玩坏了… 为了避免这种事情在服务器上发生，还是得深入研究下这一块。</p><a id="more"></a><h2 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h2><p>在 Linux 上，添加用户有两种方式：<code>useradd</code>和<code>adduser</code>，其区别就是：</p><ul><li>useradd 是一个Linux 命令，它提供很多参数给用户根据自己的需要进行设置。</li><li>adduser 则是一个perl 脚本，在使用时通过简单的人机交互界面，供用户进行个性设置。</li></ul><h3 id="adduser"><a href="#adduser" class="headerlink" title="adduser"></a>adduser</h3><p>相比 useradd，adduser的使用要简单很多。</p><p>使用adduser 添加一个用户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adduser boo</span><br></pre></td></tr></table></figure><p>然后根据提示填写相应的内容，需要注意的是，该命令会自动的在 <code>/home</code> 目录下创建一个与用户同名的目录。</p><p>用 adduser 这个命令创建的账号是系统账号，可以用来登录到 ubuntu系统。</p><h3 id="useradd"><a href="#useradd" class="headerlink" title="useradd"></a>useradd</h3><p>useradd 命令有大量的参数供我们进行个性设置，常用参数如下：</p><ul><li>-d&lt;登入目录&gt;：指定用户登入时的启始目录，并赋予用户对该目录的的完全控制权</li><li>-g&lt;群组&gt;：指定用户所属的群组；</li><li>-G&lt;群组&gt;：指定用户所属的附加群组；</li><li>-m：在 /home 目录下自动建立用户的登入目录；</li><li>-r：建立系统帐号；</li><li>-s<shell>：指定用户登入后所使用的shell；</li><li>-u<uid>：指定用户的 id</li></ul><p>使用 useradd 创建用户的一般步骤如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ useradd -m boo -s &#x2F;bin&#x2F;bash</span><br><span class="line">$ passwd boo</span><br><span class="line">$ ls &#x2F;home&#x2F;</span><br><span class="line">boo</span><br></pre></td></tr></table></figure><p>其中要注意的有：</p><ol><li>useradd 命令如果不带任何参数（useradd boo），表示只是创建一个用户，既没有 /home 目录下的同名文件夹，也没有设置密码，但是可以在 /etc/passwd 文件的最后一行看到刚才添加的用户。</li><li>useradd <del>这个命令创建的是普通账号，并不能用来登录系统</del>。加上参数<code>-r</code>，将该用户加入到系统用户，系统用户为 id在 1000以下的用户，而普通用户则是id 在 1000以上。事实证明 无论是普通用户还是系统用户 只要密码输入正确都能登入系统。</li><li>当使用参数<code>-m</code>的时候，系统会自动地在 /home 目录下建立一个与新建用户同名的用户主文件夹；如果不使用<code>-m</code>的话，那么就默认是使用<code>-M</code>参数，不创建主文件夹，即使你使用了<code>-d</code>这个参数。所以如果想要自己选择主文件夹，需要同时加上<code>-m</code>和<code>-d</code>参数。</li><li>误区：很都时候刚拿到一台新的机器，会发现用户目录下只有一个当前用户的文件夹，不要误以为该系统只有你一个用户，是因为很多系统用户的主目录并不在 /home 下。</li></ol><h2 id="权限分配"><a href="#权限分配" class="headerlink" title="权限分配"></a>权限分配</h2><h3 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h3><p>无论是使用 adduser 还是 useradd 创建的用户，都试着执行一下以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install vim</span><br></pre></td></tr></table></figure><p>不出意外，你肯定会得到这样一个错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[sudo] password for boo:</span><br><span class="line">boo is not in the sudoers file.  This incident will be reported.</span><br></pre></td></tr></table></figure><p>这个错误的意思是说该用户并不在 sudoers 文件中，那么该如何解决呢？</p><p>使用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo visudo</span><br><span class="line"></span><br><span class="line"># Members of the admin group may gain root privileges</span><br><span class="line">%admin ALL&#x3D;(ALL) ALL</span><br><span class="line"></span><br><span class="line"># 找到该注释，在其下增加一行 </span><br><span class="line">%yourusername ALL&#x3D;(ALL) ALL</span><br></pre></td></tr></table></figure><p>然后保存退出，就会发现可以使用 sudo 提权了。</p><h3 id="赋予-root-权限"><a href="#赋予-root-权限" class="headerlink" title="赋予 root 权限"></a>赋予 root 权限</h3><p>这里有三种方式，先来看看最简单的方式：</p><p>方式一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vim &#x2F;etc&#x2F;passwd</span><br><span class="line"></span><br><span class="line"># 将用户id 改为 0</span><br><span class="line">testuser1:x:0:1001::&#x2F;home&#x2F;testuser1:&#x2F;bin&#x2F;sh</span><br></pre></td></tr></table></figure><p>需要注意的是：</p><ol><li>该方法适用于普通用户以及管理员用户</li><li>使用 testuser1 账户登录后，直接获取的就是 root 帐号的权限。</li></ol><p>方式二：（这里以ubuntu 系统为例）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo visudo # sudo vim &#x2F;etc&#x2F;sudoers</span><br><span class="line"></span><br><span class="line">#  Allow members of group sudo to execute any command</span><br><span class="line">%sudo   ALL&#x3D;(ALL:ALL) ALL</span><br><span class="line"></span><br><span class="line"># 在其后面增加一行</span><br><span class="line">%wheel ALL&#x3D;(ALL:ALL) ALL</span><br></pre></td></tr></table></figure><p>然后修改该用户，使其属于 root 组（wheel）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ usermod -g root boo</span><br></pre></td></tr></table></figure><p>修改完成之后，使用boo 用户登入，执行命令：<code>su -</code>，输入 root 账户的密码，即可获得root 权限。</p><p>方式三：（这里以ubuntu 为例）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo visudo # sudo vim &#x2F;etc&#x2F;sudoers</span><br><span class="line"></span><br><span class="line"># User privilege specification</span><br><span class="line">root    ALL&#x3D;(ALL:ALL) ALL</span><br><span class="line">boo ALL&#x3D;(ALL:ALL) ALL</span><br></pre></td></tr></table></figure><p>修改完成之后，使用boo 用户登入，执行命令：<code>su -</code>，输入 root 账户的密码，即可获得root 权限。</p><p>方式二、方式三和方式一的区别就是：前者需要知道root 账户的密码，而后者可以直接以普通用户的身份或者管理员身份获取root 权限。</p><p>另外还有一个需要注意的地方就是：使用第一种方式获取 root 权限，其实也有弊端，弊端就是 <del>远程使用该用户登入时，还是需要输入 root 密码，才能验证身份成功，是的 必须输入 root 用户的密码。</del></p><p>事实证明，并非上面所述，ssh 连接时的确需要输入密码验证，但不是 root 用户的密码，之前之所以一直看到 <code>Permission denied, please try again.</code>这样的错误，只是因为 没有开启允许 root 用户远程登入的权限。如何开启，见下文扩展补充。</p><h3 id="扩展补充"><a href="#扩展补充" class="headerlink" title="扩展补充"></a>扩展补充</h3><h4 id="在Ubuntu中如何修改-root-密码"><a href="#在Ubuntu中如何修改-root-密码" class="headerlink" title="在Ubuntu中如何修改 root 密码"></a>在Ubuntu中如何修改 root 密码</h4><p>默认情况下，出于安全原因，root用户帐户密码在Ubuntu Linux 中被锁定。因此，无法使用root用户登录或使用诸如<code>su -</code>之类的命令成为超级用户。</p><p>但可以借助其他方式，使用<code>passwd</code>命令来修改。因为普通用户只能更改其帐户的密码。超级用户（root）可以更改任何用户帐户的密码（包括它自己）。</p><p>使用以下命令成为 root用户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo -i</span><br><span class="line">$ passwd root</span><br></pre></td></tr></table></figure><p>如果在sudo 命令使用不了的情况下，可以进入单用户模式，再进行修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ passwd root</span><br></pre></td></tr></table></figure><h4 id="在Ubuntu中如何远程-root-登入"><a href="#在Ubuntu中如何远程-root-登入" class="headerlink" title="在Ubuntu中如何远程 root 登入"></a>在Ubuntu中如何远程 root 登入</h4><p>在Ubuntu中，默认是不能使用 root 账户登入到系统的，如果一定想要用 root账户登入，可以编辑 sshd 配置，执行如下操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vim &#x2F;etc&#x2F;ssh&#x2F;sshd_config</span><br><span class="line"></span><br><span class="line"># PermitRootLogin prohibit-password</span><br><span class="line"># 修改为：</span><br><span class="line"># PermitRootLogin yes</span><br><span class="line"></span><br><span class="line"># 重启sshd 服务</span><br><span class="line">$ sudo systemctl restart sshd</span><br></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://blog.csdn.net/li_101357/article/details/46778827" target="_blank" rel="noopener">adduser 和 useradd 的区别</a></li><li><a href="https://www.cnblogs.com/noway-neway/p/5235300.html" target="_blank" rel="noopener">Ubuntu 如何进入单用户模式</a></li><li><a href="https://raspberrypi.stackexchange.com/questions/48056/how-to-login-as-root-remotely" target="_blank" rel="noopener">ssh-如何远程以root 登入</a></li><li><a href="https://www.cyberciti.biz/faq/change-root-password-ubuntu-linux/" target="_blank" rel="noopener">如何在Ubuntu Linux 中更改 root 密码</a></li><li><a href="https://www.cyberciti.biz/faq/become-superuser-on-ubuntu-linux/" target="_blank" rel="noopener">如何使用su / sudo成为Ubuntu Linux的超级用户？</a></li><li><a href="https://www.cyberciti.biz/faq/ubuntu-linux-root-password-default-password/" target="_blank" rel="noopener">Ubuntu Linux root 用户默认密码</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux init、service、systemctl 这三者之间的区别</title>
      <link href="/the-difference-between-linux-init-service-systemctl/"/>
      <url>/the-difference-between-linux-init-service-systemctl/</url>
      
        <content type="html"><![CDATA[<p>在接触到Linux 的服务之后，我所知道的管理服务的方式有三种，分别是<code>init</code>、<code>service</code>、<code>systemctl</code>。</p><p>至于这三者之间的区别不得而知，所以整理这片笔记的目的就是了解这三者之间的区别。</p><a id="more"></a><h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><p>历史上，Linux 的启动一直采用init 进程。</p><p>在类Unix 的计算机操作系统中，Init（初始化的简称）是在启动计算机系统期间启动的第一个进程。</p><p>Init 是一个守护进程，它将持续运行，直到系统关闭。它是所有其他进程的直接或间接的父进程。</p><p>因为init 的参数全在<code>/etc/init.d</code>目录下，所以使用 init 启动一个服务，应该这样做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo &#x2F;etc&#x2F;init.d&#x2F;nginx start</span><br></pre></td></tr></table></figure><h2 id="service"><a href="#service" class="headerlink" title="service"></a>service</h2><p>通过查看man 手册页可以得知，service是一个运行<code>System V init</code>的脚本命令。</p><blockquote><p>那么什么是 System V init 呢？</p></blockquote><p>也就是<code>/etc/init.d</code> 目录下的参数。</p><p>所以分析可知service 是去<code>/etc/init.d</code>目录下执行相关程序，服务配置文件的存放目录就是<code>/etc/init.d</code>.</p><p>使用 service 启动一个服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ service nginx start</span><br></pre></td></tr></table></figure><p>可以理解成 service 就是<code>init.d</code> 的一种实现方式。<br>所以这两者启动方式（或者是停止、重启）并没有什么区别。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo &#x2F;etc&#x2F;init.d&#x2F;nginx start</span><br><span class="line">&#x2F;&#x2F; 等价于</span><br><span class="line">$ service nginx start</span><br></pre></td></tr></table></figure><p>但是这两种方式均有如下缺点：</p><ol><li>启动时间长。init 进程是串行启动，只有前一个进程启动完，才会启动下一个进程。</li><li>启动脚本复杂。init进程只是执行启动脚本，不管其他事情。脚本需要自己处理各种情况，这往往使得脚本变得很长。</li></ol><h2 id="systemd"><a href="#systemd" class="headerlink" title="systemd"></a>systemd</h2><p>Systemd 就是为了解决这些问题而诞生的。它包括 System and Service Manager，为系统的启动和管理提供一套完整的解决方案。<br>Systemd 是Linux 系统中最新的初始化系统（init），它主要的设计目的是克服 <code>System V init</code>固有的缺点，提高系统的启动速度。</p><p>根据 Linux 惯例，字母d是守护进程（daemon）的缩写。 Systemd 这个名字的含义，就是它要守护整个系统。</p><p>使用了 Systemd，就不需要再用init 了。Systemd 取代了initd（Initd 的PID 是0） ，成为系统的第一个进程（Systemd 的PID 等于 1），其他进程都是它的子进程。</p><p>Systemd 的优点是功能强大，使用方便，缺点是体系庞大，非常复杂。</p><p>查看Systemd 的版本信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl --version</span><br></pre></td></tr></table></figure><h3 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h3><p><strong>Systemd 并不是一个命令，而是一组命令</strong>，涉及到系统管理的方方面面。</p><h4 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h4><p>systemctl是 Systemd 的主命令，用于管理系统。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 重启系统</span><br><span class="line">$ sudo systemctl reboot</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 启动进入救援状态（单用户状态）</span><br><span class="line">$ sudo systemctl rescue</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 管理服务</span><br><span class="line">$ sudo systemctl start nginx</span><br></pre></td></tr></table></figure><h4 id="hostnamectl"><a href="#hostnamectl" class="headerlink" title="hostnamectl"></a>hostnamectl</h4><p>hostnamectl命令用于查看当前主机的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 显示当前主机信息</span><br><span class="line">$ hostnamectl</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 设置主机名</span><br><span class="line">$ sudo hostnamectl set-hostname BoodeUbuntu</span><br></pre></td></tr></table></figure><h4 id="localectl"><a href="#localectl" class="headerlink" title="localectl"></a>localectl</h4><p>localectl命令用于查看本地化设置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 查看本地化设置</span><br><span class="line">$ localectl</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 设置本地化参数。</span><br><span class="line">$ sudo localectl set-locale LANG&#x3D;en_GB.utf8</span><br><span class="line">$ sudo localectl set-keymap en_GB</span><br></pre></td></tr></table></figure><h4 id="timedatectl"><a href="#timedatectl" class="headerlink" title="timedatectl"></a>timedatectl</h4><p>timedatectl命令用于查看当前时区设置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 查看当前时区设置</span><br><span class="line">$ timedatectl</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 显示所有可用的时区</span><br><span class="line">$ timedatectl list-timezones                                                                                   </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 设置当前时区</span><br><span class="line">$ sudo timedatectl set-timezone America&#x2F;New_York</span><br><span class="line">$ sudo timedatectl set-time YYYY-MM-DD</span><br><span class="line">$ sudo timedatectl set-time HH:MM:SS</span><br></pre></td></tr></table></figure><p>总结一下，<code>init</code> 是最初的进程管理方式，<code>service</code> 是<code>init</code> 的另一种实现，而 <code>systemd</code> 则是一种取代 <code>initd</code> 的解决方案，其中 <code>systemctl</code> 是 <code>systemd</code> 的主命令，用于管理系统以及服务。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://en.wikipedia.org/wiki/Init" target="_blank" rel="noopener">Linux Init - 维基百科</a></li><li><a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html" target="_blank" rel="noopener">Systemd 入门教程 - 阮一峰的网络日志</a></li><li><a href="https://blog.csdn.net/lineuman/article/details/52578399" target="_blank" rel="noopener">init、service、systemctl 的区别</a></li><li><a href="http://www.ruanyifeng.com/blog/2016/02/linux-daemon.html" target="_blank" rel="noopener">Linux 守护进程的启动方式</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>了解 Linux的管道符、重定向、环境变量</title>
      <link href="/understand-linux-pipe-symbols-redirects-environment-variables/"/>
      <url>/understand-linux-pipe-symbols-redirects-environment-variables/</url>
      
        <content type="html"><![CDATA[<p>这篇文章浅谈一下 Linux 的管道符、重定向和环境变量。</p><a id="more"></a><h3 id="输入输出重定向"><a href="#输入输出重定向" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h3><p>在了解什么是输入输出重定向之前，我们先要搞清楚以下两种输出信息的区别：</p><ul><li>标准输出信息：<br>包括该文件的一些相关权限、所有者、所属组、文件大小及修改时间等信息。</li><li>错误输出信息：<br>Bash终端显示的报错提示信息<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[max@localhost 桌面]$ ls</span><br><span class="line">testdir   test.txt</span><br><span class="line">[max@localhost 桌面]$ cat test.txt</span><br><span class="line">Hello Linux!                        # 标准输出信息</span><br><span class="line">[max@localhost 桌面]$ cat xxx</span><br><span class="line">cat: xxx: 没有那个文件或目录        # 错误输出信息 因为不存在xxx文件</span><br></pre></td></tr></table></figure></li><li>标准输入重定向（STDIN，文件描述符为0）：默认从键盘输入，也可从其他文件或命令中输入。</li><li>标准输出重定向（STDOUT，文件描述符为1）：默认输出到屏幕。</li><li>错误输出重定向（STDERR，文件描述符为2）：默认输出到屏幕。</li></ul><p>之所以花这么大力气，理解这个概念，是因为待会有个很重要的知识点要用到这个概念。</p><h3 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">命令 &gt; 文件        将标准输出重定向到一个文件中（清空原有文件的数据）</span><br><span class="line">命令 2&gt; 文件    将错误输出重定向到一个文件中（清空原有文件的数据）</span><br><span class="line">命令 &gt;&gt; 文件    将标准输出重定向到一个文件中（追加到原有内容的后面）</span><br><span class="line">命令 2&gt;&gt; 文件   将错误输出重定向到一个文件中（追加到原有内容的后面）</span><br><span class="line">命令 &gt;&gt; 文件 2&gt;&amp;1 或</span><br><span class="line">命令 &amp;&gt;&gt; 文件将标准输出与错误输出共同写入到文件中（追加到原有内容的后面）</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[max@localhost 桌面]$ cat test.txt</span><br><span class="line">Hello Linux!</span><br><span class="line">[max@localhost 桌面]$ echo &quot;测试输出重定向(追加模式)&quot; &gt;&gt; test.txt</span><br><span class="line">[max@localhost 桌面]$ cat test.txt </span><br><span class="line">Hello Linux!</span><br><span class="line">测试输出重定向(追加模式)</span><br><span class="line"></span><br><span class="line">[max@localhost 桌面]$ echo &quot;测试输出重定向(清除模式)&quot; &gt; test.txt</span><br><span class="line">[max@localhost 桌面]$ cat test.txt</span><br><span class="line">测试输出重定向(清除模式)</span><br></pre></td></tr></table></figure><h3 id="输入重定向"><a href="#输入重定向" class="headerlink" title="输入重定向"></a>输入重定向</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">命令 &lt; 文件将文件作为命令的标准输入</span><br><span class="line">命令 &lt;&lt; 分界符从标准输入中读入，直到遇见分界符才停止</span><br><span class="line">命令 &lt; 文件1 &gt; 文件2将文件1作为命令的标准输入并将标准输出到文件2</span><br></pre></td></tr></table></figure><p>输入重定向相对于输出重定向较使用的少一些，可以理解为：<strong>输入重定向的作用是把文件直接导入到命令中</strong>。<br>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 将文件text.txt导入给 &#96;wc -l&#96;命令，统计行数。</span><br><span class="line">[max@localhost 桌面]$ wc -l &lt; test.txt</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="管道符"><a href="#管道符" class="headerlink" title="管道符"></a>管道符</h3><p>管道符的概念就是：把前一个命令原本要输出到屏幕的标准正常数据当作是后一个命令的标准输入。</p><p>举个例子，把<code>etc</code>目录下的所有文件的属性信息，作为标准输入传递给 <code>more</code>命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[max@localhost 桌面]$ ls -l &#x2F;etc&#x2F; | more</span><br><span class="line">总用量 1396</span><br><span class="line">drwxr-xr-x.  3 root root       97 8月  24 04:35 abrt</span><br><span class="line">-rw-r--r--.  1 root root       16 8月  24 04:43 adjtime</span><br><span class="line">-rw-r--r--.  1 root root    21929 1月  29 2014 brltty.conf</span><br><span class="line">drwxr-xr-x.  2 root root        6 1月  29 2014 chkconfig.d</span><br><span class="line">-rw-r--r--.  1 root root     1157 2月   6 2014 chrony.conf</span><br><span class="line">--More--</span><br></pre></td></tr></table></figure><h3 id="命令行中的通配符"><a href="#命令行中的通配符" class="headerlink" title="命令行中的通配符"></a>命令行中的通配符</h3><ul><li>星号（*）代表匹配零个或多个字符</li><li>问号（?）代表匹配单个字符</li><li>中括号内加上数字[0-9]代表匹配0～9之间的单个数字的字符</li><li>而中括号内加上字母[abc]则是代表匹配a、b、c三个字符中的任意一个字符<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[max@localhost test]$ ls</span><br><span class="line">file1  file2  file3  file99  filex</span><br><span class="line">[max@localhost test]$ ls -l file?</span><br><span class="line">-rw-rw-r--. 1 max max 0 10月 10 22:49 file1</span><br><span class="line">-rw-rw-r--. 1 max max 0 10月 10 22:49 file2</span><br><span class="line">-rw-rw-r--. 1 max max 0 10月 10 22:49 file3</span><br><span class="line">-rw-rw-r--. 1 max max 0 10月 10 22:49 filex</span><br><span class="line">[max@localhost test]$ ls -l file*</span><br><span class="line">-rw-rw-r--. 1 max max 0 10月 10 22:49 file1</span><br><span class="line">-rw-rw-r--. 1 max max 0 10月 10 22:49 file2</span><br><span class="line">-rw-rw-r--. 1 max max 0 10月 10 22:49 file3</span><br><span class="line">-rw-rw-r--. 1 max max 0 10月 10 22:49 file99</span><br><span class="line">-rw-rw-r--. 1 max max 0 10月 10 22:49 filex</span><br><span class="line">[max@localhost test]$ ls -l file[1-2]</span><br><span class="line">-rw-rw-r--. 1 max max 0 10月 10 22:49 file1</span><br><span class="line">-rw-rw-r--. 1 max max 0 10月 10 22:49 file2</span><br><span class="line">[max@localhost test]$ ls -l file[x]</span><br><span class="line">-rw-rw-r--. 1 max max 0 10月 10 22:49 filex</span><br></pre></td></tr></table></figure><h3 id="常用的转义字符"><a href="#常用的转义字符" class="headerlink" title="常用的转义字符"></a>常用的转义字符</h3><blockquote><p>反斜杠（\）：使反斜杠后面的一个变量变为单纯的字符串。</p><p>单引号（’’）：转义其中所有的变量为单纯的字符串。</p><p>双引号（””）：保留其中的变量属性，不进行转义处理。</p><p>反引号（``）：把其中的命令执行后返回结果。</p></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[max@localhost test]$ PRICE&#x3D;5</span><br><span class="line">[max@localhost test]$ echo &quot;The price of this shirt is $PRICE&quot;</span><br><span class="line">The price of this shirt is 5</span><br></pre></td></tr></table></figure><p>上面的输出看上去挺对的，但是并不完美，我们希望能够输出“The price of this shirt is $5”，于是我们试着这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[max@localhost test]$ echo &quot;The price of this shirt is $$PRICE&quot;</span><br><span class="line">The price of this shirt is 9944PRICE</span><br></pre></td></tr></table></figure><p>不幸的是美元符号和变量提取符号合并后<code>$$</code>作用是显示当前程序的进程ID。</p><p>要想让第一个<code>$</code>乖乖地作为美元符号，那么就需要使用反斜杠<code>\</code>来进行转义，将这个命令提取符转义成单纯的文本，去除其特殊功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[max@localhost test]$ echo &quot;The price of this shirt is \$$PRICE&quot;</span><br><span class="line">The price of this shirt is $5</span><br></pre></td></tr></table></figure><p>如果只需要某个命令的输出值时，可以像<code>命令</code>这样，将命令用反引号括起来，达到预期的效果.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[max@localhost test]$ echo &#96;uname -a&#96; &gt;&gt; file1</span><br><span class="line">[max@localhost test]$ cat file1</span><br><span class="line">Linux localhost.localdomain 3.10.0-123.el7.x86_64 #1 SMP Mon May 5 11:16:57 EDT 2014 x86_64 x86_64 x86_64 GNU&#x2F;Linux</span><br></pre></td></tr></table></figure><blockquote><p>思考：如何将普通变量转换为全局变量？</p></blockquote><p>使用命令：<code>export [变量名称]</code>，需要在拥有管理员权限时才能正常使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost home]# WORKDIR&#x3D;&#x2F;home&#x2F;workdir</span><br><span class="line">[root@localhost home]# mkdir $WORKDIR </span><br><span class="line">[root@localhost home]# cd $WORKDIR</span><br><span class="line">[root@localhost workdir]# pwd</span><br><span class="line">&#x2F;home&#x2F;workdir</span><br><span class="line">[root@localhost workdir]# exit</span><br><span class="line">exit</span><br><span class="line">[max@localhost home]$ cd $WORKDIR</span><br><span class="line">[max@localhost ~]$ echo $WORKDIR</span><br><span class="line">[max@localhost ~]$ su root</span><br><span class="line">密码：</span><br><span class="line">[root@localhost max]# export WORKDIR</span><br><span class="line">[root@localhost &#x2F;]# su max</span><br><span class="line">[max@localhost &#x2F;]$ cd $WORKDIR</span><br><span class="line">[max@localhost workdir]$ pwd</span><br><span class="line">&#x2F;home&#x2F;workdir</span><br></pre></td></tr></table></figure><h4 id="重点一："><a href="#重点一：" class="headerlink" title="重点一："></a>重点一：</h4><p>在上面的命令中有一个很重要的知识点：</p><blockquote><p>关于如何在Linux中创建一个变量的问题？有两个地方需要注意。</p></blockquote><ol><li>所有字母都需要大写</li><li>变量与赋值符号(=)之间不能存在空格</li><li>无论是系统环境变量还是自定义变量还是全局变量，在调用时 都需要使用<code>$</code>符号来标识。</li></ol><h4 id="重点二"><a href="#重点二" class="headerlink" title="重点二"></a>重点二</h4><ul><li>在Linux 系统中当普通用户身份时命令提示符的前缀标识是：<code>$</code>。</li><li>在Linux 系统中当为管理员身份时命令提示符的前缀标识是：<code>#</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PM2 快速上手</title>
      <link href="/pm2-quick-start/"/>
      <url>/pm2-quick-start/</url>
      
        <content type="html"><![CDATA[<p><a href="http://pm2.keymetrics.io/" target="_blank" rel="noopener">PM2</a> 是Node.js 生产环境中的进程管理工具，自带负载均衡功能。</p><a id="more"></a><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install pm2 -g</span><br></pre></td></tr></table></figure><p>无缝更新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 update</span><br></pre></td></tr></table></figure><h2 id="启动应用"><a href="#启动应用" class="headerlink" title="启动应用"></a>启动应用</h2><p>PM2 中有两种方式启动应用，一种是<strong>直接调用应用入口文件</strong>，一种是<strong>通过调用配置文件启动应用</strong>。</p><h3 id="命令行启动"><a href="#命令行启动" class="headerlink" title="命令行启动"></a>命令行启动</h3><p>在生产环境中，通过命令行启动服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 stat app.js</span><br></pre></td></tr></table></figure><h3 id="配置文件启动"><a href="#配置文件启动" class="headerlink" title="配置文件启动"></a>配置文件启动</h3><p>很多时候，仅仅只是使用 <code>PM2</code> 去启动应用，可能不能完全满足我们的需求。</p><p>当需要对应用有更多的要求时，这个时候就需要用到<code>PM2</code> 的配置文件了。</p><p>PM2 支持通过配置文件创建管理应用，首先在项目根目录创建配置文件<code>precesses.json</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;apps&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;myApp&quot;,</span><br><span class="line">      &quot;cwd&quot;: &quot;&#x2F;var&#x2F;www&#x2F;app&#x2F;&quot;,</span><br><span class="line">      &quot;script&quot;: &quot;.&#x2F;app.js&quot;,</span><br><span class="line">      &quot;watch&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是一个最简单的<code>processes.json</code>配置，创建了一个<code>myApp</code>应用，如果你有多个服务，那么<code>apps</code> 这个数组中创建多个应用。</p><blockquote><p>创建好配置文件之后，那么该如何启动呢？</p></blockquote><p>有两种方式：</p><ol><li>直接调用配置文件启动</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 start processes.json</span><br></pre></td></tr></table></figure><p>可以增加<code>--env</code>参数，来指定当前启动环境。</p><ol start="2"><li>通过<code>package.json</code> 配置文件，配置脚本启动</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; package.json</span><br><span class="line"></span><br><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;node server&#x2F;index&quot;,</span><br><span class="line">    &quot;pm2&quot;: &quot;pm2 start processes.json&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>然后就可以直接使用<code>npm start pm2</code> 来启动应用了。</p><h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><p>在配置文件你可以指定环境变量、日志文件、进程文件，重启最大次数…等配置项。支持JSON和YAML格式。</p><p>PM2 的配置支持非常多的参数，下面会对常用的参数一一做说明。</p><table><thead><tr><th>字段</th><th>类型</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td>name</td><td>string</td><td>myApp</td><td>应用的名字，默认是脚本文件名</td></tr><tr><td>cwd</td><td>string</td><td>/var/www/myApp</td><td>应用程序所在目录</td></tr><tr><td>script</td><td>string</td><td>./server.js</td><td>应用程序的脚本路径，相对于应用程序所在目录</td></tr><tr><td>log_date_format</td><td>string</td><td>YYYY-MM-DD HH:mm Z</td><td>日志时间格式</td></tr><tr><td>error_file</td><td>string</td><td>-</td><td>错误日志存放路径</td></tr><tr><td>out_file</td><td>string</td><td>-</td><td>输出日志存放路径</td></tr><tr><td>pid_file</td><td>string</td><td>-</td><td>pid文件路径</td></tr><tr><td>watch</td><td>boolean or array</td><td>true</td><td>当目录文件或子目录文件有变化时自动重新加载应用</td></tr><tr><td>ignore_watch</td><td>list</td><td>[”[/]./”, “node_modules”]</td><td>list中的正则匹配的文件和目录有变化时不重新加载应用</td></tr><tr><td>max_memory_restart</td><td>string</td><td>50M</td><td>当应用超过设定的内存大小就自动重启</td></tr><tr><td>min_uptime</td><td>string</td><td>60s</td><td>最小运行时间，这里设置的是60s即如果应用程序在60s内退出，pm2会认为程序异常退出，此时触发重启max_restarts设置数量</td></tr><tr><td>max_restarts</td><td>number</td><td>10</td><td>设置应用程序异常退出重启的次数，默认15次（从0开始计数）</td></tr><tr><td>instances</td><td>number</td><td>1</td><td>启动实例个数</td></tr><tr><td>cron_restart</td><td>string</td><td>1 0 * * *</td><td>定时重启</td></tr><tr><td>exec_interpreter</td><td>string</td><td>node</td><td>应用程序的脚本类型，默认是node</td></tr><tr><td>exec_mode</td><td>string</td><td>fork</td><td>应用启动模式，支持fork和cluster模式，默认为fork</td></tr><tr><td>autorestart</td><td>boolean</td><td>true</td><td>应用程序崩溃或退出时自动重启</td></tr></tbody></table><blockquote><p>注意：如果<code>processes.json</code>配置文件如果发生了变化，那么需要删除应用之后，重新创建，配置文件才会生效。</p></blockquote><h3 id="进程监控"><a href="#进程监控" class="headerlink" title="进程监控"></a>进程监控</h3><p>列出所有节点应用程序（进程/微服务）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 list</span><br><span class="line">$ pm2 ls</span><br></pre></td></tr></table></figure><p>可以将进程列表以JSON格式打印出来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 jlist</span><br><span class="line">$ pm2 prettylist</span><br></pre></td></tr></table></figure><p>使用进程ID或名称查看所示的单个Node进程的详细信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 describe &lt;id | app_name&gt;</span><br><span class="line">$ pm2 show &lt;id | app_name&gt;</span><br></pre></td></tr></table></figure><p>实时监控所有进程CPU或内存使用情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 monit</span><br></pre></td></tr></table></figure><h3 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h3><p>查看某个应用的日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 logs [&#39;all&#39; | app_name | app_id ]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 logs --json         # JSON 格式输出</span><br><span class="line">$ pm2 logs --format       # 格式化 output</span><br><span class="line">$ pm2 flush               # 清空所有日志文件</span><br><span class="line">$ pm2 reloadLogs          # 重新加载所有日志文件</span><br></pre></td></tr></table></figure><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>停止所有进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 stop all</span><br></pre></td></tr></table></figure><p>重启所有进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 restart all</span><br></pre></td></tr></table></figure><p>0秒停机重载进程 (用于 NETWORKED 进程)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 reload all</span><br></pre></td></tr></table></figure><p>停止指定的进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 stop 0</span><br></pre></td></tr></table></figure><p>重启指定的进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 restart 0</span><br></pre></td></tr></table></figure><p>杀死指定的进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 delete 0</span><br></pre></td></tr></table></figure><p>杀死全部进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 delete all</span><br></pre></td></tr></table></figure><h3 id="使用PM2-运行-npm-start"><a href="#使用PM2-运行-npm-start" class="headerlink" title="使用PM2 运行 npm start"></a>使用PM2 运行 npm start</h3><p><code>npm run xxxx</code> 是 node常用的启动方式之一，那么如何使用<code>PM2</code>来实现对该方式的启动呢？</p><p><code>npm run</code>、<code>npm start</code>等命令之所以可以使用，是因为<code>package.json</code>配置文件中增加了对应的脚本命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start-dev&quot;: &quot;env $(cat .env | xargs) nodemon server&#x2F;index&quot;,</span><br><span class="line">    &quot;start&quot;: &quot;node server&#x2F;index&quot;,</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 start npm --watch --name &lt;taskname&gt; -- run &lt;scriptname&gt;;</span><br></pre></td></tr></table></figure><p>其中 <code>--watch</code>监听代码变化，<code>--name</code>重命名任务名称，<code>-- run</code>后面跟脚本名字</p><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 等效于 npm start</span><br><span class="line">pm2 start npm --watch --name webserver -- run start</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://www.linuxidc.com/Linux/2019-07/159432.htm" target="_blank" rel="noopener">如何在生产服务器上安装PM2运行Node.js应用程序</a></li><li><a href="https://fynn90.github.io/2018/01/11/PM2%E5%AE%9E%E7%94%A8%E6%89%8B%E5%86%8C/#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4" target="_blank" rel="noopener">PM2 实用手册</a></li><li><a href="https://www.cnblogs.com/hai-cheng/articles/8690115.html" target="_blank" rel="noopener">PM2 部署 nodejs 项目</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
          <category> Tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tutorial </tag>
            
            <tag> PM2 </tag>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 中的eval、反引号、$()的区别</title>
      <link href="/the-difference-between-eval-and-backquotes-in-linux-and/"/>
      <url>/the-difference-between-eval-and-backquotes-in-linux-and/</url>
      
        <content type="html"><![CDATA[<p>之前在搭建 SSH 环境时，遇到了这样一个问题：</p><blockquote><p>使用命令：<code>eval$(ssh-agent)</code>去创建一个代理进程，但是会提示：<code>No Such file or directory</code> 。</p></blockquote><p>就很纳闷，之前都用着好好的，为什么在新的环境中就不行了？</p><p>后来，了解到原来一直使用的 <code>eval$(ssh-agent)</code> ，其中的<code>$()</code> 原来在<code>Linux</code>中有特殊的意义。</p><p>所以这篇笔记专门用来了解 <code>eval</code> 和 <code>反引号</code> 以及 <code>$()</code>之间的区别。 它们的作用都是<strong>命令替换</strong>。</p><a id="more"></a><h2 id="场景重现"><a href="#场景重现" class="headerlink" title="场景重现"></a>场景重现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ &#96;ssh-agent&#96;</span><br><span class="line">sh.exe&quot;: SSH_AUTH_SOCK&#x3D;&#x2F;tmp&#x2F;ssh-myYvgp1404&#x2F;agent.1404;: No such file or directory</span><br><span class="line"></span><br><span class="line">$ eval ssh-agent</span><br><span class="line">SSH_AUTH_SOCK&#x3D;&#x2F;tmp&#x2F;ssh-zIQZKN6080&#x2F;agent.6080; export SSH_AUTH_SOCK;</span><br><span class="line">SSH_AGENT_PID&#x3D;1092; export SSH_AGENT_PID;</span><br><span class="line">echo Agent pid 1092;</span><br><span class="line"></span><br><span class="line">$ eval &#96;ssh-agent&#96;</span><br><span class="line">Agent pid 4288</span><br></pre></td></tr></table></figure><p>直到我输入 eval <code>ssh-agent</code> 时，似乎就对了。</p><h3 id="命令代换"><a href="#命令代换" class="headerlink" title="命令代换"></a>命令代换</h3><p>这三种不同的方式都是<code>shell</code>脚本中的命令代换。</p><p>命令代换是指<code>shell</code>能够将一个命令的标准输出插在一个命令行中任何位置。</p><h4 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h4><p>首先要介绍的是: <code>eval</code></p><p>它的作用是：<strong>重新运算求出参数的内容</strong>。</p><p>该命令使用于那些一次扫描无法实现其功能的变量。该命令对变量进行两次扫描。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ touch test.txt</span><br><span class="line">$ vim test.txt      </span><br><span class="line">&#x2F;&#x2F; 写入 Hello eval</span><br><span class="line"></span><br><span class="line">$ var&#x3D;&quot;cat test.txt&quot;</span><br><span class="line">&#x2F;&#x2F; 注意：中间没有空格，前面没有美元符号。</span><br><span class="line"></span><br><span class="line">$ echo $var</span><br><span class="line">cat test.txt</span><br><span class="line">$ eval $var</span><br><span class="line">Hello eval</span><br></pre></td></tr></table></figure><h4 id="反引号与"><a href="#反引号与" class="headerlink" title="反引号与 $()"></a>反引号与 $()</h4><p>实例一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ DATE1&#x3D;$(date)</span><br><span class="line">$ DATE2&#x3D;&#96;date&#96;</span><br><span class="line">$ DATE3&#x3D;&#96;eval date&#96;</span><br><span class="line"></span><br><span class="line">$ echo $DATE1</span><br><span class="line">2019年01月23日 21:20:36</span><br><span class="line">$ echo $DATE2</span><br><span class="line">2019年01月23日 21:20:36</span><br><span class="line">$ echo $DATE3</span><br><span class="line">2019年01月23日 21:20:36</span><br></pre></td></tr></table></figure><p>实例二：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ echo &#96;echo &#39;\\&#39;&#96; </span><br><span class="line">\</span><br><span class="line">$ echo $(echo &#39;\\&#39;)</span><br><span class="line">\\</span><br></pre></td></tr></table></figure><p>暂时没太明白这三者的实际应用场景，不过了解到了 它们之间的一些区别与联系。</p><h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><ul><li><a href="https://kyle.io/2012/09/ssh-agent-messiness-solving-it/" target="_blank" rel="noopener">https://kyle.io/2012/09/ssh-agent-messiness-solving-it/</a></li><li><a href="https://blog.csdn.net/Y1730008223CONG/article/details/74136055" target="_blank" rel="noopener">shell脚本中命令代换：反引号、$()、eval区别</a></li><li><a href="https://blog.csdn.net/if9600/article/details/74221548" target="_blank" rel="noopener">shell脚本中命令代换：反引号、$()、eval区别2</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 中的Shell 种类</title>
      <link href="/shell-types-in-linux/"/>
      <url>/shell-types-in-linux/</url>
      
        <content type="html"><![CDATA[<p>什么是Shell？</p><a id="more"></a><p>Shell 是一个程序，其作用是将用户输入的命令发送到OS（系统内核）。</p><p>据说它起源于作为存在于OS 内部和用户之间的外壳的依附着。所以为形象的称作为 壳（Shell）。</p><h2 id="Shell-的种类"><a href="#Shell-的种类" class="headerlink" title="Shell 的种类"></a>Shell 的种类</h2><p>Linux Shell 的种类很多，目前流行的Shell 包括ash、bash、ksh、csh、zsh等，种类多了，也就有了标准化的要求，这就是POSIX的由来。</p><p>POSIX 表示可移植操作系统接口（UNIX的可移植操作系统接口，缩写为POSIX），POSIX标准定义了操作系统应该为应用程序提供的接口标准。</p><p>通过以下命令来查看文件中的内容来查看自己主机中当前有哪些种类的Shell：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ cat &#x2F;etc&#x2F;shells</span><br><span class="line">&#x2F;bin&#x2F;sh</span><br><span class="line">&#x2F;bin&#x2F;bash</span><br><span class="line">&#x2F;bin&#x2F;ksh</span><br><span class="line">&#x2F;bin&#x2F;pdksh</span><br><span class="line">&#x2F;bin&#x2F;tcsh</span><br><span class="line">&#x2F;bin&#x2F;zsh</span><br><span class="line">&#x2F;bin&#x2F;dash</span><br><span class="line">&#x2F;bin&#x2F;posh</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;sh</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;bash</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;ksh</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;pdksh</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;tcsh</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;zsh</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;dash</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;posh</span><br></pre></td></tr></table></figure><p>如何查看当前正在使用的Shell 类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo $SHELL</span><br><span class="line">&#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p><code>$SHELL</code>是一个环境变量，它记录了Linux 当前用户所使用的Shell类型。</p><p>用户可以通过直接输入各种Shell的二进制文件名（因为这些二进制文件本身是可以被执行的），来进入到该Shell下，比如进入<code>zsh</code>可以直接输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ &#x2F;bin&#x2F;zsh</span><br></pre></td></tr></table></figure><p>这个命令为用户又启动了一个Shell，这个Shell在最初登录的那个Shell之后，称为下级的Shell或子Shell。</p><h2 id="最标准的Shell"><a href="#最标准的Shell" class="headerlink" title="最标准的Shell"></a>最标准的Shell</h2><h3 id="Bash"><a href="#Bash" class="headerlink" title="Bash"></a>Bash</h3><p><code>sh</code>是Unix 上最古老的Shell，在<code>sh</code>的基础上添加了各种扩展功能的是<code>bash</code>，它成为Linux标准Shell。有如下的特点：</p><ul><li>使用上下键快速查看历史命令</li><li>Tab 键自动补全</li></ul><h2 id="其他Shell"><a href="#其他Shell" class="headerlink" title="其他Shell"></a>其他Shell</h2><h3 id="ash"><a href="#ash" class="headerlink" title="ash"></a>ash</h3><p><code>ash</code>是Linux 中占用系统资源最少的一个小Shell，它只包含24个内部命令，因而使用起来很不方便。</p><h3 id="csh"><a href="#csh" class="headerlink" title="csh"></a>csh</h3><p><code>csh</code>是Linux 比较大的内核，共有52个内部命令。该Shell其实是指向/bin/tcsh这样的一个Shell，也就是说，csh其实就是tcsh。</p><h3 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h3><p>zch是Linux 最大的Shell之一，共有84 个内部命令。 zsh具有如下特性：</p><ul><li>更好的自动补全、更高效</li><li>更好的文件名展开（通配符展开）</li><li>可定制性高</li></ul><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://academy.gmocloud.com/keywords/20170324/4010" target="_blank" rel="noopener">什么是Shell以及常见Shell种类</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>免费 CDN：JsDelivr + Github</title>
      <link href="/free-cdn-jsdelivr-github/"/>
      <url>/free-cdn-jsdelivr-github/</url>
      
        <content type="html"><![CDATA[<p>不知道大家通常是如何访问图床的，我之前一直使用的方式是：<code>GitHub</code> 图床 + <code>raw.githubusercontent</code>。</p><p>图片相关的资源全部放在<code>GitHub</code>上，然后使用GitHub 提供的素材服务器<code>raw.githubusercontent</code>去访问。但是这种方式存在一个问题，那就是放在 Github 的资源在国内加载速度比较慢，如果网络稍微差一些，资源可能就会加载失败。</p><p>因此需要使用 CDN 来加速来优化资源加载速度。</p><a id="more"></a><h2 id="CDN-是什么"><a href="#CDN-是什么" class="headerlink" title="CDN 是什么"></a>CDN 是什么</h2><blockquote><p>CDN的全称是<code>Content Delivery Network</code>，即内容分发网络。CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。——百度百科</p></blockquote><p>由于某些原因，很多公用免费的 CDN 资源在中国大陆并不很好用，就算是付费的，也有一定的限制，例如每天的刷新次数有限之类的。<br>幸运的是在中国大陆唯一有 license 的公有 CDN竟然是免费的，它就是——<a href="https://www.jsdelivr.com/" target="_blank" rel="noopener">JsDelivr</a>。</p><h2 id="JsDelivr-是什么"><a href="#JsDelivr-是什么" class="headerlink" title="JsDelivr 是什么"></a>JsDelivr 是什么</h2><blockquote><p>A free CDN for Open Source fast, reliable, and automated. —— JsDelivr 官网</p></blockquote><p>根据官网的介绍我们可以知道它是一个<strong>免费</strong>、<strong>快速</strong>、<strong>可靠</strong>、<strong>自动化</strong> 的CDN。</p><p>那么，这么棒的CDN，到底该如何使用呢？下面会一一介绍。</p><h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><p>JsDelivr 目前有三种用法：</p><ul><li>Npm</li><li>Github</li><li>Wordpress</li></ul><p>因为本文的重点是如何使用 GitHub + JsDelivr，来搭建免费的CDN，所以这里就不对其他两种用法做过多介绍。</p><h3 id="1-新建Github-仓库"><a href="#1-新建Github-仓库" class="headerlink" title="1. 新建Github 仓库"></a>1. 新建Github 仓库</h3><p>这个仓库是用于存储资源文件的，最好是public，因为private的仓库，资源链接会带token验证，而这个token会存在过期的问题。</p><h3 id="2-将本地资源推送至仓库"><a href="#2-将本地资源推送至仓库" class="headerlink" title="2. 将本地资源推送至仓库"></a>2. 将本地资源推送至仓库</h3><p>将资源文件加入本地仓库，然后推送至 CDN 的远程仓库。</p><h3 id="3-发布仓库"><a href="#3-发布仓库" class="headerlink" title="3. 发布仓库"></a>3. 发布仓库</h3><p>如果没有发布就直接使用，可能会导致文件加载异常。</p><p>自定义发布版本号：<br><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200710132805.png" alt=""></p><p>然后点击<code>Publish release</code>。</p><h3 id="4-通过jsDeliver引用资源"><a href="#4-通过jsDeliver引用资源" class="headerlink" title="4. 通过jsDeliver引用资源"></a>4. 通过jsDeliver引用资源</h3><p>只需要通过符合 JSDelivr 规则的 URL 引用，即可直接使用 Github 中的资源。</p><p>规则如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;username&#x2F;repository@version&#x2F;file</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>cdn.jsdelivr.net/gh/</code>：jsDeliver 规定Github 的引用地址</li><li><code>username</code>：你的GitHub 用户名</li><li><code>repository</code>：CDN 仓库</li><li><code>@version</code>：发布的版本号</li><li><code>file</code>：资源文件在仓库中的路径</li></ul><p>版本号不是必需的，是为了区分新旧资源，如果不使用版本号，将会直接引用最新资源，除此之外还可以使用某个范围内的版本，查看所有资源等，具体使用方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 通过指定版本号引用</span><br><span class="line">https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;0xAiKang&#x2F;CDN&#x2F;blog&#x2F;images&#x2F;avatar.jpg</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用一个范围内的版本</span><br><span class="line">https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;jquery&#x2F;jquery@3.2.1&#x2F;dist&#x2F;jquery.min.js</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 忽略版本号则默认使用最新版</span><br><span class="line">https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;jquery&#x2F;jquery&#x2F;dist&#x2F;jquery.min.js</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在任意JS&#x2F;CSS文件后添加 .min 能得到一个缩小版</span><br><span class="line">&#x2F;&#x2F; 如果它本身不存在，我们将会为你生成</span><br><span class="line">https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;jquery&#x2F;jquery@3.2.1&#x2F;src&#x2F;core.min.js</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在末尾加 &#x2F; 则得到目录列表</span><br><span class="line">https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;jquery&#x2F;jquery&#x2F;</span><br></pre></td></tr></table></figure><p>同样的一张图片，可以对比一下<code>jsDeliver</code>和<code>raw.githubusercontent</code> 的访问速度。</p><ul><li><code>jsDeliver</code>：<a href="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/avatar.jpg" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/avatar.jpg</a></li><li><code>raw.githubusercontent</code>：<a href="https://raw.githubusercontent.com/0xAiKang/CDN/master/blog/images/avatar.jpg" target="_blank" rel="noopener">https://raw.githubusercontent.com/0xAiKang/CDN/master/blog/images/avatar.jpg</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tutorial </category>
          
          <category> GitHub </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tutorial </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何写好Commit log</title>
      <link href="/how-to-write-a-commit-log/"/>
      <url>/how-to-write-a-commit-log/</url>
      
        <content type="html"><![CDATA[<p>其实关于这个问题，老早都想整理了，只是一直没有腾出空来。最近刚好有空，索性整理了下。</p><p>这里就不过多介绍什么是<code>Git</code>了，本文的重点是<code>Commit Log</code>，如果还不清楚<code>Git</code>是什么，可以看一下我的<code>Git</code>系列的其他笔记。</p><a id="more"></a><h2 id="为什么要关注提交信息"><a href="#为什么要关注提交信息" class="headerlink" title="为什么要关注提交信息"></a>为什么要关注提交信息</h2><ol><li>加快<code>Reviewing Code</code>的过程</li><li>提醒自己或他人，某个提交具体增加了什么功能，改动了哪些地方</li><li>提高项目的整体质量</li></ol><h2 id="Angular-规范的-Commit-message-格式"><a href="#Angular-规范的-Commit-message-格式" class="headerlink" title="Angular 规范的 Commit message 格式"></a>Angular 规范的 Commit message 格式</h2><p>这种格式（规范）是我目前觉得相对其他格式（规范）而言，最容易接受、上手的一种。</p><p>其核心是每次提交，Commit message 都包括三个部分：Header，Body 和 Footer。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br><span class="line">&#x2F;&#x2F; 空一行</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&#x2F;&#x2F; 空一行</span><br><span class="line">&lt;footer&gt;</span><br></pre></td></tr></table></figure><p>其中，Header 是必需的，Body 和 Footer 可以省略。</p><h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3><p>Header 部分只有一行，包括三个字段：<strong>type</strong>（必需）、<strong>scope</strong>（可选）和 <strong>subject</strong>（必需）。</p><p><strong>type</strong> 用于说明 <code>commit</code> 的类别，只允许使用下面 7 个标识。</p><ul><li><strong>feat</strong> 新功能（feature）</li><li><strong>fix</strong> 修补 bug</li><li><strong>docs</strong> 文档（documentation）</li><li><strong>style</strong> 格式（不影响代码运行的变动）</li><li><strong>refactor</strong> 重构（即不是新增功能，也不是修改 bug 的代码变动）</li><li><strong>test</strong> 增加测试</li><li><strong>chore</strong> 构建过程、辅助工具的变动</li><li><strong>perf</strong> 提高性能</li><li><strong>typo</strong> 打字错误</li></ul><p><strong>scope</strong> 用于说明 <code>commit</code> 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。</p><p><strong>subject</strong> 是 <code>commit</code> 目的的简短描述，不超过 50 个字符。</p><h3 id="Body"><a href="#Body" class="headerlink" title="Body"></a>Body</h3><p>Body 部分是对本次 commit 的详细描述，可以分成多行。</p><h3 id="Footer"><a href="#Footer" class="headerlink" title="Footer"></a>Footer</h3><p>Footer 部分只用于不兼容变动和关闭 Issue。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本来我自己一直使用的方式就是：<code>git commit -am &quot;fix login bug</code>，虽然并没有绝对的对错，但这显然不是最好的方式。</p><p>这种东西并没有强制性的规定，只要团队之间约定好，然后按照这个约定协作就好了。</p><p>所以我觉得在团队之间<code>commit</code>时，可以不用完全按照<code>Angular 规范的Commit message</code>格式去提交，可以按照以下约定来执行。</p><ul><li><code>commit</code>时，只用保留 Header 部分就好。</li><li><code>pull request</code>时，才需要 Header、Body、Footer 这三部分。</li></ul><p>另外<code>commit</code>时需要注意以下几点：</p><ul><li>创建短小而明确的<code>commit</code>，一句话说清楚。</li><li>一个小改动对应一次<code>commit</code>，不建议一大堆改动，一次<code>commit</code>。</li><li>如果添加的代码会使项目发生极大的变化，那么需要及时更新<code>remade</code>文件以向他人说明此次更改。</li></ul><h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docs: add FAQ in readme file</span><br><span class="line">feat: increase user login function</span><br><span class="line">fix: fix user login bug</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://ruby-china.org/topics/15737" target="_blank" rel="noopener">Git 如何写好 Commit Log？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tutorial </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo Volantis 主题优化 | 增加分析与统计</title>
      <link href="/hexo-volantis-theme-optimization-add-analysis-and-statistics/"/>
      <url>/hexo-volantis-theme-optimization-add-analysis-and-statistics/</url>
      
        <content type="html"><![CDATA[<p>Volantis 默认支持 <a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener">不蒜子</a> 的访问统计，可以自行添加<a href="https://tongji.baidu.com/" target="_blank" rel="noopener">百度统计</a>和 <a href="https://analytics.google.com/" target="_blank" rel="noopener">Google Analytics</a>。</p><a id="more"></a><h2 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h2><ul><li>Hexo：4.2</li><li>Node：12</li><li>Volantis：2.6</li></ul><h2 id="分析与统计"><a href="#分析与统计" class="headerlink" title="分析与统计"></a>分析与统计</h2><h3 id="字数和阅读时长"><a href="#字数和阅读时长" class="headerlink" title="字数和阅读时长"></a>字数和阅读时长</h3><ol><li>Volantis 默认没有安装 <code>wordcount</code>插件，所以需要手动安装：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save hexo-wordcount</span><br></pre></td></tr></table></figure><ol start="2"><li>修改主题配置文件<code>themes/volantis/_config.yml</code>，将 wordcount 插件打开</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">plugins:</span><br><span class="line">  ...</span><br><span class="line">  # 文章字数统计、阅读时长，开启需要安装插件: npm i --save hexo-wordcount</span><br><span class="line">  wordcount: true</span><br></pre></td></tr></table></figure><ol start="3"><li>继续修改主题配置文件<code>themes/volantis/_config.yml</code>，将 <code>wordcount</code> 放在需要显示的 meta 位置：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 布局</span><br><span class="line">layout:</span><br><span class="line">  on_list:</span><br><span class="line">    meta: [..., wordcount, ...]</span><br><span class="line">  on_page:</span><br><span class="line">    meta:</span><br><span class="line">      header: [..., wordcount, ...]</span><br><span class="line">      footer: [..., wordcount, ...]</span><br></pre></td></tr></table></figure><h3 id="百度统计"><a href="#百度统计" class="headerlink" title="百度统计"></a>百度统计</h3><p>百度统计是百度推出的一款免费的专业网站流量分析工具，能够告诉用户访客是如何找到并浏览用户的网站，在网站上做了些什么，非常有趣，接下来我们把百度统计添加到自己博客当中。</p><ol><li>访问<a href="https://tongji.baidu.com/" target="_blank" rel="noopener">百度统计首页</a>，注册一个账号后登陆，添加你的博客网站。</li></ol><p><img src="https://raw.githubusercontent.com/0xAiKang/CDN/master/blog/images/20200709204712.png" alt=""></p><ol start="2"><li><p>点击获取代码，复制该代码。</p></li><li><p>在主题配置文件中，增加以下内容：</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnzz: true</span><br></pre></td></tr></table></figure><p>用于设置是否开启百度统计。</p><ol start="4"><li>在<code>themes/volantis/layout/_partial</code>目录下，新建一个<code>cnzz.ejs</code>文件，将刚才复制的内容粘贴进去：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if (theme.cnzz)&#123; %&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var _hmt &#x3D; _hmt || [];</span><br><span class="line">    (function () &#123;</span><br><span class="line">        var hm &#x3D; document.createElement(&quot;script&quot;);</span><br><span class="line">        hm.src &#x3D; &quot;https:&#x2F;&#x2F;hm.baidu.com&#x2F;hm.js?xxxxxxxxxxxxxxxxxxxxxxx&quot;;</span><br><span class="line">        var s &#x3D; document.getElementsByTagName(&quot;script&quot;)[0];</span><br><span class="line">        s.parentNode.insertBefore(hm, s);</span><br><span class="line">    &#125;)();</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><ol start="5"><li>最后将以下内容放在网站首页的尾部<code>themes/volantis/layout/_partial/footer.ejs</code>中：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%- partial(&#39;cnzz&#39;) %&gt;</span><br></pre></td></tr></table></figure><p>完成以上所有操作之后，可以在<a href="https://tongji.baidu.com/sc-web/10000236600/home/site/index" target="_blank" rel="noopener">百度统计管理页面</a>检查代码是否安装正确，如果正确安装，通常二十分钟之后就可以看到网站的分析数据了。</p>]]></content>
      
      
      <categories>
          
          <category> Tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Tutorial </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo Volantis 主题优化 | 添加日历图</title>
      <link href="/hexo-volantis-theme-optimization-add-calendar/"/>
      <url>/hexo-volantis-theme-optimization-add-calendar/</url>
      
        <content type="html"><![CDATA[<p>一直觉得GitHub 日历图（代码提交统计样式）很好看，偶然发现是可以通过配置将日历模块引入到Hexo 的主题中的。</p><p>默认效果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200709204832.png" alt=""></p><p>因为我使用的Hexo 主题是<code>Volantis</code>、而该主题目前并没有集成该控件，所以需要手动配置。</p><a id="more"></a><h2 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h2><ul><li>Hexo：4.2</li><li>Node：12</li><li>Volantis：2.6</li></ul><p>Volantis 低版本可能会不适用于本文介绍的方法，可以参考 <code>YINUXY</code> 的 <a href="https://cloud.tencent.com/developer/article/1597223" target="_blank" rel="noopener">Hexo主题美化 | 给你的博客加上GITHUB日历云和分类</a></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ol><li><p>在主题配置文件 <code>themes\volantis\_config.yml</code> 下添加以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">postCalendar: true</span><br></pre></td></tr></table></figure><p>用于设置在归档页面中是否显示’文章日历’控件，如果不想显示，设置为 <code>false</code> 即可。</p></li><li><p>在归档页面 <code>themes/volantis/layout/archive.ejs</code> 添加以下代码：</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;calendar&quot;&gt;</span><br><span class="line">&lt;% if (theme.postCalendar) &#123; %&gt;</span><br><span class="line">&lt;%- partial(&#39;_widget&#x2F;post-calendar&#39;) %&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>具体添加位置：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200709205348.png" alt="IMAGE"></p><p>这里会根据主题配置文件中的<code>postCalendar</code>的值，来判断是否需要渲染。</p><ol start="3"><li>点击下载日历样式文件 <code>post-calendar.ejs</code>，放置于<code>themes/volantis/layout/_widget</code>目录下。</li></ol><p>将其中的第 16 行，替换成以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;0xAiKang&#x2F;CDN@1.0&#x2F;blog&#x2F;js&#x2F;echarts.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>至此已经完成了，使用<code>hexo generate &amp;&amp; hexo server</code>查看是否可以正常加载日历图。</p><p>默认的样式是高仿<code>gittee</code>，如果觉得不满意，可以参考<a href="https://echarts.apache.org/zh/option.html#calendar" target="_blank" rel="noopener">官方文档</a>自定义。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://blog.csdn.net/cungudafa/article/details/106420842" target="_blank" rel="noopener">hexo（sakura）仿gitee添加文章贡献度日历图（echarts）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Tutorial </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编写第一个Shell 脚本</title>
      <link href="/write-the-first-shell-script/"/>
      <url>/write-the-first-shell-script/</url>
      
        <content type="html"><![CDATA[<p>这篇笔记用来记录编写 Shell 脚本过程中的一些基础知识。</p><a id="more"></a><h2 id="什么是-shell-脚本"><a href="#什么是-shell-脚本" class="headerlink" title="什么是 shell 脚本"></a>什么是 shell 脚本</h2><blockquote><p><code>Shell</code> 脚本就是将一堆的 <code>Shell</code> 命令以及指定执行 <code>Shell</code> ，通过放在一个文件中来执行。</p></blockquote><h2 id="创建第一个shell-脚本"><a href="#创建第一个shell-脚本" class="headerlink" title="创建第一个shell 脚本"></a>创建第一个shell 脚本</h2><p>下面我们来创建第一个 shell 脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ vim showdate</span><br><span class="line"></span><br><span class="line">#! &#x2F;bin&#x2F;bash</span><br><span class="line"># this script displays the date and who&#39;s logged on</span><br><span class="line">date</span><br><span class="line">who</span><br></pre></td></tr></table></figure><p>大功告成！这样就完成了一个简单的 shell 脚本的创建，是不是很简单！不过有以下几点需要注意：</p><ol><li>shell 脚本的名称不是一定需要用 .sh 来结尾，只是用 .sh 结尾会让其他人一目了然知道这是一个 shell 脚本文件。</li><li>在创建shell 脚本时，必须在第一行指定要使用的 shell，且格式固定为：<code>#!</code>开头。</li><li>第二行的井号作为注释行。</li></ol><p>运行shell 脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">showdate</span><br><span class="line">$ .&#x2F;showdate</span><br><span class="line">bash: permission denied: .&#x2F;showdate</span><br><span class="line">$ sudo .&#x2F;showdate</span><br><span class="line">sudo: .&#x2F;showdate: command not found</span><br><span class="line">$ chmod u+x showdate</span><br><span class="line">$ .&#x2F;showdate</span><br></pre></td></tr></table></figure><p>创建完 shell 脚本，想要运行，有两种方案：</p><ol><li>将 shell 脚本所处的目录添加到 PATH 环境变量中;</li><li>在提示符中用绝对路径或者是相对路径来引用 shell 脚本文件;</li></ol><p>在上面的例子中，用的是绝对路径的方式来执行shell 脚本，使用单点操作符表示当前目录下的文件。</p><p>需要注意的是，因为文件夹权限的关系，而不能直接用 sudo 命令去执行，因为sudo 命令会检查showdate 并不在sudo 命令列表中。</p><p>所以正解是：修改该文件的文件夹权限。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对于Shell编程的理解</title>
      <link href="/understanding-of-shell-programming/"/>
      <url>/understanding-of-shell-programming/</url>
      
        <content type="html"><![CDATA[<p>在开始聊Shell编程之前，我们先来看看计算机编程语言的都有哪些类型。</p><p>计算机语言可以分为两大类：</p><ol><li>低级语言</li><li>高级语言</li></ol><a id="more"></a><p>低级语言包括：<strong>机器语言</strong>和<strong>汇编语言</strong>。</p><p>高级语言包括：<strong>静态语言</strong>和<strong>动态语言</strong>。</p><p>这里就不对机器语言和汇编语言做介绍了，今天的主角是高级语言下的动态语言。</p><h3 id="动态语言"><a href="#动态语言" class="headerlink" title="动态语言"></a>动态语言</h3><p><strong>动态语言又叫做脚本语言。</strong></p><p>它和传统的静态语言的区别就在于:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">前者的运行过程为：编写-&gt;解释-&gt;执行</span><br><span class="line">而后者的运行过程为：编写-&gt;编译-&gt;链接-&gt;执行</span><br></pre></td></tr></table></figure><p>脚本语言的优势就在于 只要有一个可以写代码的编辑器和能解释执行的脚本解释器就行了。</p><p>这样一想，也就明白了为什么搭建<code>Python</code>的开发环境远比<code>C#</code>要快，因为它只要安装一个解释器就好了。</p><blockquote><p>动态语言与静态语言存在的争议之一：</p></blockquote><p>在静态语言中，写代码时必须知道每个变量的类型; 而在动态语言中，随便什么时候，你都可以把变量设为任意类型的值。</p><h3 id="Shell编程"><a href="#Shell编程" class="headerlink" title="Shell编程"></a>Shell编程</h3><p>最初在学习<code>Shell</code>脚本时，产生过这样一个问题：<br><strong>为什么还能用<code>PHP</code>写<code>Shell</code>脚本？</strong></p><p>当时就很不理解。这里就反应了两个问题：</p><ol><li>对<code>PHP</code>的理解不深</li><li>对<code>Shell</code>脚本的理解不深</li></ol><p><strong>理论上讲，只要一门语言提供了解释器，这门语言就可以胜任脚本编程。</strong></p><p>所以用 <code>PHP</code> 可以写 <code>Shell</code> 脚本，就没有什么好奇怪的了。<br>你可能会问：这句话里面的 <code>Shell</code>怎么理解？</p><p>还记得吗，<code>Shell</code>的概念是什么？</p><blockquote><p><code>Shell</code> 脚本就是将一堆的 <code>Shell</code> 命令以及指定执行 <code>Shell</code> ，通过放在一个文件中来执行。</p></blockquote><h3 id="脚本语言的分类"><a href="#脚本语言的分类" class="headerlink" title="脚本语言的分类"></a>脚本语言的分类</h3><p>脚本语言又可以分为以下两大类：</p><ol><li><code>Shell</code>脚本</li><li>通用动态语言</li></ol><h5 id="常见的Shell脚本："><a href="#常见的Shell脚本：" class="headerlink" title="常见的Shell脚本："></a>常见的Shell脚本：</h5><ul><li>sh</li><li>bash</li><li>csh</li><li>ksh</li><li>tcsh</li><li>zsh</li><li>AppleScript </li></ul><h5 id="常见的脚本语言"><a href="#常见的脚本语言" class="headerlink" title="常见的脚本语言"></a>常见的脚本语言</h5><ul><li>JavaScript</li><li>Perl</li><li>PHP</li><li>Python</li><li>Ruby</li><li>VBScript</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Linux的Shell、Shell脚本、Shell环境的理解</title>
      <link href="/understanding-of-linux-shell-shell-script-shell-environment/"/>
      <url>/understanding-of-linux-shell-shell-script-shell-environment/</url>
      
        <content type="html"><![CDATA[<p>如标题所示，这片笔记主要目的是加深对<code>Linux</code>的<code>Shell</code>、<code>Shell脚本</code>、<code>Shell环境</code>的理解。</p><a id="more"></a><h2 id="什么是Shell？"><a href="#什么是Shell？" class="headerlink" title="什么是Shell？"></a>什么是Shell？</h2><ul><li><p>在回答这个问题之前，我们先来考虑一个问题：人是如何跟计算机打交道的？或者说怎样让计算机按照我们的要求完成某个任务？</p><ul><li>现在和计算机交互的方式很简单，直接用图形界面的工具就好了，想要计算机完成某个任务，通过操作图形界面的工具就能到达目的。</li><li>那么在以前呢？在那个计算机还没有这么先进的时代呢？人们又是如何让计算完成某个任务。通过“命令”的方式告诉计算机我需要你帮你完成这件事。这个“命令”又是怎么告诉计算机的呢？通过一个交互工具。这个工具可以实现与计算机之间的“你问我答，你说我做”的功能。</li></ul></li><li><p><code>Shell</code>就是一种应用程序（注意：我这里用的是一种）。</p></li><li><p>这个应用程序提供了一个界面（方便我们与计算机进行交互），用户通过这个界面访问操作系统内核的服务。</p></li></ul><h2 id="什么是Shell脚本？"><a href="#什么是Shell脚本？" class="headerlink" title="什么是Shell脚本？"></a>什么是Shell脚本？</h2><p><code>Shell</code> 脚本（<code>Shell Script</code>），是一种为 <code>Shell</code> 编写的脚本程序。</p><blockquote><p>Shell 脚本编程有两种方式</p></blockquote><ol><li>交互式（Interactive）：用户每输入一条命令就立即执行。</li><li>批处理（Batch）：由用户事先编写好一个完整的<code>Shell</code>脚本，<code>Shell</code>会一次性执行脚本中诸多的命令。</li></ol><h2 id="什么是Shell环境"><a href="#什么是Shell环境" class="headerlink" title="什么是Shell环境"></a>什么是Shell环境</h2><p><code>Shell</code>编程跟<code>java</code>、<code>php</code>编程一样，只要有一个<strong>能编写代码的文本编辑器</strong>和一个<strong>能解释执行的脚本解释器</strong>就可以了。</p><h3 id="0x01-Linux"><a href="#0x01-Linux" class="headerlink" title="0x01 Linux"></a>0x01 Linux</h3><ul><li><code>Linux</code> 默认安装了 <code>Shell</code> 解释器。</li><li>在<code>Linux</code>中，主流的 <code>Shell</code> 是 <code>Bash</code>。</li></ul><p>在一般情况下，人们并不区分 <code>Bourne Shell</code> 和 <code>Bourne Again Shell</code>，所以，像 <code>#!/bin/sh</code>，它同样也可以改为 <code>#!/bin/bash</code>。</p><h3 id="0x02-Mac-OS"><a href="#0x02-Mac-OS" class="headerlink" title="0x02 Mac OS"></a>0x02 Mac OS</h3><ul><li>Mac OS不仅带了sh、bash这两个最基础的解释器，还内置了ksh、csh、zsh等不常用的解释器。</li></ul><h3 id="0x03-Windows"><a href="#0x03-Windows" class="headerlink" title="0x03 Windows"></a>0x03 Windows</h3><p>Windows 出厂时没有内置 <code>Shell</code> 解释器，通常我们都是安装<code>cygwin</code>或者<code>mingw</code> 模拟器来Linux环境。</p><ul><li><a href="http://www.cygwin.com/" target="_blank" rel="noopener">Cygwin</a></li><li><a href="http://www.mingw.org/" target="_blank" rel="noopener">Mingw</a></li></ul><p>如Git的交互界面就是由<code>Mingw</code>模拟器提供的<code>Bash</code>。</p><h4 id="脚本解释器"><a href="#脚本解释器" class="headerlink" title="脚本解释器"></a>脚本解释器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bash &#x3D;&gt; Bourne Again Shell（&#x2F;bin&#x2F;bash）</span><br><span class="line">sh &#x3D;&gt;  Bourne Shell（&#x2F;usr&#x2F;bin&#x2F;sh或&#x2F;bin&#x2F;sh）</span><br><span class="line">csh &#x3D;&gt; C Shell（&#x2F;usr&#x2F;bin&#x2F;csh）</span><br><span class="line">ksh &#x3D;&gt; K Shell（&#x2F;usr&#x2F;bin&#x2F;ksh）</span><br><span class="line">Shell for Root（&#x2F;sbin&#x2F;sh）</span><br></pre></td></tr></table></figure><h4 id="第一个Shell脚本"><a href="#第一个Shell脚本" class="headerlink" title="第一个Shell脚本"></a>第一个Shell脚本</h4><p>打开Bash或者任何一个文本编辑器，新建一个文件 Hello.sh，扩展名为<code>sh</code>(sh代表shell)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">#第一个Shell脚本</span><br><span class="line">#作用是列出当前目录下的所有文件的详情信息</span><br><span class="line">PWDS&#x3D;echo &#96;pwd&#96;</span><br><span class="line">cd $PWDS</span><br><span class="line">ls -l</span><br></pre></td></tr></table></figure><p>上面这个脚本中，有三种不同的元素：</p><ol><li>第一行的脚本声明（<code>#!</code>）用来告诉系统使用<strong>哪种 Shell 解释器</strong>来执行该脚本；</li><li>第二行的注释信息（<code>#</code>）是对脚本功能和某些命令的介绍信息，使得看到脚本时能快速反应是做什么的。</li><li>剩下没有前缀标识的就是 所要执行的脚本具体命令了。</li></ol><h4 id="运行Shell脚本"><a href="#运行Shell脚本" class="headerlink" title="运行Shell脚本"></a>运行Shell脚本</h4><p>有两种方式：</p><h5 id="1-作为可执行程序"><a href="#1-作为可执行程序" class="headerlink" title="1. 作为可执行程序"></a>1. 作为可执行程序</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ chmod +x example.sh    # 使脚本具有执行权限</span><br><span class="line">$ .&#x2F;example.sh           # 执行脚本</span><br></pre></td></tr></table></figure><h5 id="2-作为解释器参数"><a href="#2-作为解释器参数" class="headerlink" title="2. 作为解释器参数"></a>2. 作为解释器参数</h5><p>这种运行方式是，直接运行解释器，其参数就是shell脚本的文件名:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 执行脚本</span><br><span class="line">$ &#x2F;bin&#x2F;sh example.sh</span><br><span class="line">$ bash example.sh</span><br><span class="line">$ bash example.php</span><br></pre></td></tr></table></figure><p>使用这种方式时，可以不用在脚本第一行声明解释器信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cat example.php</span><br><span class="line">#这是一个用php写的Shell脚本，有两个作用</span><br><span class="line">#1.确认是否用解释器参数执行shell脚本可以不用写声明</span><br><span class="line">#2.确认如何用php写shell脚本</span><br><span class="line">string&#x3D;&quot;php shell&quot;</span><br><span class="line">echo $string</span><br><span class="line">$ bash example.php</span><br><span class="line">php shell</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>moment.js 用法总结</title>
      <link href="/moment-js-usage-summary/"/>
      <url>/moment-js-usage-summary/</url>
      
        <content type="html"><![CDATA[<p>最近在做的一个前端项目，经常会遇到对时间的处理，因为原生的时间格式处理起来很费劲，所以引入了一个轻量级的日期处理类库。</p><p><a href="http://momentjs.cn/" target="_blank" rel="noopener">momentjs</a> 支持日期格式化、Date、时间戳等相互转换，它使得操作时间变得非常简单。</p><a id="more"></a><h3 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h3><p><code>momentjs</code>支持多个环境，所有的代码都应该在这两种环境中都可以工作。</p><h4 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install moment</span><br><span class="line">var moment &#x3D; require(&#39;moment&#39;);</span><br></pre></td></tr></table></figure><h4 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;moment.js&#x2F;2.9.0&#x2F;moment.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>获取当前的日期和时间：</p><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moment();</span><br></pre></td></tr></table></figure><p>相当于moment(new Date()) 此处会返回一个moment封装的<strong>日期对象</strong>。</p><p><img src="https://raw.githubusercontent.com/0xAiKang/CDN/master/blog/images/20200707190535.png" alt=""></p><h4 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">moment().format(&#39;YYYY年MM月DD日 HH:mm:ss&#39;) &#x2F;&#x2F; &quot;2020年07月07日 07:49:38&quot;</span><br><span class="line">moment().format(&#39;YYYY-MM-DD HH:mm:ss&#39;) &#x2F;&#x2F; &quot;2020-07-07 07:50:57&quot;</span><br><span class="line">moment().format(&#39;YYYY&#x2F;MM&#x2F;DD HH:mm:ss&#39;) &#x2F;&#x2F; &quot;2020&#x2F;07&#x2F;07 07:51:17&quot;</span><br><span class="line">moment().format(&#39;hh:m:ss&#39;) &#x2F;&#x2F; &quot;07:51:34&quot;</span><br><span class="line">moment().format(&#39;YYYY&#39;) &#x2F;&#x2F; &quot;2020&quot;</span><br><span class="line">moment().format(&#39;d&#39;) &#x2F;&#x2F; 2，今天是周二</span><br><span class="line">moment().format(&#39;X&#39;) &#x2F;&#x2F; 获取当前时间的Unix时间戳</span><br></pre></td></tr></table></figure><h4 id="转换为Date对象"><a href="#转换为Date对象" class="headerlink" title="转换为Date对象"></a>转换为Date对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">moment().toDate() &#x2F;&#x2F; Mon Jan 22 2018 18:11:55 GMT+0800 (中国标准时间)</span><br><span class="line">moment(&#39;2018-01-20&#39;).toDate() &#x2F;&#x2F; Tue Jan 20 2015 00:00:00 GMT+0800 (中国标准时间)</span><br><span class="line">moment(&#39;2018-01-22 10:20:15&#39;).toDate() &#x2F;&#x2F; Mon Jan 22 2018 10:20:15 GMT+0800 (中国标准时间)</span><br><span class="line">moment(1448896064621).toDate() &#x2F;&#x2F;毫秒转日期</span><br></pre></td></tr></table></figure><h4 id="获取时间信息"><a href="#获取时间信息" class="headerlink" title="获取时间信息"></a>获取时间信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">moment().second() &#x2F;&#x2F; 获取当前这一分钟的多少秒</span><br><span class="line">moment().date() &#x2F;&#x2F; 获取天</span><br><span class="line">moment().day()  &#x2F;&#x2F; 获取星期</span><br><span class="line">moment().dayOfYear()  &#x2F;&#x2F; 一年内的多少天</span><br><span class="line">moment().week() &#x2F;&#x2F; 一年里的多少周</span><br><span class="line">moment().month()  &#x2F;&#x2F; 获取当前月份（实际月份-1）</span><br><span class="line">moment().quarter() &#x2F;&#x2F; 一年内的第几个季度</span><br><span class="line">moment().year() &#x2F;&#x2F; 获取年份</span><br><span class="line">moment().daysInMonth() &#x2F;&#x2F; 获取当月天数</span><br></pre></td></tr></table></figure><h4 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h4><p>一旦解析和操作完成后，需要某些方式来显示 moment。</p><p>使用<code>format</code>来格式化日期：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">moment().format() &#x2F;&#x2F; &quot;2020-07-07T08:24:35+08:00&quot;</span><br><span class="line">moment.unix(timestamp).format(&#39;YYYY-MM-DD HH:mm:ss&#39;);   &#x2F;&#x2F; 将Unix 时间戳转换为日期格式</span><br><span class="line">moment(timestamp).format(&#39;YYYY-MM-DD HH:mm:ss&#39;);   &#x2F;&#x2F; 将Unix 毫秒时间戳转换为日期格式</span><br><span class="line">moment().unix();        &#x2F;&#x2F; 获取Unix 时间戳</span><br><span class="line">moment().format(&quot;X&quot;);   &#x2F;&#x2F; 获取Unix 时间戳</span><br><span class="line">moment().format(&quot;x&quot;);   &#x2F;&#x2F; 获取Unix 毫秒时间戳</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何选择一个适合自己的图床</title>
      <link href="/how-to-choose-a-picture-bed-that-suits-you/"/>
      <url>/how-to-choose-a-picture-bed-that-suits-you/</url>
      
        <content type="html"><![CDATA[<p>因为没有把博客部署在服务器上，而是选择GitHub Pages 的方式，所以如果遇到需要插入图片的时候，只能通过图床来存储图片。</p><p>如果不是因为<a href="https://sm.ms/" target="_blank" rel="noopener">SM.MS</a> 图床在今天突然挂掉了，我可能都不会去想是否需要更换图床这个问题。</p><p><img src="https://raw.githubusercontent.com/0xAiKang/CDN/master/blog/images/20200706225801.png" alt=""></p><p>于是我开始寻找一个免费、稳定的图床，最后在众多图床中，最后选择了GitHub 图床。</p><p>使用GitHub 图床，可能唯一的问题是需要自备好科学上网工具，否则图片无法加载。</p><a id="more"></a><blockquote><p>为什么不选择国内的那些图床服务？</p></blockquote><p>我只是想存一些图片，而国内的大部分图床服务，还需要做域名备案以及绑定各种服务，感觉很繁琐，加上我的域名不是在国内的域名服务商那里买的，索性就没有考虑国内的图床服务。</p><h3 id="图床管理工具"><a href="#图床管理工具" class="headerlink" title="图床管理工具"></a>图床管理工具</h3><p>有了图床，就需要顺手配置一个图床管理工具，这里我选择的是 <a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a>，仅目前支持的图床就有：SM.MS图床，微博图床，七牛图床，腾讯云COS，阿里云OSS，Imgur，又拍云，GitHub 图床等。</p><h3 id="创建GitHub-图床"><a href="#创建GitHub-图床" class="headerlink" title="创建GitHub 图床"></a>创建GitHub 图床</h3><p>首先，你得有一个<a href="https://github.com/" target="_blank" rel="noopener">GitHub</a> 账号。</p><h4 id="1-新建一个仓库"><a href="#1-新建一个仓库" class="headerlink" title="1. 新建一个仓库"></a>1. 新建一个仓库</h4><p>这个仓库是用于存储图片，最好是public，因为private的仓库，图片链接会带token，而这个token会存在过期的问题。</p><h4 id="2-获取授权token"><a href="#2-获取授权token" class="headerlink" title="2. 获取授权token"></a>2. 获取授权token</h4><p>通过<code>Settings-&gt;Developer settings-&gt;Personal access tokens</code> <a href="https://github.com/settings/tokens/new" target="_blank" rel="noopener">创建一个新的token</a> 用于PicGo操作你的仓库。</p><p>把repo的勾打上即可，点击Generate token的绿色按钮生成 token。</p><p>创建成功后，会生成一串token，这串token之后不会再显示，所以第一次看到的时候最好保存好。</p><h3 id="配置PicGo"><a href="#配置PicGo" class="headerlink" title="配置PicGo"></a>配置PicGo</h3><p>GitHub 图床的配置还是比较简单的，下面是参数说明。</p><p><img src="https://raw.githubusercontent.com/0xAiKang/CDN/master/blog/images/20200706225324.png" alt=""></p><ul><li>仓库名：你的图床仓库的名称，格式为：<code>username/repository</code></li><li>分支名：一般选择默认分支 <code>master</code></li><li>Token：刚才生成的 Token</li><li>存储路径：指定存放在仓库的哪个目录下</li><li>自定义域名：<code>raw.githubusercontent.com/username/repository/branch</code></li></ul><p>自定义域名最好按照一定的规则去定义：<code>raw.githubusercontent.com</code>+你的github用户名+仓库名称+分支名称</p><blockquote><p><code>raw.githubusercontent.com</code> 是github用来存储用户上传文件的服务地址，是github 的素材服务器 (assets server)。</p></blockquote><p>通常配置完成之后，就可以直接使用了。</p><p>如果你上传失败的情况，可以打开PicGo 的日志看看具体是什么异常</p><p><img src="https://raw.githubusercontent.com/0xAiKang/CDN/master/blog/images/20200706220223.png" alt=""></p><p>如果得到了这样的异常，那么大概率是因为你没有开启全局代理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[PicGo ERROR] RequestError: Error: connect ECONNREFUSED 13.250.168.23:443&#96;</span><br></pre></td></tr></table></figure><p>因为GitHub 服务器和国内 GFW 的问题会导致有时上传成功，有时上传失败，所以需要自备好科学上网工具。</p><p>如果你还有其他问题，可以查阅 <a href="https://github.com/Molunerfinn/PicGo/blob/dev/FAQ.md" target="_blank" rel="noopener">PicGo FAQ</a>。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>如果你和我一样，讨厌域名备案，又希望能有一个免费、稳定的图床，那么一定不要错过GitHub 图床。</li><li>如果你只是需要存储一些不怎么重要的图片，那么可以使用免费不限大小的SM.MS图床。</li><li>如果打算长期稳定使用可以优先选择又拍云或者七牛云。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Tutorial </category>
          
          <category> Skill </category>
          
          <category> GitHub </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tutorial </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Travis CI 快速上手</title>
      <link href="/travis-ci-quick-start/"/>
      <url>/travis-ci-quick-start/</url>
      
        <content type="html"><![CDATA[<p>最近使用Github Pages 搭建Hexo 时，用到了一项新技术。hmm…也不能说是新技术吧，只是之前一直有听说，但却没有实际用过。</p><p>它就是持续集成，听上去好像是一个高大上的概念，但通俗一点解释就是：写完代码提交之后，会根据你的要求，自动做编译测试。</p><p>其中最出名大概就是<a href="https://travis-ci.com/" target="_blank" rel="noopener">Travis CI</a>了，本文的目的就是快速入门 Travis CI。</p><a id="more"></a><h2 id="什么是持续集成？"><a href="#什么是持续集成？" class="headerlink" title="什么是持续集成？"></a>什么是持续集成？</h2><p>持续集成(Continuous Integration)是对小周期的的代码进行更改，其目的是通过以较小的增量开发和测试来构建更健康的软件。</p><p>而Travis CI 作为一个持续集成平台，通过自动构建和测试代码，并提供更改成功的即时反馈。</p><h3 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h3><p>在正式开始之前，需要提前准备好以下先决条件：</p><ul><li>一个 <a href="https://github.com/" target="_blank" rel="noopener">GitHub</a> 帐户</li><li>托管在 <a href="https://github.com/" target="_blank" rel="noopener">Github</a> 的项目的所有者权限</li></ul><p>需要注意的是：Travis CI不是完全免费的服务，前100个私有构建是免费的，后续就要进行付费，如果你的项目是开源的，或者你是学生，则不受限制。</p><h4 id="在Github-上使用Travis-CI"><a href="#在Github-上使用Travis-CI" class="headerlink" title="在Github 上使用Travis CI"></a>在Github 上使用Travis CI</h4><ol><li>将 <a href="https://github.com/marketplace/travis-ci" target="_blank" rel="noopener">Travis CI</a> 添加到你的 GitHub 账户中。</li><li>前往 GitHub 的 <a href="https://github.com/settings/installations" target="_blank" rel="noopener">Applications settings</a>，配置 Travis CI 权限，使其能够访问你的 repository。</li><li>前往 GitHub 新建 <a href="https://github.com/settings/tokens" target="_blank" rel="noopener">Personal Access Token</a>，只勾选 repo 的权限并生成一个新的 Token。Token 生成后请复制并保存好。</li><li>回到 Travis CI，前往你的 repository 的设置页面，在 Environment Variables 下新建一个环境变量，Name 为 GH_TOKEN，Value 为刚才你在 GitHub 生成的 Token。确保 DISPLAY VALUE IN BUILD LOG 保持 不被勾选 避免你的 Token 泄漏。点击 Add 保存。</li><li>在你的项目中新建一个 <code>.travis.yml</code> 文件。</li><li>提交并推送以触发Travis CI构建。</li></ol><p>其中<code>.travis.yml</code>文件的目的是告诉 Travis CI 应该做些什么。</p><p>以下示例指定了应使用Ruby 2.2和最新版本的JRuby构建的Ruby项目。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">language: ruby</span><br><span class="line">rvm:</span><br><span class="line"> - 2.2</span><br><span class="line"> - jruby</span><br></pre></td></tr></table></figure><p>通过访问<a href="https://travis-ci.com/auth" target="_blank" rel="noopener">Travis CI</a> 并选择repository，检查构建状态页面，以根据构建命令的返回状态查看构建是否通过或失败。</p>]]></content>
      
      
      <categories>
          
          <category> Tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tutorial </tag>
            
            <tag> CI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 快速上手</title>
      <link href="/hexo-quick-start/"/>
      <url>/hexo-quick-start/</url>
      
        <content type="html"><![CDATA[<p>最近使用Hexo 搭建了一套博客系统，整个过程还算顺利，不过还是遇到了一些问题，整理记录一下。</p><a id="more"></a><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><p>新建一个网站。如果没有设置 <code>folder</code>，Hexo 默认在目前的文件夹建立网站。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init [folder]</span><br></pre></td></tr></table></figure><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><p>layout 有三种选择：</p><ul><li>post：新建一片文章</li><li>page：新建一个页面</li><li>draft：新建一篇草稿</li></ul><p>如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><h3 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h3><p>生成静态文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br><span class="line">&#x2F;&#x2F; 等效于 hexo g</span><br></pre></td></tr></table></figure><p>常用参数：<br>|选项|描述|<br>|-|-|<br>|-d, –deploy|文件生成后立即部署网站|<br>|-w, –watch|监视文件变动|<br>|-b, –bail|生成过程中如果发生任何未处理的异常则抛出异常|</p><h3 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h3><p>发表草稿</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo publish [layout] &lt;filename&gt;</span><br></pre></td></tr></table></figure><h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><p>启动服务器。默认情况下，访问网址为： <code>http://localhost:4000/</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br><span class="line">&#x2F;&#x2F; 等效于 hexo s</span><br></pre></td></tr></table></figure><h3 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h3><p>部署网站。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br><span class="line">&#x2F;&#x2F; 等效于 hexo d</span><br></pre></td></tr></table></figure><p><code>-g</code>，<code>--generate</code>：部署之前预先生成静态文件</p><h3 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h3><p>清除缓存文件 (db.json) 和已生成的静态文件 (public)。</p><p>在某些情况（尤其是更换主题后），如果发现对站点的更改无论如何也不生效，那可能需要运行该命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>列出网站资料。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo list</span><br></pre></td></tr></table></figure><h3 id="version"><a href="#version" class="headerlink" title="version"></a>version</h3><p>显示 Hexo 版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo version</span><br></pre></td></tr></table></figure><h3 id="其他模式"><a href="#其他模式" class="headerlink" title="其他模式"></a>其他模式</h3><h4 id="安全模式"><a href="#安全模式" class="headerlink" title="安全模式"></a>安全模式</h4><p>在安全模式下，不会载入插件和脚本。当需要安装新插件遭遇问题时，可以尝试以安全模式重新执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo --safe</span><br></pre></td></tr></table></figure><h4 id="调试模式"><a href="#调试模式" class="headerlink" title="调试模式"></a>调试模式</h4><p>在终端中显示调试信息并记录到 debug.log。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo --debug</span><br></pre></td></tr></table></figure><h4 id="显示草稿"><a href="#显示草稿" class="headerlink" title="显示草稿"></a>显示草稿</h4><p>显示 source/_drafts 文件夹中的草稿文章。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo --draft</span><br></pre></td></tr></table></figure><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="CNAME-文件被删除"><a href="#CNAME-文件被删除" class="headerlink" title="CNAME 文件被删除"></a>CNAME 文件被删除</h3><p>GitHub Pages 为我们免费提供了<code>&lt;username&gt;.github.io</code>这样的域名作为 GitHub Page，但如果你觉得这个域名太长了，不满意，那么你也可以绑定自己的域名。</p><p>通常绑定完成之后，会在项目目录下面生成一个叫做<code>CNAME</code>的文件，这个文件的作用就是用来记录GitHub Pages 所绑定的域名。</p><p>这个时候就会产生一个问题：</p><blockquote><p>CNAME文件会在每次 hexo deploy 时消失，然后需要重新手动绑定，这样就很繁琐。</p></blockquote><p>有以下几种方式可以解决这个问题：</p><ol><li>每次 <code>hexo d</code> 之后，就去 GitHub 仓库根目录新建 CNAME文件。—— 繁琐</li><li>在 <code>hexo g</code> 之后， <code>hexo d</code> 之前，把CNAME文件复制到 <code>public</code> 目录下面，里面写入你要绑定的域名。—— 繁琐</li><li>将需要上传至 GitHub 的内容放在<code>source</code>文件夹，例如CNAME、favicon.ico、images等，这样在 <code>hexo d</code> 之后就不会被删除了。</li><li>通过安装插件实现永久保留。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-cname --save</span><br></pre></td></tr></table></figure><p>编辑<code>_config.yml</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Plugins:</span><br><span class="line">- hexo-generator-cname</span><br></pre></td></tr></table></figure><p>推荐第三种方式，简单方便。</p><h3 id="配置apex-域"><a href="#配置apex-域" class="headerlink" title="配置apex 域"></a>配置apex 域</h3><p>Github Pages 是支持绑定自己的私有域名的，但默认只能绑定 <code>CNAME</code>的私有子域名，那有没有办法主域名呢？</p><p>答案是有的。</p><p>如果绑定主域名，例如 example.com，建议还设置一个 <code>www</code> 子域，GitHub Pages 将自动在域之间创建重定向，当输入<code>example.com</code>时，会重定向到 <code>www.example.com</code>。</p><p>通常我们绑定好私有子域名之后，回生成一个<code>CNAME</code>的文件，里面记录着我们绑定好的私有子域名。</p><p>此时只需要去DNS 做解析，创建一个ALIAS、ANAME 或 A 记录：</p><ul><li>创建ALIAS、ANAME记录：将 apex 域指向站点的默认域。</li><li>创建A 记录：将 apex 域指向 GitHub Pages 的 IP 地址。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; GitHub Pages 的 IP 地址</span><br><span class="line">185.199.108.153</span><br><span class="line">185.199.109.153</span><br><span class="line">185.199.110.153</span><br><span class="line">185.199.111.153</span><br></pre></td></tr></table></figure><p>这里我选择的是创建A 记录，所以我的DNS 解析是这样的：</p><p><img src="https://raw.githubusercontent.com/0xAiKang/CDN/master/blog/images/20200706203008.png" alt="DNS解析A记录"></p><p>配置完DNS 解析之后，可以使用<code>dig</code>命令来检验是否解析成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ dig example.com +noall +answer</span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; aikang.me +noall +answer</span><br><span class="line">;; global options: +cmd</span><br><span class="line">aikang.me.4502INA185.199.111.153</span><br><span class="line">aikang.me.4502INA185.199.110.153</span><br><span class="line">aikang.me.4502INA185.199.108.153</span><br><span class="line">aikang.me.4502INA185.199.109.153</span><br></pre></td></tr></table></figure><p>将example.com 替换成你自己的 apex 域，确认结果与上面 GitHub Pages 的 IP 地址相匹配。</p><p>至此，就完成了apex 域的配置了。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://www.cnblogs.com/chengxs/p/7496265.html" target="_blank" rel="noopener">github+hexo搭建自己的博客网站（七）注意事项</a></li><li><a href="https://hexo.io/zh-cn/docs/commands" target="_blank" rel="noopener">Hexo | 指令</a></li><li><a href="https://docs.github.com/cn/github/working-with-github-pages/managing-a-custom-domain-for-your-github-pages-site#configuring-an-apex-domain" target="_blank" rel="noopener">管理 GitHub Pages 站点的自定义域</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Tutorial </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github Pages 部署 Hexo 个人博客</title>
      <link href="/deploy-hexo-using-github-pages-personal-blog/"/>
      <url>/deploy-hexo-using-github-pages-personal-blog/</url>
      
        <content type="html"><![CDATA[<p>关于个人博客，在很久之前就想自己搭建一套，甚至还为此买了一台服务器，但奈何自己太忙了(tai lan le) =_=，这件事情就一直搁浅了，服务器大部分时间也都是空闲状态。</p><p>这段时间，突然很想把这件事情做好，觉得不能在这么拖下去了，所以便有了这篇文章。</p><a id="more"></a><blockquote><p>为什么使用Github Pages？</p></blockquote><p>我是出于以下原因考虑的：</p><ol><li>暂时没有服务器的需要，我只想有一个能写博客的地方。</li><li>GitHub Pages 可以提供 https服务，我不用担心域名备案的问题。</li><li>免费</li></ol><p>总之，如果你想用最简单、最省心的方式，搭建属于自己的博客，那么 Github Pages 一定不会让你失望。</p><h2 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h2><ul><li>Mac OS 10.15.4</li><li>Node.js 12</li><li>Hexo-cli: 3.1</li><li>NPM: 6.9</li></ul><h3 id="创建Github-Pages"><a href="#创建Github-Pages" class="headerlink" title="创建Github Pages"></a>创建Github Pages</h3><p>Github Pages分为两类，用户或组织主页、项目主页。</p><ul><li>用户或组织主页：在新建仓库时，仓库名称应该以<code>&lt;yourusername&gt;.github.io</code>的格式去填写。<code>&lt;yourusername&gt;</code>指的是你的Github 的用户名称。</li><li>创建项目主页：在新建仓库时，名称可以任意设置，然后通过<code>Setting-&gt;Options-&gt;Github Pages</code>将 <code>Source</code>选项设置为<code>Master Branch</code>，此时这个项目就变成一个 Github Pages项目了。</li></ul><p>需要注意的是：</p><ol><li>Github Pages 只针对开源的项目是免费的，如果你不想开源，那可能就需要考虑收费的套餐了。</li><li>第一种方式不能更改 Github Pages 部署分支。</li><li>如果你有自己的域名，那么推荐使用方式二创建 Github Pages。如果你没有自己的域名，那也没有关系，可以使用Github Pages 提供的域名访问<code>http://&lt;yourusername&gt;.github.io</code>。</li></ol><h3 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h3><p>如果你是通过方式一，创建的Github Pages，那么可以跳过此部分。</p><p>在 2018 年 5 月 1 日之后，GitHub Pages 已经开始提供免费为自定义域名开启 HTTPS 的功能，并且大大简化了操作的流程，现在用户已经不再需要自己提供证书，只需要将自己的域名使用 CNAME 的方式指向自己的 GitHub Pages 域名即可。</p><p>首先需要在你的 DNS 解析里添加一条解析记录，例如我选择添加子域名<code>blog.aikang.me</code>，通过 CNAME 的方式指向我刚刚自定义的 GitHub Pages 域名 <code>0xAiKang.github.io</code>。</p><p><img src="https://i.loli.net/2020/07/04/BDX384QPIZqniJU.png" alt="DNS 域名解析"></p><p>添加完成后等待 DNS 解析的生效的同时回到项目的<code>Setting</code>界面，将刚才的子域名与 Github Pages 绑定在一起。</p><p>保存之后，我们只需要耐心等待 GitHub 生成证书并确认域名的解析是否正常。</p><p><img src="https://i.loli.net/2020/07/04/OZ2Vu8p9tXgTj7q.png" alt="等待 GitHub 生成证书并确认域名解析正常"></p><h3 id="将Hexo-部署到Github-Pages"><a href="#将Hexo-部署到Github-Pages" class="headerlink" title="将Hexo 部署到Github Pages"></a>将Hexo 部署到Github Pages</h3><p>域名解析成功之后，就可以通过我们刚才绑定的域名进行访问了，但是你会发现，现在只能看到一片空白，这是因为我们的网站还没有任何内容，所以下一步需要做的就是选择一套静态模版系统。</p><p>目前市场上有很多优秀的静态模板系统，比如：</p><ul><li>Node.js 编写的 Hexo</li><li>Go 编写的 Hugo</li><li>Python 编写的 Pelican</li><li>静态博客写作客户端 Gridea</li></ul><blockquote><p>为什么要选择Hexo？</p></blockquote><p>最初在选择博客模版系统时，并没有发现 Gridea ，事后发现这个小众的静态博客写作客户端似乎才是我真正想要的。</p><p>不过既然选择了Hexo，也是因为它的生态环境很大，可选主题非常多，并且都是开源的。</p><blockquote><p>如何将 Hexo 部署到 GitHub Pages？</p></blockquote><ol><li>将 <a href="https://github.com/marketplace/travis-ci" target="_blank" rel="noopener">Travis CI</a> 添加到你的 GitHub 账户中。</li><li>前往 GitHub 的 <a href="https://github.com/settings/installations" target="_blank" rel="noopener">Applications settings</a>，配置 Travis CI 权限，使其能够访问你的 repository。</li><li>正常情况下你会被重定向到 Travis CI 的页面。如果没有，请 <a href="https://travis-ci.com/" target="_blank" rel="noopener">手动前往</a>。</li><li>前往 GitHub 新建 <a href="https://github.com/settings/tokens" target="_blank" rel="noopener">Personal Access Token</a>，只勾选 repo 的权限并生成一个新的 Token。Token 生成后请复制并保存好。</li><li>回到 Travis CI，前往你的 repository 的设置页面，在 Environment Variables 下新建一个环境变量，Name 为 GH_TOKEN，Value 为刚才你在 GitHub 生成的 Token。确保 DISPLAY VALUE IN BUILD LOG 保持 不被勾选 避免你的 Token 泄漏。点击 Add 保存。</li><li>在你的 Hexo 站点文件夹中新建一个 <code>.travis.yml</code> 文件：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">sudo: false</span><br><span class="line">language: node_js</span><br><span class="line">node_js:</span><br><span class="line">  - 10 # use nodejs v10 LTS</span><br><span class="line">cache: npm</span><br><span class="line">branches:</span><br><span class="line">  only:</span><br><span class="line">    - master # build master branch only</span><br><span class="line">script:</span><br><span class="line">  - hexo generate # generate static files</span><br><span class="line">deploy:</span><br><span class="line">  provider: pages</span><br><span class="line">  skip-cleanup: true</span><br><span class="line">  github-token: $GH_TOKEN</span><br><span class="line">  keep-history: true</span><br><span class="line">  on:</span><br><span class="line">    branch: master</span><br><span class="line">  local-dir: public</span><br></pre></td></tr></table></figure><p>上面这个配置文件的作用是用来自动构建，编译测试。</p><p>将 <code>.travis.yml</code> 推送到 repository 中。Travis CI 会自动开始运行，并将生成的文件推送到同一 repository 下的 <code>gh-pages</code> 分支下。</p><h4 id="修改发布源"><a href="#修改发布源" class="headerlink" title="修改发布源"></a>修改发布源</h4><p>推送完成之后，会发现多了一个 <code>gh-gages</code>分支，这个分支就是用于部署站点的分支，但是GitHub Pages 会默认使用<code>master</code>分支作为发布源，所以我们需要切换发布源。</p><p>在<code>Setting-&gt;Option-&gt;GitHub Pages</code>下，使用 Source（源）下拉菜单选择发布源。</p><p><img src="https://i.loli.net/2020/07/04/AHldtP2bIhaqr8c.png" alt="修改默认源"></p><p>注意：使用用户或组织主页构建的 Github Pages 不能修改发布源，只能使用默认的 <code>master</code>分支。</p><h3 id="一键部署"><a href="#一键部署" class="headerlink" title="一键部署"></a>一键部署</h3><p>Hexo 提供了快速方便的一键部署功能，让你只需一条命令就能将网站部署到服务器上。</p><p>在正式部署之前，我们需要先修改<code>_config.yml</code> 文件，配置参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: &lt;repository url&gt; #https:&#x2F;&#x2F;bitbucket.org&#x2F;JohnSmith&#x2F;johnsmith.bitbucket.io</span><br><span class="line">  branch: [branch]</span><br><span class="line">  message: [message]</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td>type</td><td>deployer</td><td>-</td></tr><tr><td>repo</td><td>项目地址</td><td>-</td></tr><tr><td>branch</td><td>分支名称</td><td>gh-pages</td></tr></tbody></table><p>有以下两点需要注意：<br>1.repo 需要选择SSH 协议，HTTPS协议会报错。<br>2.branch 选择Github Pages中设置的那个分支，而不是拉取这个项目的分支</p><p>我这里使用的是<code>git</code> 作为 deployer，所以需要手动安装一个插件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>生成站点文件并部署至远程库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo deploy --generate</span><br></pre></td></tr></table></figure><p>至此，就完成了使用Github Pages 部署 Hexo 个人博客的全部过程，总的来说还是很顺利的。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://sspai.com/post/54608" target="_blank" rel="noopener">Github Pages 搭建教程</a></li><li><a href="https://hexo.io/zh-cn/docs/github-pages.html" target="_blank" rel="noopener">将Hexo 部署到 GitHub Pages</a></li><li><a href="https://hexo.io/zh-cn/docs/one-command-deployment.html" target="_blank" rel="noopener">Hexo 一键部署</a></li><li><a href="https://juejin.im/post/5acf02086fb9a028b92d8652#heading-15" target="_blank" rel="noopener">Github Pages部署个人博客（Hexo篇）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tutorial </category>
          
          <category> GitHub </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tutorial </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
