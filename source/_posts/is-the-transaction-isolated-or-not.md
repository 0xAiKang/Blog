---
title: 08 事务到底是隔离的还是不隔离的
date: 2022-06-14 22:44:51
tags: ["Mysql"]
categories: ["Mysql"]
---

本文是基于 [极客时间——MySQL 实战 45 讲](https://time.geekbang.org/column/intro/100020801) 整理的学习笔记，仅供学习参考，请勿用于商业用途，如若侵权，请联系并删除。

课程重点：
* 了解 Mysql 的全局锁
* 了解当前读的概念

<!-- more -->

下面是一个只有两行的表的初始化语句。
```mysql
CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `k` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB;

insert into t(id, k) values(1,1),(2,2);
```

![clipboard.png](inkdrop://file:ZJBcivXF4)
在如图所示的事务启动时机下，最终事务 B 查到的 k 的值是 3，而事务 A 查到的 k 的值是 1。

在 MySQL 里，有两个“视图”的概念：
* 一个是 view。它是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。创建视图的语法是 create view … ，而它的查询方法与表一样。
* 另一个是 InnoDB 在实现 MVCC 时用到的一致性读视图，即 consistent read view，用于支持 RC（Read Committed，读提交）和 RR（Repeatable Read，可重复读）隔离级别的实现。

一致性读视图它没有物理结构，作用是事务执行期间用来定义“我能看到什么数据”。

## “快照”在 MVCC 里是怎么工作的？

InnoDB 里面每个事务有一个唯一的事务 ID，叫作 transaction id。它是在事务开始的时候向 InnoDB 的事务系统申请的，是按申请顺序严格递增的。

数据表中的一行记录，其实可能有多个版本 (row)，每个版本有自己的 row trx_id。

按照可重复读的定义，一个事务启动的时候，能够看到所有已经提交的事务结果。但是之后，这个事务执行期间，其他事务的更新对它不可见。

因此，一个事务只需要在启动的时候声明说：
* 以我启动的时刻为准，如果一个数据版本是在我启动之前生成的，就认。
* 如果是我启动以后才生成的，我就不认，我必须要找到它的上一个版本。

当然，如果“上一个版本”也不可见，那就得继续往前找。还有，如果是这个事务自己更新的数据，它自己还是要认的。

在实现上， InnoDB 为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务 ID。“活跃”指的就是，启动了但还没提交。

数组里面事务 ID 的最小值记为低水位，当前系统里面已经创建过的事务 ID 的最大值加 1 记为高水位。

**这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）**。

数据型版本的可见性规则（基于数据的 row trx_id 和这个一致性视图的对比结果得到）：

![clipboard.png](inkdrop://file:2CGAB0Q69)

这样，对于当前事务的启动瞬间来说，一个数据版本的 row trx_id，有以下几种可能：

如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；
如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；
如果落在黄色部分，那就包括两种情况
a. 若 row trx_id 在数组中，表示这个版本是由还没提交的事务生成的，不可见；
b. 若 row trx_id 不在数组中，表示这个版本是已经提交了的事务生成的，可见。

![clipboard.png](inkdrop://file:vyobdNYum)
接下来，我们继续看一下图 1 中的三个事务，分析下事务 A 的语句返回的结果，为什么是 k=1。

这里，我们不妨做如下假设：
* 事务 A 开始前，系统里面只有一个活跃事务 ID 是 99；
* 事务 A、B、C 的版本号分别是 100、101、102，且当前系统里只有这四个事务；
* 三个事务开始前，(1,1）这一行数据的 row trx_id 是 90。

这样，事务 A 的视图数组就是 [99,100], 事务 B 的视图数组是 [99,100,101], 事务 C 的视图数组是 [99,100,101,102]。

为了简化分析，先把其他干扰语句去掉，只画出跟事务 A 查询逻辑有关的操作：

![clipboard.png](inkdrop://file:lZOIMF8MF)

一个数据版本，对于一个事务视图来说，除了自己的更新总是可见以外，有以下三种情况：
1. 版本未提交，不可见
2. 版本已提交，但是是在视图创建后提交的，不可见
3. 版本已提交，而且是在视图创建前提交的，可见

有了这个规则之后，可以尝试判断事务 A 的查询语句的查询过程：
1. (1,3) 当前版本还未提交，属于情况 1，不可见
2. (1,2) 历史版本已经提交，但是是在视图数组创建之后提交的，属于情况 2，不可见
3. (1,1) 是在视图数组创建之前提交的，可见

## 更新逻辑
按照上面的逻辑，那事务 B 的值应该是 2 才对，可最后怎么又变成了 3 呢？

是的，如果事务 B 在更新之前查询一次数据，这个查询返回的 k 的值确实是 1。

但是，当它要去更新数据的时候，就不能再在历史版本上更新了，否则事务 C 的更新就丢失了。因此，事务 B 此时的 set k=k+1 是在（1,2）的基础上进行的操作。

所以，这里就用到了这样一条规则：**更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）**。

因此，在更新的时候，当前读拿到的数据是 (1,2)，更新后生成了新版本的数据 (1,3)，这个新版本的 row trx_id 是 101。

所以，在执行事务 B 查询语句的时候，一看自己的版本号是 101，最新数据的版本号也是 101，是自己的更新，可以直接使用，所以查询得到的 k 的值是 3。

## 总结
1. 在可重复读隔离级别下，事务启动时，会创建一个一致性视图 read-view
2. `begin/start transaction` 命令并不是一个事务的起点，在执行到它们之后的第一个操作 InnoDB 表的语句，事务才真正启动。
3. 在 `autocommit=1` 时，直接执行一个 update 语句，表示这个 update 语句本身就是一个事务，语句完成的时候会自动提交事务。
4. 每次事务更新数据时，都会生成一个新的数据版本，并且把 transaction id（唯一的事务 ID） 赋值给这个数据版本的事务 ID，记为 row trx_id。
